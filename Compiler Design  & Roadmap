# AILang Self-Hosting Compiler Architecture
## Reference Document v1.0

### Overview

The self-hosting compiler is built in AILang to compile AILang source to native x86-64 ELF executables. It follows a **modular architecture** with clear separation between:

1. **Frontend** - Lexing and Parsing (COMPLETE)
2. **AST** - Abstract Syntax Tree manipulation (NEW)
3. **Compile** - AST â†’ Instructions (one file per construct)
4. **CodeEmit** - Instructions â†’ Bytes (pure byte emission)
5. **Output** - Bytes â†’ ELF executable

### Design Principles

- **Separation of Concerns**: Compile modules call Emit functions, never emit bytes directly
- **One Construct = One File**: Easy to test, modify, maintain
- **No Monolithic Compiler**: Each module has Init/Process/Cleanup pattern
- **Clear Interfaces**: Modules communicate through well-defined function signatures

---

# AILang Self-Hosting Compiler - File Structure

```
Librarys/
â”œâ”€â”€ XArrays.ailang                    # Dynamic array library
â”‚
â””â”€â”€ Compiler/
    â”‚
    â”œâ”€â”€ Frontend/                     # Lexer, Parser, AST
    â”‚   â”‚
    â”‚   â”œâ”€â”€ Lexer/
    â”‚   â”‚   â”œâ”€â”€ Library.CLexerTypes.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CLexerCore.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CLexerKeywords.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CLexerStrings.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CLexerNumbers.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CLexerOperators.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CLexerIdentifiers.ailang
    â”‚   â”‚   â””â”€â”€ Library.CLexerMain.ailang
    â”‚   â”‚
    â”‚   â”œâ”€â”€ Parser/
    â”‚   â”‚   â”œâ”€â”€ Library.CParserTypes.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CParserCore.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CParserExpressions.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CParserStatements.ailang
    â”‚   â”‚   â”œâ”€â”€ Library.CParserDeclarations.ailang
    â”‚   â”‚   â””â”€â”€ Library.CParserMain.ailang
    â”‚   â”‚
    â”‚   â””â”€â”€ AST/
    â”‚       â”œâ”€â”€ Library.CASTTypes.ailang
    â”‚       â”œâ”€â”€ Library.CASTCore.ailang
    â”‚       â”œâ”€â”€ Library.CASTNodes.ailang
    â”‚       â”œâ”€â”€ Library.CASTDebug.ailang
    â”‚       â””â”€â”€ Library.CSemanticCore.ailang
    â”‚
    â”œâ”€â”€ Compile/                      # AST â†’ Instructions (architecture-agnostic)
    â”‚   â”‚
    â”‚   â”œâ”€â”€ Library.CCompileMain.ailang       # Main dispatcher âœ“
    â”‚   â”œâ”€â”€ Library.CCompileTypes.ailang      # Compile state, VarEntry, etc.
    â”‚   â”‚
    â”‚   â””â”€â”€ Modules/                  # One file per primitive group
    â”‚       â”œâ”€â”€ Library.CCompileFunc.ailang       # Function, SubRoutine, UserCall
    â”‚       â”œâ”€â”€ Library.CCompileStmt.ailang       # If, While, Assignment, Return
    â”‚       â”œâ”€â”€ Library.CCompileExpr.ailang       # Expressions, operators
    â”‚       â”œâ”€â”€ Library.CCompileArith.ailang      # Add, Subtract, Multiply, Divide
    â”‚       â”œâ”€â”€ Library.CCompileCompare.ailang    # EqualTo, LessThan, GreaterThan
    â”‚       â”œâ”€â”€ Library.CCompileLogic.ailang      # And, Or, Not
    â”‚       â”œâ”€â”€ Library.CCompileBitwise.ailang    # BitAnd, BitOr, ShiftLeft
    â”‚       â”œâ”€â”€ Library.CCompileIO.ailang         # PrintMessage, PrintNumber
    â”‚       â”œâ”€â”€ Library.CCompileString.ailang     # String operations
    â”‚       â”œâ”€â”€ Library.CCompileMem.ailang        # Allocate, StoreValue, Dereference
    â”‚       â”œâ”€â”€ Library.CCompileArray.ailang      # ArrayCreate, ArrayGet, ArraySet
    â”‚       â”œâ”€â”€ Library.CCompileXArray.ailang     # XArray operations
    â”‚       â””â”€â”€ Library.CCompileSystem.ailang     # SystemCall, Exit
    â”‚
    â”œâ”€â”€ CodeEmit/                     # Instructions â†’ Bytes (architecture-specific)
    â”‚   â”‚
    â”‚   â”œâ”€â”€ Library.CEmitTypes.ailang         # Emit state, Reg enum, CC enum âœ“
    â”‚   â”œâ”€â”€ Library.CEmitCore.ailang          # Buffer mgmt, labels, fixups âœ“
    â”‚   â”‚
    â”‚   â”œâ”€â”€ X86/                      # x86-64 target
    â”‚   â”‚   â”œâ”€â”€ Library.CEmitX86Reg.ailang    # MOV reg,reg / MOV reg,imm âœ“
    â”‚   â”‚   â”œâ”€â”€ Library.CEmitX86Mem.ailang    # Load/store, addressing modes âœ“
    â”‚   â”‚   â”œâ”€â”€ Library.CEmitX86Stack.ailang  # PUSH, POP, prologue/epilogue âœ“
    â”‚   â”‚   â”œâ”€â”€ Library.CEmitX86Arith.ailang  # ADD, SUB, MUL, DIV, NEG âœ“
    â”‚   â”‚   â”œâ”€â”€ Library.CEmitX86Logic.ailang  # AND, OR, XOR, NOT, shifts âœ“
    â”‚   â”‚   â”œâ”€â”€ Library.CEmitX86Cmp.ailang    # CMP, TEST, SETcc âœ“
    â”‚   â”‚   â”œâ”€â”€ Library.CEmitX86Jump.ailang   # JMP, Jcc, CALL, RET âœ“
    â”‚   â”‚   â””â”€â”€ Library.CEmitX86Sys.ailang    # SYSCALL, NOP, misc âœ“
    â”‚   â”‚
    â”‚   â””â”€â”€ RISCV/                    # RISC-V target (future)
    â”‚       â”œâ”€â”€ Library.CEmitRISCV.ailang
    â”‚       â””â”€â”€ Library.CEmitRISCVSys.ailang
    â”‚
    â”œâ”€â”€ Assembler/                    # Low-level assembly utilities
    â”‚   â””â”€â”€ (reserved for future use)
    â”‚
    â”œâ”€â”€ Output/                       # Binary output generation
    â”‚   â”œâ”€â”€ Library.CELFTypes.ailang          # ELF constants, header structs
    â”‚   â”œâ”€â”€ Library.CELFBuilder.ailang        # ELF executable builder
    â”‚   â”œâ”€â”€ Library.CRelocate.ailang          # Relocation handling
    â”‚   â””â”€â”€ Library.COutput.ailang            # File writing
    â”‚
    â””â”€â”€ Modules/                      # Shared/utility modules
        â””â”€â”€ (reserved for future use)
```

## Import Paths

```ailang
// Frontend
LibraryImport.Compiler.Frontend.Lexer.CLexerMain
LibraryImport.Compiler.Frontend.Parser.CParserMain
LibraryImport.Compiler.Frontend.AST.CASTCore

// Compile
LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.Compile.Modules.CCompileArith

// CodeEmit
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86

// Output
LibraryImport.Compiler.Output.CELFBuilder
```

## Build Status

### Phase 1: Foundation âœ“
- [x] Lexer (complete)
- [x] Parser (complete)
- [x] AST module (complete)
- [x] CEmitTypes (complete)
- [x] CEmitCore (complete) - includes label/fixup management
- [x] CEmitX86* (complete) - all 8 instruction files

### Phase 2: Minimal Compiler (CURRENT)
- [x] CCompileMain - dispatcher skeleton
- [ ] CCompileArith - Add, Subtract, Multiply, Divide
- [ ] CCompileIO - PrintMessage, PrintNumber
- [ ] CCompileExpr - expression evaluation
- [ ] CCompileFunc - Function compilation

**Test Target**: `PrintNumber(Add(1, 2))`

### Phase 3: Output
- [ ] CELFTypes - ELF constants
- [ ] CELFBuilder - ELF generation
- [ ] COutput - File writing

**Test Target**: Generate working ELF executable

### Phase 4: Statements & Control Flow
- [ ] CCompileStmt - Assignment, Return, Block
- [ ] CCompileStmt - If, While
- [ ] Loop context (break, continue)

### Phase 5: Memory & Pools
- [ ] CCompileMem - Allocate, StoreValue, Dereference
- [ ] CCompilePool - FixedPool access

### Phase 6: Full Compiler
- [ ] CCompileCompare, CCompileLogic, CCompileBitwise
- [ ] CCompileString, CCompileArray, CCompileXArray
- [ ] CCompileSystem

### Phase 7: Self-Hosting
- [ ] Compile the compiler with itself!


```
Source Code
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLexerMain     â”‚  Lex_Tokenize(source)
â”‚  (Lexer)        â”‚  â†’ Token stream
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CParserMain    â”‚  Parse_Program(tokens)
â”‚  (Parser)       â”‚  â†’ AST
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CCompileMain   â”‚  Compile_Program(ast)
â”‚  (Compiler)     â”‚  â†’ Calls CCompile* modules
â”‚                 â”‚  â†’ Calls CEmit* functions
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CEmitCore      â”‚  Emit_ResolveFixups()
â”‚  (Fixups)       â”‚  â†’ Patched code buffer
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CELFBuilder    â”‚  ELF_Build()
â”‚  (ELF Gen)      â”‚  â†’ ELF binary
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COutput        â”‚  Output_WriteFile()
â”‚  (File I/O)     â”‚  â†’ Executable file
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Example: Compiling `x = Add(1, 2)`

```
1. Parser creates AST:
   ASSIGNMENT
   â”œâ”€â”€ DATA1: "x"
   â””â”€â”€ CALL
       â”œâ”€â”€ DATA1: "Add"
       â”œâ”€â”€ NUMBER (1)
       â””â”€â”€ NUMBER (2)

2. CCompileMain dispatches to CCompileStmt_Assignment

3. CCompileStmt_Assignment:
   - Calls CompileExpr_Expression(value_node)
   - Calls X86_MovRbpOffsetRax(var_offset)

4. CompileExpr_Expression sees CALL node:
   - Dispatches to CompileCall_Call

5. CompileCall_Call sees "Add" is builtin:
   - Calls CompileCall_Builtin(Builtin.ADD, args)

6. CompileCall_Builtin for ADD:
   - CompileExpr_Expression(arg1) â†’ X86_MovRaxImm64(1)
   - X86_PushRax()
   - CompileExpr_Expression(arg2) â†’ X86_MovRaxImm64(2)
   - X86_MovRegReg(RBX, RAX)
   - X86_PopRax()
   - X86_AddRaxRbx()

7. Back in Assignment:
   - X86_MovRbpOffsetRax(x_offset)

8. Final bytes in Emit.code buffer
```

---

## Build Order (Iterative)

### Phase 1: Foundation
1. âœ… Lexer (complete)
2. âœ… Parser (complete)
3. ðŸ”² AST module (extract from CParserUtils)
4. ðŸ”² CEmitTypes + CEmitCore (buffer management)

### Phase 2: Minimal Compiler
5. ðŸ”² CEmitInstr (basic: MOV, ADD, SUB, RET)
6. ðŸ”² CCompileTypes
7. ðŸ”² CCompileExpr (NUMBER, IDENTIFIER only)
8. ðŸ”² CCompileOps (Add, Subtract)
9. ðŸ”² CCompileIO (PrintMessage, PrintNumber)

**Test**: Compile `PrintNumber(Add(1, 2))`

### Phase 3: Functions
10. ðŸ”² CCompileFunc (Function, SubRoutine)
11. ðŸ”² CCompileCall (user functions)
12. ðŸ”² CCompileStmt (Assignment, Return)

**Test**: Compile simple function with return value

### Phase 4: Control Flow
13. ðŸ”² CCompileStmt (If, While)
14. ðŸ”² Loop context (break, continue)

**Test**: Compile loops and conditionals

### Phase 5: Memory & Pools
15. ðŸ”² CCompileMem (Allocate, Store, Load)
16. ðŸ”² CCompilePool (FixedPool)

**Test**: Compile pool access

### Phase 6: Output
17. ðŸ”² CELFBuilder
18. ðŸ”² CRelocate
19. ðŸ”² COutput

**Test**: Generate working ELF executable

### Phase 7: Self-Hosting
20. ðŸ”² Compile the compiler with itself!

---

## Known Issues / Notes

1. **Pool Variable Collision**: Field names must be unique across all pools. CParserTypes uses P_ prefix to avoid collision with CLexerTypes.

2. **Pool Table Size**: Minimum 16KB (2048 slots) to handle large library imports. Fixed in memory_manager.py.

3. **Import Order**: Libraries are discovered AFTER pool table allocation. This is a bug in the Python compiler to fix in self-hosted version.

4. **Register Allocation**: R15 is reserved for pool table base. R14 reserved for future use. Use R12, R13 for temps, stack for deeper nesting.

---

## Console Application

The `ailang_console.ailang` provides interactive testing:

```
ailang> load test.ailang
ailang> compile
ailang> ast on
ailang> tokens on
ailang> status
ailang> quit
```

Current status: Lexer + Parser working. Code generation stubbed.

---

*Document Version: 1.0*
*Date: December 25, 2025*
*Status: Architecture defined, implementation in progress*
