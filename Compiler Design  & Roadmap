# AILang Self-Hosting Compiler - Complete Architecture Plan

## Document Version: 1.0
## Status: Final Planning Document for Project Knowledge
## Date: December 2024

---

# Table of Contents

1. [Overview & Goals](#1-overview--goals)
2. [Architecture Principles](#2-architecture-principles)
3. [Directory Structure](#3-directory-structure)
4. [Compilation Pipeline](#4-compilation-pipeline)
5. [Module Organization](#5-module-organization)
6. [Abstract Instruction Set (CEmitInstr)](#6-abstract-instruction-set-cemitinstr)
7. [X86_64 Encoding Specification](#7-x86_64-encoding-specification)
8. [Assembler Module Organization](#8-assembler-module-organization)
9. [ELF Output Generation](#9-elf-output-generation)
10. [Porting Strategy](#10-porting-strategy)
11. [Implementation Phases](#11-implementation-phases)
12. [Appendix: Quick Reference](#appendix-quick-reference)

---

# 1. Overview & Goals

## 1.1 Purpose

Build a self-hosting AILang compiler written entirely in AILang, eliminating the Python dependency. The compiler will transform AILang source code into native x86_64 Linux executables.

## 1.2 Key Goals

1. **Self-hosting**: Compiler written in AILang, compiles itself
2. **Clean separation**: Compiler modules emit abstract instructions, assembler encodes bytes
3. **Portable architecture**: Easy to add new target architectures (ARM64, RISC-V)
4. **Modular design**: Match existing Python compiler's module organization
5. **No conditionals for targets**: Separate backend directories per architecture, not #ifdef

## 1.3 Non-Goals (Explicit Exclusions)

- No intermediate representation (IR) layer initially - direct AST to assembly
- No optimization passes in v1.0
- No cross-compilation in v1.0 (native compilation only)

---

# 2. Architecture Principles

## 2.1 Core Principle: Separation of Concerns

```
COMPILER MODULES          EMIT LAYER              ASSEMBLER
(what to generate)    (abstract instrs)       (how to encode)
      │                      │                       │
      │  Asm_Mov(RAX, RBX)  │  [MOV, RAX, RBX]     │  0x48 0x89 0xD8
      │  Asm_Add(RAX, 42)   │  [ADD, RAX, IMM:42]  │  0x48 0x83 0xC0 0x2A
      │  Asm_Jmp(label)     │  [JMP, LABEL:".L0"]  │  0xE9 <offset>
      ▼                      ▼                       ▼
```

**Critical Rule: No raw bytes in compiler modules. Ever.**

## 2.2 Layer Responsibilities

| Layer | Responsibility | Does NOT Do |
|-------|---------------|-------------|
| Frontend | Lexing, parsing, AST construction | Code generation |
| Compiler Modules | Decide what instructions to emit | Encode bytes |
| Emit Layer | Buffer abstract instructions | Target-specific encoding |
| Assembler | Encode instructions to bytes | Semantic decisions |
| ELF Generator | Create executable format | Instruction encoding |

## 2.3 Benefits

1. **Compiler modules are target-agnostic** - `Asm_Mov(RAX, RBX)` not bytes
2. **Porting = new assembler** - ARM64 means new `Assembler/ARM64/`, nothing else
3. **Readable compiler code** - `Asm_Cmp(RAX, RBX)` not `EmitBytes3(0x48, 0x39, 0xD8)`
4. **Testable layers** - Unit test instruction emission separately from encoding
5. **Matches existing structure** - Same module breakdown as Python compiler

---

# 3. Directory Structure

```
Libraries/
└── Compiler/
    │
    ├── Frontend/                         # Language Processing
    │   ├── Library.CLexerCore.ailang         # Token types, lexer state
    │   ├── Library.CLexerTokenize.ailang     # Main tokenization loop
    │   ├── Library.CLexerKeywords.ailang     # AILang keyword matching
    │   ├── Library.CParserCore.ailang        # Parser state, AST creation helpers
    │   ├── Library.CParserExpr.ailang        # Expression parsing (precedence climbing)
    │   ├── Library.CParserStmt.ailang        # Statement parsing
    │   ├── Library.CParserDecl.ailang        # Function, FixedPool, LibraryImport
    │   └── Library.CASTNodes.ailang          # AST node types and accessors
    │
    ├── Modules/                          # Compiler Operations (NO BYTES!)
    │   ├── Library.CArithmeticOps.ailang     # Add, Subtract, Multiply, Divide, Modulo
    │   ├── Library.CMathOps.ailang           # Min, Max, Abs, ISqrt, Sign, Clamp, trig
    │   ├── Library.CStringOps.ailang         # StringConcat, StringCompare, StringLength
    │   ├── Library.CMemoryOps.ailang         # Allocate, Deallocate, SetByte, GetByte
    │   ├── Library.CArrayOps.ailang          # ArrayCreate, ArrayGet, ArraySet, ArrayLength
    │   ├── Library.CHashOps.ailang           # HashCreate, HashSet, HashGet, HashDelete
    │   ├── Library.CControlFlow.ailang       # IfCondition, WhileLoop, ForEvery, labels
    │   ├── Library.CComparisonOps.ailang     # EqualTo, LessThan, GreaterThan, etc.
    │   ├── Library.CBitwiseOps.ailang        # And, Or, Xor, Not, Shl, Shr
    │   ├── Library.CDebugOps.ailang          # Debug markers, assertions, profiling
    │   ├── Library.CFileIOOps.ailang         # File open, read, write, close
    │   ├── Library.CProcessOps.ailang        # SystemCall, process management
    │   ├── Library.CNetworkOps.ailang        # Socket operations
    │   ├── Library.CAtomicOps.ailang         # Atomic operations for concurrency
    │   ├── Library.CLowLevelOps.ailang       # MMIO, hardware register access
    │   ├── Library.CExpressionCompiler.ailang # Expression dispatch and evaluation
    │   ├── Library.CUserFunctions.ailang     # User-defined function compilation
    │   ├── Library.CSymbolTable.ailang       # Symbol/scope management
    │   └── Library.CSemanticAnalysis.ailang  # Type checking, validation
    │
    ├── CodeEmit/                         # Abstract Instruction Layer
    │   ├── Library.CEmitCore.ailang          # Instruction buffer, label management
    │   ├── Library.CEmitInstr.ailang         # Asm_Mov, Asm_Add, Asm_Jmp, etc.
    │   ├── Library.CEmitRegisters.ailang     # Reg.RAX, Reg.RBX constants
    │   └── Library.CEmitData.ailang          # Data section management
    │
    ├── Assembler/                        # Target-Specific Encoding (BYTES HERE)
    │   ├── X86_64/
    │   │   ├── Library.CAsmX86Core.ailang        # Assembler state, output buffer
    │   │   ├── Library.CAsmX86Encode.ailang      # Main instruction encoder
    │   │   ├── Library.CAsmX86ModRM.ailang       # ModR/M, SIB, REX encoding
    │   │   ├── Library.CAsmX86Tables.ailang      # Opcode lookup tables
    │   │   └── Library.CAsmX86Fixup.ailang       # Label resolution, relocations
    │   │
    │   └── ARM64/                            # Future: Copy X86_64, modify
    │       ├── Library.CAsmARMCore.ailang
    │       ├── Library.CAsmARMEncode.ailang
    │       └── Library.CAsmARMTables.ailang
    │
    ├── Output/                           # Executable Generation
    │   ├── Library.CELFCore.ailang           # ELF structures and constants
    │   ├── Library.CELFSections.ailang       # Section management (.text, .data, etc.)
    │   ├── Library.CELFSymbols.ailang        # Symbol and string tables
    │   └── Library.CELFBuilder.ailang        # Final ELF assembly
    │
    └── Driver/                           # Orchestration
        ├── Library.CDriver.ailang            # Main compilation pipeline
        └── Library.CErrors.ailang            # Error reporting and recovery
```

---

# 4. Compilation Pipeline

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        AILang Source (.ailang)                          │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
══════════════════════════════════════════════════════════════════════════
                           FRONTEND (Language-Specific)
══════════════════════════════════════════════════════════════════════════
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  LEXER                                                                  │
│  ────────────────────────────────────────────────────────────────────── │
│  • CLexerCore: Token types, lexer state (pos, line, col)               │
│  • CLexerTokenize: Main tokenization loop                               │
│  • CLexerKeywords: AILang keyword recognition                           │
│  Output: XArray of token records                                        │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  PARSER                                                                 │
│  ────────────────────────────────────────────────────────────────────── │
│  • CParserCore: State management, token access, AST helpers            │
│  • CParserExpr: Precedence climbing for expressions                     │
│  • CParserStmt: Control flow, assignments, calls                        │
│  • CParserDecl: Function, SubRoutine, FixedPool, LibraryImport         │
│  Output: AST root node                                                  │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  AST NODES                                                              │
│  ────────────────────────────────────────────────────────────────────── │
│  • Uniform structure: [Type, Line, Col, ...fields]                     │
│  • Tree built with XArrays for child lists                              │
│  • Accessor functions for type-safe field access                        │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
══════════════════════════════════════════════════════════════════════════
                           SEMANTIC ANALYSIS
══════════════════════════════════════════════════════════════════════════
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  SYMBOL TABLE & TYPE CHECKING                                           │
│  ────────────────────────────────────────────────────────────────────── │
│  • Build symbol table (functions, variables, pools)                    │
│  • Resolve identifier references                                        │
│  • Validate function signatures                                         │
│  • Check type compatibility (Integer vs Address)                       │
│  Output: Annotated AST + Symbol Table                                   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
══════════════════════════════════════════════════════════════════════════
                        CODE GENERATION (Target-Agnostic)
══════════════════════════════════════════════════════════════════════════
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  COMPILER MODULES                                                       │
│  ────────────────────────────────────────────────────────────────────── │
│  • CArithmeticOps: Emit Asm_Add, Asm_Sub, Asm_Mul, Asm_Div             │
│  • CMathOps: Emit Asm_Mov, Asm_Cmp, Asm_Cmov for min/max/abs           │
│  • CStringOps: String manipulation via Asm_* calls                     │
│  • CControlFlow: Emit Asm_Jmp, Asm_Je, Asm_Call, labels                │
│  • ... (one module per operation category)                             │
│  Output: Stream of abstract instructions                                │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  INSTRUCTION BUFFER (CEmitCore)                                         │
│  ────────────────────────────────────────────────────────────────────── │
│  • Stores instruction records: [opcode, operands...]                   │
│  • Manages labels and forward references                                │
│  • Manages data section (strings, constants)                           │
│  Output: XArray of instruction records + data items                     │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
══════════════════════════════════════════════════════════════════════════
                        ASSEMBLER (Target-Specific)
══════════════════════════════════════════════════════════════════════════
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  X86_64 ASSEMBLER                                                       │
│  ────────────────────────────────────────────────────────────────────── │
│  • CAsmX86Encode: Pattern match instructions, emit bytes               │
│  • CAsmX86ModRM: Build REX, ModR/M, SIB bytes                          │
│  • CAsmX86Tables: Opcode lookup tables                                 │
│  • CAsmX86Fixup: Resolve labels, calculate jump offsets                │
│  Output: Machine code bytes + relocation info                           │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
══════════════════════════════════════════════════════════════════════════
                           OUTPUT GENERATION
══════════════════════════════════════════════════════════════════════════
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  ELF GENERATOR                                                          │
│  ────────────────────────────────────────────────────────────────────── │
│  • CELFCore: ELF header, program headers                               │
│  • CELFSections: .text, .data, .bss, .rodata                           │
│  • CELFSymbols: Symbol table, string table                             │
│  • CELFBuilder: Assemble final binary                                  │
│  Output: Executable ELF file                                            │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Executable Binary                               │
└─────────────────────────────────────────────────────────────────────────┘
```

---

# 5. Module Organization

## 5.1 Matching Python Compiler Structure

The AILang compiler modules mirror the existing Python structure:

| Python Module | AILang Module | Responsibility |
|--------------|---------------|----------------|
| `arithmetic_ops.py` | `CArithmeticOps.ailang` | Add, Sub, Mul, Div, Mod |
| `math_ops.py` | `CMathOps.ailang` | Min, Max, Abs, ISqrt, trig |
| `string_ops.py` | `CStringOps.ailang` | String manipulation |
| `memory_manager.py` | `CMemoryOps.ailang` | Allocate, pointers |
| `array_ops.py` | `CArrayOps.ailang` | Array operations |
| `hash_ops.py` | `CHashOps.ailang` | Hash table operations |
| `control_flow.py` | `CControlFlow.ailang` | If, While, For |
| `debug_ops.py` | `CDebugOps.ailang` | Debug/profiling |
| `fileio_ops.py` | `CFileIOOps.ailang` | File I/O |
| `process_ops.py` | `CProcessOps.ailang` | Syscalls, processes |
| `network_ops.py` | `CNetworkOps.ailang` | Sockets |
| `atomic_ops.py` | `CAtomicOps.ailang` | Atomics |
| `lowlevel_ops.py` | `CLowLevelOps.ailang` | MMIO, hardware |
| `expression_compiler.py` | `CExpressionCompiler.ailang` | Expression dispatch |
| `user_functions.py` | `CUserFunctions.ailang` | User function calls |
| `symbol_table.py` | `CSymbolTable.ailang` | Symbols/scopes |

## 5.2 Module Interface Pattern

Each compiler module follows this pattern:

```ailang
// Library.CArithmeticOps.ailang

LibraryImport.CEmitInstr      // For Asm_* functions
LibraryImport.CExpressionCompiler  // For compiling sub-expressions

// State for this module
FixedPool.Arith {
    "depth": Initialize=0, CanChange=True
}

// Main dispatcher
Function.Arith_CompileOperation {
    Input: op_type: Integer
    Input: args: Address    // XArray of AST nodes
    Output: Integer         // 1=handled, 0=not handled
    Body: {
        IfCondition EqualTo(op_type, Op.ADD) ThenBlock: {
            ReturnValue(Arith_CompileAdd(args))
        }
        // ... dispatch to other operations
        ReturnValue(0)
    }
}

// Individual operation compilers
Function.Arith_CompileAdd {
    Input: args: Address
    Output: Integer
    Body: {
        left = XArray.XGet(args, 0)
        right = XArray.XGet(args, 1)
        
        // Compile right operand first (will be in temp register)
        // Then compile left (will be in RAX)
        // Then emit add instruction
        
        Expr_Compile(right)
        Asm_Push_R(Reg.RAX)
        Expr_Compile(left)
        Asm_Pop_R(Reg.RBX)
        Asm_Add_RR(Reg.RAX, Reg.RBX)
        
        ReturnValue(1)
    }
}
```

---

# 6. Abstract Instruction Set (CEmitInstr)

## 6.1 Design Philosophy

The instruction set is **abstract but close to hardware**. It's not a high-level IR - it maps directly to real instructions but without encoding details. This keeps the assembler simple (pattern matching) while keeping compiler modules readable.

## 6.2 Operand Types

```ailang
FixedPool.OpType {
    "NONE": Initialize=0          // No operand
    "REG": Initialize=1           // Register (Reg.RAX, etc.)
    "IMM8": Initialize=2          // 8-bit immediate
    "IMM32": Initialize=3         // 32-bit immediate
    "IMM64": Initialize=4         // 64-bit immediate
    "MEM_REG": Initialize=5       // [reg]
    "MEM_REG_OFF": Initialize=6   // [reg + offset]
    "MEM_REG_REG": Initialize=7   // [reg + reg*scale]
    "MEM_RIP": Initialize=8       // [rip + offset] for data
    "LABEL": Initialize=9         // Label reference
    "DATA_REF": Initialize=10     // Data section reference
}
```

## 6.3 Register Set

```ailang
FixedPool.Reg {
    // General Purpose 64-bit
    "RAX": Initialize=0       "R8": Initialize=8
    "RCX": Initialize=1       "R9": Initialize=9
    "RDX": Initialize=2       "R10": Initialize=10
    "RBX": Initialize=3       "R11": Initialize=11
    "RSP": Initialize=4       "R12": Initialize=12
    "RBP": Initialize=5       "R13": Initialize=13
    "RSI": Initialize=6       "R14": Initialize=14
    "RDI": Initialize=7       "R15": Initialize=15
}

// Size variants handled by instruction functions:
// Asm_Mov8_RR()  - uses AL, BL, etc.
// Asm_Mov32_RR() - uses EAX, EBX, etc.
// Asm_Mov64_RR() - uses RAX, RBX, etc. (default)
```

## 6.4 Instruction Opcode Constants

```ailang
FixedPool.Op {
    // Data Movement
    "MOV": Initialize=1
    "PUSH": Initialize=2
    "POP": Initialize=3
    "LEA": Initialize=4
    "XCHG": Initialize=5
    "MOVZX": Initialize=6
    "MOVSX": Initialize=7
    
    // Arithmetic
    "ADD": Initialize=10
    "SUB": Initialize=11
    "MUL": Initialize=12
    "IMUL": Initialize=13
    "DIV": Initialize=14
    "IDIV": Initialize=15
    "NEG": Initialize=16
    "INC": Initialize=17
    "DEC": Initialize=18
    
    // Bitwise Logic
    "AND": Initialize=20
    "OR": Initialize=21
    "XOR": Initialize=22
    "NOT": Initialize=23
    "SHL": Initialize=24
    "SHR": Initialize=25
    "SAR": Initialize=26
    "ROL": Initialize=27
    "ROR": Initialize=28
    
    // Comparison
    "CMP": Initialize=30
    "TEST": Initialize=31
    
    // Control Flow - Unconditional
    "JMP": Initialize=40
    "CALL": Initialize=41
    "RET": Initialize=42
    
    // Control Flow - Conditional
    "JE": Initialize=50
    "JNE": Initialize=51
    "JL": Initialize=52
    "JLE": Initialize=53
    "JG": Initialize=54
    "JGE": Initialize=55
    "JB": Initialize=56
    "JBE": Initialize=57
    "JA": Initialize=58
    "JAE": Initialize=59
    "JS": Initialize=60
    "JNS": Initialize=61
    "JO": Initialize=62
    "JNO": Initialize=63
    "JZ": Initialize=64
    "JNZ": Initialize=65
    
    // Conditional Move
    "CMOVE": Initialize=70
    "CMOVNE": Initialize=71
    "CMOVL": Initialize=72
    "CMOVLE": Initialize=73
    "CMOVG": Initialize=74
    "CMOVGE": Initialize=75
    "CMOVB": Initialize=76
    "CMOVBE": Initialize=77
    "CMOVA": Initialize=78
    "CMOVAE": Initialize=79
    "CMOVS": Initialize=80
    "CMOVNS": Initialize=81
    
    // Set Byte on Condition
    "SETE": Initialize=90
    "SETNE": Initialize=91
    "SETL": Initialize=92
    "SETLE": Initialize=93
    "SETG": Initialize=94
    "SETGE": Initialize=95
    
    // Special
    "CQO": Initialize=100
    "CDQ": Initialize=101
    "SYSCALL": Initialize=102
    "NOP": Initialize=103
    "INT": Initialize=104
    "HLT": Initialize=105
    "CPUID": Initialize=106
    "RDTSC": Initialize=107
    "MFENCE": Initialize=108
    "LFENCE": Initialize=109
    "SFENCE": Initialize=110
    
    // Pseudo-ops
    "LABEL": Initialize=200
    "DATA": Initialize=201
}
```

## 6.5 Instruction Emission Functions

### Data Movement

```
Asm_Mov_RR(dst_reg, src_reg)              MOV reg, reg
Asm_Mov_RI(dst_reg, imm64)                MOV reg, immediate
Asm_Mov_RM(dst_reg, base_reg, offset)     MOV reg, [base + offset]
Asm_Mov_MR(base_reg, offset, src_reg)     MOV [base + offset], reg
Asm_Mov_MI(base_reg, offset, imm32)       MOV [base + offset], immediate

Asm_Movzx_RR(dst_reg, src_reg, src_size)  Zero-extend move
Asm_Movsx_RR(dst_reg, src_reg, src_size)  Sign-extend move

Asm_Lea(dst_reg, base_reg, offset)        LEA reg, [base + offset]
Asm_Lea_Indexed(dst_reg, base, index, scale, offset)

Asm_Push_R(reg)                           PUSH reg
Asm_Push_I(imm32)                         PUSH immediate
Asm_Push_M(base_reg, offset)              PUSH [base + offset]

Asm_Pop_R(reg)                            POP reg
Asm_Pop_M(base_reg, offset)               POP [base + offset]

Asm_Xchg_RR(reg1, reg2)                   XCHG reg, reg
```

### Arithmetic

```
Asm_Add_RR(dst_reg, src_reg)              ADD reg, reg
Asm_Add_RI(dst_reg, imm32)                ADD reg, immediate
Asm_Add_RM(dst_reg, base_reg, offset)     ADD reg, [base + offset]
Asm_Add_MR(base_reg, offset, src_reg)     ADD [base + offset], reg
Asm_Add_MI(base_reg, offset, imm32)       ADD [base + offset], immediate

Asm_Sub_RR(dst_reg, src_reg)              SUB reg, reg
Asm_Sub_RI(dst_reg, imm32)                SUB reg, immediate
Asm_Sub_RM(dst_reg, base_reg, offset)     SUB reg, [base + offset]
Asm_Sub_MR(base_reg, offset, src_reg)     SUB [base + offset], reg
Asm_Sub_MI(base_reg, offset, imm32)       SUB [base + offset], immediate

Asm_Imul_RR(dst_reg, src_reg)             IMUL reg, reg
Asm_Imul_RRI(dst_reg, src_reg, imm32)     IMUL reg, reg, immediate
Asm_Imul_R(reg)                           IMUL reg (RDX:RAX = RAX * reg)

Asm_Mul_R(reg)                            MUL reg (unsigned)

Asm_Idiv_R(reg)                           IDIV reg (RAX=quotient, RDX=remainder)
Asm_Div_R(reg)                            DIV reg (unsigned)

Asm_Neg_R(reg)                            NEG reg
Asm_Neg_M(base_reg, offset)               NEG [base + offset]

Asm_Inc_R(reg)                            INC reg
Asm_Inc_M(base_reg, offset)               INC [base + offset]

Asm_Dec_R(reg)                            DEC reg
Asm_Dec_M(base_reg, offset)               DEC [base + offset]

Asm_Cqo()                                 CQO (sign extend RAX to RDX:RAX)
Asm_Cdq()                                 CDQ (sign extend EAX to EDX:EAX)
```

### Bitwise Logic

```
Asm_And_RR(dst_reg, src_reg)              AND reg, reg
Asm_And_RI(dst_reg, imm32)                AND reg, immediate
Asm_And_RM(dst_reg, base_reg, offset)     AND reg, [base + offset]

Asm_Or_RR(dst_reg, src_reg)               OR reg, reg
Asm_Or_RI(dst_reg, imm32)                 OR reg, immediate
Asm_Or_RM(dst_reg, base_reg, offset)      OR reg, [base + offset]

Asm_Xor_RR(dst_reg, src_reg)              XOR reg, reg
Asm_Xor_RI(dst_reg, imm32)                XOR reg, immediate
Asm_Xor_RM(dst_reg, base_reg, offset)     XOR reg, [base + offset]

Asm_Not_R(reg)                            NOT reg
Asm_Not_M(base_reg, offset)               NOT [base + offset]

Asm_Shl_RI(reg, imm8)                     SHL reg, immediate
Asm_Shl_RCL(reg)                          SHL reg, CL

Asm_Shr_RI(reg, imm8)                     SHR reg, immediate (logical)
Asm_Shr_RCL(reg)                          SHR reg, CL

Asm_Sar_RI(reg, imm8)                     SAR reg, immediate (arithmetic)
Asm_Sar_RCL(reg)                          SAR reg, CL

Asm_Rol_RI(reg, imm8)                     ROL reg, immediate
Asm_Ror_RI(reg, imm8)                     ROR reg, immediate
```

### Comparison & Test

```
Asm_Cmp_RR(reg1, reg2)                    CMP reg, reg
Asm_Cmp_RI(reg, imm32)                    CMP reg, immediate
Asm_Cmp_RM(reg, base_reg, offset)         CMP reg, [base + offset]
Asm_Cmp_MR(base_reg, offset, reg)         CMP [base + offset], reg
Asm_Cmp_MI(base_reg, offset, imm32)       CMP [base + offset], immediate

Asm_Test_RR(reg1, reg2)                   TEST reg, reg
Asm_Test_RI(reg, imm32)                   TEST reg, immediate
Asm_Test_RM(reg, base_reg, offset)        TEST reg, [base + offset]
```

### Control Flow - Unconditional

```
Asm_Jmp_L(label)                          JMP label (direct)
Asm_Jmp_R(reg)                            JMP reg (indirect)
Asm_Jmp_M(base_reg, offset)               JMP [base + offset]

Asm_Call_L(label)                         CALL label (direct)
Asm_Call_R(reg)                           CALL reg (indirect)
Asm_Call_M(base_reg, offset)              CALL [base + offset]

Asm_Ret()                                 RET
Asm_Ret_I(imm16)                          RET immediate
```

### Control Flow - Conditional Jumps

```
Asm_Je(label)       JE/JZ    Jump if equal/zero
Asm_Jne(label)      JNE/JNZ  Jump if not equal/not zero
Asm_Jl(label)       JL       Jump if less (signed)
Asm_Jle(label)      JLE      Jump if less or equal (signed)
Asm_Jg(label)       JG       Jump if greater (signed)
Asm_Jge(label)      JGE      Jump if greater or equal (signed)
Asm_Jb(label)       JB       Jump if below (unsigned)
Asm_Jbe(label)      JBE      Jump if below or equal (unsigned)
Asm_Ja(label)       JA       Jump if above (unsigned)
Asm_Jae(label)      JAE      Jump if above or equal (unsigned)
Asm_Js(label)       JS       Jump if sign (negative)
Asm_Jns(label)      JNS      Jump if not sign
Asm_Jo(label)       JO       Jump if overflow
Asm_Jno(label)      JNO      Jump if not overflow
Asm_Jz(label)       JZ       Jump if zero (alias for JE)
Asm_Jnz(label)      JNZ      Jump if not zero (alias for JNE)
```

### Conditional Move

```
Asm_Cmove_RR(dst, src)    CMOVE   Move if equal
Asm_Cmovne_RR(dst, src)   CMOVNE  Move if not equal
Asm_Cmovl_RR(dst, src)    CMOVL   Move if less (signed)
Asm_Cmovle_RR(dst, src)   CMOVLE  Move if less or equal
Asm_Cmovg_RR(dst, src)    CMOVG   Move if greater (signed)
Asm_Cmovge_RR(dst, src)   CMOVGE  Move if greater or equal
Asm_Cmovb_RR(dst, src)    CMOVB   Move if below (unsigned)
Asm_Cmovbe_RR(dst, src)   CMOVBE  Move if below or equal
Asm_Cmova_RR(dst, src)    CMOVA   Move if above (unsigned)
Asm_Cmovae_RR(dst, src)   CMOVAE  Move if above or equal
Asm_Cmovs_RR(dst, src)    CMOVS   Move if sign
Asm_Cmovns_RR(dst, src)   CMOVNS  Move if not sign
```

### Set Byte on Condition

```
Asm_Sete_R(reg)     SETE    Set byte if equal
Asm_Setne_R(reg)    SETNE   Set byte if not equal
Asm_Setl_R(reg)     SETL    Set byte if less
Asm_Setle_R(reg)    SETLE   Set byte if less or equal
Asm_Setg_R(reg)     SETG    Set byte if greater
Asm_Setge_R(reg)    SETGE   Set byte if greater or equal
... (all conditions)
```

### System & Special

```
Asm_Syscall()                 SYSCALL
Asm_Nop()                     NOP
Asm_Int(imm8)                 INT immediate
Asm_Hlt()                     HLT
Asm_Cli()                     CLI
Asm_Sti()                     STI
Asm_Cpuid()                   CPUID
Asm_Rdtsc()                   RDTSC
Asm_Mfence()                  MFENCE
Asm_Lfence()                  LFENCE
Asm_Sfence()                  SFENCE
```

### Label & Data Management

```
Asm_Label(name)                      Define label at current position
Asm_CreateLabel() -> label_name      Generate unique label name

Asm_DataString(string) -> data_ref   Add string to data section
Asm_DataInt64(value) -> data_ref     Add 64-bit value to data section
Asm_DataBytes(array) -> data_ref     Add raw bytes to data section

Asm_LoadDataAddr(dst_reg, data_ref)  LEA reg, [rip + data_offset]
```

## 6.6 Instruction Record Format

Each instruction stored in the buffer:

```
[opcode, size, op1_type, op1_val, op1_extra, op2_type, op2_val, op2_extra]

Fields:
  opcode    - Op.MOV, Op.ADD, etc.
  size      - 8, 16, 32, 64 (operand size in bits)
  op1_type  - OpType.REG, OpType.IMM, OpType.MEM_REG_OFF, etc.
  op1_val   - Register number, immediate value, or base register
  op1_extra - Offset for memory, scale for indexed, 0 otherwise
  op2_type  - Same as op1
  op2_val   - Same as op1
  op2_extra - Same as op1

Examples:
  MOV RAX, RBX       [Op.MOV, 64, REG, RAX, 0, REG, RBX, 0]
  MOV RAX, 42        [Op.MOV, 64, REG, RAX, 0, IMM64, 42, 0]
  MOV RAX, [RBP-8]   [Op.MOV, 64, REG, RAX, 0, MEM_REG_OFF, RBP, -8]
  ADD [RBP-16], 100  [Op.ADD, 64, MEM_REG_OFF, RBP, -16, IMM32, 100, 0]
  JMP .L5            [Op.JMP, 0, LABEL, ".L5", 0, NONE, 0, 0]
  CALL func          [Op.CALL, 0, LABEL, "func", 0, NONE, 0, 0]
```

---

# 7. X86_64 Encoding Specification

## 7.1 Instruction Format Overview

```
x86_64 Instruction:
┌──────────┬────────┬────────┬────────┬─────┬─────────────┬─────────────┐
│ Prefixes │  REX   │ Opcode │ ModR/M │ SIB │ Displacement│  Immediate  │
│ (0-4 B)  │ (0-1 B)│ (1-3 B)│ (0-1 B)│(0-1)│   (0/1/4 B) │ (0/1/2/4/8) │
└──────────┴────────┴────────┴────────┴─────┴─────────────┴─────────────┘
```

## 7.2 REX Prefix

```
REX = 0100 WRXB

W = 1: 64-bit operand size
R = 1: Extension of ModR/M reg field (access R8-R15)
X = 1: Extension of SIB index field
B = 1: Extension of ModR/M r/m or SIB base field

Examples:
  0x48 = REX.W       (64-bit operation)
  0x4C = REX.W + REX.R (64-bit, extended reg field)
  0x49 = REX.W + REX.B (64-bit, extended r/m field)
  0x4D = REX.W + REX.R + REX.B (64-bit, both extended)
```

## 7.3 ModR/M Byte

```
ModR/M = [Mod:2][Reg:3][R/M:3]

Mod field:
  00 = [r/m]           Memory, no displacement (except RBP/R13)
  01 = [r/m + disp8]   Memory, 8-bit displacement
  10 = [r/m + disp32]  Memory, 32-bit displacement
  11 = r/m             Register direct

Reg field: Register operand or opcode extension (/0 through /7)

R/M field: Register or memory operand
  When Mod=11: register
  When Mod!=11: base register (or 100 for SIB, 101 for RIP-relative)
```

## 7.4 SIB Byte

```
SIB = [Scale:2][Index:3][Base:3]

Scale: 00=*1, 01=*2, 10=*4, 11=*8
Index: Index register (100 = none)
Base: Base register (101 with Mod=00 = disp32 only)

Used when:
  - RSP/R12 is base register (R/M = 100)
  - Scaled index addressing needed
```

## 7.5 Condition Codes

```ailang
FixedPool.X86CC {
    "O": Initialize=0       // Overflow
    "NO": Initialize=1      // Not overflow
    "B": Initialize=2       // Below (unsigned <), alias C, NAE
    "AE": Initialize=3      // Above or equal (unsigned >=), alias NB, NC
    "E": Initialize=4       // Equal, alias Z
    "NE": Initialize=5      // Not equal, alias NZ
    "BE": Initialize=6      // Below or equal (unsigned <=), alias NA
    "A": Initialize=7       // Above (unsigned >), alias NBE
    "S": Initialize=8       // Sign (negative)
    "NS": Initialize=9      // Not sign
    "P": Initialize=10      // Parity even
    "NP": Initialize=11     // Parity odd
    "L": Initialize=12      // Less (signed <), alias NGE
    "GE": Initialize=13     // Greater or equal (signed >=), alias NL
    "LE": Initialize=14     // Less or equal (signed <=), alias NG
    "G": Initialize=15      // Greater (signed >), alias NLE
}

Jcc short:  0x70 + cc, rel8
Jcc near:   0x0F 0x80 + cc, rel32
CMOVcc:     0x0F 0x40 + cc, ModR/M
SETcc:      0x0F 0x90 + cc, ModR/M
```

## 7.6 Primary Opcode Table

```ailang
FixedPool.X86Opc {
    // ADD
    "ADD_RM_R": Initialize=0x01     // ADD r/m64, r64
    "ADD_R_RM": Initialize=0x03     // ADD r64, r/m64
    "ADD_AL_I": Initialize=0x04     // ADD AL, imm8
    "ADD_RAX_I": Initialize=0x05    // ADD RAX, imm32
    "ADD_RM_I8": Initialize=0x83    // ADD r/m64, imm8 (/0)
    "ADD_RM_I32": Initialize=0x81   // ADD r/m64, imm32 (/0)
    
    // SUB
    "SUB_RM_R": Initialize=0x29     // SUB r/m64, r64
    "SUB_R_RM": Initialize=0x2B     // SUB r64, r/m64
    "SUB_RAX_I": Initialize=0x2D    // SUB RAX, imm32
    "SUB_RM_I8": Initialize=0x83    // SUB r/m64, imm8 (/5)
    "SUB_RM_I32": Initialize=0x81   // SUB r/m64, imm32 (/5)
    
    // AND
    "AND_RM_R": Initialize=0x21     // AND r/m64, r64
    "AND_R_RM": Initialize=0x23     // AND r64, r/m64
    "AND_RAX_I": Initialize=0x25    // AND RAX, imm32
    "AND_RM_I8": Initialize=0x83    // AND r/m64, imm8 (/4)
    "AND_RM_I32": Initialize=0x81   // AND r/m64, imm32 (/4)
    
    // OR
    "OR_RM_R": Initialize=0x09      // OR r/m64, r64
    "OR_R_RM": Initialize=0x0B      // OR r64, r/m64
    "OR_RAX_I": Initialize=0x0D     // OR RAX, imm32
    "OR_RM_I8": Initialize=0x83     // OR r/m64, imm8 (/1)
    "OR_RM_I32": Initialize=0x81    // OR r/m64, imm32 (/1)
    
    // XOR
    "XOR_RM_R": Initialize=0x31     // XOR r/m64, r64
    "XOR_R_RM": Initialize=0x33     // XOR r64, r/m64
    "XOR_RAX_I": Initialize=0x35    // XOR RAX, imm32
    "XOR_RM_I8": Initialize=0x83    // XOR r/m64, imm8 (/6)
    "XOR_RM_I32": Initialize=0x81   // XOR r/m64, imm32 (/6)
    
    // CMP
    "CMP_RM_R": Initialize=0x39     // CMP r/m64, r64
    "CMP_R_RM": Initialize=0x3B     // CMP r64, r/m64
    "CMP_RAX_I": Initialize=0x3D    // CMP RAX, imm32
    "CMP_RM_I8": Initialize=0x83    // CMP r/m64, imm8 (/7)
    "CMP_RM_I32": Initialize=0x81   // CMP r/m64, imm32 (/7)
    
    // MOV
    "MOV_RM_R": Initialize=0x89     // MOV r/m64, r64
    "MOV_R_RM": Initialize=0x8B     // MOV r64, r/m64
    "MOV_R_I64": Initialize=0xB8    // MOV r64, imm64 (+rd)
    "MOV_RM_I32": Initialize=0xC7   // MOV r/m64, imm32 (/0)
    "MOV_AL_I": Initialize=0xB0     // MOV AL, imm8 (+rb)
    
    // TEST
    "TEST_RM_R": Initialize=0x85    // TEST r/m64, r64
    "TEST_RAX_I": Initialize=0xA9   // TEST RAX, imm32
    "TEST_RM_I": Initialize=0xF7    // TEST r/m64, imm32 (/0)
    
    // LEA
    "LEA": Initialize=0x8D          // LEA r64, m
    
    // PUSH/POP
    "PUSH_R": Initialize=0x50       // PUSH r64 (+rd)
    "POP_R": Initialize=0x58        // POP r64 (+rd)
    "PUSH_I8": Initialize=0x6A      // PUSH imm8
    "PUSH_I32": Initialize=0x68     // PUSH imm32
    
    // INC/DEC
    "INC_RM": Initialize=0xFF       // INC r/m64 (/0)
    "DEC_RM": Initialize=0xFF       // DEC r/m64 (/1)
    
    // NEG/NOT
    "NEG_RM": Initialize=0xF7       // NEG r/m64 (/3)
    "NOT_RM": Initialize=0xF7       // NOT r/m64 (/2)
    
    // MUL/DIV
    "MUL_RM": Initialize=0xF7       // MUL r/m64 (/4)
    "IMUL_RM": Initialize=0xF7      // IMUL r/m64 (/5)
    "DIV_RM": Initialize=0xF7       // DIV r/m64 (/6)
    "IDIV_RM": Initialize=0xF7      // IDIV r/m64 (/7)
    
    // Shifts
    "SHL_RM_1": Initialize=0xD1     // SHL r/m64, 1 (/4)
    "SHL_RM_CL": Initialize=0xD3    // SHL r/m64, CL (/4)
    "SHL_RM_I": Initialize=0xC1     // SHL r/m64, imm8 (/4)
    "SHR_RM_1": Initialize=0xD1     // SHR r/m64, 1 (/5)
    "SHR_RM_CL": Initialize=0xD3    // SHR r/m64, CL (/5)
    "SHR_RM_I": Initialize=0xC1     // SHR r/m64, imm8 (/5)
    "SAR_RM_1": Initialize=0xD1     // SAR r/m64, 1 (/7)
    "SAR_RM_CL": Initialize=0xD3    // SAR r/m64, CL (/7)
    "SAR_RM_I": Initialize=0xC1     // SAR r/m64, imm8 (/7)
    
    // Control flow
    "JMP_REL8": Initialize=0xEB     // JMP rel8
    "JMP_REL32": Initialize=0xE9    // JMP rel32
    "CALL_REL32": Initialize=0xE8   // CALL rel32
    "RET": Initialize=0xC3          // RET
    "RET_I": Initialize=0xC2        // RET imm16
    
    // JMP/CALL indirect
    "JMP_RM": Initialize=0xFF       // JMP r/m64 (/4)
    "CALL_RM": Initialize=0xFF      // CALL r/m64 (/2)
    
    // Misc
    "NOP": Initialize=0x90          // NOP
    "CQO": Initialize=0x99          // CQO (with REX.W)
    "SYSCALL_1": Initialize=0x0F    // SYSCALL (0F 05)
    "SYSCALL_2": Initialize=0x05
}
```

## 7.7 ModR/M Extension Table (/digit)

```ailang
FixedPool.X86Ext {
    // For 0x80-0x83 group (ADD, OR, ADC, SBB, AND, SUB, XOR, CMP)
    "ADD": Initialize=0    // /0
    "OR": Initialize=1     // /1
    "ADC": Initialize=2    // /2
    "SBB": Initialize=3    // /3
    "AND": Initialize=4    // /4
    "SUB": Initialize=5    // /5
    "XOR": Initialize=6    // /6
    "CMP": Initialize=7    // /7
    
    // For 0xC0/0xC1/0xD0/0xD1/0xD2/0xD3 shift group
    "ROL": Initialize=0    // /0
    "ROR": Initialize=1    // /1
    "RCL": Initialize=2    // /2
    "RCR": Initialize=3    // /3
    "SHL": Initialize=4    // /4 (also SAL)
    "SHR": Initialize=5    // /5
    "SAR": Initialize=7    // /7
    
    // For 0xF6/0xF7 group
    "TEST_I": Initialize=0 // /0
    "NOT": Initialize=2    // /2
    "NEG": Initialize=3    // /3
    "MUL": Initialize=4    // /4
    "IMUL": Initialize=5   // /5
    "DIV": Initialize=6    // /6
    "IDIV": Initialize=7   // /7
    
    // For 0xFE/0xFF group
    "INC": Initialize=0    // /0
    "DEC": Initialize=1    // /1
    "CALL_IND": Initialize=2  // /2
    "JMP_IND": Initialize=4   // /4
    "PUSH_M": Initialize=6    // /6
}
```

## 7.8 Two-Byte Opcode Instructions (0x0F prefix)

```
SYSCALL           0F 05
CPUID             0F A2
RDTSC             0F 31

CMOVcc r64, r/m64    [REX.W] 0F 40+cc ModR/M
SETcc r/m8           0F 90+cc ModR/M

IMUL r64, r/m64      [REX.W] 0F AF ModR/M

MOVZX r64, r/m8      [REX.W] 0F B6 ModR/M
MOVZX r64, r/m16     [REX.W] 0F B7 ModR/M
MOVSX r64, r/m8      [REX.W] 0F BE ModR/M
MOVSX r64, r/m16     [REX.W] 0F BF ModR/M

Jcc rel32            0F 80+cc rel32
```

## 7.9 Special Encoding Cases

```
RSP/R12 as base requires SIB:
  MOV RAX, [RSP]      48 8B 04 24      (SIB: scale=0, index=4, base=4)
  MOV RAX, [RSP+8]    48 8B 44 24 08   (SIB + disp8)

RBP/R13 with no displacement needs disp8=0:
  MOV RAX, [RBP]      48 8B 45 00      (Mod=01, disp8=0)

RIP-relative (for data section):
  MOV RAX, [RIP+disp32]  48 8B 05 disp32  (Mod=00, R/M=101)

Extended registers need REX:
  MOV R8, RAX         4C 89 C0         (REX.R=1)
  MOV RAX, R8         49 89 C0         (REX.B=1)
  MOV R8, R9          4D 89 C8         (REX.R=1, REX.B=1)

64-bit immediate only with MOV r64, imm64:
  MOV RAX, 0x123456789ABCDEF0   48 B8 [8 bytes little-endian]
```

---

# 8. Assembler Module Organization

## 8.1 Module Breakdown

```
Library.CAsmX86Core.ailang
  ├── Assembler state (code buffer, data buffer, fixups)
  ├── Initialization / finalization
  ├── Output retrieval functions
  └── Data section management

Library.CAsmX86Encode.ailang
  ├── Main encoding dispatcher
  ├── Pattern matching on instruction records
  ├── Instruction-specific encoders
  └── Calls ModRM/SIB helpers

Library.CAsmX86ModRM.ailang
  ├── X86_EncodeREX(w, r, x, b)
  ├── X86_EncodeModRM(mod, reg, rm)
  ├── X86_EncodeSIB(scale, index, base)
  ├── X86_EncodeDisplacement(offset)
  ├── X86_EncodeImmediate(value, size)
  └── Register encoding helpers

Library.CAsmX86Tables.ailang
  ├── Opcode lookup tables
  ├── Condition code tables
  ├── Register encoding tables
  └── Instruction format tables

Library.CAsmX86Fixup.ailang
  ├── Label resolution
  ├── Jump offset calculation (short vs near)
  ├── Relocation generation
  └── Two-pass offset calculation
```

## 8.2 Encoding Flow Example

```
Input: Asm_Add_RR(Reg.RAX, Reg.RBX)

CEmitInstr stores:
  [Op.ADD, 64, OpType.REG, 0, 0, OpType.REG, 3, 0]

Assembler processes:
  1. Match Op.ADD with REG, REG operands
  2. Look up opcode: ADD r/m64, r64 = 0x01
  3. Check REX needed: 64-bit=yes, regs<8 = REX.W only
  4. Build REX: 0100 1000 = 0x48
  5. Build ModR/M: mod=11, reg=RBX(3), rm=RAX(0)
     → 11 011 000 = 0xD8
  6. Emit bytes: 0x48, 0x01, 0xD8

Output: 48 01 D8
```

---

# 9. ELF Output Generation

## 9.1 ELF Structure

```
┌─────────────────────────────┐
│       ELF Header            │  64 bytes
├─────────────────────────────┤
│    Program Headers          │  2 entries × 56 bytes
│    (LOAD segments)          │
├─────────────────────────────┤
│       .text section         │  Executable code
├─────────────────────────────┤
│       .data section         │  Initialized data
├─────────────────────────────┤
│       .bss section          │  Uninitialized data (no file space)
├─────────────────────────────┤
│    Section Headers          │  Optional, for debugging
│    (if included)            │
└─────────────────────────────┘
```

## 9.2 Key ELF Constants

```ailang
FixedPool.ELF {
    // File type
    "ET_EXEC": Initialize=2        // Executable
    
    // Machine
    "EM_X86_64": Initialize=62     // AMD x86-64
    
    // Segment types
    "PT_LOAD": Initialize=1        // Loadable segment
    "PT_NOTE": Initialize=4        // Note segment
    
    // Segment flags
    "PF_X": Initialize=1           // Execute
    "PF_W": Initialize=2           // Write
    "PF_R": Initialize=4           // Read
    
    // Section types
    "SHT_PROGBITS": Initialize=1   // Program data
    "SHT_NOBITS": Initialize=8     // BSS
    "SHT_STRTAB": Initialize=3     // String table
    "SHT_SYMTAB": Initialize=2     // Symbol table
    
    // Base addresses
    "TEXT_BASE": Initialize=0x400000   // Code segment base
    "DATA_BASE": Initialize=0x600000   // Data segment base
}
```

## 9.3 Minimal Executable Requirements

For a minimal executable:
1. ELF header (64 bytes)
2. Two program headers (LOAD for text, LOAD for data)
3. .text section (code)
4. .data section (initialized data)
5. Entry point set to `_start` or `main`

---

# 10. Porting Strategy

## 10.1 Adding a New Architecture

To add ARM64 support:

1. **Copy backend directory:**
   ```
   cp -r Assembler/X86_64/ Assembler/ARM64/
   ```

2. **Modify encoding files:**
   - `CAsmARMCore.ailang` - Same interface, ARM state
   - `CAsmARMEncode.ailang` - ARM instruction encoding
   - `CAsmARMTables.ailang` - ARM opcode tables

3. **Register mapping:**
   ```
   X86_64          ARM64
   ──────          ─────
   RAX      →      X0 (return value)
   RDI      →      X0 (arg 1)
   RSI      →      X1 (arg 2)
   RDX      →      X2 (arg 3)
   RCX      →      X3 (arg 4)
   R8       →      X4 (arg 5)
   R9       →      X5 (arg 6)
   RSP      →      SP
   RBP      →      X29 (FP)
   ```

4. **Instruction translation:**
   ```
   X86_64                ARM64
   ──────                ─────
   MOV RAX, RBX    →     MOV X0, X1
   ADD RAX, RBX    →     ADD X0, X0, X1
   JMP label       →     B label
   JE label        →     B.EQ label
   CALL func       →     BL func
   RET             →     RET
   SYSCALL         →     SVC #0
   ```

5. **No changes to:**
   - Frontend (lexer, parser)
   - Compiler modules
   - CodeEmit layer
   - ELF generator (update machine type only)

## 10.2 What Changes Per Architecture

| Component | X86_64 | ARM64 | RISC-V |
|-----------|--------|-------|--------|
| Frontend | Same | Same | Same |
| Compiler Modules | Same | Same | Same |
| CodeEmit | Same | Same | Same |
| Assembler | X86_64/ | ARM64/ | RISCV/ |
| ELF Machine | EM_X86_64 | EM_AARCH64 | EM_RISCV |

---

# 11. Implementation Phases

## Phase 1: Foundation (Weeks 1-2)

### 1.1 Lexer (CLexerCore, CLexerTokenize, CLexerKeywords)
- Token type definitions for all AILang tokens
- Lexer state management (position, line, column)
- Character classification helpers
- Keyword recognition table
- String and number literal parsing
- **Test**: Tokenize simple AILang files

### 1.2 Core Data Structures
- Instruction record format
- Register constants (Reg.RAX, etc.)
- Opcode constants (Op.MOV, etc.)
- Operand type constants

### 1.3 Instruction Emission Core (CEmitCore)
- Instruction buffer (XArray of records)
- Label creation and marking
- Data section item storage

---

## Phase 2: Parser (Weeks 3-4)

### 2.1 Parser Core (CParserCore)
- Parser state management
- Token access helpers
- AST node creation functions
- Error recovery basics

### 2.2 Expression Parser (CParserExpr)
- Precedence climbing implementation
- Literal parsing (numbers, strings)
- Identifier parsing
- Function call parsing
- Binary and unary operators

### 2.3 Statement Parser (CParserStmt)
- Assignment statements
- IfCondition / ThenBlock / ElseBlock
- WhileLoop
- ForEvery
- ReturnValue
- BreakLoop / ContinueLoop

### 2.4 Declaration Parser (CParserDecl)
- Function definitions
- SubRoutine definitions
- FixedPool definitions
- LibraryImport handling
- Input/Output/Body structure

---

## Phase 3: Basic Code Generation (Weeks 5-7)

### 3.1 Instruction Emission Functions (CEmitInstr)
- Data movement: Asm_Mov_*, Asm_Push_*, Asm_Pop_*
- Arithmetic: Asm_Add_*, Asm_Sub_*, Asm_Imul_*, Asm_Idiv_*
- Comparison: Asm_Cmp_*, Asm_Test_*
- Control flow: Asm_Jmp_*, Asm_Jcc_*, Asm_Call_*, Asm_Ret
- Special: Asm_Syscall, Asm_Cqo

### 3.2 Arithmetic Operations (CArithmeticOps)
- Add, Subtract, Multiply, Divide, Modulo
- Register depth tracking for nested expressions
- Proper operand evaluation order

### 3.3 Comparison Operations (CComparisonOps)
- EqualTo, NotEqual
- LessThan, LessEqual, GreaterThan, GreaterEqual
- Result in RAX (0 or 1)

### 3.4 Control Flow (CControlFlow)
- IfCondition compilation with labels
- WhileLoop compilation
- ForEvery compilation (range-based)
- Break and Continue handling

### 3.5 Basic Function Framework
- Function prologue (push rbp, mov rbp rsp, sub rsp)
- Function epilogue (leave, ret)
- Parameter passing (System V ABI)
- Local variable allocation
- Return value handling

---

## Phase 4: X86_64 Assembler (Weeks 8-10)

### 4.1 Assembler Core (CAsmX86Core)
- Output byte buffer
- Label storage and lookup
- Fixup list for forward references
- Data section bytes

### 4.2 ModR/M Encoding (CAsmX86ModRM)
- REX prefix generation
- ModR/M byte construction
- SIB byte construction
- Displacement encoding
- Immediate encoding

### 4.3 Instruction Encoding (CAsmX86Encode)
- Pattern matching dispatcher
- Register-register encoding
- Register-immediate encoding
- Register-memory encoding
- Memory-register encoding
- Jump/call encoding

### 4.4 Opcode Tables (CAsmX86Tables)
- Primary opcode table
- Two-byte opcode table (0F prefix)
- ModR/M extension table (/digit)
- Condition code table

### 4.5 Fixup Resolution (CAsmX86Fixup)
- Label offset calculation
- Short vs near jump selection
- Relocation record generation
- Two-pass assembly for forward refs

---

## Phase 5: ELF Generation (Weeks 11-12)

### 5.1 ELF Core (CELFCore)
- ELF header structure
- Program header structure
- Section header structure
- Constants and magic numbers

### 5.2 Section Management (CELFSections)
- .text section (executable code)
- .data section (initialized data)
- .bss section (uninitialized data)
- Section alignment

### 5.3 ELF Builder (CELFBuilder)
- Header generation
- Program header generation
- Section layout calculation
- Final binary assembly
- File output

---

## Phase 6: Extended Operations (Weeks 13-16)

### 6.1 Math Operations (CMathOps)
- Min, Max, Abs, Sign
- Clamp, ISqrt
- Conditional moves for branchless code

### 6.2 String Operations (CStringOps)
- StringLength
- StringCompare
- StringConcat
- StringCopy
- Print operations

### 6.3 Memory Operations (CMemoryOps)
- Allocate (mmap syscall)
- Deallocate (munmap syscall)
- SetByte, GetByte
- SetMemory, Dereference

### 6.4 Array Operations (CArrayOps)
- ArrayCreate
- ArrayGet, ArraySet
- ArrayLength
- ArrayDestroy

### 6.5 Bitwise Operations (CBitwiseOps)
- And, Or, Xor, Not
- Shl, Shr, Sar
- Rotate operations

---

## Phase 7: Advanced Features (Weeks 17-20)

### 7.1 Hash Operations (CHashOps)
- HashCreate
- HashSet, HashGet
- HashDelete
- HashContains

### 7.2 File I/O (CFileIOOps)
- File open/close
- File read/write
- File seek

### 7.3 Process Operations (CProcessOps)
- SystemCall compilation
- Exit handling
- Process management

### 7.4 Symbol Table (CSymbolTable)
- Scope management
- Variable lookup
- Function signature storage
- Type tracking (Integer vs Address)

### 7.5 Semantic Analysis (CSemanticAnalysis)
- Type checking
- Undefined variable detection
- Function signature validation
- FixedPool field validation

---

## Phase 8: Self-Hosting (Weeks 21-24)

### 8.1 Driver Integration (CDriver)
- Command line parsing
- File reading
- Pipeline orchestration
- Error reporting

### 8.2 Library Import System
- Library file loading
- Symbol resolution across files
- Dependency ordering

### 8.3 Bootstrap Testing
- Compile simple programs
- Compile compiler components
- Full self-compilation test
- Verification against Python compiler output

### 8.4 Optimization (Optional)
- Peephole optimizations
- Register allocation improvements
- Instruction selection improvements

---

## Phase 9: Documentation & Polish (Ongoing)

### 9.1 Documentation
- Module API documentation
- Instruction set reference
- Encoding reference
- User guide

### 9.2 Testing
- Unit tests per module
- Integration tests
- Regression test suite
- Comparison tests with Python compiler

### 9.3 Error Handling
- Meaningful error messages
- Source location tracking
- Recovery strategies

---

# Appendix: Quick Reference

## A.1 Common X86_64 Encodings

```
Instruction              Bytes
───────────────────────  ─────────────────
MOV RAX, RBX             48 89 D8
MOV RAX, 42              48 C7 C0 2A000000
MOV RAX, [RBP-8]         48 8B 45 F8
MOV [RBP-8], RAX         48 89 45 F8

ADD RAX, RBX             48 01 D8
ADD RAX, 42              48 83 C0 2A
SUB RAX, RBX             48 29 D8
IMUL RAX, RBX            48 0F AF C3
IDIV RBX                 48 F7 FB
CQO                      48 99

CMP RAX, RBX             48 39 D8
TEST RAX, RAX            48 85 C0

XOR RAX, RAX             48 31 C0
AND RAX, RBX             48 21 D8
OR RAX, RBX              48 09 D8
SHL RAX, 3               48 C1 E0 03
SHR RAX, 1               48 D1 E8

JMP label                E9 rel32 (or EB rel8)
JE label                 0F 84 rel32 (or 74 rel8)
JNE label                0F 85 rel32 (or 75 rel8)
JL label                 0F 8C rel32 (or 7C rel8)
JLE label                0F 8E rel32 (or 7E rel8)
JG label                 0F 8F rel32 (or 7F rel8)
JGE label                0F 8D rel32 (or 7D rel8)

CALL label               E8 rel32
RET                      C3

PUSH RAX                 50
PUSH RBX                 53
PUSH R12                 41 54
POP RAX                  58
POP RBX                  5B
POP R12                  41 5C

SYSCALL                  0F 05
NOP                      90

CMOVL RAX, RBX           48 0F 4C C3
CMOVG RAX, RBX           48 0F 4F C3
CMOVE RAX, RBX           48 0F 44 C3

LEA RAX, [RBP-16]        48 8D 45 F0
LEA RAX, [RIP+disp32]    48 8D 05 disp32
```

## A.2 Register Encoding

```
Register   Code   REX.B/R
────────   ────   ───────
RAX        0      0
RCX        1      0
RDX        2      0
RBX        3      0
RSP        4      0
RBP        5      0
RSI        6      0
RDI        7      0
R8         0      1
R9         1      1
R10        2      1
R11        3      1
R12        4      1
R13        5      1
R14        6      1
R15        7      1
```

## A.3 System V AMD64 ABI Summary

```
Arguments:     RDI, RSI, RDX, RCX, R8, R9 (then stack)
Return value:  RAX (and RDX for 128-bit)
Caller-saved:  RAX, RCX, RDX, RSI, RDI, R8-R11
Callee-saved:  RBX, RBP, R12-R15
Stack:         16-byte aligned before CALL
Red zone:      128 bytes below RSP (leaf functions)
```

## A.4 Linux Syscall Numbers (x86_64)

```
Syscall        Number   Arguments
───────        ──────   ─────────
read           0        fd, buf, count
write          1        fd, buf, count
open           2        filename, flags, mode
close          3        fd
mmap           9        addr, len, prot, flags, fd, offset
munmap         11       addr, len
brk            12       addr
exit           60       status
```

## A.5 ModR/M Quick Reference

```
Mod  R/M   Meaning
───  ───   ───────────────────────────
00   000   [RAX]
00   001   [RCX]
00   010   [RDX]
00   011   [RBX]
00   100   SIB follows
00   101   [RIP + disp32]
00   110   [RSI]
00   111   [RDI]

01   xxx   [reg + disp8]
10   xxx   [reg + disp32]
11   xxx   register direct

SIB needed when:
  - Base is RSP or R12 (R/M = 100)
  - Indexed addressing used
```

---

# Document End

**Version**: 1.0
**Status**: Approved for Implementation
**Next Steps**: Begin Phase 1 with Lexer implementation

This document serves as the authoritative reference for the AILang self-hosting compiler architecture. All implementation should follow the specifications outlined herein.
