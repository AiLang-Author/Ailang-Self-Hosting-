# AILang Self-Hosting Compiler Architecture
## Reference Document v1.0

### Overview

The self-hosting compiler is built in AILang to compile AILang source to native x86-64 ELF executables. It follows a **modular architecture** with clear separation between:

1. **Frontend** - Lexing and Parsing (COMPLETE)
2. **AST** - Abstract Syntax Tree manipulation (NEW)
3. **Compile** - AST â†’ Instructions (one file per construct)
4. **CodeEmit** - Instructions â†’ Bytes (pure byte emission)
5. **Output** - Bytes â†’ ELF executable

### Design Principles

- **Separation of Concerns**: Compile modules call Emit functions, never emit bytes directly
- **One Construct = One File**: Easy to test, modify, maintain
- **No Monolithic Compiler**: Each module has Init/Process/Cleanup pattern
- **Clear Interfaces**: Modules communicate through well-defined function signatures

---

## Directory Structure

```
Librarys/Compiler/
â”œâ”€â”€ Frontend/
â”‚   â”œâ”€â”€ Lexer/                    [COMPLETE]
â”‚   â”‚   â”œâ”€â”€ Library.CLexerTypes.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CLexerCore.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CLexerKeywords.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CLexerStrings.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CLexerNumbers.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CLexerOperators.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CLexerIdentifiers.ailang
â”‚   â”‚   â””â”€â”€ Library.CLexerMain.ailang
â”‚   â”‚
â”‚   â”œâ”€â”€ Parser/                   [COMPLETE - needs AST extraction]
â”‚   â”‚   â”œâ”€â”€ Library.CParserTypes.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CParserCore.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CParserExpressions.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CParserStatements.ailang
â”‚   â”‚   â”œâ”€â”€ Library.CParserDeclarations.ailang
â”‚   â”‚   â””â”€â”€ Library.CParserMain.ailang
â”‚   â”‚
â”‚   â””â”€â”€ AST/                      [NEW - extract from CParserUtils]
â”‚       â”œâ”€â”€ Library.CASTTypes.ailang
â”‚       â”œâ”€â”€ Library.CASTCore.ailang
â”‚       â”œâ”€â”€ Library.CASTNodes.ailang
â”‚       â””â”€â”€ Library.CASTDebug.ailang
â”‚
â”œâ”€â”€ Compile/                      [NEW]
â”‚   â”œâ”€â”€ Library.CCompileTypes.ailang
â”‚   â”œâ”€â”€ Library.CCompileMain.ailang
â”‚   â”œâ”€â”€ Library.CCompileExpr.ailang
â”‚   â”œâ”€â”€ Library.CCompileStmt.ailang
â”‚   â”œâ”€â”€ Library.CCompileFunc.ailang
â”‚   â”œâ”€â”€ Library.CCompilePool.ailang
â”‚   â”œâ”€â”€ Library.CCompileCall.ailang
â”‚   â”œâ”€â”€ Library.CCompileIO.ailang
â”‚   â”œâ”€â”€ Library.CCompileOps.ailang
â”‚   â””â”€â”€ Library.CCompileMem.ailang
â”‚
â”œâ”€â”€ CodeEmit/                     [NEW]
â”‚   â”œâ”€â”€ Library.CEmitTypes.ailang
â”‚   â”œâ”€â”€ Library.CEmitCore.ailang
â”‚   â”œâ”€â”€ Library.CEmitInstr.ailang
â”‚   â””â”€â”€ Library.CEmitX86.ailang
â”‚
â””â”€â”€ Output/                       [NEW]
    â”œâ”€â”€ Library.CELFTypes.ailang
    â”œâ”€â”€ Library.CELFBuilder.ailang
    â”œâ”€â”€ Library.CRelocate.ailang
    â””â”€â”€ Library.COutput.ailang
```

---

## Module Specifications

### 1. AST Module (`Frontend/AST/`)

#### CASTTypes.ailang
```
FixedPool.AST {
    // Node types: PROGRAM, FUNCTION, IF, WHILE, CALL, etc.
    // See full list in artifact
}

FixedPool.ASTField {
    TYPE, LINE, COL, DATA1, DATA2, DATA3, DATA4, CHILDREN
    NODE_SIZE = 64 bytes
}

FixedPool.ASTState {
    node_count, max_children, error, error_msg
}
```

#### CASTCore.ailang - Key Functions
```
AST_Create(node_type) â†’ Address
AST_CreateAt(node_type, line, col) â†’ Address
AST_GetType(node) â†’ Integer
AST_GetLine/Col/Data1/Data2/Data3/Data4(node) â†’ Integer
AST_GetChildren(node) â†’ Address (XArray)
AST_SetType/Line/Col/Data1/Data2/Data3/Data4(node, value)
AST_AddChild(parent, child)
AST_GetChild(node, index) â†’ Address
AST_GetChildCount(node) â†’ Integer
AST_Free(node)
AST_IsType(node, expected) â†’ Integer
```

#### CASTNodes.ailang - Convenience Creators
```
AST_MakeProgram() â†’ Address
AST_MakeFunction(name) â†’ Address
AST_MakeSubRoutine(name) â†’ Address
AST_MakeParameter(name, type) â†’ Address
AST_MakeIdentifier(name) â†’ Address
AST_MakeNumber(value) â†’ Address
AST_MakeString(value) â†’ Address
AST_MakeBinaryOp(op_type, left, right) â†’ Address
AST_MakeCall(func_name) â†’ Address
AST_MakeAssignment(target, value) â†’ Address
AST_MakeIf(condition, then_block, else_block) â†’ Address
AST_MakeWhile(condition, body) â†’ Address
AST_MakeReturn(value) â†’ Address
AST_MakeBlock() â†’ Address
// ... etc
```

#### CASTDebug.ailang
```
AST_TypeName(node_type) â†’ Address (string)
AST_PrintNode(node, indent)
AST_PrintTree(node, indent)
AST_Dump(root)
AST_Validate(root) â†’ Integer
AST_PrintStats()
```

---

### 2. Compile Module (`Compile/`)

#### CCompileTypes.ailang
```
FixedPool.Compile {
    ast, functions, variables, pools
    current_func, current_scope
    stack_size, stack_offset
    error, error_msg
    nodes_compiled, bytes_emitted
}

FixedPool.FuncEntry { NAME, ADDRESS, PARAM_COUNT, STACK_SIZE, FLAGS }
FixedPool.VarEntry { NAME, OFFSET, TYPE, SCOPE, FLAGS }
FixedPool.VarType { LOCAL, PARAM, POOL, GLOBAL }
FixedPool.Builtin { ADD, SUBTRACT, MULTIPLY, ... PRINTMESSAGE, ... }
FixedPool.Scope { stack, depth }
FixedPool.Loop { stack, depth, break_label, continue_label }
```

#### CCompileMain.ailang - Orchestrator
```
Compile_Init()
Compile_Free()
Compile_Program(ast) â†’ Integer
Compile_DiscoverDeclarations(program) â†’ Integer
Compile_GenerateCode(program) â†’ Integer
Compile_Node(node) â†’ Integer  // Dispatcher
Compile_Error(msg)
Compile_PrintStats()
```

#### CCompileExpr.ailang - Expressions
```
CompileExpr_Expression(node) â†’ Integer
CompileExpr_Identifier(node) â†’ Integer
CompileExpr_Number(node) â†’ Integer
CompileExpr_String(node) â†’ Integer
CompileExpr_BinaryOp(node) â†’ Integer
CompileExpr_UnaryOp(node) â†’ Integer
CompileExpr_MemberAccess(node) â†’ Integer
```

#### CCompileStmt.ailang - Statements
```
CompileStmt_Statement(node) â†’ Integer
CompileStmt_Block(node) â†’ Integer
CompileStmt_If(node) â†’ Integer
CompileStmt_While(node) â†’ Integer
CompileStmt_ForEvery(node) â†’ Integer
CompileStmt_Return(node) â†’ Integer
CompileStmt_Assignment(node) â†’ Integer
CompileStmt_ExitLoop(node) â†’ Integer
CompileStmt_ContinueLoop(node) â†’ Integer
```

#### CCompileFunc.ailang - Functions
```
CompileFunc_Function(node) â†’ Integer
CompileFunc_SubRoutine(node) â†’ Integer
CompileFunc_Prologue(stack_size)
CompileFunc_Epilogue()
CompileFunc_Parameter(node, index) â†’ Integer
CompileFunc_LocalVar(name) â†’ Integer (offset)
```

#### CCompilePool.ailang - Pools
```
CompilePool_FixedPool(node) â†’ Integer
CompilePool_DynamicPool(node) â†’ Integer
CompilePool_Member(node, pool_base) â†’ Integer
CompilePool_Access(pool_name, field_name) â†’ Integer
CompilePool_Store(pool_name, field_name) â†’ Integer
```

#### CCompileCall.ailang - Function Calls
```
CompileCall_Call(node) â†’ Integer
CompileCall_Builtin(builtin_id, args) â†’ Integer
CompileCall_UserFunction(func_name, args) â†’ Integer
CompileCall_PushArgs(args) â†’ Integer
CompileCall_PopArgs(count)
```

#### CCompileIO.ailang - I/O Operations
```
CompileIO_PrintMessage(node) â†’ Integer
CompileIO_PrintNumber(node) â†’ Integer
CompileIO_PrintString(node) â†’ Integer
CompileIO_ReadLine(node) â†’ Integer
CompileIO_SystemCall(node) â†’ Integer
```

#### CCompileOps.ailang - Arithmetic/Logic
```
CompileOps_Add(left, right) â†’ Integer
CompileOps_Subtract(left, right) â†’ Integer
CompileOps_Multiply(left, right) â†’ Integer
CompileOps_Divide(left, right) â†’ Integer
CompileOps_Modulo(left, right) â†’ Integer
CompileOps_Compare(op, left, right) â†’ Integer
CompileOps_And(left, right) â†’ Integer
CompileOps_Or(left, right) â†’ Integer
CompileOps_Not(operand) â†’ Integer
CompileOps_BitwiseAnd/Or/Xor/Not/Shift(...)
```

#### CCompileMem.ailang - Memory Operations
```
CompileMem_Allocate(size_node) â†’ Integer
CompileMem_Deallocate(ptr_node, size_node) â†’ Integer
CompileMem_StoreValue(ptr_node, value_node) â†’ Integer
CompileMem_Dereference(ptr_node) â†’ Integer
CompileMem_GetByte(ptr_node, offset_node) â†’ Integer
CompileMem_SetByte(ptr_node, offset_node, value_node) â†’ Integer
CompileMem_AddressOf(var_node) â†’ Integer
CompileMem_SizeOf(type_node) â†’ Integer
```

---

### 3. CodeEmit Module (`CodeEmit/`)

**Key Principle**: These functions ONLY emit bytes. No AST knowledge.

#### CEmitTypes.ailang
```
FixedPool.Emit {
    code, code_size, code_capacity
    data, data_size, data_capacity
    labels, label_count
    fixups, fixup_count
    relocs, reloc_count
    symbols, symbol_count
    stack_size, error
}

FixedPool.Reg { RAX=0, RCX=1, RDX=2, RBX=3, RSP=4, RBP=5, RSI=6, RDI=7, R8-R15 }
FixedPool.CC { E=4, NE=5, L=12, LE=14, G=15, GE=13, ... }
FixedPool.FixupType { REL32, ABS64 }
```

#### CEmitCore.ailang - Buffer Management
```
Emit_Init()
Emit_Free()
Emit_Byte(b)
Emit_Word(w)
Emit_DWord(d)
Emit_QWord(q)
Emit_AddString(str) â†’ offset
Emit_AddData(ptr, size) â†’ offset
Emit_CreateLabel() â†’ label_id
Emit_MarkLabel(label_id)
Emit_GetLabel(label_id) â†’ address
Emit_AddFixup(label_id, fixup_type)
Emit_ResolveFixups()
Emit_AddSymbol(name, type) â†’ sym_id
Emit_Error(msg)
Emit_HasError() â†’ Integer
Emit_DumpCode(max_bytes)
Emit_PrintStats()
```

#### CEmitInstr.ailang - x86-64 Instructions
```
// MOV
X86_MovRegImm64(reg, imm)
X86_MovRaxImm64(imm)
X86_MovRegReg(dst, src)
X86_MovRaxRbpOffset(offset)      // Load local
X86_MovRbpOffsetRax(offset)      // Store local
X86_MovRaxR15Offset(offset)      // Load pool
X86_MovR15OffsetRax(offset)      // Store pool

// Arithmetic
X86_AddRaxRbx()
X86_AddRaxImm32(imm)
X86_SubRaxRbx()
X86_SubRaxImm32(imm)
X86_SubRspImm32(imm)             // Stack alloc
X86_AddRspImm32(imm)             // Stack dealloc
X86_ImulRaxRbx()
X86_IdivRbx()
X86_Cqo()                        // Sign extend

// Compare
X86_CmpRaxRbx()
X86_CmpRaxImm32(imm)
X86_TestRaxRax()

// Jumps
X86_Jmp(label_id)
X86_Jcc(cc, label_id)
X86_Je/Jne/Jl/Jle/Jg/Jge(label_id)

// Call/Return
X86_Call(label_id)
X86_Ret()

// Stack
X86_Push(reg)
X86_Pop(reg)
X86_PushRax/Rbx/Rbp()
X86_PopRax/Rbx/Rbp()

// Function frame
X86_Prologue(stack_size)
X86_Epilogue()

// System
X86_Syscall()

// Set flags
X86_Sete/Setne/Setl/Setle/Setg/Setge()
X86_MovzxRaxAl()

// Misc
X86_XorRaxRax()
X86_Nop()
```

---

### 4. Output Module (`Output/`)

#### CELFTypes.ailang
```
FixedPool.ELF {
    // ELF header constants
    MAGIC = 0x464C457F
    CLASS64 = 2
    LITTLE_ENDIAN = 1
    // ... etc
}

FixedPool.ELFState {
    header, program_headers, section_headers
    code_section, data_section
    entry_point
}
```

#### CELFBuilder.ailang
```
ELF_Init()
ELF_SetEntryPoint(address)
ELF_AddCodeSection(code, size)
ELF_AddDataSection(data, size)
ELF_BuildHeader()
ELF_BuildProgramHeaders()
ELF_BuildSectionHeaders()
ELF_GetOutput() â†’ Address
ELF_GetSize() â†’ Integer
```

#### CRelocate.ailang
```
Reloc_Init()
Reloc_AddEntry(offset, type, symbol, addend)
Reloc_Process(code, data)
Reloc_ApplyFixups(base_address)
```

#### COutput.ailang
```
Output_WriteFile(filename, buffer, size) â†’ Integer
Output_MakeExecutable(filename) â†’ Integer
Output_Build(filename) â†’ Integer  // Main entry
```

---

## Compilation Pipeline

```
Source Code
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLexerMain     â”‚  Lex_Tokenize(source)
â”‚  (Lexer)        â”‚  â†’ Token stream
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CParserMain    â”‚  Parse_Program(tokens)
â”‚  (Parser)       â”‚  â†’ AST
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CCompileMain   â”‚  Compile_Program(ast)
â”‚  (Compiler)     â”‚  â†’ Calls CCompile* modules
â”‚                 â”‚  â†’ Calls CEmit* functions
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CEmitCore      â”‚  Emit_ResolveFixups()
â”‚  (Fixups)       â”‚  â†’ Patched code buffer
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CELFBuilder    â”‚  ELF_Build()
â”‚  (ELF Gen)      â”‚  â†’ ELF binary
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  COutput        â”‚  Output_WriteFile()
â”‚  (File I/O)     â”‚  â†’ Executable file
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Example: Compiling `x = Add(1, 2)`

```
1. Parser creates AST:
   ASSIGNMENT
   â”œâ”€â”€ DATA1: "x"
   â””â”€â”€ CALL
       â”œâ”€â”€ DATA1: "Add"
       â”œâ”€â”€ NUMBER (1)
       â””â”€â”€ NUMBER (2)

2. CCompileMain dispatches to CCompileStmt_Assignment

3. CCompileStmt_Assignment:
   - Calls CompileExpr_Expression(value_node)
   - Calls X86_MovRbpOffsetRax(var_offset)

4. CompileExpr_Expression sees CALL node:
   - Dispatches to CompileCall_Call

5. CompileCall_Call sees "Add" is builtin:
   - Calls CompileCall_Builtin(Builtin.ADD, args)

6. CompileCall_Builtin for ADD:
   - CompileExpr_Expression(arg1) â†’ X86_MovRaxImm64(1)
   - X86_PushRax()
   - CompileExpr_Expression(arg2) â†’ X86_MovRaxImm64(2)
   - X86_MovRegReg(RBX, RAX)
   - X86_PopRax()
   - X86_AddRaxRbx()

7. Back in Assignment:
   - X86_MovRbpOffsetRax(x_offset)

8. Final bytes in Emit.code buffer
```

---

## Build Order (Iterative)

### Phase 1: Foundation
1. âœ… Lexer (complete)
2. âœ… Parser (complete)
3. ðŸ”² AST module (extract from CParserUtils)
4. ðŸ”² CEmitTypes + CEmitCore (buffer management)

### Phase 2: Minimal Compiler
5. ðŸ”² CEmitInstr (basic: MOV, ADD, SUB, RET)
6. ðŸ”² CCompileTypes
7. ðŸ”² CCompileExpr (NUMBER, IDENTIFIER only)
8. ðŸ”² CCompileOps (Add, Subtract)
9. ðŸ”² CCompileIO (PrintMessage, PrintNumber)

**Test**: Compile `PrintNumber(Add(1, 2))`

### Phase 3: Functions
10. ðŸ”² CCompileFunc (Function, SubRoutine)
11. ðŸ”² CCompileCall (user functions)
12. ðŸ”² CCompileStmt (Assignment, Return)

**Test**: Compile simple function with return value

### Phase 4: Control Flow
13. ðŸ”² CCompileStmt (If, While)
14. ðŸ”² Loop context (break, continue)

**Test**: Compile loops and conditionals

### Phase 5: Memory & Pools
15. ðŸ”² CCompileMem (Allocate, Store, Load)
16. ðŸ”² CCompilePool (FixedPool)

**Test**: Compile pool access

### Phase 6: Output
17. ðŸ”² CELFBuilder
18. ðŸ”² CRelocate
19. ðŸ”² COutput

**Test**: Generate working ELF executable

### Phase 7: Self-Hosting
20. ðŸ”² Compile the compiler with itself!

---

## Known Issues / Notes

1. **Pool Variable Collision**: Field names must be unique across all pools. CParserTypes uses P_ prefix to avoid collision with CLexerTypes.

2. **Pool Table Size**: Minimum 16KB (2048 slots) to handle large library imports. Fixed in memory_manager.py.

3. **Import Order**: Libraries are discovered AFTER pool table allocation. This is a bug in the Python compiler to fix in self-hosted version.

4. **Register Allocation**: R15 is reserved for pool table base. R14 reserved for future use. Use R12, R13 for temps, stack for deeper nesting.

---

## Console Application

The `ailang_console.ailang` provides interactive testing:

```
ailang> load test.ailang
ailang> compile
ailang> ast on
ailang> tokens on
ailang> status
ailang> quit
```

Current status: Lexer + Parser working. Code generation stubbed.

---

*Document Version: 1.0*
*Date: December 25, 2025*
*Status: Architecture defined, implementation in progress*
