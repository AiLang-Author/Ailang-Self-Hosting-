// =============================================================================
// ISA DISPATCHER - Add to Library.CEmitCore.ailang
// =============================================================================
// Add these at the END of CEmitCore.ailang
// Compile modules call Emit_*, dispatcher routes to X86_* or ARM_* based on target

// Architecture constants (add to CEmitTypes.ailang if not present)
Constant.Arch.X86_64 = 1
Constant.Arch.ARM64 = 2
Constant.Arch.RISCV = 3

// Target architecture - set at init time
Global.Emit.target = 1   // Default: X86_64

// =============================================================================
// IMMEDIATE LOADS
// =============================================================================

Function.Emit_MovRaxImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_MovRaxImm64(value)
        }
    }
}

Function.Emit_MovRbxImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_MovRbxImm64(value)
        }
    }
}

// =============================================================================
// LOCAL VARIABLE ACCESS (RBP-relative stack)
// =============================================================================

// MOV RAX, [RBP + offset] - Load local
Function.Emit_MovRaxRbpOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_MovRaxRbpOffset(offset)
        }
    }
}

// MOV [RBP + offset], RAX - Store local
Function.Emit_MovRbpOffsetRax {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_MovRbpOffsetRax(offset)
        }
    }
}

// =============================================================================
// POOL VARIABLE ACCESS (R15-relative)
// =============================================================================

// MOV RAX, [R15 + offset] - Load pool var
Function.Emit_MovRaxR15Offset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_MovRaxR15Offset(offset)
        }
    }
}

// MOV [R15 + offset], RAX - Store pool var
Function.Emit_MovR15OffsetRax {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_MovR15OffsetRax(offset)
        }
    }
}

// =============================================================================
// STACK OPERATIONS
// =============================================================================

Function.Emit_PushRax {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_PushRax()
        }
    }
}

Function.Emit_PopRax {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_PopRax()
        }
    }
}

Function.Emit_PushRbx {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_PushRbx()
        }
    }
}

Function.Emit_PopRbx {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_PopRbx()
        }
    }
}

// =============================================================================
// ARITHMETIC
// =============================================================================

Function.Emit_AddRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_AddRaxRbx()
        }
    }
}

Function.Emit_SubRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_SubRaxRbx()
        }
    }
}

// =============================================================================
// COMPARE / TEST
// =============================================================================

Function.Emit_TestRaxRax {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_TestRaxRax()
        }
    }
}

Function.Emit_CmpRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_CmpRaxRbx()
        }
    }
}

// =============================================================================
// JUMPS
// =============================================================================

Function.Emit_Jmp {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Jmp(label_id)
        }
    }
}

Function.Emit_Jcc {
    Input: cc: Integer
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Jcc(cc, label_id)
        }
    }
}

Function.Emit_Je {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Je(label_id)
        }
    }
}

Function.Emit_Jne {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Jne(label_id)
        }
    }
}

Function.Emit_Jz {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Jz(label_id)
        }
    }
}

Function.Emit_Jnz {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Jnz(label_id)
        }
    }
}

// =============================================================================
// CALL / RETURN
// =============================================================================

Function.Emit_Call {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Call(label_id)
        }
    }
}

Function.Emit_Ret {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Ret()
        }
    }
}

// =============================================================================
// FUNCTION PROLOGUE / EPILOGUE
// =============================================================================

Function.Emit_Prologue {
    Input: stack_size: Integer
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Prologue(stack_size)
        }
    }
}

Function.Emit_Epilogue {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Epilogue()
        }
    }
}

// =============================================================================
// SYSCALL
// =============================================================================

Function.Emit_Syscall {
    Body: {
        IfCondition EqualTo(Emit.target, Arch.X86_64) ThenBlock: {
            X86_Syscall()
        }
    }
}


// =============================================================================
// SPECIFIC REGISTER DISPATCHERS
// =============================================================================

// --- Immediate Loads (specific registers) ---
Function.Emit_MovRaxImm64 { Input: value: Integer Body: { X86_MovRaxImm64(value) } }
Function.Emit_MovRbxImm64 { Input: value: Integer Body: { X86_MovRbxImm64(value) } }
Function.Emit_MovRcxImm64 { Input: value: Integer Body: { X86_MovRcxImm64(value) } }
Function.Emit_MovRdxImm64 { Input: value: Integer Body: { X86_MovRdxImm64(value) } }
Function.Emit_MovRdiImm64 { Input: value: Integer Body: { X86_MovRdiImm64(value) } }
Function.Emit_MovRsiImm64 { Input: value: Integer Body: { X86_MovRsiImm64(value) } }
Function.Emit_MovR8Imm64 { Input: value: Integer Body: { X86_MovR8Imm64(value) } }
Function.Emit_MovR9Imm64 { Input: value: Integer Body: { X86_MovR9Imm64(value) } }
Function.Emit_MovR10Imm64 { Input: value: Integer Body: { X86_MovR10Imm64(value) } }

// --- Push (specific registers) ---
Function.Emit_PushRax { Body: { X86_PushRax() } }
Function.Emit_PushRbx { Body: { X86_PushRbx() } }
Function.Emit_PushRcx { Body: { X86_PushRcx() } }
Function.Emit_PushRdx { Body: { X86_PushRdx() } }
Function.Emit_PushRbp { Body: { X86_PushRbp() } }
Function.Emit_PushRsi { Body: { X86_PushRsi() } }
Function.Emit_PushRdi { Body: { X86_PushRdi() } }
Function.Emit_PushR12 { Body: { X86_PushR12() } }
Function.Emit_PushR13 { Body: { X86_PushR13() } }
Function.Emit_PushR14 { Body: { X86_PushR14() } }
Function.Emit_PushR15 { Body: { X86_PushR15() } }

// --- Pop (specific registers) ---
Function.Emit_PopRax { Body: { X86_PopRax() } }
Function.Emit_PopRbx { Body: { X86_PopRbx() } }
Function.Emit_PopRcx { Body: { X86_PopRcx() } }
Function.Emit_PopRdx { Body: { X86_PopRdx() } }
Function.Emit_PopRbp { Body: { X86_PopRbp() } }
Function.Emit_PopRsi { Body: { X86_PopRsi() } }
Function.Emit_PopRdi { Body: { X86_PopRdi() } }
Function.Emit_PopR8 { Body: { X86_PopR8() } }
Function.Emit_PopR9 { Body: { X86_PopR9() } }
Function.Emit_PopR10 { Body: { X86_PopR10() } }
Function.Emit_PopR12 { Body: { X86_PopR12() } }
Function.Emit_PopR13 { Body: { X86_PopR13() } }
Function.Emit_PopR14 { Body: { X86_PopR14() } }
Function.Emit_PopR15 { Body: { X86_PopR15() } }

// --- XOR (zero registers) ---
Function.Emit_XorRaxRax { Body: { X86_XorRaxRax() } }
Function.Emit_XorRdiRdi { Body: { X86_XorRdiRdi() } }
Function.Emit_XorRsiRsi { Body: { X86_XorRsiRsi() } }
Function.Emit_XorRdxRdx { Body: { X86_XorRdxRdx() } }
Function.Emit_XorR8R8 { Body: { X86_XorR8R8() } }
Function.Emit_XorR9R9 { Body: { X86_XorR9R9() } }
Function.Emit_XorR10R10 { Body: { X86_XorR10R10() } }

// --- Arithmetic (specific) ---
Function.Emit_AddRaxRbx { Body: { X86_AddRaxRbx() } }
Function.Emit_SubRaxRbx { Body: { X86_SubRaxRbx() } }
Function.Emit_ImulRaxRbx { Body: { X86_ImulRaxRbx() } }
Function.Emit_IdivRbx { Body: { X86_IdivRbx() } }
Function.Emit_Cqo { Body: { X86_Cqo() } }
Function.Emit_NegRax { Body: { X86_NegRax() } }
Function.Emit_IncRax { Body: { X86_IncRax() } }
Function.Emit_DecRax { Body: { X86_DecRax() } }

// --- Logic ---
Function.Emit_AndRaxRbx { Body: { X86_AndRaxRbx() } }
Function.Emit_OrRaxRbx { Body: { X86_OrRaxRbx() } }
Function.Emit_XorRaxRbx { Body: { X86_XorRaxRbx() } }
Function.Emit_NotRax { Body: { X86_NotRax() } }
Function.Emit_ShlRaxCl { Body: { X86_ShlRaxCl() } }
Function.Emit_SarRaxCl { Body: { X86_SarRaxCl() } }

// --- Compare/Test ---
Function.Emit_CmpRaxRbx { Body: { X86_CmpRaxRbx() } }
Function.Emit_TestRaxRax { Body: { X86_TestRaxRax() } }

// --- SETcc ---
Function.Emit_SetEAl { Body: { X86_SetEAl() } }
Function.Emit_SetNEAl { Body: { X86_SetNEAl() } }
Function.Emit_SetLAl { Body: { X86_SetLAl() } }
Function.Emit_SetGAl { Body: { X86_SetGAl() } }
Function.Emit_SetLEAl { Body: { X86_SetLEAl() } }
Function.Emit_SetGEAl { Body: { X86_SetGEAl() } }
Function.Emit_SetZAl { Body: { X86_SetZAl() } }
Function.Emit_MovzxRaxAl { Body: { X86_MovzxRaxAl() } }

// --- Memory (RBP-relative) ---
Function.Emit_MovRaxRbpOffset { Input: offset: Integer Body: { X86_MovRaxRbpOffset(offset) } }
Function.Emit_MovRbpOffsetRax { Input: offset: Integer Body: { X86_MovRbpOffsetRax(offset) } }

// --- Memory (R15-relative for pools) ---
Function.Emit_MovRaxR15Offset { Input: offset: Integer Body: { X86_MovRaxR15Offset(offset) } }
Function.Emit_MovR15OffsetRax { Input: offset: Integer Body: { X86_MovR15OffsetRax(offset) } }

// --- Memory (dereference) ---
Function.Emit_MovRaxRaxDeref { Body: { X86_MovRaxRaxDeref() } }
Function.Emit_MovRaxRaxOffset { Input: offset: Integer Body: { X86_MovRaxRaxOffset(offset) } }
Function.Emit_MovRdiDerefRax { Body: { X86_MovRdiDerefRax() } }
Function.Emit_MovzxRaxByteRax { Body: { X86_MovzxRaxByteRax() } }
Function.Emit_MovByteRdiAl { Body: { X86_MovByteRdiAl() } }

// --- Memory (data section) ---
Function.Emit_LoadDataAddress { Input: offset: Integer Body: { X86_LoadDataAddress(offset) } }
Function.Emit_MovRsiDataOffset { Input: offset: Integer Body: { X86_MovRsiDataOffset(offset) } }

// --- Register moves (specific) ---
Function.Emit_MovRbxRax { Body: { X86_MovRbxRax() } }
Function.Emit_MovRsiRax { Body: { X86_MovRsiRax() } }
Function.Emit_MovRdiRax { Body: { X86_MovRdiRax() } }
Function.Emit_MovR12Rax { Body: { X86_MovR12Rax() } }
Function.Emit_MovRaxR12 { Body: { X86_MovRaxR12() } }
Function.Emit_MovRbxR12 { Body: { X86_MovRbxR12() } }
Function.Emit_MovRcxR12 { Body: { X86_MovRcxR12() } }
Function.Emit_MovR13Rax { Body: { X86_MovR13Rax() } }
Function.Emit_MovRaxR13 { Body: { X86_MovRaxR13() } }
Function.Emit_MovRbxR13 { Body: { X86_MovRbxR13() } }
Function.Emit_MovRcxR13 { Body: { X86_MovRcxR13() } }

// --- Stack allocation ---
Function.Emit_SubRspImm32 { Input: value: Integer Body: { X86_SubRspImm32(value) } }
Function.Emit_AddRspImm32 { Input: value: Integer Body: { X86_AddRspImm32(value) } }
Function.Emit_AndRspImm8 { Input: value: Integer Body: { X86_AndRspImm8(value) } }

// --- Jumps ---
Function.Emit_Jmp { Input: label_id: Integer Body: { X86_Jmp(label_id) } }
Function.Emit_Je { Input: label_id: Integer Body: { X86_Je(label_id) } }
Function.Emit_Jne { Input: label_id: Integer Body: { X86_Jne(label_id) } }
Function.Emit_Jz { Input: label_id: Integer Body: { X86_Jz(label_id) } }
Function.Emit_Jnz { Input: label_id: Integer Body: { X86_Jnz(label_id) } }
Function.Emit_Jl { Input: label_id: Integer Body: { X86_Jl(label_id) } }
Function.Emit_Jle { Input: label_id: Integer Body: { X86_Jle(label_id) } }
Function.Emit_Jg { Input: label_id: Integer Body: { X86_Jg(label_id) } }
Function.Emit_Jge { Input: label_id: Integer Body: { X86_Jge(label_id) } }

// --- Call/Return ---
Function.Emit_Call { Input: label_id: Integer Body: { X86_Call(label_id) } }
Function.Emit_Ret { Body: { X86_Ret() } }

// --- Syscall ---
Function.Emit_SysInstr { Body: { X86_SysInstr() } }

// --- String ops ---
Function.Emit_RepMovsb { Body: { X86_RepMovsb() } }
Function.Emit_RepStosb { Body: { X86_RepStosb() } }


// =============================================================================
// JUMP TO LABEL (architecture-agnostic IR)
// This is the primary jump dispatcher - Compile modules use this
// =============================================================================
Function.Emit_JumpToLabel {
    Input: label: Integer
    Input: condition: Integer
    Body: {
        // ALWAYS = unconditional jump
        IfCondition EqualTo(condition, CC.ALWAYS) ThenBlock: {
            X86_Jmp(label)
            ReturnValue(0)
        }
        
        // Conditional jumps
        IfCondition EqualTo(condition, CC.Z) ThenBlock: { X86_Jz(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NZ) ThenBlock: { X86_Jnz(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.E) ThenBlock: { X86_Je(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NE) ThenBlock: { X86_Jne(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.L) ThenBlock: { X86_Jl(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.LE) ThenBlock: { X86_Jle(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.G) ThenBlock: { X86_Jg(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.GE) ThenBlock: { X86_Jge(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.B) ThenBlock: { X86_Jb(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.BE) ThenBlock: { X86_Jbe(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.A) ThenBlock: { X86_Ja(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.AE) ThenBlock: { X86_Jae(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.S) ThenBlock: { X86_Js(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NS) ThenBlock: { X86_Jns(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.O) ThenBlock: { X86_Jo(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NO) ThenBlock: { X86_Jno(label) ReturnValue(0) }
        
        // Unknown condition code
        ReturnValue(0)
    }
}