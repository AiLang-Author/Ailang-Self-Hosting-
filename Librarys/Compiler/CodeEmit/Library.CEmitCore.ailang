// Library.CEmitCore.ailang
// Core buffer management, labels, and fixups for code emission
// Architecture-agnostic - works with any target
// Location: Librarys/Compiler/CodeEmit/Library.CEmitCore.ailang

LibraryImport.XArrays
LibraryImport.Compiler.CodeEmit.CEmitTypes

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Emit_Init {
    Body: {
        // Allocate code buffer
        Emit.code = Allocate(EmitSize.CODE_INITIAL)
        Emit.code_size = 0
        Emit.code_capacity = EmitSize.CODE_INITIAL
        
        // Allocate data buffer
        Emit.data = Allocate(EmitSize.DATA_INITIAL)
        Emit.data_size = 0
        Emit.data_capacity = EmitSize.DATA_INITIAL
        
        // Initialize BSS
        Emit.bss_size = 0
        
        // Labels array
        Emit.labels = XArray.XCreate(EmitSize.LABEL_INITIAL)
        Emit.label_count = 0
        Emit.label_capacity = EmitSize.LABEL_INITIAL
        
        // Fixups array
        Emit.fixups = XArray.XCreate(EmitSize.FIXUP_INITIAL)
        Emit.fixup_count = 0
        Emit.fixup_capacity = EmitSize.FIXUP_INITIAL
        
        // Relocations
        Emit.relocs = XArray.XCreate(256)
        Emit.reloc_count = 0
        
        // Symbols
        Emit.symbols = XArray.XCreate(EmitSize.SYMBOL_INITIAL)
        Emit.symbol_count = 0
        
        // Strings
        Emit.strings = XArray.XCreate(EmitSize.STRING_INITIAL)
        Emit.string_count = 0
        
        // Current state
        Emit.current_section = Section.TEXT
        Emit.stack_depth = 0
        
        // Clear errors
        Emit.error = 0
        Emit.error_msg = 0
        Emit.instructions_emitted = 0
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.Emit_Free {
    Body: {
        IfCondition NotEqual(Emit.code, 0) ThenBlock: {
            Deallocate(Emit.code, Emit.code_capacity)
            Emit.code = 0
        }
        
        IfCondition NotEqual(Emit.data, 0) ThenBlock: {
            Deallocate(Emit.data, Emit.data_capacity)
            Emit.data = 0
        }
        
        IfCondition NotEqual(Emit.labels, 0) ThenBlock: {
            // Free label entries
            i = 0
            WhileLoop LessThan(i, Emit.label_count) {
                entry = XArray.XGet(Emit.labels, i)
                IfCondition NotEqual(entry, 0) ThenBlock: {
                    Deallocate(entry, LabelField.ENTRY_SIZE)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Emit.labels)
            Emit.labels = 0
        }
        
        IfCondition NotEqual(Emit.fixups, 0) ThenBlock: {
            // Free fixup entries
            i = 0
            WhileLoop LessThan(i, Emit.fixup_count) {
                entry = XArray.XGet(Emit.fixups, i)
                IfCondition NotEqual(entry, 0) ThenBlock: {
                    Deallocate(entry, FixupField.ENTRY_SIZE)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Emit.fixups)
            Emit.fixups = 0
        }
        
        IfCondition NotEqual(Emit.relocs, 0) ThenBlock: {
            XArray.XDestroy(Emit.relocs)
            Emit.relocs = 0
        }
        
        IfCondition NotEqual(Emit.symbols, 0) ThenBlock: {
            XArray.XDestroy(Emit.symbols)
            Emit.symbols = 0
        }
        
        IfCondition NotEqual(Emit.strings, 0) ThenBlock: {
            XArray.XDestroy(Emit.strings)
            Emit.strings = 0
        }
        
        Emit.code_size = 0
        Emit.data_size = 0
        Emit.label_count = 0
        Emit.fixup_count = 0
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================
Function.Emit_Error {
    Input: msg: Address
    Body: {
        Emit.error = 1
        Emit.error_msg = msg
        PrintMessage("[EMIT ERROR] ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

Function.Emit_HasError {
    Output: Integer
    Body: {
        ReturnValue(Emit.error)
    }
}

// =============================================================================
// CODE BUFFER - BYTE EMISSION
// =============================================================================

// Emit single byte to code buffer
Function.Emit_Byte {
    Input: b: Integer
    Body: {
        // Check capacity
        IfCondition GreaterOrEqual(Emit.code_size, Emit.code_capacity) ThenBlock: {
            Emit_GrowCodeBuffer()
        }
        
        // Write byte
        addr = Add(Emit.code, Emit.code_size)
        SetByte(addr, b)
        Emit.code_size = Add(Emit.code_size, 1)
    }
}

// Emit 16-bit word (little-endian)
Function.Emit_Word {
    Input: w: Integer
    Body: {
        Emit_Byte(BitAnd(w, 255))
        Emit_Byte(BitAnd(ShiftRight(w, 8), 255))
    }
}

// Emit 32-bit dword (little-endian)
Function.Emit_DWord {
    Input: d: Integer
    Body: {
        Emit_Byte(BitAnd(d, 255))
        Emit_Byte(BitAnd(ShiftRight(d, 8), 255))
        Emit_Byte(BitAnd(ShiftRight(d, 16), 255))
        Emit_Byte(BitAnd(ShiftRight(d, 24), 255))
    }
}

// Emit 64-bit qword (little-endian)
Function.Emit_QWord {
    Input: q: Integer
    Body: {
        Emit_DWord(BitAnd(q, 4294967295))
        Emit_DWord(ShiftRight(q, 32))
    }
}

// Emit multiple bytes from buffer
Function.Emit_Bytes {
    Input: ptr: Address
    Input: count: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, count) {
            b = GetByte(Add(ptr, i))
            Emit_Byte(b)
            i = Add(i, 1)
        }
    }
}

// Get current code position
Function.Emit_GetPosition {
    Output: Integer
    Body: {
        ReturnValue(Emit.code_size)
    }
}

// Patch a byte at specific position
Function.Emit_PatchByte {
    Input: position: Integer
    Input: value: Integer
    Body: {
        IfCondition LessThan(position, Emit.code_size) ThenBlock: {
            addr = Add(Emit.code, position)
            SetByte(addr, value)
        }
    }
}

// Patch a dword at specific position
Function.Emit_PatchDWord {
    Input: position: Integer
    Input: value: Integer
    Body: {
        IfCondition LessThan(Add(position, 3), Emit.code_size) ThenBlock: {
            addr = Add(Emit.code, position)
            SetByte(addr, BitAnd(value, 255))
            SetByte(Add(addr, 1), BitAnd(ShiftRight(value, 8), 255))
            SetByte(Add(addr, 2), BitAnd(ShiftRight(value, 16), 255))
            SetByte(Add(addr, 3), BitAnd(ShiftRight(value, 24), 255))
        }
    }
}

// Grow code buffer when full
Function.Emit_GrowCodeBuffer {
    Body: {
        new_capacity = Multiply(Emit.code_capacity, 2)
        IfCondition GreaterThan(new_capacity, EmitSize.CODE_MAX) ThenBlock: {
            Emit_Error("Code buffer exceeded maximum size")
            ReturnValue(0)
        }
        
        new_buffer = Allocate(new_capacity)
        
        // Copy existing code
        i = 0
        WhileLoop LessThan(i, Emit.code_size) {
            b = GetByte(Add(Emit.code, i))
            SetByte(Add(new_buffer, i), b)
            i = Add(i, 1)
        }
        
        // Free old buffer
        Deallocate(Emit.code, Emit.code_capacity)
        
        Emit.code = new_buffer
        Emit.code_capacity = new_capacity
        
        ReturnValue(1)
    }
}

// =============================================================================
// DATA BUFFER
// =============================================================================

// Add string to data section, return offset
Function.Emit_AddString {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        offset = Emit.data_size
        
        // Copy string bytes including null terminator
        i = 0
        done = 0
        WhileLoop EqualTo(done, 0) {
            c = GetByte(Add(str, i))
            Emit_DataByte(c)
            IfCondition EqualTo(c, 0) ThenBlock: {
                done = 1
            }
            i = Add(i, 1)
        }
        
        // Track string
        XArray.XAppend(Emit.strings, str)
        Emit.string_count = Add(Emit.string_count, 1)
        
        ReturnValue(offset)
    }
}

// Add raw data to data section, return offset
Function.Emit_AddData {
    Input: ptr: Address
    Input: size: Integer
    Output: Integer
    Body: {
        offset = Emit.data_size
        
        i = 0
        WhileLoop LessThan(i, size) {
            b = GetByte(Add(ptr, i))
            Emit_DataByte(b)
            i = Add(i, 1)
        }
        
        ReturnValue(offset)
    }
}

// Emit byte to data buffer
Function.Emit_DataByte {
    Input: b: Integer
    Body: {
        IfCondition GreaterOrEqual(Emit.data_size, Emit.data_capacity) ThenBlock: {
            Emit_GrowDataBuffer()
        }
        
        addr = Add(Emit.data, Emit.data_size)
        SetByte(addr, b)
        Emit.data_size = Add(Emit.data_size, 1)
    }
}

Function.Emit_GrowDataBuffer {
    Body: {
        new_capacity = Multiply(Emit.data_capacity, 2)
        IfCondition GreaterThan(new_capacity, EmitSize.DATA_MAX) ThenBlock: {
            Emit_Error("Data buffer exceeded maximum size")
            ReturnValue(0)
        }
        
        new_buffer = Allocate(new_capacity)
        
        i = 0
        WhileLoop LessThan(i, Emit.data_size) {
            b = GetByte(Add(Emit.data, i))
            SetByte(Add(new_buffer, i), b)
            i = Add(i, 1)
        }
        
        Deallocate(Emit.data, Emit.data_capacity)
        Emit.data = new_buffer
        Emit.data_capacity = new_capacity
        
        ReturnValue(1)
    }
}

// =============================================================================
// LABEL MANAGEMENT
// =============================================================================

// Create a new label, return label ID
Function.Emit_CreateLabel {
    Output: Integer
    Body: {
        label_id = Emit.label_count
        
        // Create label entry
        entry = Allocate(LabelField.ENTRY_SIZE)
        StoreValue(Add(entry, LabelField.NAME), 0)
        StoreValue(Add(entry, LabelField.ADDRESS), 0)
        StoreValue(Add(entry, LabelField.RESOLVED), 0)
        StoreValue(Add(entry, LabelField.SECTION), Emit.current_section)
        
        XArray.XAppend(Emit.labels, entry)
        Emit.label_count = Add(Emit.label_count, 1)
        
        ReturnValue(label_id)
    }
}

// Create named label
Function.Emit_CreateNamedLabel {
    Input: name: Address
    Output: Integer
    Body: {
        label_id = Emit_CreateLabel()
        entry = XArray.XGet(Emit.labels, label_id)
        StoreValue(Add(entry, LabelField.NAME), name)
        ReturnValue(label_id)
    }
}

// Register a named label (alias for CreateNamedLabel)
Function.Emit_RegisterLabel {
    Input: name: Address
    Input: label_id: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            StoreValue(Add(entry, LabelField.NAME), name)
        }
    }
}

// Mark label at current position
Function.Emit_MarkLabel {
    Input: label_id: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            StoreValue(Add(entry, LabelField.ADDRESS), Emit.code_size)
            StoreValue(Add(entry, LabelField.RESOLVED), 1)
        }
    }
}

// Get label address (0 if unresolved)
Function.Emit_GetLabelAddress {
    Input: label_id: Integer
    Output: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            resolved = Dereference(Add(entry, LabelField.RESOLVED))
            IfCondition EqualTo(resolved, 1) ThenBlock: {
                ReturnValue(Dereference(Add(entry, LabelField.ADDRESS)))
            }
        }
        ReturnValue(0)
    }
}

// Check if label is resolved
Function.Emit_IsLabelResolved {
    Input: label_id: Integer
    Output: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            ReturnValue(Dereference(Add(entry, LabelField.RESOLVED)))
        }
        ReturnValue(0)
    }
}

// Find label by name
Function.Emit_FindLabel {
    Input: name: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Emit.label_count) {
            entry = XArray.XGet(Emit.labels, i)
            label_name = Dereference(Add(entry, LabelField.NAME))
            IfCondition NotEqual(label_name, 0) ThenBlock: {
                IfCondition EqualTo(StringCompare(name, label_name), 0) ThenBlock: {
                    ReturnValue(i)
                }
            }
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

// =============================================================================
// FIXUP MANAGEMENT
// =============================================================================

// Add fixup at current position
Function.Emit_AddFixup {
    Input: label_id: Integer
    Input: fixup_type: Integer
    Body: {
        entry = Allocate(FixupField.ENTRY_SIZE)
        StoreValue(Add(entry, FixupField.POSITION), Emit.code_size)
        StoreValue(Add(entry, FixupField.LABEL_ID), label_id)
        StoreValue(Add(entry, FixupField.TYPE), fixup_type)
        
        // Set size based on type
        size = 4
        IfCondition EqualTo(fixup_type, FixupType.REL8) ThenBlock: {
            size = 1
        }
        IfCondition EqualTo(fixup_type, FixupType.ABS64) ThenBlock: {
            size = 8
        }
        StoreValue(Add(entry, FixupField.SIZE), size)
        
        XArray.XAppend(Emit.fixups, entry)
        Emit.fixup_count = Add(Emit.fixup_count, 1)
    }
}

// Add fixup at specific position
Function.Emit_AddFixupAt {
    Input: position: Integer
    Input: label_id: Integer
    Input: fixup_type: Integer
    Body: {
        entry = Allocate(FixupField.ENTRY_SIZE)
        StoreValue(Add(entry, FixupField.POSITION), position)
        StoreValue(Add(entry, FixupField.LABEL_ID), label_id)
        StoreValue(Add(entry, FixupField.TYPE), fixup_type)
        
        size = 4
        IfCondition EqualTo(fixup_type, FixupType.REL8) ThenBlock: { size = 1 }
        IfCondition EqualTo(fixup_type, FixupType.ABS64) ThenBlock: { size = 8 }
        StoreValue(Add(entry, FixupField.SIZE), size)
        
        XArray.XAppend(Emit.fixups, entry)
        Emit.fixup_count = Add(Emit.fixup_count, 1)
    }
}

// Resolve all fixups
Function.Emit_ResolveFixups {
    Body: {
        PrintMessage("[EMIT] Resolving ")
        PrintNumber(Emit.fixup_count)
        PrintMessage(" fixups...\n")
        
        i = 0
        WhileLoop LessThan(i, Emit.fixup_count) {
            entry = XArray.XGet(Emit.fixups, i)
            
            position = Dereference(Add(entry, FixupField.POSITION))
            label_id = Dereference(Add(entry, FixupField.LABEL_ID))
            fixup_type = Dereference(Add(entry, FixupField.TYPE))
            size = Dereference(Add(entry, FixupField.SIZE))
            
            // Get label address
            label_entry = XArray.XGet(Emit.labels, label_id)
            resolved = Dereference(Add(label_entry, LabelField.RESOLVED))
            
            IfCondition EqualTo(resolved, 0) ThenBlock: {
                PrintMessage("[EMIT] WARNING: Unresolved label ")
                PrintNumber(label_id)
                PrintMessage("\n")
            } ElseBlock: {
                target = Dereference(Add(label_entry, LabelField.ADDRESS))
                
                // Calculate offset based on fixup type
                IfCondition EqualTo(fixup_type, FixupType.REL8) ThenBlock: {
                    // 8-bit relative: target - (position + 1)
                    offset = Subtract(target, Add(position, 1))
                    Emit_PatchByte(position, offset)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.REL32) ThenBlock: {
                    // 32-bit relative: target - (position + 4)
                    offset = Subtract(target, Add(position, 4))
                    Emit_PatchDWord(position, offset)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.RIP_REL32) ThenBlock: {
                    // RIP-relative: same as REL32 for our purposes
                    offset = Subtract(target, Add(position, 4))
                    Emit_PatchDWord(position, offset)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.ABS32) ThenBlock: {
                    Emit_PatchDWord(position, target)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.ABS64) ThenBlock: {
                    // 64-bit absolute - patch 8 bytes
                    Emit_PatchDWord(position, BitAnd(target, 4294967295))
                    Emit_PatchDWord(Add(position, 4), ShiftRight(target, 32))
                }
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[EMIT] Fixups resolved\n")
    }
}

// =============================================================================
// SYMBOL MANAGEMENT
// =============================================================================

Function.Emit_AddSymbol {
    Input: name: Address
    Input: sym_type: Integer
    Output: Integer
    Body: {
        sym_id = Emit.symbol_count
        
        entry = Allocate(SymbolField.ENTRY_SIZE)
        StoreValue(Add(entry, SymbolField.NAME), name)
        StoreValue(Add(entry, SymbolField.ADDRESS), Emit.code_size)
        StoreValue(Add(entry, SymbolField.TYPE), sym_type)
        StoreValue(Add(entry, SymbolField.SECTION), Emit.current_section)
        StoreValue(Add(entry, SymbolField.SIZE), 0)
        
        XArray.XAppend(Emit.symbols, entry)
        Emit.symbol_count = Add(Emit.symbol_count, 1)
        
        ReturnValue(sym_id)
    }
}

// =============================================================================
// STATISTICS
// =============================================================================
Function.Emit_PrintStats {
    Body: {
        PrintMessage("[EMIT STATS]\n")
        PrintMessage("  Code size: ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Data size: ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Labels: ")
        PrintNumber(Emit.label_count)
        PrintMessage("\n")
        PrintMessage("  Fixups: ")
        PrintNumber(Emit.fixup_count)
        PrintMessage("\n")
        PrintMessage("  Symbols: ")
        PrintNumber(Emit.symbol_count)
        PrintMessage("\n")
        PrintMessage("  Strings: ")
        PrintNumber(Emit.string_count)
        PrintMessage("\n")
        PrintMessage("  Instructions: ")
        PrintNumber(Emit.instructions_emitted)
        PrintMessage("\n")
    }
}

// =============================================================================
// DEBUG UTILITIES
// =============================================================================
Function.Emit_DumpCode {
    Input: max_bytes: Integer
    Body: {
        PrintMessage("[CODE DUMP] ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes total, showing first ")
        
        count = max_bytes
        IfCondition GreaterThan(count, Emit.code_size) ThenBlock: {
            count = Emit.code_size
        }
        PrintNumber(count)
        PrintMessage(":\n")
        
        i = 0
        WhileLoop LessThan(i, count) {
            IfCondition EqualTo(Modulo(i, 16), 0) ThenBlock: {
                PrintMessage("\n  ")
                PrintNumber(i)
                PrintMessage(": ")
            }
            
            b = GetByte(Add(Emit.code, i))
            // Print hex byte (simplified - just decimal for now)
            PrintNumber(b)
            PrintMessage(" ")
            
            i = Add(i, 1)
        }
        PrintMessage("\n")
    }
}