// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CEmitCore.ailang
// Core buffer management, labels, and fixups for code emission
// Architecture-agnostic - works with any target
// Location: Librarys/Compiler/CodeEmit/Library.CEmitCore.ailang

LibraryImport.XArrays
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys


// =============================================================================
// DATA RELOCATION MANAGEMENT
// Records positions in code that need data section address patching
// =============================================================================

// Field offsets for data relocation entries
FixedPool.DataRelocField {
    "POSITION": Initialize=0    
    "DATA_OFFSET": Initialize=8  
    "ENTRY_SIZE": Initialize=16
}




// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Emit_Init {
    Body: {
        
        // Initialize relocations array
        Emit.data_relocs = XArray.XCreate(64)
        Emit.data_reloc_count = 0
        Emit.data_base_addr = 0        
        
        // Allocate code buffer
        Emit.code = Allocate(EmitSize.CODE_INITIAL)
        Emit.code_size = 0
        Emit.code_capacity = EmitSize.CODE_INITIAL
        
        // Allocate data buffer
        Emit.data = Allocate(EmitSize.DATA_INITIAL)
        Emit.data_size = 0
        Emit.data_capacity = EmitSize.DATA_INITIAL
                
        // Initialize BSS
        Emit.bss_size = 0
        
        // Labels array
        Emit.labels = XArray.XCreate(EmitSize.LABEL_INITIAL)
        Emit.label_count = 0
        Emit.label_capacity = EmitSize.LABEL_INITIAL
        
        // Fixups array
        Emit.fixups = XArray.XCreate(EmitSize.FIXUP_INITIAL)
        Emit.fixup_count = 0
        Emit.fixup_capacity = EmitSize.FIXUP_INITIAL
        
        // Relocations
        Emit.relocs = XArray.XCreate(256)
        Emit.reloc_count = 0
        
        // Symbols
        Emit.symbols = XArray.XCreate(EmitSize.SYMBOL_INITIAL)
        Emit.symbol_count = 0
        
        // Strings
        Emit.strings = XArray.XCreate(EmitSize.STRING_INITIAL)
        Emit.string_count = 0
        
        // Initialize data relocations
        Emit_InitDataRelocs()
        
        // Current state
        Emit.current_section = Section.TEXT
        Emit.stack_depth = 0
        
        // Clear errors
        Emit.error = 0
        Emit.error_msg = 0
        Emit.instructions_emitted = 0
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.Emit_Free {
    Body: {
        IfCondition NotEqual(Emit.code, 0) ThenBlock: {
            Deallocate(Emit.code, Emit.code_capacity)
            Emit.code = 0
        }
        
        IfCondition NotEqual(Emit.data, 0) ThenBlock: {
            Deallocate(Emit.data, Emit.data_capacity)
            Emit.data = 0
        }
        
        IfCondition NotEqual(Emit.labels, 0) ThenBlock: {
            // Free label entries
            i = 0
            WhileLoop LessThan(i, Emit.label_count) {
                entry = XArray.XGet(Emit.labels, i)
                IfCondition NotEqual(entry, 0) ThenBlock: {
                    Deallocate(entry, LabelField.ENTRY_SIZE)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Emit.labels)
            Emit.labels = 0
        }
        
        IfCondition NotEqual(Emit.fixups, 0) ThenBlock: {
            // Free fixup entries
            i = 0
            WhileLoop LessThan(i, Emit.fixup_count) {
                entry = XArray.XGet(Emit.fixups, i)
                IfCondition NotEqual(entry, 0) ThenBlock: {
                    Deallocate(entry, FixupField.ENTRY_SIZE)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Emit.fixups)
            Emit.fixups = 0
        }
        
        IfCondition NotEqual(Emit.relocs, 0) ThenBlock: {
            XArray.XDestroy(Emit.relocs)
            Emit.relocs = 0
        }
        
        IfCondition NotEqual(Emit.symbols, 0) ThenBlock: {
            XArray.XDestroy(Emit.symbols)
            Emit.symbols = 0
        }
        
        IfCondition NotEqual(Emit.strings, 0) ThenBlock: {
            XArray.XDestroy(Emit.strings)
            Emit.strings = 0
        }
        
        // Free data relocations
        Emit_FreeDataRelocs()
        
        Emit.code_size = 0
        Emit.data_size = 0
        Emit.label_count = 0
        Emit.fixup_count = 0
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================
Function.Emit_Error {
    Input: msg: Address
    Body: {
        Emit.error = 1
        Emit.error_msg = msg
        PrintMessage("[EMIT ERROR] ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

Function.Emit_HasError {
    Output: Integer
    Body: {
        ReturnValue(Emit.error)
    }
}

// =============================================================================
// CODE BUFFER - BYTE EMISSION
// =============================================================================

// Emit single byte to code buffer
Function.Emit_Byte {
    Input: b: Integer
    Body: {
        // Check capacity
        IfCondition GreaterEqual(Emit.code_size, Emit.code_capacity) ThenBlock: {
            Emit_GrowCodeBuffer()
        }
        
        // Write byte
        SetByte(Emit.code, Emit.code_size, b)
        Emit.code_size = Add(Emit.code_size, 1)
    }
}

// Emit 16-bit word (little-endian)
Function.Emit_Word {
    Input: w: Integer
    Body: {
        Emit_Byte(BitwiseAnd(w, 255))
        Emit_Byte(BitwiseAnd(RightShift(w, 8), 255))
    }
}

// Emit 32-bit dword (little-endian)
Function.Emit_DWord {
    Input: d: Integer
    Body: {
        Emit_Byte(BitwiseAnd(d, 255))
        Emit_Byte(BitwiseAnd(RightShift(d, 8), 255))
        Emit_Byte(BitwiseAnd(RightShift(d, 16), 255))
        Emit_Byte(BitwiseAnd(RightShift(d, 24), 255))
    }
}

// Emit 64-bit qword (little-endian)
Function.Emit_QWord {
    Input: q: Integer
    Body: {
        Emit_DWord(BitwiseAnd(q, 4294967295))
        Emit_DWord(RightShift(q, 32))
    }
}

// Emit multiple bytes from buffer
Function.Emit_Bytes {
    Input: ptr: Address
    Input: count: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, count) {
            b = GetByte(ptr, i)
            Emit_Byte(b)
            i = Add(i, 1)
        }
    }
}

// Get current code position
Function.Emit_GetPosition {
    Output: Integer
    Body: {
        ReturnValue(Emit.code_size)
    }
}

// Patch a byte at specific position
Function.Emit_PatchByte {
    Input: position: Integer
    Input: value: Integer
    Body: {
        IfCondition LessThan(position, Emit.code_size) ThenBlock: {
            SetByte(Emit.code, position, value)
        }
    }
}

// Patch a dword at specific position
Function.Emit_PatchDWord {
    Input: position: Integer
    Input: value: Integer
    Body: {
        IfCondition LessThan(Add(position, 3), Emit.code_size) ThenBlock: {
            addr = Add(Emit.code, position)
            SetByte(Emit.code, position, BitwiseAnd(value, 255))
            SetByte(addr, 1, BitwiseAnd(RightShift(value, 8), 255))
            SetByte(addr, 2, BitwiseAnd(RightShift(value, 16), 255))
            SetByte(addr, 3, BitwiseAnd(RightShift(value, 24), 255))
        }
    }
}

// Grow code buffer when full
Function.Emit_GrowCodeBuffer {
    Body: {
        new_capacity = Multiply(Emit.code_capacity, 2)
        IfCondition GreaterThan(new_capacity, EmitSize.CODE_MAX) ThenBlock: {
            Emit_Error("Code buffer exceeded maximum size")
            ReturnValue(0)
        }
        
        new_buffer = Allocate(new_capacity)
        
        // Copy existing code
        i = 0
        WhileLoop LessThan(i, Emit.code_size) {
            b = GetByte(Emit.code, i)
            SetByte(new_buffer, i, b)
            i = Add(i, 1)
        }
        
        // Free old buffer
        Deallocate(Emit.code, Emit.code_capacity)
        
        Emit.code = new_buffer
        Emit.code_capacity = new_capacity
        
        ReturnValue(1)
    }
}

// =============================================================================
// DATA BUFFER
// =============================================================================

// Add string to data section, return offset
Function.Emit_AddString {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        offset = Emit.data_size
        
        // Copy string bytes including null terminator
        i = 0
        done = 0
        WhileLoop EqualTo(done, 0) {
            c = GetByte(str, i)
            Emit_DataByte(c)
            IfCondition EqualTo(c, 0) ThenBlock: {
                done = 1
            }
            i = Add(i, 1)
        }
        
        // Track string
        XArray.XPush(Emit.strings, str)
        Emit.string_count = Add(Emit.string_count, 1)
        
        ReturnValue(offset)
    }
}

// Add raw data to data section, return offset
Function.Emit_AddData {
    Input: ptr: Address
    Input: size: Integer
    Output: Integer
    Body: {
        offset = Emit.data_size
        
        i = 0
        WhileLoop LessThan(i, size) {
            b = GetByte(ptr, i)
            Emit_DataByte(b)
            i = Add(i, 1)
        }
        
        ReturnValue(offset)
    }
}

// Emit byte to data buffer
Function.Emit_DataByte {
    Input: b: Integer
    Body: {
        IfCondition GreaterEqual(Emit.data_size, Emit.data_capacity) ThenBlock: {
            Emit_GrowDataBuffer()
        }
        
        SetByte(Emit.data, Emit.data_size, b)
        Emit.data_size = Add(Emit.data_size, 1)
    }
}

Function.Emit_GrowDataBuffer {
    Body: {
        new_capacity = Multiply(Emit.data_capacity, 2)
        IfCondition GreaterThan(new_capacity, EmitSize.DATA_MAX) ThenBlock: {
            Emit_Error("Data buffer exceeded maximum size")
            ReturnValue(0)
        }
        
        new_buffer = Allocate(new_capacity)
        
        i = 0
        WhileLoop LessThan(i, Emit.data_size) {
            b = GetByte(Emit.data, i)
            SetByte(new_buffer, i, b)
            i = Add(i, 1)
        }
        
        Deallocate(Emit.data, Emit.data_capacity)
        Emit.data = new_buffer
        Emit.data_capacity = new_capacity
        
        ReturnValue(1)
    }
}

// =============================================================================
// LABEL MANAGEMENT
// =============================================================================

// Create a new label, return label ID
Function.Emit_CreateLabel {
    Output: Integer
    Body: {
        label_id = Emit.label_count
        
        // Create label entry
        entry = Allocate(LabelField.ENTRY_SIZE)
        StoreValue(Add(entry, LabelField.NAME), 0)
        StoreValue(Add(entry, LabelField.ADDRESS), 0)
        StoreValue(Add(entry, LabelField.RESOLVED), 0)
        StoreValue(Add(entry, LabelField.SECTION), Emit.current_section)
        
        XArray.XPush(Emit.labels, entry)
        Emit.label_count = Add(Emit.label_count, 1)
        
        ReturnValue(label_id)
    }
}

// Create named label
Function.Emit_CreateNamedLabel {
    Input: name: Address
    Output: Integer
    Body: {
        label_id = Emit_CreateLabel()
        entry = XArray.XGet(Emit.labels, label_id)
        StoreValue(Add(entry, LabelField.NAME), name)
        ReturnValue(label_id)
    }
}

// Register a named label (alias for CreateNamedLabel)
Function.Emit_RegisterLabel {
    Input: name: Address
    Input: label_id: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            StoreValue(Add(entry, LabelField.NAME), name)
        }
    }
}

// Mark label at current position
Function.Emit_MarkLabel {
    Input: label_id: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            StoreValue(Add(entry, LabelField.ADDRESS), Emit.code_size)
            StoreValue(Add(entry, LabelField.RESOLVED), 1)
        }
    }
}

Function.Emit_DefineLabel {
    Input: label_id: Integer
    Body: {
        Emit_MarkLabel(label_id)
    }
}

// Get label address (0 if unresolved)
Function.Emit_GetLabelAddress {
    Input: label_id: Integer
    Output: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            resolved = Dereference(Add(entry, LabelField.RESOLVED))
            IfCondition EqualTo(resolved, 1) ThenBlock: {
                ReturnValue(Dereference(Add(entry, LabelField.ADDRESS)))
            }
        }
        ReturnValue(0)
    }
}

// Check if label is resolved
Function.Emit_IsLabelResolved {
    Input: label_id: Integer
    Output: Integer
    Body: {
        IfCondition LessThan(label_id, Emit.label_count) ThenBlock: {
            entry = XArray.XGet(Emit.labels, label_id)
            ReturnValue(Dereference(Add(entry, LabelField.RESOLVED)))
        }
        ReturnValue(0)
    }
}

// Find label by name
Function.Emit_FindLabel {
    Input: name: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Emit.label_count) {
            entry = XArray.XGet(Emit.labels, i)
            label_name = Dereference(Add(entry, LabelField.NAME))
            IfCondition NotEqual(label_name, 0) ThenBlock: {
                IfCondition EqualTo(StringCompare(name, label_name), 0) ThenBlock: {
                    ReturnValue(i)
                }
            }
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

// =============================================================================
// FIXUP MANAGEMENT
// =============================================================================

// Add fixup at current position
Function.Emit_AddFixup {
    Input: label_id: Integer
    Input: fixup_type: Integer
    Body: {
        entry = Allocate(FixupField.ENTRY_SIZE)
        StoreValue(Add(entry, FixupField.POSITION), Emit.code_size)
        StoreValue(Add(entry, FixupField.LABEL_ID), label_id)
        StoreValue(Add(entry, FixupField.TYPE), fixup_type)
        
        // Set size based on type
        size = 4
        IfCondition EqualTo(fixup_type, FixupType.REL8) ThenBlock: {
            size = 1
        }
        IfCondition EqualTo(fixup_type, FixupType.ABS64) ThenBlock: {
            size = 8
        }
        StoreValue(Add(entry, FixupField.SIZE), size)
        
        XArray.XPush(Emit.fixups, entry)
        Emit.fixup_count = Add(Emit.fixup_count, 1)
    }
}

// Add fixup at specific position
Function.Emit_AddFixupAt {
    Input: position: Integer
    Input: label_id: Integer
    Input: fixup_type: Integer
    Body: {
        entry = Allocate(FixupField.ENTRY_SIZE)
        StoreValue(Add(entry, FixupField.POSITION), position)
        StoreValue(Add(entry, FixupField.LABEL_ID), label_id)
        StoreValue(Add(entry, FixupField.TYPE), fixup_type)
        
        size = 4
        IfCondition EqualTo(fixup_type, FixupType.REL8) ThenBlock: { size = 1 }
        IfCondition EqualTo(fixup_type, FixupType.ABS64) ThenBlock: { size = 8 }
        StoreValue(Add(entry, FixupField.SIZE), size)
        
        XArray.XPush(Emit.fixups, entry)
        Emit.fixup_count = Add(Emit.fixup_count, 1)
    }
}

// Resolve all fixups
Function.Emit_ResolveFixups {
    Body: {
        PrintMessage("[EMIT] Resolving ")
        PrintNumber(Emit.fixup_count)
        PrintMessage(" fixups...\n")
        
        i = 0
        WhileLoop LessThan(i, Emit.fixup_count) {
            entry = XArray.XGet(Emit.fixups, i)
            
            position = Dereference(Add(entry, FixupField.POSITION))
            label_id = Dereference(Add(entry, FixupField.LABEL_ID))
            fixup_type = Dereference(Add(entry, FixupField.TYPE))
            size = Dereference(Add(entry, FixupField.SIZE))
            
            // Get label address
            label_entry = XArray.XGet(Emit.labels, label_id)
            resolved = Dereference(Add(label_entry, LabelField.RESOLVED))
            
            IfCondition EqualTo(resolved, 0) ThenBlock: {
                PrintMessage("[EMIT] WARNING: Unresolved label ")
                PrintNumber(label_id)
                PrintMessage("\n")
            } ElseBlock: {
                target = Dereference(Add(label_entry, LabelField.ADDRESS))
                
                // Calculate offset based on fixup type
                IfCondition EqualTo(fixup_type, FixupType.REL8) ThenBlock: {
                    // 8-bit relative: target - (position + 1)
                    offset = Subtract(target, Add(position, 1))
                    Emit_PatchByte(position, offset)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.REL32) ThenBlock: {
                    // 32-bit relative: target - (position + 4)
                    offset = Subtract(target, Add(position, 4))
                    Emit_PatchDWord(position, offset)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.RIP_REL32) ThenBlock: {
                    // RIP-relative: same as REL32 for our purposes
                    offset = Subtract(target, Add(position, 4))
                    Emit_PatchDWord(position, offset)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.ABS32) ThenBlock: {
                    Emit_PatchDWord(position, target)
                }
                
                IfCondition EqualTo(fixup_type, FixupType.ABS64) ThenBlock: {
                    // 64-bit absolute - patch 8 bytes
                    Emit_PatchDWord(position, BitwiseAnd(target, 4294967295))
                    Emit_PatchDWord(Add(position, 4), RightShift(target, 32))
                }
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[EMIT] Fixups resolved\n")
    }
}


// Jump to label with condition code (architecture-agnostic IR)
Function.Emit_JumpToLabel {
    Input: label: Integer
    Input: condition: Integer
    Body: {
        // ALWAYS = unconditional jump
        IfCondition EqualTo(condition, CC.ALWAYS) ThenBlock: {
            X86_Jmp(label)
            ReturnValue(0)
        }
        
        // Conditional jumps
        IfCondition EqualTo(condition, CC.Z) ThenBlock: { X86_Jz(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NZ) ThenBlock: { X86_Jnz(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.E) ThenBlock: { X86_Je(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NE) ThenBlock: { X86_Jne(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.L) ThenBlock: { X86_Jl(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.LE) ThenBlock: { X86_Jle(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.G) ThenBlock: { X86_Jg(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.GE) ThenBlock: { X86_Jge(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.B) ThenBlock: { X86_Jb(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.BE) ThenBlock: { X86_Jbe(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.A) ThenBlock: { X86_Ja(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.AE) ThenBlock: { X86_Jae(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.S) ThenBlock: { X86_Js(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NS) ThenBlock: { X86_Jns(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.O) ThenBlock: { X86_Jo(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NO) ThenBlock: { X86_Jno(label) ReturnValue(0) }
        
        // Unknown condition code
        ReturnValue(0)
    }
}

// =============================================================================
// SYMBOL MANAGEMENT
// =============================================================================

Function.Emit_AddSymbol {
    Input: name: Address
    Input: sym_type: Integer
    Output: Integer
    Body: {
        sym_id = Emit.symbol_count
        
        entry = Allocate(SymbolField.ENTRY_SIZE)
        StoreValue(Add(entry, SymbolField.NAME), name)
        StoreValue(Add(entry, SymbolField.ADDRESS), Emit.code_size)
        StoreValue(Add(entry, SymbolField.TYPE), sym_type)
        StoreValue(Add(entry, SymbolField.SECTION), Emit.current_section)
        StoreValue(Add(entry, SymbolField.SIZE), 0)
        
        XArray.XPush(Emit.symbols, entry)
        Emit.symbol_count = Add(Emit.symbol_count, 1)
        
        ReturnValue(sym_id)
    }
}


// =============================================================================
// DATA RELOCATION MANAGEMENT
// Tracks code locations that need patching with final data addresses
// =============================================================================

// Initialize data relocation array (call in Emit_Init)
Function.Emit_InitDataRelocs {
    Body: {
        Emit.data_relocs = XArray.XCreate(64)
        Emit.data_reloc_count = 0
        Emit.code_base_addr = 0
        Emit.data_base_addr = 0
    }
}

// Add a data relocation entry
// Called when emitting code that loads a data section address
Function.Emit_AddDataReloc {
    Input: code_position: Integer
    Input: data_offset: Integer
    Body: {
        entry = Allocate(DataRelocField.ENTRY_SIZE)
        StoreValue(Add(entry, DataRelocField.CODE_POSITION), code_position)
        StoreValue(Add(entry, DataRelocField.DATA_OFFSET), data_offset)
        XArray.XPush(Emit.data_relocs, entry)
        Emit.data_reloc_count = Add(Emit.data_reloc_count, 1)
    }
}


// Set base addresses (called by ELF builder after layout calculation)
Function.Emit_SetBaseAddresses {
    Input: code_addr: Integer
    Input: data_addr: Integer
    Body: {
        Emit.code_base_addr = code_addr
        Emit.data_base_addr = data_addr
        
        PrintMessage("[EMIT] Base addresses set: code=0x")
        PrintNumber(code_addr)
        PrintMessage(" data=0x")
        PrintNumber(data_addr)
        PrintMessage("\n")
    }
}

// Apply all data relocations
// Must be called AFTER Emit_SetBaseAddresses and BEFORE code is written to ELF
Function.Emit_ApplyDataRelocations {
    Body: {
        IfCondition EqualTo(Emit.data_base_addr, 0) ThenBlock: {
            PrintMessage("[EMIT] WARNING: Data base address not set\n")
            ReturnValue(0)
        }
        
        PrintMessage("[EMIT] Applying ")
        PrintNumber(Emit.data_reloc_count)
        PrintMessage(" data relocations...\n")
        
        i = 0
        WhileLoop LessThan(i, Emit.data_reloc_count) {
            entry = XArray.XGet(Emit.data_relocs, i)
            code_pos = Dereference(Add(entry, DataRelocField.CODE_POSITION))
            data_offset = Dereference(Add(entry, DataRelocField.DATA_OFFSET))
            final_addr = Add(Emit.data_base_addr, data_offset)
            Emit_PatchQWord(code_pos, final_addr)
            i = Add(i, 1)
        }
        
        PrintMessage("[EMIT] Data relocations applied\n")
        ReturnValue(1)
    }
}

Function.Emit_PatchQWord {
    Input: position: Integer
    Input: value: Integer
    Body: {
        addr = Add(Emit.code, position)
        SetByte(addr, 0, BitwiseAnd(value, 255))
        SetByte(addr, 1, BitwiseAnd(RightShift(value, 8), 255))
        SetByte(addr, 2, BitwiseAnd(RightShift(value, 16), 255))
        SetByte(addr, 3, BitwiseAnd(RightShift(value, 24), 255))
        SetByte(addr, 4, BitwiseAnd(RightShift(value, 32), 255))
        SetByte(addr, 5, BitwiseAnd(RightShift(value, 40), 255))
        SetByte(addr, 6, BitwiseAnd(RightShift(value, 48), 255))
        SetByte(addr, 7, BitwiseAnd(RightShift(value, 56), 255))
    }
}

// Free data relocation array (call in Emit_Free)
Function.Emit_FreeDataRelocs {
    Body: {
        IfCondition NotEqual(Emit.data_relocs, 0) ThenBlock: {
            i = 0
            WhileLoop LessThan(i, Emit.data_reloc_count) {
                entry = XArray.XGet(Emit.data_relocs, i)
                IfCondition NotEqual(entry, 0) ThenBlock: {
                    Deallocate(entry, DataRelocField.ENTRY_SIZE)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Emit.data_relocs)
            Emit.data_relocs = 0
        }
        Emit.data_reloc_count = 0
    }
}

// =============================================================================
// ARCHITECTURE-AGNOSTIC EMIT WRAPPERS
// Compile modules call ONLY these functions, never X86_* directly
// =============================================================================

// --- Stack Operations ---
Function.Emit_AllocStack {
    Input: bytes: Integer
    Body: { X86_SubRspImm32(bytes) }
}

Function.Emit_FreeStack {
    Input: bytes: Integer
    Body: { X86_AddRspImm32(bytes) }
}

// --- Register Moves ---
Function.Emit_MovRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: { X86_MovRegReg(dst, src) }
}

Function.Emit_MovRegImm64 {
    Input: reg: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_MovRaxImm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_MovRbxImm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_MovRcxImm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDX) ThenBlock: { X86_MovRdxImm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_MovRdiImm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_MovRsiImm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R8) ThenBlock: { X86_MovR8Imm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R9) ThenBlock: { X86_MovR9Imm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R10) ThenBlock: { X86_MovR10Imm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R11) ThenBlock: { X86_MovR11Imm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_MovR12Imm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_MovR13Imm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_MovR14Imm64(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R15) ThenBlock: { X86_MovR15Imm64(value) ReturnValue(0) }
    }
}

// --- XOR (used for zeroing registers) ---
Function.Emit_XorRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: { X86_XorRegReg(dst, src) }
}

// --- Arithmetic ---
Function.Emit_AddRegImm32 {
    Input: reg: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_AddRaxImm32(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_AddRbxImm32(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_AddRcxImm32(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDX) ThenBlock: { X86_AddRdxImm32(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_AddR12Imm32(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_AddR13Imm32(value) ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_AddR14Imm32(value) ReturnValue(0) }
    }
}

Function.Emit_AddRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: { X86_AddRegReg(dst, src) }
}

Function.Emit_SubRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: { X86_SubRegReg(dst, src) }
}

// --- Test/Compare ---
Function.Emit_TestRegReg {
    Input: reg1: Integer
    Input: reg2: Integer
    Body: { X86_TestRegReg(reg1, reg2) }
}

Function.Emit_CmpRegReg {
    Input: reg1: Integer
    Input: reg2: Integer
    Body: { X86_CmpRegReg(reg1, reg2) }
}

Function.Emit_CmpRegImm32 {
    Input: reg: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_CmpRaxImm32(value) ReturnValue(0) }
    }
}

// --- Negate ---
Function.Emit_NegReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_NegRax() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_NegRbx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_NegR12() ReturnValue(0) }
    }
}

// --- Increment/Decrement ---
Function.Emit_IncReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_IncRax() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_IncRbx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_IncRcx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_IncRdi() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_IncRsi() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_IncR13() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_IncR14() ReturnValue(0) }
    }
}

Function.Emit_DecReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_DecRax() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_DecRbx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_DecRcx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_DecRdi() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_DecR14() ReturnValue(0) }
    }
}

// --- Division ---
Function.Emit_SignExtendRaxToRdx {
    Body: { X86_Cqo() }
}

Function.Emit_IdivReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_IdivRbx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_IdivRcx() ReturnValue(0) }
    }
}

// --- Push/Pop ---
Function.Emit_PushReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_PushRax() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_PushRbx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_PushRcx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDX) ThenBlock: { X86_PushRdx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_PushRsi() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_PushRdi() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBP) ThenBlock: { X86_PushRbp() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_PushR12() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_PushR13() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_PushR14() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R15) ThenBlock: { X86_PushR15() ReturnValue(0) }
    }
}

Function.Emit_PopReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_PopRax() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_PopRbx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_PopRcx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDX) ThenBlock: { X86_PopRdx() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_PopRsi() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_PopRdi() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.RBP) ThenBlock: { X86_PopRbp() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_PopR12() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_PopR13() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_PopR14() ReturnValue(0) }
        IfCondition EqualTo(reg, Reg.R15) ThenBlock: { X86_PopR15() ReturnValue(0) }
    }
}

// --- Memory Access ---
Function.Emit_StoreByteAtRegOffset {
    Input: base_reg: Integer
    Input: offset: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(base_reg, Reg.RSP) ThenBlock: { 
            X86_MovByteRspOffsetImm8(offset, value) 
            ReturnValue(0) 
        }
        IfCondition EqualTo(base_reg, Reg.R14) ThenBlock: { 
            X86_MovByteR14OffsetImm8(offset, value) 
            ReturnValue(0) 
        }
    }
}

Function.Emit_StoreByteAtReg {
    Input: base_reg: Integer
    Input: src_reg: Integer
    Body: {
        IfCondition EqualTo(base_reg, Reg.R14) ThenBlock: {
            IfCondition EqualTo(src_reg, Reg.RDX) ThenBlock: {
                X86_MovByteR14Dl()
                ReturnValue(0)
            }
        }
    }
}

Function.Emit_LoadRegFromRegOffset {
    Input: dst_reg: Integer
    Input: base_reg: Integer
    Input: offset: Integer
    Body: {
        X86_MovRegMemOffset(dst_reg, base_reg, offset)
    }
}

Function.Emit_StoreRegToRegOffset {
    Input: base_reg: Integer
    Input: offset: Integer
    Input: src_reg: Integer
    Body: {
        X86_MovMemOffsetReg(base_reg, offset, src_reg)
    }
}
Function.X86_Syscall {
    Body: { X86_SysInstr() }
}

// --- Syscall ---
Function.Emit_Syscall {
    Body: { X86_Syscall() }
}

// --- Return ---
Function.Emit_Return {
    Body: { X86_Ret() }
}


// =============================================================================
// STATISTICS
// =============================================================================
Function.Emit_PrintStats {
    Body: {
        PrintMessage("[EMIT STATS]\n")
        PrintMessage("  Code size: ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Data size: ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Labels: ")
        PrintNumber(Emit.label_count)
        PrintMessage("\n")
        PrintMessage("  Fixups: ")
        PrintNumber(Emit.fixup_count)
        PrintMessage("\n")
        PrintMessage("  Symbols: ")
        PrintNumber(Emit.symbol_count)
        PrintMessage("\n")
        PrintMessage("  Strings: ")
        PrintNumber(Emit.string_count)
        PrintMessage("\n")
        PrintMessage("  Instructions: ")
        PrintNumber(Emit.instructions_emitted)
        PrintMessage("\n")
    }
}

// =============================================================================
// DEBUG UTILITIES
// =============================================================================
Function.Emit_DumpCode {
    Input: max_bytes: Integer
    Body: {
        PrintMessage("[CODE DUMP] ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes total, showing first ")
        
        count = max_bytes
        IfCondition GreaterThan(count, Emit.code_size) ThenBlock: {
            count = Emit.code_size
        }
        PrintNumber(count)
        PrintMessage(":\n")
        
        i = 0
        WhileLoop LessThan(i, count) {
            IfCondition EqualTo(Modulo(i, 16), 0) ThenBlock: {
                PrintMessage("\n  ")
                PrintNumber(i)
                PrintMessage(": ")
            }
            
            b = GetByte(Emit.code, i)
            // Print hex byte (simplified - just decimal for now)
            PrintNumber(b)
            PrintMessage(" ")
            
            i = Add(i, 1)
        }
        PrintMessage("\n")
    }
}