// Library.CEmitCoreArch.ailang
// ISA Dispatcher - Routes Emit_* calls to architecture-specific implementations
// Compile modules call Emit_*, dispatcher routes to X86_* or ARM_* based on Emit.target
// Location: Librarys/Compiler/CodeEmit/Library.CEmitCoreArch.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys
LibraryImport.Compiler.CodeEmit.X86.CEmitX86String
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Macros

// =============================================================================
// ARCHITECTURE CONSTANTS
// =============================================================================
FixedPool.Arch {
    "X86_64": Initialize=1, CanChange=False
    "ARM64": Initialize=2, CanChange=False
    "RISCV": Initialize=3, CanChange=False
}

// =============================================================================
// IMMEDIATE LOADS
// =============================================================================

// -----------------------------------------------------------------------------
// Frame pointer setup
// -----------------------------------------------------------------------------
Function.Emit_MovRbpRsp {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbpRsp()
        }
    }
}

Function.Emit_MovRspRbp {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRspRbp()
        }
    }
}

// -----------------------------------------------------------------------------
// R12 moves (depth 0 temp register)
// -----------------------------------------------------------------------------
Function.Emit_MovR12Rbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR12Rbx()
        }
    }
}

Function.Emit_MovR12Rcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR12Rcx()
        }
    }
}

Function.Emit_MovR12Rdx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR12Rdx()
        }
    }
}

Function.Emit_MovRdxR12 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdxR12()
        }
    }
}

// -----------------------------------------------------------------------------
// R13 moves (depth 1 temp register)
// -----------------------------------------------------------------------------
Function.Emit_MovR13Rbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR13Rbx()
        }
    }
}

Function.Emit_MovR13Rcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR13Rcx()
        }
    }
}

Function.Emit_MovR13Rdx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR13Rdx()
        }
    }
}

Function.Emit_MovRdxR13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdxR13()
        }
    }
}

// -----------------------------------------------------------------------------
// R14 moves (reserved - future use)
// -----------------------------------------------------------------------------
Function.Emit_MovR14Rbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR14Rbx()
        }
    }
}

Function.Emit_MovR14Rcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR14Rcx()
        }
    }
}

Function.Emit_MovRbxR14 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxR14()
        }
    }
}

Function.Emit_MovRcxR14 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRcxR14()
        }
    }
}

Function.Emit_MovRdxR14 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdxR14()
        }
    }
}

// -----------------------------------------------------------------------------
// R15 moves (pool base register - use carefully)
// -----------------------------------------------------------------------------
Function.Emit_MovR15Rbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR15Rbx()
        }
    }
}

Function.Emit_MovRbxR15 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxR15()
        }
    }
}

Function.Emit_MovRcxR15 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRcxR15()
        }
    }
}

Function.Emit_MovRdxR15 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdxR15()
        }
    }
}

Function.Emit_MovR15Rax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR15Rax()
        }
    }
}

Function.Emit_XorR15R15 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorR15R15()
        }
    }
}

// -----------------------------------------------------------------------------
// Additional common moves
// -----------------------------------------------------------------------------
Function.Emit_MovRdiRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdiRbx()
        }
    }
}

Function.Emit_MovRsiRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRsiRbx()
        }
    }
}

Function.Emit_MovRbxRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxRdi()
        }
    }
}

Function.Emit_MovRbxRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxRsi()
        }
    }
}


Function.Emit_MovRaxImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxImm64(value)
        }
    }
}

Function.Emit_MovRbxImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxImm64(value)
        }
    }
}

Function.Emit_MovRcxImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRcxImm64(value)
        }
    }
}

Function.Emit_MovRdxImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdxImm64(value)
        }
    }
}

Function.Emit_MovRdiImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdiImm64(value)
        }
    }
}

Function.Emit_MovRsiImm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRsiImm64(value)
        }
    }
}

// Emit_LeaRspRbpOffset - Wrapper for LEA RSP, [RBP + offset]
// THIS IS THE CRITICAL MISSING FUNCTION FOR EPILOGUE
Function.Emit_LeaRspRbpOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_LeaRspRbpOffset(offset)
        }
    }
}

// Emit_MovRaxR8 - Wrapper (if not present)
Function.Emit_MovRaxR8 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxR8()
        }
    }
}

// Emit_MovRaxR9 - Wrapper (if not present)
Function.Emit_MovRaxR9 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxR9()
        }
    }
}

Function.Emit_MovR8Imm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR8Imm64(value)
        }
    }
}

Function.Emit_MovR9Imm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR9Imm64(value)
        }
    }
}

Function.Emit_MovR10Imm64 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR10Imm64(value)
        }
    }
}


// -----------------------------------------------------------------------------
// LOAD BYTE FROM MEMORY TO 8-BIT REGISTER
// -----------------------------------------------------------------------------

// Load byte from [RDI] into AL
Function.Emit_MovAlDerefRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovAlDerefRdi()
        }
    }
}

// Load byte from [RSI] into AL
Function.Emit_MovAlDerefRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovAlDerefRsi()
        }
    }
}

// Load byte from [RSI] into BL
Function.Emit_MovBlDerefRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovBlDerefRsi()
        }
    }
}

// Load byte from [RDI] into BL
Function.Emit_MovBlDerefRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovBlDerefRdi()
        }
    }
}

// Load byte from [RBX] into CL
Function.Emit_MovClDerefRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovClDerefRbx()
        }
    }
}

// Load byte from [RSI] into DL
Function.Emit_MovDlDerefRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDlDerefRsi()
        }
    }
}

// -----------------------------------------------------------------------------
// COMPARE 8-BIT REGISTERS
// -----------------------------------------------------------------------------

// CMP AL, BL - compare two bytes
Function.Emit_CmpAlBl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_CmpAlBl()
        }
    }
}

// CMP AL, DL
Function.Emit_CmpAlDl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_CmpAlDl()
        }
    }
}

// CMP AL, CL
Function.Emit_CmpAlCl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_CmpAlCl()
        }
    }
}

// -----------------------------------------------------------------------------
// TEST 8-BIT REGISTERS (null terminator check)
// -----------------------------------------------------------------------------

// TEST AL, AL - sets ZF if AL is zero
Function.Emit_TestAlAl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_TestAlAl()
        }
    }
}

// TEST CL, CL
Function.Emit_TestClCl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_TestClCl()
        }
    }
}

// TEST BL, BL
Function.Emit_TestBlBl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_TestBlBl()
        }
    }
}

// -----------------------------------------------------------------------------
// STORE BYTE FROM 8-BIT REGISTER TO MEMORY
// -----------------------------------------------------------------------------

// MOV [RDI], AL
Function.Emit_MovDerefRdiAl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDerefRdiAl()
        }
    }
}

// MOV [RSI], AL
Function.Emit_MovDerefRsiAl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDerefRsiAl()
        }
    }
}

// MOV [RBX], AL
Function.Emit_MovDerefRbxAl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDerefRbxAl()
        }
    }
}

// MOV [RDI], CL
Function.Emit_MovDerefRdiCl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDerefRdiCl()
        }
    }
}

// MOV BYTE [RDI], 0 - null terminator
Function.Emit_MovByteDerefRdiZero {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovByteDerefRdiZero()
        }
    }
}

// =============================================================================
// PUSH OPERATIONS
// =============================================================================

Function.Emit_PushRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushRax()
        }
    }
}

Function.Emit_PushRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushRbx()
        }
    }
}

Function.Emit_PushRcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushRcx()
        }
    }
}

Function.Emit_PushRdx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushRdx()
        }
    }
}

Function.Emit_PushRbp {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushRbp()
        }
    }
}

Function.Emit_PushRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushRsi()
        }
    }
}

Function.Emit_PushRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushRdi()
        }
    }
}

Function.Emit_PushR12 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushR12()
        }
    }
}

Function.Emit_PushR13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushR13()
        }
    }
}

Function.Emit_PushR14 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushR14()
        }
    }
}

Function.Emit_PushR15 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushR15()
        }
    }
}

// =============================================================================
// POP OPERATIONS
// =============================================================================

Function.Emit_PopRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopRax()
        }
    }
}

Function.Emit_PopRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopRbx()
        }
    }
}

Function.Emit_PopRcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopRcx()
        }
    }
}

Function.Emit_PopRdx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopRdx()
        }
    }
}

Function.Emit_PopRbp {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopRbp()
        }
    }
}

Function.Emit_PopRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopRsi()
        }
    }
}

Function.Emit_PopRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopRdi()
        }
    }
}

Function.Emit_PopR8 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR8()
        }
    }
}

Function.Emit_PopR9 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR9()
        }
    }
}

Function.Emit_PopR10 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR10()
        }
    }
}

Function.Emit_PopR12 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR12()
        }
    }
}

Function.Emit_PopR13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR13()
        }
    }
}

Function.Emit_PopR14 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR14()
        }
    }
}

Function.Emit_PopR15 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR15()
        }
    }
}

// =============================================================================
// XOR (ZERO REGISTERS)
// =============================================================================

Function.Emit_XorRaxRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRaxRax()
        }
    }
}

Function.Emit_XorRbxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRbxRbx()
        }
    }
}

Function.Emit_XorRcxRcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRcxRcx()
        }
    }
}

Function.Emit_XorRdxRdx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRdxRdx()
        }
    }
}

Function.Emit_XorRdiRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRdiRdi()
        }
    }
}

Function.Emit_XorRsiRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRsiRsi()
        }
    }
}

Function.Emit_XorR8R8 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorR8R8()
        }
    }
}

Function.Emit_XorR9R9 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorR9R9()
        }
    }
}

Function.Emit_XorR10R10 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorR10R10()
        }
    }
}

// =============================================================================
// ARITHMETIC
// =============================================================================

Function.Emit_AddRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_AddRaxRbx()
        }
    }
}

Function.Emit_SubRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_SubRaxRbx()
        }
    }
}

Function.Emit_ImulRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_ImulRaxRbx()
        }
    }
}

Function.Emit_IdivRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_IdivRbx()
        }
    }
}

Function.Emit_Cqo {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Cqo()
        }
    }
}

Function.Emit_NegRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_NegRax()
        }
    }
}

Function.Emit_IncRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_IncRax()
        }
    }
}

Function.Emit_IncRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_IncRbx()
        }
    }
}

Function.Emit_IncRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_IncRdi()
        }
    }
}

Function.Emit_IncRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_IncRsi()
        }
    }
}

Function.Emit_DecRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_DecRax()
        }
    }
}

// =============================================================================
// LOGIC
// =============================================================================

Function.Emit_AndRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_AndRaxRbx()
        }
    }
}

Function.Emit_OrRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_OrRaxRbx()
        }
    }
}

Function.Emit_XorRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRaxRbx()
        }
    }
}

Function.Emit_NotRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_NotRax()
        }
    }
}

Function.Emit_ShlRaxCl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_ShlRaxCl()
        }
    }
}

Function.Emit_SarRaxCl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_SarRaxCl()
        }
    }
}

// =============================================================================
// COMPARE / TEST
// =============================================================================

Function.Emit_CmpRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_CmpRaxRbx()
        }
    }
}

Function.Emit_TestRaxRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_TestRaxRax()
        }
    }
}

Function.Emit_TestR13R13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_TestR13R13()
        }
    }
}

Function.Emit_ImulRaxR12 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_ImulRaxR12()
        }
    }
}

Function.Emit_DecR13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_DecR13()
        }
    }
}

// =============================================================================
// ADD TO Library.CEmitCoreArch.ailang
// Emit wrappers for the X86 functions
// =============================================================================

Function.Emit_PushR11 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PushR11()
        }
    }
}

Function.Emit_PopR11 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_PopR11()
        }
    }
}

Function.Emit_MovR11Rsp {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR11Rsp()
        }
    }
}

Function.Emit_MovRspR11 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRspR11()
        }
    }
}

// =============================================================================
// SETcc INSTRUCTIONS
// =============================================================================

Function.Emit_Sete {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Sete()
        }
    }
}

Function.Emit_Setne {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setne()
        }
    }
}

Function.Emit_Setl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setl()
        }
    }
}

Function.Emit_Setg {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setg()
        }
    }
}

Function.Emit_Setle {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setle()
        }
    }
}

Function.Emit_Setge {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setge()
        }
    }
}

Function.Emit_Setz {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setz()
        }
    }
}

Function.Emit_Setnz {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setnz()
        }
    }
}

Function.Emit_Setb {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setb()
        }
    }
}

Function.Emit_Setbe {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setbe()
        }
    }
}

Function.Emit_Seta {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Seta()
        }
    }
}

Function.Emit_Setae {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setae()
        }
    }
}

Function.Emit_Sets {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Sets()
        }
    }
}

Function.Emit_Setns {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Setns()
        }
    }
}

Function.Emit_MovzxRaxAl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovzxRaxAl()
        }
    }
}

// =============================================================================
// MEMORY - RBP RELATIVE (LOCAL VARIABLES)
// =============================================================================

Function.Emit_MovRaxRbpOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxRbpOffset(offset)
        }
    }
}

Function.Emit_MovRbpOffsetRax {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbpOffsetRax(offset)
        }
    }
}

// =============================================================================
// MEMORY - R15 RELATIVE (POOL VARIABLES)
// =============================================================================

Function.Emit_MovRaxR15Offset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxR15Offset(offset)
        }
    }
}

Function.Emit_MovR15OffsetRax {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR15OffsetRax(offset)
        }
    }
}

// =============================================================================
// MEMORY - DEREFERENCE
// =============================================================================

Function.Emit_MovRbxRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxRax()
        }
    }
}

Function.Emit_MovRsiRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRsiRax()
        }
    }
}

Function.Emit_MovRdiRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdiRax()
        }
    }
}

Function.Emit_MovRaxRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxRdi()
        }
    }
}

Function.Emit_MovRaxRsi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxRsi()
        }
    }
}

Function.Emit_MovRcxRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRcxRax()
        }
    }
}

Function.Emit_MovRdxRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdxRax()
        }
    }
}

Function.Emit_MovRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxRbx()
        }
    }
}

Function.Emit_MovRaxRcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxRcx()
        }
    }
}

Function.Emit_MovRaxRdx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxRdx()
        }
    }
}

// R12 moves
Function.Emit_MovR12Rax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR12Rax()
        }
    }
}

Function.Emit_MovRaxR12 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxR12()
        }
    }
}

Function.Emit_MovRbxR12 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxR12()
        }
    }
}

Function.Emit_MovRcxR12 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRcxR12()
        }
    }
}

// R13 moves
Function.Emit_MovR13Rax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR13Rax()
        }
    }
}

Function.Emit_MovRaxR13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxR13()
        }
    }
}

Function.Emit_MovRbxR13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRbxR13()
        }
    }
}

Function.Emit_MovRcxR13 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRcxR13()
        }
    }
}

// R14 moves
Function.Emit_MovR14Rax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovR14Rax()
        }
    }
}

Function.Emit_MovRaxR14 {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxR14()
        }
    }
}

// =============================================================================
// STACK ALLOCATION
// =============================================================================

Function.Emit_SubRspImm32 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_SubRspImm32(value)
        }
    }
}

Function.Emit_AddRspImm32 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_AddRspImm32(value)
        }
    }
}

Function.Emit_SubRspImm8 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_SubRspImm8(value)
        }
    }
}

Function.Emit_AddRspImm8 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_AddRspImm8(value)
        }
    }
}

Function.Emit_AndRspImm8 {
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_AndRspImm8(value)
        }
    }
}

// =============================================================================
// JUMPS
// =============================================================================

Function.Emit_Jmp {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jmp(label_id)
        }
    }
}

Function.Emit_Je {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Je(label_id)
        }
    }
}

Function.Emit_Jne {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jne(label_id)
        }
    }
}

Function.Emit_Jz {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jz(label_id)
        }
    }
}

Function.Emit_Jnz {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jnz(label_id)
        }
    }
}

Function.Emit_Jl {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jl(label_id)
        }
    }
}

Function.Emit_Jle {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jle(label_id)
        }
    }
}

Function.Emit_Jg {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jg(label_id)
        }
    }
}

Function.Emit_Jge {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jge(label_id)
        }
    }
}

Function.Emit_Jb {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jb(label_id)
        }
    }
}

Function.Emit_Jbe {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jbe(label_id)
        }
    }
}

Function.Emit_Ja {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Ja(label_id)
        }
    }
}

Function.Emit_Jae {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jae(label_id)
        }
    }
}

Function.Emit_Js {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Js(label_id)
        }
    }
}

Function.Emit_Jns {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jns(label_id)
        }
    }
}

Function.Emit_Jo {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jo(label_id)
        }
    }
}

Function.Emit_Jno {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Jno(label_id)
        }
    }
}

// =============================================================================
// CALL / RETURN
// =============================================================================

Function.Emit_Call {
    Input: label_id: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Call(label_id)
        }
    }
}

Function.Emit_Ret {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Ret()
        }
    }
}

// =============================================================================
// PROLOGUE / EPILOGUE
// =============================================================================

Function.Emit_Prologue {
    Input: stack_size: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Prologue(stack_size)
        }
    }
}

Function.Emit_Epilogue {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Epilogue()
        }
    }
}

// =============================================================================
// SYSCALL
// =============================================================================

Function.Emit_SysInstr{
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_SysInstr()
        }
    }
}

// =============================================================================
// STRING OPERATIONS
// =============================================================================

Function.Emit_RepMovsb {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_RepMovsb()
        }
    }
}

Function.Emit_RepStosb {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_RepStosb()
        }
    }
}

Function.Emit_RepMovsq {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_RepMovsq()
        }
    }
}

Function.Emit_RepStosq {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_RepStosq()
        }
    }
}

Function.Emit_RepeCmpsb {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_RepeCmpsb()
        }
    }
}

Function.Emit_RepneScasb {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_RepneScasb()
        }
    }
}

// =============================================================================
// LEA - LOAD EFFECTIVE ADDRESS (RIP-relative for data section)
// =============================================================================

Function.Emit_LeaRaxRipOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_LeaRaxRipOffset(offset)
        }
    }
}

Function.Emit_LeaRsiRipOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_LeaRsiRipOffset(offset)
        }
    }
}

Function.Emit_LeaRdiRipOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_LeaRdiRipOffset(offset)
        }
    }
}

// =============================================================================
// BYTE ACCESS
// =============================================================================

Function.Emit_MovzxRaxByteDerefRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovzxRaxByteDerefRax()
        }
    }
}

Function.Emit_MovzxRaxByteDerefRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovzxRaxByteDerefRbx()
        }
    }
}

Function.Emit_MovzxRaxByteDerefRdi {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovzxRaxByteDerefRdi()
        }
    }
}

Function.Emit_MovByteDerefRdiAl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovByteDerefRdiAl()
        }
    }
}

Function.Emit_MovByteDerefRaxBl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovByteDerefRaxBl()
        }
    }
}

Function.Emit_MovByteDerefRbxAl {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovByteDerefRbxAl()
        }
    }
}

// =============================================================================
// OFFSET ACCESS
// =============================================================================

Function.Emit_MovRaxDerefRaxOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxDerefRaxOffset(offset)
        }
    }
}

Function.Emit_MovDerefRaxOffsetRbx {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDerefRaxOffsetRbx(offset)
        }
    }
}

Function.Emit_MovRaxDerefRbxOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxDerefRbxOffset(offset)
        }
    }
}


// MOV RAX, [RAX] - Load qword through pointer in RAX
Function.Emit_MovRaxDerefRax {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxDerefRax()
        }
    }
}

// MOV RAX, [RBX] - Load qword through pointer in RBX
Function.Emit_MovRaxDerefRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxDerefRbx()
        }
    }
}

// MOV [RAX], RBX - Store RBX to address in RAX
Function.Emit_MovDerefRaxRbx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDerefRaxRbx()
        }
    }
}

// MOV [RAX], RCX - Store RCX to address in RAX
Function.Emit_MovDerefRaxRcx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovDerefRaxRcx()
        }
    }
}

// =============================================================================
// GENERIC JUMP DISPATCHER (Architecture-agnostic IR)
// Compile modules can use this for condition-code based jumps
// =============================================================================

Function.Emit_JumpToLabel {
    Input: label: Integer
    Input: condition: Integer
    Body: {
        // ALWAYS = unconditional jump
        IfCondition EqualTo(condition, CC.ALWAYS) ThenBlock: {
            Emit_Jmp(label)
            ReturnValue(0)
        }
        
        // Conditional jumps - dispatch based on condition code
        IfCondition EqualTo(condition, CC.Z) ThenBlock: { Emit_Jz(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NZ) ThenBlock: { Emit_Jnz(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.E) ThenBlock: { Emit_Je(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NE) ThenBlock: { Emit_Jne(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.L) ThenBlock: { Emit_Jl(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.LE) ThenBlock: { Emit_Jle(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.G) ThenBlock: { Emit_Jg(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.GE) ThenBlock: { Emit_Jge(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.B) ThenBlock: { Emit_Jb(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.BE) ThenBlock: { Emit_Jbe(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.A) ThenBlock: { Emit_Ja(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.AE) ThenBlock: { Emit_Jae(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.S) ThenBlock: { Emit_Js(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NS) ThenBlock: { Emit_Jns(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.O) ThenBlock: { Emit_Jo(label) ReturnValue(0) }
        IfCondition EqualTo(condition, CC.NO) ThenBlock: { Emit_Jno(label) ReturnValue(0) }
        
        // Unknown condition - no-op
        ReturnValue(0)
    }
}

Debug("library.load", level=1) {
    PrintMessage("CEmitCoreArch ISA Dispatcher loaded\n")
}
// =============================================================================
// DATA SECTION ACCESS
// =============================================================================

Function.Emit_MovRsiDataOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRsiDataOffset(offset)
        }
    }
}

Function.Emit_MovRaxDataOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxDataOffset(offset)
        }
    }
}

Function.Emit_MovRdiDataOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRdiDataOffset(offset)
        }
    }
}

// =============================================================================
// STACK ALLOCATION
// =============================================================================

Function.Emit_AllocStack {
    Input: size: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_SubRspImm32(size)
        }
    }
}

Function.Emit_FreeStack {
    Input: size: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_AddRspImm32(size)
        }
    }
}

// =============================================================================
// GENERIC REGISTER OPERATIONS
// =============================================================================

Function.Emit_MovRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRegReg(dst, src)
        }
    }
}

Function.Emit_XorRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_XorRegReg(dst, src)
        }
    }
}

Function.Emit_CmpRegReg {
    Input: reg1: Integer
    Input: reg2: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_CmpRegReg(reg1, reg2)
        }
    }
}

Function.Emit_TestRegReg {
    Input: reg1: Integer
    Input: reg2: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_TestRegReg(reg1, reg2)
        }
    }
}

// =============================================================================
// GENERIC IMMEDIATE LOADS
// =============================================================================

Function.Emit_MovRegImm64 {
    Input: reg: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_MovRaxImm64(value) }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_MovRbxImm64(value) }
            IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_MovRcxImm64(value) }
            IfCondition EqualTo(reg, Reg.RDX) ThenBlock: { X86_MovRdxImm64(value) }
            IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_MovRdiImm64(value) }
            IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_MovRsiImm64(value) }
            IfCondition EqualTo(reg, Reg.R8) ThenBlock: { X86_MovR8Imm64(value) }
            IfCondition EqualTo(reg, Reg.R9) ThenBlock: { X86_MovR9Imm64(value) }
            IfCondition EqualTo(reg, Reg.R10) ThenBlock: { X86_MovR10Imm64(value) }
            IfCondition EqualTo(reg, Reg.R11) ThenBlock: { X86_MovR11Imm64(value) }
            IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_MovR12Imm64(value) }
            IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_MovR13Imm64(value) }
            IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_MovR14Imm64(value) }
            IfCondition EqualTo(reg, Reg.R15) ThenBlock: { X86_MovR15Imm64(value) }
        }
    }
}

// =============================================================================
// GENERIC ARITHMETIC WITH IMMEDIATE
// =============================================================================

Function.Emit_AddRegImm32 {
    Input: reg: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_AddRaxImm32(value) }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_AddRbxImm32(value) }
            IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_AddRcxImm32(value) }
            IfCondition EqualTo(reg, Reg.RDX) ThenBlock: { X86_AddRdxImm32(value) }
            IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_AddR12Imm32(value) }
            IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_AddR13Imm32(value) }
            IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_AddR14Imm32(value) }
            IfCondition EqualTo(reg, Reg.RSP) ThenBlock: { X86_AddRspImm32(value) }
        }
    }
}

Function.Emit_SubRegImm32 {
    Input: reg: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_SubRaxImm32(value) }
            IfCondition EqualTo(reg, Reg.RSP) ThenBlock: { X86_SubRspImm32(value) }
        }
    }
}

// =============================================================================
// BYTE MEMORY OPERATIONS
// =============================================================================

Function.Emit_StoreByteAtRegOffset {
    Input: base_reg: Integer
    Input: offset: Integer
    Input: byte_val: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(base_reg, Reg.RSP) ThenBlock: { X86_MovByteRspOffsetImm8(offset, byte_val) }
            IfCondition EqualTo(base_reg, Reg.R14) ThenBlock: { X86_MovByteR14OffsetImm8(offset, byte_val) }
        }
    }
}

Function.Emit_LoadByteFromRegOffset {
    Input: base_reg: Integer
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(base_reg, Reg.RAX) ThenBlock: { X86_MovzxRaxByteDerefRax() }
            IfCondition EqualTo(base_reg, Reg.RBX) ThenBlock: { X86_MovzxRaxByteDerefRbx() }
            IfCondition EqualTo(base_reg, Reg.RSI) ThenBlock: { X86_MovzxRaxByteDerefRsi() }
            IfCondition EqualTo(base_reg, Reg.RDI) ThenBlock: { X86_MovzxRaxByteDerefRdi() }
        }
    }
}

// =============================================================================
// SYSTEM CALLS
// =============================================================================

Function.Emit_Syscall {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_SysInstr()
        }
    }
}

// =============================================================================
// UNARY OPERATIONS
// =============================================================================

Function.Emit_NegReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_NegRax() }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_NegRbx() }
            IfCondition EqualTo(reg, Reg.R12) ThenBlock: { X86_NegR12() }
        }
    }
}

Function.Emit_NotReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_NotRax() }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_NotRbx() }
        }
    }
}

Function.Emit_IncReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_IncRax() }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_IncRbx() }
            IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_IncRcx() }
            IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_IncRdi() }
            IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_IncRsi() }
            IfCondition EqualTo(reg, Reg.R13) ThenBlock: { X86_IncR13() }
            IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_IncR14() }
        }
    }
}

Function.Emit_DecReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_DecRax() }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_DecRbx() }
            IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_DecRcx() }
            IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_DecRdi() }
            IfCondition EqualTo(reg, Reg.R14) ThenBlock: { X86_DecR14() }
        }
    }
}

// =============================================================================
// SIGN EXTENSION / DIVISION SUPPORT
// =============================================================================

Function.Emit_SignExtendRaxToRdx {
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_Cqo()
        }
    }
}

Function.Emit_IdivReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_IdivRbx() }
            IfCondition EqualTo(reg, Reg.RCX) ThenBlock: { X86_IdivRcx() }
        }
    }
}

Function.Emit_DivReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_DivRbx() }
        }
    }
}

// =============================================================================
// BYTE STORE AT REGISTER (no offset)
// =============================================================================

Function.Emit_StoreByteAtReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_MovByteDerefRdiAl() }
            IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_MovByteDerefRsiAl() }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_MovByteDerefRbxAl() }
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_MovByteDerefRaxBl() }
        }
    }
}

Function.Emit_LoadByteFromReg {
    Input: reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(reg, Reg.RAX) ThenBlock: { X86_MovzxRaxByteDerefRax() }
            IfCondition EqualTo(reg, Reg.RBX) ThenBlock: { X86_MovzxRaxByteDerefRbx() }
            IfCondition EqualTo(reg, Reg.RSI) ThenBlock: { X86_MovzxRaxByteDerefRsi() }
            IfCondition EqualTo(reg, Reg.RDI) ThenBlock: { X86_MovzxRaxByteDerefRdi() }
        }
    }
}

// =============================================================================
// DATA ADDRESS LOADING
// =============================================================================

Function.Emit_LoadDataAddress {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_LoadDataAddress(offset)
        }
    }
}

Function.Emit_LoadDataAddressRsi {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_LoadDataAddressRsi(offset)
        }
    }
}

Function.Emit_LoadDataAddressRdi {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_LoadDataAddressRdi(offset)
        }
    }
}

// =============================================================================
// BYTE STORE FROM REGISTER TO MEMORY AT REGISTER
// =============================================================================

Function.Emit_StoreByteAtRegFromReg {
    Input: dest_reg: Integer
    Input: src_reg: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            IfCondition EqualTo(dest_reg, Reg.R14) ThenBlock: {
                IfCondition EqualTo(src_reg, Reg.RDX) ThenBlock: { X86_MovByteR14Dl() }
            }
            IfCondition EqualTo(dest_reg, Reg.RDI) ThenBlock: {
                IfCondition EqualTo(src_reg, Reg.RAX) ThenBlock: { X86_MovByteDerefRdiAl() }
            }
            IfCondition EqualTo(dest_reg, Reg.RSI) ThenBlock: {
                IfCondition EqualTo(src_reg, Reg.RAX) ThenBlock: { X86_MovByteDerefRsiAl() }
            }
            IfCondition EqualTo(dest_reg, Reg.RBX) ThenBlock: {
                IfCondition EqualTo(src_reg, Reg.RAX) ThenBlock: { X86_MovByteDerefRbxAl() }
            }
        }
    }
}




// =============================================================================
// MEMORY ACCESS WITH OFFSET FROM RAX
// =============================================================================

Function.Emit_MovRaxRaxOffset {
    Input: offset: Integer
    Body: {
        IfCondition EqualTo(Emit.target, 1) ThenBlock: {
            X86_MovRaxDerefRaxOffset(offset)
        }
    }
}
