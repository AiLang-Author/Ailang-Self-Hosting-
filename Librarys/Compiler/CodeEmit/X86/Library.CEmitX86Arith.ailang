// Library.CEmitX86Arith.ailang
// x86-64 arithmetic instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Arith.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// ADD INSTRUCTIONS
// =============================================================================

// ADD RAX, RBX
Function.X86_AddRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(1)     // 0x01 ADD r/m64, r64
        Emit_Byte(216)   // 0xD8 ModR/M: mod=11, reg=RBX, r/m=RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RAX, RCX
Function.X86_AddRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(1)
        Emit_Byte(200)   // 0xC8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RAX, imm32
Function.X86_AddRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(5)     // 0x05 ADD RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RAX, imm8 (sign-extended)
Function.X86_AddRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(131)   // 0x83 ADD r/m64, imm8
        Emit_Byte(192)   // 0xC0 ModR/M: RAX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// SUB INSTRUCTIONS
// =============================================================================

// SUB RAX, RBX
Function.X86_SubRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(41)    // 0x29 SUB r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RAX, RCX
Function.X86_SubRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(41)
        Emit_Byte(200)   // 0xC8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RAX, imm32
Function.X86_SubRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(45)    // 0x2D SUB RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RAX, imm8
Function.X86_SubRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)
        Emit_Byte(131)   // 0x83
        Emit_Byte(232)   // 0xE8 ModR/M: /5, RAX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MULTIPLY INSTRUCTIONS
// =============================================================================

// IMUL RAX, RBX (signed multiply)
Function.X86_ImulRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(175)   // 0xAF IMUL r64, r/m64
        Emit_Byte(195)   // 0xC3 ModR/M: RAX, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IMUL RAX, RCX
Function.X86_ImulRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(15)
        Emit_Byte(175)
        Emit_Byte(193)   // 0xC1 ModR/M: RAX, RCX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IMUL RAX, imm32 (3-operand form)
Function.X86_ImulRaxRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(105)   // 0x69 IMUL r64, r/m64, imm32
        Emit_Byte(192)   // 0xC0 ModR/M: RAX, RAX
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MUL RBX (unsigned multiply, RDX:RAX = RAX * RBX)
Function.X86_MulRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 MUL r/m64
        Emit_Byte(227)   // 0xE3 ModR/M: /4, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// DIVIDE INSTRUCTIONS
// =============================================================================

// CQO - Sign extend RAX into RDX:RAX for division
Function.X86_Cqo {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(153)   // 0x99 CQO
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IDIV RBX - Signed divide RDX:RAX by RBX
// Quotient in RAX, remainder in RDX
Function.X86_IdivRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 IDIV r/m64
        Emit_Byte(251)   // 0xFB ModR/M: /7, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IDIV RCX
Function.X86_IdivRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(247)
        Emit_Byte(249)   // 0xF9 ModR/M: /7, RCX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// DIV RBX - Unsigned divide
Function.X86_DivRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 DIV r/m64
        Emit_Byte(243)   // 0xF3 ModR/M: /6, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// NEGATE / INCREMENT / DECREMENT
// =============================================================================

// NEG RAX (two's complement negate)
Function.X86_NegRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 NEG r/m64
        Emit_Byte(216)   // 0xD8 ModR/M: /3, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NEG RBX
Function.X86_NegRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(247)
        Emit_Byte(219)   // 0xDB
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// INC RAX
Function.X86_IncRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(255)   // 0xFF INC r/m64
        Emit_Byte(192)   // 0xC0 ModR/M: /0, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// INC RBX
Function.X86_IncRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(255)
        Emit_Byte(195)   // 0xC3
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// INC RCX
Function.X86_IncRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(255)
        Emit_Byte(193)   // 0xC1
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// INC RDI
Function.X86_IncRdi {
    Body: {
        Emit_Byte(72)
        Emit_Byte(255)
        Emit_Byte(199)   // 0xC7
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// INC RSI
Function.X86_IncRsi {
    Body: {
        Emit_Byte(72)
        Emit_Byte(255)
        Emit_Byte(198)   // 0xC6
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// DEC RAX
Function.X86_DecRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(255)   // 0xFF DEC r/m64
        Emit_Byte(200)   // 0xC8 ModR/M: /1, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// DEC RBX
Function.X86_DecRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(255)
        Emit_Byte(203)   // 0xCB
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// DEC RCX
Function.X86_DecRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(255)
        Emit_Byte(201)   // 0xC9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// DEC RDI
Function.X86_DecRdi {
    Body: {
        Emit_Byte(72)
        Emit_Byte(255)
        Emit_Byte(207)   // 0xCF
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}