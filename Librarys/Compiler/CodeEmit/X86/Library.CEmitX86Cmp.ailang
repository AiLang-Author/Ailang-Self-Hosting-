// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CEmitX86Cmp.ailang
// x86-64 compare, test, and SETcc instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Cmp.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// COMPARE INSTRUCTIONS
// =============================================================================

// CMP RAX, RBX
Function.X86_CmpRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(57)    // 0x39 CMP r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP RAX, RCX
Function.X86_CmpRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(57)
        Emit_Byte(200)   // 0xC8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP RAX, imm32
Function.X86_CmpRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(61)    // 0x3D CMP RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP RAX, imm8 (sign-extended)
Function.X86_CmpRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(131)   // 0x83 CMP r/m64, imm8
        Emit_Byte(248)   // 0xF8 ModR/M: /7, RAX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP RBX, imm8
Function.X86_CmpRbxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)
        Emit_Byte(131)
        Emit_Byte(251)   // 0xFB ModR/M: /7, RBX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP RCX, imm8
Function.X86_CmpRcxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)
        Emit_Byte(131)
        Emit_Byte(249)   // 0xF9 ModR/M: /7, RCX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP BYTE [RDI+RCX], 0
Function.X86_CmpByteRdiRcxZero {
    Body: {
        Emit_Byte(128)   // 0x80 CMP r/m8, imm8
        Emit_Byte(60)    // 0x3C ModR/M with SIB
        Emit_Byte(15)    // 0x0F SIB: RDI + RCX
        Emit_Byte(0)     // imm8 = 0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// TEST INSTRUCTIONS
// =============================================================================

// TEST RAX, RAX (sets flags based on RAX & RAX)
Function.X86_TestRaxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(133)   // 0x85 TEST r/m64, r64
        Emit_Byte(192)   // 0xC0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// TEST RBX, RBX
Function.X86_TestRbxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(133)
        Emit_Byte(219)   // 0xDB
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// TEST RAX, RBX
Function.X86_TestRaxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(133)
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// TEST RAX, imm32
Function.X86_TestRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(169)   // 0xA9 TEST RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// TEST AL, imm8
Function.X86_TestAlImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(168)   // 0xA8 TEST AL, imm8
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// SET INSTRUCTIONS (set byte based on flags)
// =============================================================================

// SETE AL (set if equal/zero)
Function.X86_Sete {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(148)   // 0x94 SETE r/m8
        Emit_Byte(192)   // 0xC0 ModR/M: AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETNE AL (set if not equal)
Function.X86_Setne {
    Body: {
        Emit_Byte(15)
        Emit_Byte(149)   // 0x95
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETL AL (set if less, signed)
Function.X86_Setl {
    Body: {
        Emit_Byte(15)
        Emit_Byte(156)   // 0x9C
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETLE AL (set if less or equal, signed)
Function.X86_Setle {
    Body: {
        Emit_Byte(15)
        Emit_Byte(158)   // 0x9E
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETG AL (set if greater, signed)
Function.X86_Setg {
    Body: {
        Emit_Byte(15)
        Emit_Byte(159)   // 0x9F
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETGE AL (set if greater or equal, signed)
Function.X86_Setge {
    Body: {
        Emit_Byte(15)
        Emit_Byte(157)   // 0x9D
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETB AL (set if below, unsigned)
Function.X86_Setb {
    Body: {
        Emit_Byte(15)
        Emit_Byte(146)   // 0x92
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETBE AL (set if below or equal, unsigned)
Function.X86_Setbe {
    Body: {
        Emit_Byte(15)
        Emit_Byte(150)   // 0x96
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETA AL (set if above, unsigned)
Function.X86_Seta {
    Body: {
        Emit_Byte(15)
        Emit_Byte(151)   // 0x97
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETAE AL (set if above or equal, unsigned)
Function.X86_Setae {
    Body: {
        Emit_Byte(15)
        Emit_Byte(147)   // 0x93
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETS AL (set if sign/negative)
Function.X86_Sets {
    Body: {
        Emit_Byte(15)
        Emit_Byte(152)   // 0x98
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETNS AL (set if not sign)
Function.X86_Setns {
    Body: {
        Emit_Byte(15)
        Emit_Byte(153)   // 0x99
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETZ AL (alias for SETE)
Function.X86_Setz { Body: { X86_Sete() } }

// SETNZ AL (alias for SETNE)
Function.X86_Setnz { Body: { X86_Setne() } }


// CMP RBX, RAX
Function.X86_CmpRbxRax {
    Body: {
        Emit_Byte(72)
        Emit_Byte(57)
        Emit_Byte(195)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHL RCX, imm8
Function.X86_ShlRcxImm8 {
    Input: count: Integer
    Body: {
        Emit_Byte(72)
        Emit_Byte(193)
        Emit_Byte(225)
        Emit_Byte(count)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RAX, RCX
Function.X86_AddRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(1)
        Emit_Byte(200)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RAX, imm8
Function.X86_AddRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)
        Emit_Byte(131)
        Emit_Byte(192)
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}