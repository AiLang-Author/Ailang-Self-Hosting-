// Library.CEmitX86FileSupport.ailang  
// Additional X86 emit functions for file I/O support
// These may need to be merged into CEmitX86Reg.ailang or CEmitX86Mem.ailang
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86FileSupport.ailang
// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// SPDX-License-Identifier: SCSL-1.0

LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// XOR INSTRUCTIONS FOR ZEROING REGISTERS
// =============================================================================

// XOR RSI, RSI (zero RSI)
Function.X86_XorRsiRsi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR
        Emit_Byte(246)   // 0xF6 ModR/M: RSI, RSI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RDI, RDI (zero RDI)
Function.X86_XorRdiRdi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR
        Emit_Byte(255)   // 0xFF ModR/M: RDI, RDI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RDX, RDX (zero RDX)
Function.X86_XorRdxRdx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR
        Emit_Byte(210)   // 0xD2 ModR/M: RDX, RDX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R9, R9 (zero R9)
Function.X86_XorR9R9 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR
        Emit_Byte(201)   // 0xC9 ModR/M: R9, R9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// ADDITIONAL MOV INSTRUCTIONS
// =============================================================================

// MOV RSI, RCX
Function.X86_MovRsiRcx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(206)   // 0xCE ModR/M: RSI, RCX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDI, RBX
Function.X86_MovRdiRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(223)   // 0xDF ModR/M: RDI, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDI, R12
Function.X86_MovRdiR12 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(137)   // 0x89 MOV
        Emit_Byte(231)   // 0xE7 ModR/M: RDI, R12
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RSI, R13
Function.X86_MovRsiR13 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(137)   // 0x89 MOV
        Emit_Byte(238)   // 0xEE ModR/M: RSI, R13
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RSI, R14
Function.X86_MovRsiR14 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(137)   // 0x89 MOV
        Emit_Byte(246)   // 0xF6 ModR/M: RSI, R14
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDX, R13
Function.X86_MovRdxR13 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(137)   // 0x89 MOV
        Emit_Byte(234)   // 0xEA ModR/M: RDX, R13
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RCX, R14
Function.X86_MovRcxR14 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(137)   // 0x89 MOV
        Emit_Byte(242)   // 0xF2 ModR/M: RCX, R14
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RCX], DL (store byte from DL to address in RCX)
Function.X86_MovDerefRcxDl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(17)    // 0x11 ModR/M: [RCX], DL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// ADD INSTRUCTIONS WITH IMMEDIATE
// =============================================================================

// ADD RSI, imm8
Function.X86_AddRsiImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(131)   // 0x83 ADD r/m64, imm8
        Emit_Byte(198)   // 0xC6 ModR/M: RSI
        // Handle signed byte
        IfCondition LessThan(imm, 0) ThenBlock: {
            Emit_Byte(Add(256, imm))
        } ElseBlock: {
            Emit_Byte(imm)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RCX, RAX
Function.X86_AddRcxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(1)     // 0x01 ADD r/m64, r64
        Emit_Byte(193)   // 0xC1 ModR/M: RCX, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// CMP INSTRUCTIONS
// =============================================================================

// CMP RAX, imm8 (sign-extended)
Function.X86_CmpRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(131)   // 0x83 CMP r/m64, imm8
        Emit_Byte(248)   // 0xF8 ModR/M: RAX
        // Handle signed byte
        IfCondition LessThan(imm, 0) ThenBlock: {
            Emit_Byte(Add(256, imm))
        } ElseBlock: {
            Emit_Byte(imm)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// WRAPPER FUNCTIONS FOR CEmitCoreArch
// =============================================================================

Function.Emit_XorRsiRsi { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_XorRsiRsi() } } }
Function.Emit_XorRdiRdi { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_XorRdiRdi() } } }
Function.Emit_XorRdxRdx { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_XorRdxRdx() } } }
Function.Emit_XorR9R9 { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_XorR9R9() } } }

Function.Emit_MovRsiRcx { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovRsiRcx() } } }
Function.Emit_MovRdiRbx { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovRdiRbx() } } }
Function.Emit_MovRdiR12 { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovRdiR12() } } }
Function.Emit_MovRsiR13 { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovRsiR13() } } }
Function.Emit_MovRsiR14 { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovRsiR14() } } }
Function.Emit_MovRdxR13 { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovRdxR13() } } }
Function.Emit_MovRcxR14 { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovRcxR14() } } }
Function.Emit_MovDerefRcxDl { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_MovDerefRcxDl() } } }

Function.Emit_AddRsiImm8 { Input: imm: Integer Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_AddRsiImm8(imm) } } }
Function.Emit_AddRcxRax { Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_AddRcxRax() } } }

Function.Emit_CmpRaxImm8 { Input: imm: Integer Body: { IfCondition EqualTo(Emit.target, 1) ThenBlock: { X86_CmpRaxImm8(imm) } } }