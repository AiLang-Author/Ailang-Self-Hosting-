// Library.CEmitX86Jump.ailang
// x86-64 jump, call, and return instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Jump.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// UNCONDITIONAL JUMP
// =============================================================================

// JMP rel32 to label
Function.X86_Jmp {
    Input: label_id: Integer
    Body: {
        Emit_Byte(233)   // 0xE9 JMP rel32
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)    // Placeholder for fixup
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// JMP rel8 (short jump, for when target is known to be close)
Function.X86_JmpShort {
    Input: offset: Integer
    Body: {
        Emit_Byte(235)   // 0xEB JMP rel8
        Emit_Byte(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// JMP RAX (indirect jump through register)
Function.X86_JmpRax {
    Body: {
        Emit_Byte(255)   // 0xFF
        Emit_Byte(224)   // 0xE0 JMP r/m64 (RAX)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// JMP [RAX] (indirect jump through memory)
Function.X86_JmpDerefRax {
    Body: {
        Emit_Byte(255)   // 0xFF
        Emit_Byte(32)    // 0x20 JMP [r/m64]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// CONDITIONAL JUMPS (Jcc)
// =============================================================================

// Generic Jcc rel32 to label
Function.X86_Jcc {
    Input: cc: Integer
    Input: label_id: Integer
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(Add(128, cc))   // 0x80 + cc
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// JE (jump if equal/zero)
Function.X86_Je {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.E, label_id) }
}

// JNE (jump if not equal/not zero)
Function.X86_Jne {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.NE, label_id) }
}

// JZ (alias for JE)
Function.X86_Jz {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.Z, label_id) }
}

// JNZ (alias for JNE)
Function.X86_Jnz {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.NZ, label_id) }
}

// JL (jump if less, signed)
Function.X86_Jl {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.L, label_id) }
}

// JLE (jump if less or equal, signed)
Function.X86_Jle {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.LE, label_id) }
}

// JG (jump if greater, signed)
Function.X86_Jg {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.G, label_id) }
}

// JGE (jump if greater or equal, signed)
Function.X86_Jge {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.GE, label_id) }
}

// JB (jump if below, unsigned)
Function.X86_Jb {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.B, label_id) }
}

// JBE (jump if below or equal, unsigned)
Function.X86_Jbe {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.BE, label_id) }
}

// JA (jump if above, unsigned)
Function.X86_Ja {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.A, label_id) }
}

// JAE (jump if above or equal, unsigned)
Function.X86_Jae {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.AE, label_id) }
}

// JS (jump if sign/negative)
Function.X86_Js {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.S, label_id) }
}

// JNS (jump if not sign)
Function.X86_Jns {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.NS, label_id) }
}

// JO (jump if overflow)
Function.X86_Jo {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.O, label_id) }
}

// JNO (jump if not overflow)
Function.X86_Jno {
    Input: label_id: Integer
    Body: { X86_Jcc(CC.NO, label_id) }
}

// =============================================================================
// CALL INSTRUCTIONS
// =============================================================================

// CALL rel32 to label
Function.X86_Call {
    Input: label_id: Integer
    Body: {
        Emit_Byte(232)   // 0xE8 CALL rel32
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CALL RAX (indirect call through register)
Function.X86_CallRax {
    Body: {
        Emit_Byte(255)   // 0xFF
        Emit_Byte(208)   // 0xD0 CALL r/m64 (RAX)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CALL RBX
Function.X86_CallRbx {
    Body: {
        Emit_Byte(255)
        Emit_Byte(211)   // 0xD3
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CALL [RAX] (indirect call through memory)
Function.X86_CallDerefRax {
    Body: {
        Emit_Byte(255)   // 0xFF
        Emit_Byte(16)    // 0x10 CALL [r/m64]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CALL [RAX + offset]
Function.X86_CallDerefRaxOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(255)   // 0xFF CALL
        IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(80)    // mod=01
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(144)   // mod=10
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// RETURN INSTRUCTIONS
// =============================================================================

// RET
Function.X86_Ret {
    Body: {
        Emit_Byte(195)   // 0xC3
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// RET imm16 (return and pop imm16 bytes)
Function.X86_RetImm16 {
    Input: imm: Integer
    Body: {
        Emit_Byte(194)   // 0xC2 RET imm16
        Emit_Word(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// LOOP INSTRUCTIONS
// =============================================================================

// LOOP rel8 (decrement RCX, jump if not zero)
Function.X86_Loop {
    Input: offset: Integer
    Body: {
        Emit_Byte(226)   // 0xE2 LOOP rel8
        Emit_Byte(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LOOPE/LOOPZ rel8 (loop while equal/zero)
Function.X86_Loope {
    Input: offset: Integer
    Body: {
        Emit_Byte(225)   // 0xE1 LOOPE rel8
        Emit_Byte(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LOOPNE/LOOPNZ rel8 (loop while not equal/not zero)
Function.X86_Loopne {
    Input: offset: Integer
    Body: {
        Emit_Byte(224)   // 0xE0 LOOPNE rel8
        Emit_Byte(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}