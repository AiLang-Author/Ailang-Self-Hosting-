// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.





// Library.CEmitX86Logic.ailang
// x86-64 bitwise and logical instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Logic.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// AND INSTRUCTIONS
// =============================================================================

// AND RAX, RBX
Function.X86_AndRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(33)    // 0x21 AND r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// AND RAX, RCX
Function.X86_AndRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(33)
        Emit_Byte(200)   // 0xC8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}



// AND RAX, imm32
Function.X86_AndRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(37)    // 0x25 AND RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// AND RAX, imm8
Function.X86_AndRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)
        Emit_Byte(131)   // 0x83
        Emit_Byte(224)   // 0xE0 ModR/M: /4, RAX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// AND RSP, imm8 - Stack alignment (typically AND RSP, -16)
Function.X86_AndRspImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(131)   // 0x83 AND r/m64, imm8
        Emit_Byte(228)   // 0xE4 ModR/M: /4, RSP
        Emit_Byte(imm)   // imm8 (e.g., 0xF0 for -16)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}
// =============================================================================
// OR INSTRUCTIONS
// =============================================================================

// OR RAX, RBX
Function.X86_OrRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(9)     // 0x09 OR r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// OR RAX, RCX
Function.X86_OrRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(9)
        Emit_Byte(200)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// OR RAX, imm32
Function.X86_OrRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(13)    // 0x0D OR RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// XOR INSTRUCTIONS
// =============================================================================

// XOR RAX, RBX
Function.X86_XorRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RAX, RCX
Function.X86_XorRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(49)
        Emit_Byte(200)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RAX, imm32
Function.X86_XorRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(53)    // 0x35 XOR RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// NOT INSTRUCTION
// =============================================================================

// NOT RAX (one's complement)
Function.X86_NotRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 NOT r/m64
        Emit_Byte(208)   // 0xD0 ModR/M: /2, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NOT RBX
Function.X86_NotRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(247)
        Emit_Byte(211)   // 0xD3
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// SHIFT LEFT INSTRUCTIONS
// =============================================================================

// SHL RAX, CL (shift left by CL)
Function.X86_ShlRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 SHL r/m64, CL
        Emit_Byte(224)   // 0xE0 ModR/M: /4, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHL RAX, imm8
Function.X86_ShlRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(193)   // 0xC1 SHL r/m64, imm8
        Emit_Byte(224)   // 0xE0 ModR/M: /4, RAX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHL RAX, 1
Function.X86_ShlRax1 {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(209)   // 0xD1 SHL r/m64, 1
        Emit_Byte(224)   // 0xE0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// SHIFT RIGHT INSTRUCTIONS
// =============================================================================

// SHR RAX, CL (logical shift right by CL)
Function.X86_ShrRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 SHR r/m64, CL
        Emit_Byte(232)   // 0xE8 ModR/M: /5, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHR RAX, imm8
Function.X86_ShrRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(193)   // 0xC1 SHR r/m64, imm8
        Emit_Byte(232)   // 0xE8 ModR/M: /5, RAX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SAR RAX, CL (arithmetic shift right, preserves sign)
Function.X86_SarRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 SAR r/m64, CL
        Emit_Byte(248)   // 0xF8 ModR/M: /7, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SAR RAX, imm8
Function.X86_SarRaxImm8 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(193)   // 0xC1 SAR r/m64, imm8
        Emit_Byte(248)   // 0xF8 ModR/M: /7, RAX
        Emit_Byte(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// ROTATE INSTRUCTIONS
// =============================================================================

// ROL RAX, CL (rotate left)
Function.X86_RolRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 ROL r/m64, CL
        Emit_Byte(192)   // 0xC0 ModR/M: /0, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ROR RAX, CL (rotate right)
Function.X86_RorRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 ROR r/m64, CL
        Emit_Byte(200)   // 0xC8 ModR/M: /1, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// BIT TEST INSTRUCTIONS
// =============================================================================

// BT RAX, RBX (bit test - sets CF to bit RBX of RAX)
Function.X86_BtRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(163)   // 0xA3 BT r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// BTS RAX, RBX (bit test and set)
Function.X86_BtsRaxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(15)
        Emit_Byte(171)   // 0xAB BTS
        Emit_Byte(216)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// BTR RAX, RBX (bit test and reset)
Function.X86_BtrRaxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(15)
        Emit_Byte(179)   // 0xB3 BTR
        Emit_Byte(216)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}