// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// Library.CEmitX86Macros.ailang
// x86-64 specific macros for common code generation patterns
// Location: Librarys/Compiler/CodeEmit/X86/



LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack

// =============================================================================
// REGISTER MANAGEMENT MACROS
// =============================================================================

// Save registers used in string operations
Function.EMIT_SAVE_STRING_REGS {
    Body: {
        X86_PushRbx()
        X86_PushRcx()
        X86_PushRdx()
        X86_PushRsi()
        X86_PushRdi()
    }
}

// Restore registers used in string operations (reverse order)
Function.EMIT_RESTORE_STRING_REGS {
    Body: {
        X86_PopRdi()
        X86_PopRsi()
        X86_PopRdx()
        X86_PopRcx()
        X86_PopRbx()
    }
}

// =============================================================================
// STRING COMPARISON MACROS
// =============================================================================

// Setup string comparison: str1 -> PTR1, str2 -> PTR2
// Assumes RAX has value, moves to destination pointer register
Function.EMIT_SETUP_STRING_PTR1 {
    Body: {
        X86_MovRdiRax()  // RDI = first string pointer (x86-64 convention)
    }
}

Function.EMIT_SETUP_STRING_PTR2 {
    Body: {
        X86_MovRsiRax()  // RSI = second string pointer (x86-64 convention)
    }
}

// Load byte from first string pointer into comparison register
Function.EMIT_LOAD_BYTE_PTR1 {
    Body: {
        // MOV AL, [RDI]
        Emit_Byte(0x8A)
        Emit_Byte(0x07)
    }
}

// Load byte from second string pointer into comparison register
Function.EMIT_LOAD_BYTE_PTR2 {
    Body: {
        // MOV BL, [RSI]
        Emit_Byte(0x8A)
        Emit_Byte(0x1E)
    }
}

// Compare the two loaded bytes (AL vs BL)
Function.EMIT_COMPARE_BYTES {
    Body: {
        // CMP AL, BL
        Emit_Byte(0x38)
        Emit_Byte(0xD8)
    }
}

// Test if byte is zero (null terminator check)
Function.EMIT_TEST_BYTE_ZERO {
    Body: {
        // TEST AL, AL
        Emit_Byte(0x84)
        Emit_Byte(0xC0)
    }
}

// Increment first string pointer
Function.EMIT_INCREMENT_PTR1 {
    Body: {
        // INC RDI
        Emit_Byte(0x48)
        Emit_Byte(0xFF)
        Emit_Byte(0xC7)
    }
}

// Increment second string pointer
Function.EMIT_INCREMENT_PTR2 {
    Body: {
        // INC RSI
        Emit_Byte(0x48)
        Emit_Byte(0xFF)
        Emit_Byte(0xC6)
    }
}

// =============================================================================
// STRING LENGTH MACROS
// =============================================================================

// Setup for string length calculation
Function.EMIT_SETUP_LENGTH_COUNT {
    Body: {
        X86_XorRcxRcx()  // RCX = 0 (counter)
    }
}

// Setup string pointer for length (RAX -> pointer register)
Function.EMIT_SETUP_LENGTH_PTR {
    Body: {
        X86_MovRdiRax()  // RDI = string pointer
    }
}

// Compare byte at pointer with null
Function.EMIT_COMPARE_BYTE_NULL {
    Body: {
        // CMP BYTE [RDI+RCX], 0
        Emit_Byte(0x80)
        Emit_Byte(0x3C)
        Emit_Byte(0x0F)
        Emit_Byte(0x00)
    }
}

// Increment length counter
Function.EMIT_INCREMENT_LENGTH {
    Body: {
        // INC RCX
        Emit_Byte(0x48)
        Emit_Byte(0xFF)
        Emit_Byte(0xC1)
    }
}

// Move length result to return register
Function.EMIT_RETURN_LENGTH {
    Body: {
        X86_MovRaxRcx()  // RAX = RCX (length)
    }
}

// =============================================================================
// GENERAL PURPOSE MACROS
// =============================================================================

// Set return value to immediate
Function.EMIT_RETURN_VALUE {
    Input: value: Integer
    Body: {
        X86_MovRaxImm64(value)
    }
}

// Save all callee-saved registers (full set)
Function.EMIT_SAVE_ALL_REGS {
    Body: {
        X86_PushRbx()
        X86_PushRbp()
        X86_PushR12()
        X86_PushR13()
        X86_PushR14()
        X86_PushR15()
    }
}

// Restore all callee-saved registers (reverse order)
Function.EMIT_RESTORE_ALL_REGS {
    Body: {
        X86_PopR15()
        X86_PopR14()
        X86_PopR13()
        X86_PopR12()
        X86_PopRbp()
        X86_PopRbx()
    }
}