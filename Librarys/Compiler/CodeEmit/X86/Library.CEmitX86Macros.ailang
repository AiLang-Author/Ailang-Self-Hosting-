// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// Library.CEmitX86Macros.ailang
// x86-64 specific macros for common code generation patterns
// Location: Librarys/Compiler/CodeEmit/X86/



LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack

// =============================================================================
// REGISTER MANAGEMENT MACROS
// =============================================================================

// Save registers used in string operations
Function.EMIT_SAVE_STRING_REGS {
    Body: {
        X86_PushRbx()
        X86_PushRcx()
        X86_PushRdx()
        X86_PushRsi()
        X86_PushRdi()
    }
}

// Restore registers used in string operations (reverse order)
Function.EMIT_RESTORE_STRING_REGS {
    Body: {
        X86_PopRdi()
        X86_PopRsi()
        X86_PopRdx()
        X86_PopRcx()
        X86_PopRbx()
    }
}

// =============================================================================
// STRING COMPARISON MACROS
// =============================================================================

// Setup string comparison: str1 -> PTR1, str2 -> PTR2
// Assumes RAX has value, moves to destination pointer register
Function.EMIT_SETUP_STRING_PTR1 {
    Body: {
        X86_MovRdiRax()  // RDI = first string pointer (x86-64 convention)
    }
}

Function.EMIT_SETUP_STRING_PTR2 {
    Body: {
        X86_MovRsiRax()  // RSI = second string pointer (x86-64 convention)
    }
}

// Load byte from first string pointer into comparison register
Function.EMIT_LOAD_BYTE_PTR1 {
    Body: {
        // MOV AL, [RDI]
        Emit_Byte(0x8A)
        Emit_Byte(0x07)
    }
}

// Load byte from second string pointer into comparison register
Function.EMIT_LOAD_BYTE_PTR2 {
    Body: {
        // MOV BL, [RSI]
        Emit_Byte(0x8A)
        Emit_Byte(0x1E)
    }
}

// Compare the two loaded bytes (AL vs BL)
Function.EMIT_COMPARE_BYTES {
    Body: {
        // CMP AL, BL
        Emit_Byte(0x38)
        Emit_Byte(0xD8)
    }
}

// Test if byte is zero (null terminator check)
Function.EMIT_TEST_BYTE_ZERO {
    Body: {
        // TEST AL, AL
        Emit_Byte(0x84)
        Emit_Byte(0xC0)
    }
}

// Increment first string pointer
Function.EMIT_INCREMENT_PTR1 {
    Body: {
        // INC RDI
        Emit_Byte(0x48)
        Emit_Byte(0xFF)
        Emit_Byte(0xC7)
    }
}

// Increment second string pointer
Function.EMIT_INCREMENT_PTR2 {
    Body: {
        // INC RSI
        Emit_Byte(0x48)
        Emit_Byte(0xFF)
        Emit_Byte(0xC6)
    }
}

// =============================================================================
// STRING LENGTH MACROS
// =============================================================================

// Setup for string length calculation
Function.EMIT_SETUP_LENGTH_COUNT {
    Body: {
        X86_XorRcxRcx()  // RCX = 0 (counter)
    }
}

// Setup string pointer for length (RAX -> pointer register)
Function.EMIT_SETUP_LENGTH_PTR {
    Body: {
        X86_MovRdiRax()  // RDI = string pointer
    }
}

// Compare byte at pointer with null
Function.EMIT_COMPARE_BYTE_NULL {
    Body: {
        // CMP BYTE [RDI+RCX], 0
        Emit_Byte(0x80)
        Emit_Byte(0x3C)
        Emit_Byte(0x0F)
        Emit_Byte(0x00)
    }
}

// Increment length counter
Function.EMIT_INCREMENT_LENGTH {
    Body: {
        // INC RCX
        Emit_Byte(0x48)
        Emit_Byte(0xFF)
        Emit_Byte(0xC1)
    }
}

// Move length result to return register
Function.EMIT_RETURN_LENGTH {
    Body: {
        X86_MovRaxRcx()  // RAX = RCX (length)
    }
}

// =============================================================================
// GENERAL PURPOSE MACROS
// =============================================================================

// Set return value to immediate
Function.EMIT_RETURN_VALUE {
    Input: value: Integer
    Body: {
        X86_MovRaxImm64(value)
    }
}

// Save all callee-saved registers (full set)
Function.EMIT_SAVE_ALL_REGS {
    Body: {
        X86_PushRbx()
        X86_PushRbp()
        X86_PushR12()
        X86_PushR13()
        X86_PushR14()
        X86_PushR15()
    }
}

// Restore all callee-saved registers (reverse order)
Function.EMIT_RESTORE_ALL_REGS {
    Body: {
        X86_PopR15()
        X86_PopR14()
        X86_PopR13()
        X86_PopR12()
        X86_PopRbp()
        X86_PopRbx()
    }
}
// =============================================================================
// MOVZX - Zero-extend byte from memory to register
// =============================================================================

// MOVZX RAX, BYTE PTR [RAX] - load byte, zero-extend to 64-bit
Function.X86_MovzxRaxByteDerefRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(0)     // 0x00 ModR/M: RAX, [RAX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOVZX RAX, BYTE PTR [RBX] - load byte from [RBX], zero-extend to RAX
Function.X86_MovzxRaxByteDerefRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(3)     // 0x03 ModR/M: RAX, [RBX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOVZX RAX, BYTE PTR [RSI] - load byte from [RSI], zero-extend to RAX
Function.X86_MovzxRaxByteDerefRsi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(6)     // 0x06 ModR/M: RAX, [RSI]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOVZX RAX, BYTE PTR [RDI] - load byte from [RDI], zero-extend to RAX
Function.X86_MovzxRaxByteDerefRdi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(7)     // 0x07 ModR/M: RAX, [RDI]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MOV BYTE PTR - Store byte to memory
// =============================================================================

// MOV BYTE PTR [RDI], AL
Function.X86_MovByteDerefRdiAl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(7)     // 0x07 ModR/M: [RDI], AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV BYTE PTR [RSI], AL
Function.X86_MovByteDerefRsiAl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(6)     // 0x06 ModR/M: [RSI], AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV BYTE PTR [RAX], BL
Function.X86_MovByteDerefRaxBl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(24)    // 0x18 ModR/M: [RAX], BL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV BYTE PTR [RBX], AL
Function.X86_MovByteDerefRbxAl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(3)     // 0x03 ModR/M: [RBX], AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MOV with offset - Load with displacement (always disp32)
// =============================================================================

// MOV RAX, [RBX + offset]
Function.X86_MovRaxDerefRbxOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        Emit_Byte(131)   // 0x83 ModR/M: RAX, [RBX+disp32]
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, [RSI + offset]
Function.X86_MovRaxDerefRsiOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        Emit_Byte(134)   // 0x86 ModR/M: RAX, [RSI+disp32]
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, [RDI + offset]
Function.X86_MovRaxDerefRdiOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        Emit_Byte(135)   // 0x87 ModR/M: RAX, [RDI+disp32]
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}