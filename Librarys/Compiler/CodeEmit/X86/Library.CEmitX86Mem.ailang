// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.





// Library.CEmitX86Mem.ailang
// x86-64 memory load/store instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Mem.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Helpers

// =============================================================================
// LOCAL VARIABLE ACCESS (RBP-relative)
// =============================================================================

// MOV RAX, R8 - Move fifth parameter to RAX
Function.X86_MovRaxR8 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR (R8 is extended register)
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(192)   // 0xC0 ModR/M: mod=11, reg=R8(000), r/m=RAX(000)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, R9 - Move sixth parameter to RAX
Function.X86_MovRaxR9 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(200)   // 0xC8 ModR/M: mod=11, reg=R9(001), r/m=RAX(000)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, [RBP + offset] - Load local variable
Function.X86_MovRaxRbpOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            // [RBP] needs disp8=0 due to RBP encoding
            Emit_Byte(69)    // 0x45 ModR/M: mod=01, reg=RAX, r/m=RBP
            Emit_Byte(0)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(69)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(133)   // 0x85 mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RBP + offset], RAX - Store local variable
Function.X86_MovRbpOffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(69)
            Emit_Byte(0)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(69)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(133)
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MOV BYTE [RSP+offset], imm8
// =============================================================================
Function.X86_MovByteRspOffsetImm8 {
    Input: offset: Integer
    Input: value: Integer
    Body: {
        Emit_Byte(198)
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(4)
            Emit_Byte(36)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(68)
                Emit_Byte(36)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(132)
                Emit_Byte(36)
                Emit_DWord(offset)
            }
        }
        Emit_Byte(value)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV BYTE [R14+offset], imm8
Function.X86_MovByteR14OffsetImm8 {
    Input: offset: Integer
    Input: value: Integer
    Body: {
        Emit_Byte(65)
        Emit_Byte(198)
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(6)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(70)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(134)
                Emit_DWord(offset)
            }
        }
        Emit_Byte(value)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOVZX RAX, BYTE PTR [RSI] - zero-extend byte at [RSI] into RAX
// Encoding: 48 0F B6 06
Function.X86_MovzxRaxBytePtrRsi {
    Body: {
        Emit_Byte(0x48)
        Emit_Byte(0x0F)
        Emit_Byte(0xB6)
        Emit_Byte(0x06)
    }
}

// MOV BYTE PTR [RDI], imm8 - store immediate byte at [RDI]
// Encoding: C6 07 ib
Function.X86_MovByteDerefRdiImm8 {
    Input: val: Integer
    Body: {
        Emit_Byte(0xC6)
        Emit_Byte(0x07)
        Emit_Byte(val)
    }
}

// MOV BYTE [R14], DL
Function.X86_MovByteR14Dl {
    Body: {
        Emit_Byte(65)
        Emit_Byte(136)
        Emit_Byte(22)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// GENERIC MOV reg, [base+offset] and MOV [base+offset], reg
// =============================================================================
Function.X86_MovRegMemOffset {
    Input: dst: Integer
    Input: base: Integer
    Input: offset: Integer
    Body: {
        rex = 72
        IfCondition GreaterEqual(dst, 8) ThenBlock: { rex = BitwiseOr(rex, 4) }
        IfCondition GreaterEqual(base, 8) ThenBlock: { rex = BitwiseOr(rex, 1) }
        Emit_Byte(rex)
        Emit_Byte(139)
        dst_enc = BitwiseAnd(dst, 7)
        base_enc = BitwiseAnd(base, 7)
        IfCondition EqualTo(offset, 0) ThenBlock: {
            modrm = BitwiseOr(LeftShift(dst_enc, 3), base_enc)
            Emit_Byte(modrm)
            IfCondition EqualTo(base_enc, 4) ThenBlock: { Emit_Byte(36) }
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                modrm = BitwiseOr(64, BitwiseOr(LeftShift(dst_enc, 3), base_enc))
                Emit_Byte(modrm)
                IfCondition EqualTo(base_enc, 4) ThenBlock: { Emit_Byte(36) }
                Emit_Byte(offset)
            } ElseBlock: {
                modrm = BitwiseOr(128, BitwiseOr(LeftShift(dst_enc, 3), base_enc))
                Emit_Byte(modrm)
                IfCondition EqualTo(base_enc, 4) ThenBlock: { Emit_Byte(36) }
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

Function.X86_MovMemOffsetReg {
    Input: base: Integer
    Input: offset: Integer
    Input: src: Integer
    Body: {
        rex = 72
        IfCondition GreaterEqual(src, 8) ThenBlock: { rex = BitwiseOr(rex, 4) }
        IfCondition GreaterEqual(base, 8) ThenBlock: { rex = BitwiseOr(rex, 1) }
        Emit_Byte(rex)
        Emit_Byte(137)
        src_enc = BitwiseAnd(src, 7)
        base_enc = BitwiseAnd(base, 7)
        IfCondition EqualTo(offset, 0) ThenBlock: {
            modrm = BitwiseOr(LeftShift(src_enc, 3), base_enc)
            Emit_Byte(modrm)
            IfCondition EqualTo(base_enc, 4) ThenBlock: { Emit_Byte(36) }
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                modrm = BitwiseOr(64, BitwiseOr(LeftShift(src_enc, 3), base_enc))
                Emit_Byte(modrm)
                IfCondition EqualTo(base_enc, 4) ThenBlock: { Emit_Byte(36) }
                Emit_Byte(offset)
            } ElseBlock: {
                modrm = BitwiseOr(128, BitwiseOr(LeftShift(src_enc, 3), base_enc))
                Emit_Byte(modrm)
                IfCondition EqualTo(base_enc, 4) ThenBlock: { Emit_Byte(36) }
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// =============================================================================
// 
// instructions for saving/restoring RSP to/from RBP-relative stack slots
// =============================================================================

// MOV [RBP + offset], RSP - Save RSP to stack slot
// This is used to preserve RSP across function calls where expression
// evaluation might clobber registers.
//
// Encoding: 48 89 65 disp8  OR  48 89 A5 disp32
// 48 = REX.W (64-bit operand)
// 89 = MOV r/m64, r64
// 65 = ModR/M: mod=01, reg=RSP(100=4), r/m=RBP(101=5) -> 01 100 101 = 0x65
// A5 = ModR/M: mod=10, reg=RSP(100=4), r/m=RBP(101=5) -> 10 100 101 = 0xA5
//
// NOTE: RBP as r/m does NOT require SIB byte (unlike RSP)
Function.X86_MovRbpOffsetRsp {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        // RBP requires displacement even for offset=0 (ModR/M encoding quirk)
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(101)   // 0x65 mod=01, reg=RSP, r/m=RBP
            // Handle signed byte
            IfCondition LessThan(offset, 0) ThenBlock: {
                Emit_Byte(Add(256, offset))
            } ElseBlock: {
                Emit_Byte(offset)
            }
        } ElseBlock: {
            Emit_Byte(165)   // 0xA5 mod=10, reg=RSP, r/m=RBP
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RSP, [RBP + offset] - Restore RSP from stack slot
//
// Encoding: 48 8B 65 disp8  OR  48 8B A5 disp32
// 48 = REX.W (64-bit operand)
// 8B = MOV r64, r/m64
// 65 = ModR/M: mod=01, reg=RSP(100=4), r/m=RBP(101=5) -> 01 100 101 = 0x65
// A5 = ModR/M: mod=10, reg=RSP(100=4), r/m=RBP(101=5) -> 10 100 101 = 0xA5
Function.X86_MovRspRbpOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        // RBP requires displacement even for offset=0
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(101)   // 0x65 mod=01, reg=RSP, r/m=RBP
            IfCondition LessThan(offset, 0) ThenBlock: {
                Emit_Byte(Add(256, offset))
            } ElseBlock: {
                Emit_Byte(offset)
            }
        } ElseBlock: {
            Emit_Byte(165)   // 0xA5 mod=10, reg=RSP, r/m=RBP
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// POOL VARIABLE ACCESS (R15-relative)
// R15 = pool table base address
// =============================================================================

// MOV RAX, [R15 + offset] - Load pool variable
Function.X86_MovRaxR15Offset {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(139)   // 0x8B MOV
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(71)    // mod=01, reg=RAX, r/m=R15
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(135)   // mod=10
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [R15 + offset], RAX - Store pool variable
Function.X86_MovR15OffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(137)   // 0x89 MOV
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(71)
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(135)
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}



// MOV RAX, [R15] - Load from pool table base
Function.X86_MovRaxDerefR15 {
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB (W=64-bit, B=R15 extension)
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        Emit_Byte(7)     // 0x07 ModR/M: mod=00, reg=RAX(000), r/m=R15(111)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, [R15 + offset] - Load from pool table with offset
Function.X86_MovRaxDerefR15Offset {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(7)     // ModR/M: [R15]
        } ElseBlock: {
            IfCondition And(GreaterThan(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(71)    // 0x47 ModR/M: mod=01, reg=RAX, r/m=R15
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(135)   // 0x87 ModR/M: mod=10, reg=RAX, r/m=R15
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [R15], RAX - Store to pool table base
Function.X86_MovDerefR15Rax {
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(7)     // 0x07 ModR/M: [R15], RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [R15 + offset], RAX - Store to pool table with offset
Function.X86_MovDerefR15OffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(7)     // ModR/M: [R15], RAX
        } ElseBlock: {
            IfCondition And(GreaterThan(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(71)    // mod=01, reg=RAX, r/m=R15
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(135)   // mod=10, reg=RAX, r/m=R15
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RBX, [R15 + offset] - Load to RBX from pool table
Function.X86_MovRbxDerefR15Offset {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(31)    // 0x1F ModR/M: mod=00, reg=RBX(011), r/m=R15(111)
        } ElseBlock: {
            IfCondition And(GreaterThan(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(95)    // 0x5F ModR/M: mod=01, reg=RBX, r/m=R15
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(159)   // 0x9F ModR/M: mod=10, reg=RBX, r/m=R15
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [R15 + offset], RBX - Store RBX to pool table
Function.X86_MovDerefR15OffsetRbx {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(31)    // ModR/M: [R15], RBX
        } ElseBlock: {
            IfCondition And(GreaterThan(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(95)    // mod=01, reg=RBX, r/m=R15
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(159)   // mod=10, reg=RBX, r/m=R15
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LEA RAX, [R15 + offset] - Load effective address from pool table
Function.X86_LeaRaxR15Offset {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(141)   // 0x8D LEA
        
        IfCondition And(GreaterThan(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(71)    // mod=01, reg=RAX, r/m=R15
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(135)   // mod=10, reg=RAX, r/m=R15
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// STACK-RELATIVE ACCESS (RSP-relative)
// =============================================================================

// MOV RAX, [RSP + offset]
Function.X86_MovRaxRspOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            // [RSP] needs SIB byte
            Emit_Byte(4)     // ModR/M: mod=00, reg=RAX, r/m=100 (SIB)
            Emit_Byte(36)    // SIB: scale=00, index=RSP, base=RSP
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(68)    // mod=01
                Emit_Byte(36)    // SIB
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(132)   // mod=10
                Emit_Byte(36)    // SIB
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RSP + offset], RAX
Function.X86_MovRspOffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(4)
            Emit_Byte(36)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(68)
                Emit_Byte(36)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(132)
                Emit_Byte(36)
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LEA RSP, [RBP + offset] - Used to restore RSP in function epilogue
// This is critical for properly restoring callee-saved registers
Function.X86_LeaRspRbpOffset {
    Input: offset: Integer
    Body: {
        // LEA RSP, [RBP + disp]
        // Encoding: 48 8D 65 disp8  OR  48 8D A5 disp32
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA opcode
        
        // ModR/M byte: mod=01/10, reg=RSP(100), r/m=RBP(101)
        // For RBP base: use 0x65 for disp8, 0xA5 for disp32
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(101)   // 0x65 ModR/M: mod=01, reg=RSP, r/m=RBP
            // Handle signed byte
            IfCondition LessThan(offset, 0) ThenBlock: {
                Emit_Byte(Add(256, offset))  // Convert to unsigned byte
            } ElseBlock: {
                Emit_Byte(offset)
            }
        } ElseBlock: {
            Emit_Byte(165)   // 0xA5 ModR/M: mod=10, reg=RSP, r/m=RBP
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}



// =============================================================================
// INDIRECT ACCESS (through register)
// =============================================================================

// MOV RAX, [RAX] - Load through pointer in RAX
Function.X86_MovRaxDerefRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV
        Emit_Byte(0)     // ModR/M: [RAX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, [RBX]
Function.X86_MovRaxDerefRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(139)
        Emit_Byte(3)     // ModR/M: [RBX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX], RBX - Store RBX to address in RAX
Function.X86_MovDerefRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(24)    // 0x18 ModR/M: [RAX], RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX], RCX
Function.X86_MovDerefRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(137)
        Emit_Byte(8)     // ModR/M: [RAX], RCX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// BYTE ACCESS
// =============================================================================

// MOV AL, [RBX] - Load byte
Function.X86_MovAlDerefRbx {
    Body: {
        Emit_Byte(138)   // 0x8A MOV r8, r/m8
        Emit_Byte(3)     // ModR/M: AL, [RBX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RBX], AL - Store byte
Function.X86_MovDerefRbxAl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(3)     // ModR/M: [RBX], AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV AL, [RAX + RBX] - Load byte with index
Function.X86_MovAlRaxRbx {
    Body: {
        Emit_Byte(138)   // 0x8A MOV r8, r/m8
        Emit_Byte(4)     // ModR/M with SIB
        Emit_Byte(24)    // SIB: RAX + RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX + RBX], CL - Store byte with index
Function.X86_MovRaxRbxCl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(12)    // ModR/M with SIB, CL
        Emit_Byte(24)    // SIB: RAX + RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// LEA - Load Effective Address
// =============================================================================

// LEA RAX, [RBP + offset]
Function.X86_LeaRaxRbpOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(69)    // mod=01, reg=RAX, r/m=RBP
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(133)   // mod=10
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// DATA ADDRESS LOADING (with relocation tracking)
// =============================================================================

// LEA/MOV for data section address - TRACKS RELOCATION
Function.X86_LoadDataAddress {
    Input: data_offset: Integer
    Body: {
        // Use MOV RAX, imm64 for absolute address
        // This will be patched by Emit_ApplyDataRelocations
        
        Emit_Byte(0x48)   // REX.W
        Emit_Byte(0xB8)   // MOV RAX, imm64
        
        // Record current position for relocation
        Emit_AddDataReloc(Emit.code_size, data_offset)
        
        // Emit placeholder (8 bytes of zeros)
        // These will be patched with the actual address
        Emit_QWord(0)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// Alternative: Load data address into RSI (for syscalls)
Function.X86_LoadDataAddressRsi {
    Input: data_offset: Integer
    Body: {
        // MOV RSI, imm64
        Emit_Byte(0x48)   // REX.W
        Emit_Byte(0xBE)   // MOV RSI, imm64
        
        // Record for relocation
        Emit_AddDataReloc(Emit.code_size, data_offset)
        
        // Placeholder
        Emit_QWord(0)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Load data address into RDI
Function.X86_LoadDataAddressRdi {
    Input: data_offset: Integer
    Body: {
        // MOV RDI, imm64
        Emit_Byte(0x48)   // REX.W
        Emit_Byte(0xBF)   // MOV RDI, imm64
        
        Emit_AddDataReloc(Emit.code_size, data_offset)
        Emit_QWord(0)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// QWORD MEMORY ACCESS
// =============================================================================

// MOV RAX, [RAX + offset]
Function.X86_MovRaxDerefRaxOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(0)     // [RAX]
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(64)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(128)   // mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX + offset], RBX
Function.X86_MovDerefRaxOffsetRbx {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(24)    // [RAX], RBX
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(88)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(152)   // mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MOV data_offset (with relocation)
// =============================================================================

// Emits placeholder value, records position for later patching
Function.X86_MovRsiDataOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(190)   // 0xBE MOV RSI, imm64
        reloc_pos = Emit.code_size
        Emit_QWord(offset)
        Emit_AddDataReloc(reloc_pos, offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, data_offset (with relocation)
Function.X86_MovRaxDataOffset {
    Input: offset: Integer
    Body: {
        // MOV RAX, imm64: REX.W (0x48) + 0xB8 + 8-byte immediate
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(184)   // 0xB8 MOV RAX, imm64
        
        reloc_pos = Emit.code_size
        Emit_QWord(offset)
        Emit_AddDataReloc(reloc_pos, offset)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDI, data_offset (with relocation)
Function.X86_MovRdiDataOffset {
    Input: offset: Integer
    Body: {
        // MOV RDI, imm64: REX.W (0x48) + 0xBF + 8-byte immediate
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(191)   // 0xBF MOV RDI, imm64
        
        reloc_pos = Emit.code_size
        Emit_QWord(offset)
        Emit_AddDataReloc(reloc_pos, offset)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}
// =============================================================================
// LEA RIP-RELATIVE - Load Effective Address with RIP-relative offset
// =============================================================================

// LEA RAX, [RIP + disp32]
Function.X86_LeaRaxRipOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        Emit_Byte(5)     // 0x05 ModR/M: RAX, [RIP+disp32]
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LEA RSI, [RIP + disp32]
Function.X86_LeaRsiRipOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        Emit_Byte(53)    // 0x35 ModR/M: RSI, [RIP+disp32]
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LEA RDI, [RIP + disp32]
Function.X86_LeaRdiRipOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        Emit_Byte(61)    // 0x3D ModR/M: RDI, [RIP+disp32]
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}
