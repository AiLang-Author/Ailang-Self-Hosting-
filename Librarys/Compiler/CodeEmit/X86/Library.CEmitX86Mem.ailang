// Library.CEmitX86Mem.ailang
// x86-64 memory load/store instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Mem.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// LOCAL VARIABLE ACCESS (RBP-relative)
// =============================================================================

// MOV RAX, [RBP + offset] - Load local variable
Function.X86_MovRaxRbpOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            // [RBP] needs disp8=0 due to RBP encoding
            Emit_Byte(69)    // 0x45 ModR/M: mod=01, reg=RAX, r/m=RBP
            Emit_Byte(0)
        } ElseBlock: {
            IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(69)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(133)   // 0x85 mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RBP + offset], RAX - Store local variable
Function.X86_MovRbpOffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(69)
            Emit_Byte(0)
        } ElseBlock: {
            IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(69)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(133)
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// POOL VARIABLE ACCESS (R15-relative)
// R15 = pool table base address
// =============================================================================

// MOV RAX, [R15 + offset] - Load pool variable
Function.X86_MovRaxR15Offset {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(139)   // 0x8B MOV
        IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(71)    // mod=01, reg=RAX, r/m=R15
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(135)   // mod=10
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [R15 + offset], RAX - Store pool variable
Function.X86_MovR15OffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(137)   // 0x89 MOV
        IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(71)
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(135)
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// STACK-RELATIVE ACCESS (RSP-relative)
// =============================================================================

// MOV RAX, [RSP + offset]
Function.X86_MovRaxRspOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            // [RSP] needs SIB byte
            Emit_Byte(4)     // ModR/M: mod=00, reg=RAX, r/m=100 (SIB)
            Emit_Byte(36)    // SIB: scale=00, index=RSP, base=RSP
        } ElseBlock: {
            IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(68)    // mod=01
                Emit_Byte(36)    // SIB
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(132)   // mod=10
                Emit_Byte(36)    // SIB
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RSP + offset], RAX
Function.X86_MovRspOffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(4)
            Emit_Byte(36)
        } ElseBlock: {
            IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(68)
                Emit_Byte(36)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(132)
                Emit_Byte(36)
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// INDIRECT ACCESS (through register)
// =============================================================================

// MOV RAX, [RAX] - Load through pointer in RAX
Function.X86_MovRaxDerefRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV
        Emit_Byte(0)     // ModR/M: [RAX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, [RBX]
Function.X86_MovRaxDerefRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(139)
        Emit_Byte(3)     // ModR/M: [RBX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX], RBX - Store RBX to address in RAX
Function.X86_MovDerefRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(24)    // 0x18 ModR/M: [RAX], RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX], RCX
Function.X86_MovDerefRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(137)
        Emit_Byte(8)     // ModR/M: [RAX], RCX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// BYTE ACCESS
// =============================================================================

// MOV AL, [RBX] - Load byte
Function.X86_MovAlDerefRbx {
    Body: {
        Emit_Byte(138)   // 0x8A MOV r8, r/m8
        Emit_Byte(3)     // ModR/M: AL, [RBX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RBX], AL - Store byte
Function.X86_MovDerefRbxAl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(3)     // ModR/M: [RBX], AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV AL, [RAX + RBX] - Load byte with index
Function.X86_MovAlRaxRbx {
    Body: {
        Emit_Byte(138)   // 0x8A MOV r8, r/m8
        Emit_Byte(4)     // ModR/M with SIB
        Emit_Byte(24)    // SIB: RAX + RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX + RBX], CL - Store byte with index
Function.X86_MovRaxRbxCl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(12)    // ModR/M with SIB, CL
        Emit_Byte(24)    // SIB: RAX + RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// LEA - Load Effective Address
// =============================================================================

// LEA RAX, [RBP + offset]
Function.X86_LeaRaxRbpOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        
        IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(69)    // mod=01, reg=RAX, r/m=RBP
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(133)   // mod=10
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LEA RAX, [RIP + disp32] - Load data section address
Function.X86_LoadDataAddress {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        Emit_Byte(5)     // 0x05 ModR/M: RAX, [RIP+disp32]
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// QWORD MEMORY ACCESS
// =============================================================================

// MOV RAX, [RAX + offset]
Function.X86_MovRaxDerefRaxOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(0)     // [RAX]
        } ElseBlock: {
            IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(64)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(128)   // mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX + offset], RBX
Function.X86_MovDerefRaxOffsetRbx {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(24)    // [RAX], RBX
        } ElseBlock: {
            IfCondition And(GreaterOrEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(88)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(152)   // mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}