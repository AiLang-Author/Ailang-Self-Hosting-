// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.





// Library.CEmitX86Mem.ailang
// x86-64 memory load/store instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Mem.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Helpers

// =============================================================================
// LOCAL VARIABLE ACCESS (RBP-relative)
// =============================================================================

// MOV RAX, [RBP + offset] - Load local variable
Function.X86_MovRaxRbpOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            // [RBP] needs disp8=0 due to RBP encoding
            Emit_Byte(69)    // 0x45 ModR/M: mod=01, reg=RAX, r/m=RBP
            Emit_Byte(0)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(69)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(133)   // 0x85 mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RBP + offset], RAX - Store local variable
Function.X86_MovRbpOffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(69)
            Emit_Byte(0)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(69)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(133)
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}



// =============================================================================
// POOL VARIABLE ACCESS (R15-relative)
// R15 = pool table base address
// =============================================================================

// MOV RAX, [R15 + offset] - Load pool variable
Function.X86_MovRaxR15Offset {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(139)   // 0x8B MOV
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(71)    // mod=01, reg=RAX, r/m=R15
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(135)   // mod=10
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [R15 + offset], RAX - Store pool variable
Function.X86_MovR15OffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(137)   // 0x89 MOV
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(71)
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(135)
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// STACK-RELATIVE ACCESS (RSP-relative)
// =============================================================================

// MOV RAX, [RSP + offset]
Function.X86_MovRaxRspOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            // [RSP] needs SIB byte
            Emit_Byte(4)     // ModR/M: mod=00, reg=RAX, r/m=100 (SIB)
            Emit_Byte(36)    // SIB: scale=00, index=RSP, base=RSP
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(68)    // mod=01
                Emit_Byte(36)    // SIB
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(132)   // mod=10
                Emit_Byte(36)    // SIB
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RSP + offset], RAX
Function.X86_MovRspOffsetRax {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(4)
            Emit_Byte(36)
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(68)
                Emit_Byte(36)
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(132)
                Emit_Byte(36)
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// =============================================================================
// INDIRECT ACCESS (through register)
// =============================================================================

// MOV RAX, [RAX] - Load through pointer in RAX
Function.X86_MovRaxDerefRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV
        Emit_Byte(0)     // ModR/M: [RAX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, [RBX]
Function.X86_MovRaxDerefRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(139)
        Emit_Byte(3)     // ModR/M: [RBX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX], RBX - Store RBX to address in RAX
Function.X86_MovDerefRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(24)    // 0x18 ModR/M: [RAX], RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX], RCX
Function.X86_MovDerefRaxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(137)
        Emit_Byte(8)     // ModR/M: [RAX], RCX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// BYTE ACCESS
// =============================================================================

// MOV AL, [RBX] - Load byte
Function.X86_MovAlDerefRbx {
    Body: {
        Emit_Byte(138)   // 0x8A MOV r8, r/m8
        Emit_Byte(3)     // ModR/M: AL, [RBX]
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RBX], AL - Store byte
Function.X86_MovDerefRbxAl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(3)     // ModR/M: [RBX], AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV AL, [RAX + RBX] - Load byte with index
Function.X86_MovAlRaxRbx {
    Body: {
        Emit_Byte(138)   // 0x8A MOV r8, r/m8
        Emit_Byte(4)     // ModR/M with SIB
        Emit_Byte(24)    // SIB: RAX + RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX + RBX], CL - Store byte with index
Function.X86_MovRaxRbxCl {
    Body: {
        Emit_Byte(136)   // 0x88 MOV r/m8, r8
        Emit_Byte(12)    // ModR/M with SIB, CL
        Emit_Byte(24)    // SIB: RAX + RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// LEA - Load Effective Address
// =============================================================================

// LEA RAX, [RBP + offset]
Function.X86_LeaRaxRbpOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        
        IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
            Emit_Byte(69)    // mod=01, reg=RAX, r/m=RBP
            Emit_Byte(offset)
        } ElseBlock: {
            Emit_Byte(133)   // mod=10
            Emit_DWord(offset)
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// DATA ADDRESS LOADING (with relocation tracking)
// =============================================================================

// LEA/MOV for data section address - TRACKS RELOCATION
Function.X86_LoadDataAddress {
    Input: data_offset: Integer
    Body: {
        // Use MOV RAX, imm64 for absolute address
        // This will be patched by Emit_ApplyDataRelocations
        
        Emit_Byte(0x48)   // REX.W
        Emit_Byte(0xB8)   // MOV RAX, imm64
        
        // Record current position for relocation
        Emit_AddDataReloc(Emit.code_size, data_offset)
        
        // Emit placeholder (8 bytes of zeros)
        // These will be patched with the actual address
        Emit_QWord(0)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// Alternative: Load data address into RSI (for syscalls)
Function.X86_LoadDataAddressRsi {
    Input: data_offset: Integer
    Body: {
        // MOV RSI, imm64
        Emit_Byte(0x48)   // REX.W
        Emit_Byte(0xBE)   // MOV RSI, imm64
        
        // Record for relocation
        Emit_AddDataReloc(Emit.code_size, data_offset)
        
        // Placeholder
        Emit_QWord(0)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Load data address into RDI
Function.X86_LoadDataAddressRdi {
    Input: data_offset: Integer
    Body: {
        // MOV RDI, imm64
        Emit_Byte(0x48)   // REX.W
        Emit_Byte(0xBF)   // MOV RDI, imm64
        
        Emit_AddDataReloc(Emit.code_size, data_offset)
        Emit_QWord(0)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// QWORD MEMORY ACCESS
// =============================================================================

// MOV RAX, [RAX + offset]
Function.X86_MovRaxDerefRaxOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(139)   // 0x8B MOV
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(0)     // [RAX]
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(64)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(128)   // mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV [RAX + offset], RBX
Function.X86_MovDerefRaxOffsetRbx {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(137)   // 0x89 MOV
        IfCondition EqualTo(offset, 0) ThenBlock: {
            Emit_Byte(24)    // [RAX], RBX
        } ElseBlock: {
            IfCondition And(GreaterEqual(offset, -128), LessThan(offset, 128)) ThenBlock: {
                Emit_Byte(88)    // mod=01
                Emit_Byte(offset)
            } ElseBlock: {
                Emit_Byte(152)   // mod=10
                Emit_DWord(offset)
            }
        }
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MOV data_offset (with relocation)
// =============================================================================

// Emits placeholder value, records position for later patching
Function.X86_MovRsiDataOffset {
    Input: offset: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(190)   // 0xBE MOV RSI, imm64
        reloc_pos = Emit.code_size
        Emit_QWord(offset)
        Emit_AddDataReloc(reloc_pos, offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RAX, data_offset (with relocation)
Function.X86_MovRaxDataOffset {
    Input: offset: Integer
    Body: {
        // MOV RAX, imm64: REX.W (0x48) + 0xB8 + 8-byte immediate
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(184)   // 0xB8 MOV RAX, imm64
        
        reloc_pos = Emit.code_size
        Emit_QWord(offset)
        Emit_AddDataReloc(reloc_pos, offset)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDI, data_offset (with relocation)
Function.X86_MovRdiDataOffset {
    Input: offset: Integer
    Body: {
        // MOV RDI, imm64: REX.W (0x48) + 0xBF + 8-byte immediate
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(191)   // 0xBF MOV RDI, imm64
        
        reloc_pos = Emit.code_size
        Emit_QWord(offset)
        Emit_AddDataReloc(reloc_pos, offset)
        
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}