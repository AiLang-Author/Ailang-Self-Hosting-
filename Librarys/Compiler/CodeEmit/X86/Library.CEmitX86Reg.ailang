// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.




// Library.CEmitX86Reg.ailang
// x86-64 register move instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Reg.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore



// =============================================================================
// ADD TO: Library.CEmitX86Reg.ailang
// Section: XOR reg, reg - Zero a register efficiently
// =============================================================================

// XOR RDI, RDI
Function.X86_XorRdiRdi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(255)   // 0xFF ModR/M: RDI, RDI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RSI, RSI
Function.X86_XorRsiRsi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(246)   // 0xF6 ModR/M: RSI, RSI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R8, R8
Function.X86_XorR8R8 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(192)   // 0xC0 ModR/M: R8, R8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R9, R9
Function.X86_XorR9R9 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(201)   // 0xC9 ModR/M: R9, R9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R10, R10
Function.X86_XorR10R10 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(210)   // 0xD2 ModR/M: R10, R10
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// ADD TO: Library.CEmitX86Reg.ailang
// Section: MOV reg, reg - After the existing convenience functions
// =============================================================================


// -----------------------------------------------------------------------------
// Frame pointer setup/teardown
// -----------------------------------------------------------------------------

// MOV RBP, RSP - set up frame pointer
Function.X86_MovRbpRsp {
    Body: {
        // 48 89 E5 = REX.W MOV RBP, RSP
        Emit_Byte(72)   // 0x48 REX.W
        Emit_Byte(137)  // 0x89 MOV r/m64, r64
        Emit_Byte(229)  // 0xE5 ModRM: mod=11, reg=RSP(4), r/m=RBP(5)
    }
}

// MOV RSP, RBP - restore stack pointer
Function.X86_MovRspRbp {
    Body: {
        // 48 89 EC = REX.W MOV RSP, RBP
        Emit_Byte(72)   // 0x48 REX.W
        Emit_Byte(137)  // 0x89 MOV r/m64, r64
        Emit_Byte(236)  // 0xEC ModRM: mod=11, reg=RBP(5), r/m=RSP(4)
    }
}

Function.X86_TestR13R13 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WB
        Emit_Byte(133)   // 0x85 TEST
        Emit_Byte(237)   // 0xED ModR/M: R13, R13
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// X86_ImulRaxR12 - IMUL RAX, R12
Function.X86_ImulRaxR12 {
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(15)    // 0x0F
        Emit_Byte(175)   // 0xAF IMUL
        Emit_Byte(196)   // 0xC4 ModR/M: RAX, R12
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// X86_DecR13 - DEC R13
Function.X86_DecR13 {
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(255)   // 0xFF
        Emit_Byte(205)   // 0xCD ModR/M: DEC R13
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// X86_ImulRaxR12 - IMUL RAX, R12
Function.X86_ImulRaxR12 {
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(15)    // 0x0F
        Emit_Byte(175)   // 0xAF IMUL
        Emit_Byte(196)   // 0xC4 ModR/M: RAX, R12
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// X86_DecR13 - DEC R13
Function.X86_DecR13 {
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(255)   // 0xFF
        Emit_Byte(205)   // 0xCD ModR/M: DEC R13
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}



// =============================================================================
// ADD TO Library.CEmitX86Reg.ailang
// R11/RSP moves for stack alignment preservation
// =============================================================================

// PUSH R11
// Encoding: 41 53
Function.X86_PushR11 {
    Body: {
        Emit_Byte(65)    // 0x41 REX.B
        Emit_Byte(83)    // 0x53 PUSH r11 (base opcode 50 + 3)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POP R11
// Encoding: 41 5B
Function.X86_PopR11 {
    Body: {
        Emit_Byte(65)    // 0x41 REX.B
        Emit_Byte(91)    // 0x5B POP r11 (base opcode 58 + 3)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// MOV R11, RSP - Save stack pointer to R11 (caller-saved, safe scratch)
// Encoding: 4C 8B DC
Function.X86_MovR11Rsp {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(139)   // 0x8B MOV r64, r/m64
        Emit_Byte(220)   // 0xDC ModRM: R11, RSP
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RSP, R11 - Restore stack pointer from R11
// Encoding: 4C 89 DC
Function.X86_MovRspR11 {
    Body: {
        Emit_Byte(76)    // 0x4C REX.WR
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        Emit_Byte(220)   // 0xDC ModRM: RSP, R11
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Frame pointer
Function.X86_MovRbpRsp { Body: { Emit_Byte(72) Emit_Byte(137) Emit_Byte(229) } }
Function.X86_MovRspRbp { Body: { Emit_Byte(72) Emit_Byte(137) Emit_Byte(236) } }

// R12 moves
Function.X86_MovR12Rax { Body: { X86_MovRegReg(Reg.R12, Reg.RAX) } }
Function.X86_MovR12Rbx { Body: { X86_MovRegReg(Reg.R12, Reg.RBX) } }
Function.X86_MovR12Rcx { Body: { X86_MovRegReg(Reg.R12, Reg.RCX) } }
Function.X86_MovR12Rdx { Body: { X86_MovRegReg(Reg.R12, Reg.RDX) } }
Function.X86_MovRaxR12 { Body: { X86_MovRegReg(Reg.RAX, Reg.R12) } }
Function.X86_MovRbxR12 { Body: { X86_MovRegReg(Reg.RBX, Reg.R12) } }
Function.X86_MovRcxR12 { Body: { X86_MovRegReg(Reg.RCX, Reg.R12) } }
Function.X86_MovRdxR12 { Body: { X86_MovRegReg(Reg.RDX, Reg.R12) } }

// R13 moves
Function.X86_MovR13Rax { Body: { X86_MovRegReg(Reg.R13, Reg.RAX) } }
Function.X86_MovR13Rbx { Body: { X86_MovRegReg(Reg.R13, Reg.RBX) } }
Function.X86_MovR13Rcx { Body: { X86_MovRegReg(Reg.R13, Reg.RCX) } }
Function.X86_MovR13Rdx { Body: { X86_MovRegReg(Reg.R13, Reg.RDX) } }
Function.X86_MovRaxR13 { Body: { X86_MovRegReg(Reg.RAX, Reg.R13) } }
Function.X86_MovRbxR13 { Body: { X86_MovRegReg(Reg.RBX, Reg.R13) } }
Function.X86_MovRcxR13 { Body: { X86_MovRegReg(Reg.RCX, Reg.R13) } }
Function.X86_MovRdxR13 { Body: { X86_MovRegReg(Reg.RDX, Reg.R13) } }

// R14 moves
Function.X86_MovR14Rax { Body: { X86_MovRegReg(Reg.R14, Reg.RAX) } }
Function.X86_MovR14Rbx { Body: { X86_MovRegReg(Reg.R14, Reg.RBX) } }
Function.X86_MovR14Rcx { Body: { X86_MovRegReg(Reg.R14, Reg.RCX) } }
Function.X86_MovRaxR14 { Body: { X86_MovRegReg(Reg.RAX, Reg.R14) } }
Function.X86_MovRbxR14 { Body: { X86_MovRegReg(Reg.RBX, Reg.R14) } }
Function.X86_MovRcxR14 { Body: { X86_MovRegReg(Reg.RCX, Reg.R14) } }
Function.X86_MovRdxR14 { Body: { X86_MovRegReg(Reg.RDX, Reg.R14) } }


Function.X86_XorR15R15 {
    Body: {
        Emit_Byte(77)
        Emit_Byte(49)
        Emit_Byte(255)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// R15 moves (pool base - careful)
Function.X86_MovR15Rax { Body: { X86_MovRegReg(Reg.R15, Reg.RAX) } }
Function.X86_MovR15Rbx { Body: { X86_MovRegReg(Reg.R15, Reg.RBX) } }
Function.X86_MovRaxR15 { Body: { X86_MovRegReg(Reg.RAX, Reg.R15) } }
Function.X86_MovRbxR15 { Body: { X86_MovRegReg(Reg.RBX, Reg.R15) } }
Function.X86_MovRcxR15 { Body: { X86_MovRegReg(Reg.RCX, Reg.R15) } }
Function.X86_MovRdxR15 { Body: { X86_MovRegReg(Reg.RDX, Reg.R15) } }

// RDI/RSI moves
Function.X86_MovRdiRbx { Body: { X86_MovRegReg(Reg.RDI, Reg.RBX) } }
Function.X86_MovRsiRbx { Body: { X86_MovRegReg(Reg.RSI, Reg.RBX) } }
Function.X86_MovRbxRdi { Body: { X86_MovRegReg(Reg.RBX, Reg.RDI) } }
Function.X86_MovRbxRsi { Body: { X86_MovRegReg(Reg.RBX, Reg.RSI) } }

// =============================================================================
// MOV reg, imm64 - Load immediate into register
// =============================================================================

// MOV RAX, imm64
Function.X86_MovRaxImm64 {
    Input: imm: Integer
    Body: {
        // REX.W + B8+rd (0x48 0xB8) then 8 bytes
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(184)   // 0xB8 MOV RAX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RBX, imm64
Function.X86_MovRbxImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(187)   // 0xBB MOV RBX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RCX, imm64
Function.X86_MovRcxImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(185)   // 0xB9 MOV RCX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDX, imm64
Function.X86_MovRdxImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(186)   // 0xBA MOV RDX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDI, imm64
Function.X86_MovRdiImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(191)   // 0xBF MOV RDI
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RSI, imm64
Function.X86_MovRsiImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(190)   // 0xBE MOV RSI
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R8, imm64
Function.X86_MovR8Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(184)   // 0xB8 MOV R8
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R9, imm64
Function.X86_MovR9Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(185)   // 0xB9 MOV R9
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R10, imm64
Function.X86_MovR10Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(186)   // 0xBA MOV R10
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R11, imm64
Function.X86_MovR11Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(187)   // 0xBB MOV R11
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MOV R12-R15, imm64
// =============================================================================
Function.X86_MovR12Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)
        Emit_Byte(188)
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

Function.X86_MovR13Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)
        Emit_Byte(189)
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

Function.X86_MovR14Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)
        Emit_Byte(190)
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

Function.X86_MovR15Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)
        Emit_Byte(191)
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// GENERIC XOR, TEST, CMP reg, reg
// =============================================================================
Function.X86_XorRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: {
        rex = 72
        IfCondition GreaterEqual(dst, 8) ThenBlock: { rex = BitwiseOr(rex, 1) }
        IfCondition GreaterEqual(src, 8) ThenBlock: { rex = BitwiseOr(rex, 4) }
        Emit_Byte(rex)
        Emit_Byte(49)
        dst_enc = BitwiseAnd(dst, 7)
        src_enc = BitwiseAnd(src, 7)
        modrm = BitwiseOr(192, BitwiseOr(LeftShift(src_enc, 3), dst_enc))
        Emit_Byte(modrm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

Function.X86_TestRegReg {
    Input: reg1: Integer
    Input: reg2: Integer
    Body: {
        rex = 72
        IfCondition GreaterEqual(reg1, 8) ThenBlock: { rex = BitwiseOr(rex, 1) }
        IfCondition GreaterEqual(reg2, 8) ThenBlock: { rex = BitwiseOr(rex, 4) }
        Emit_Byte(rex)
        Emit_Byte(133)
        reg1_enc = BitwiseAnd(reg1, 7)
        reg2_enc = BitwiseAnd(reg2, 7)
        modrm = BitwiseOr(192, BitwiseOr(LeftShift(reg2_enc, 3), reg1_enc))
        Emit_Byte(modrm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

Function.X86_CmpRegReg {
    Input: reg1: Integer
    Input: reg2: Integer
    Body: {
        rex = 72
        IfCondition GreaterEqual(reg1, 8) ThenBlock: { rex = BitwiseOr(rex, 1) }
        IfCondition GreaterEqual(reg2, 8) ThenBlock: { rex = BitwiseOr(rex, 4) }
        Emit_Byte(rex)
        Emit_Byte(57)
        reg1_enc = BitwiseAnd(reg1, 7)
        reg2_enc = BitwiseAnd(reg2, 7)
        modrm = BitwiseOr(192, BitwiseOr(LeftShift(reg2_enc, 3), reg1_enc))
        Emit_Byte(modrm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// =============================================================================
// MOV reg, reg - Register to register moves
// =============================================================================

// General MOV r64, r64
Function.X86_MovRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: {
        // REX.W MOV r/m64, r64 = 48 89 /r
        rex = 72    // 0x48 base REX.W
        src_enc = src
        dst_enc = dst
        
        // Handle R8-R15 for source (REX.R)
        IfCondition GreaterEqual(src, 8) ThenBlock: {
            rex = BitwiseOr(rex, REX.R)
            src_enc = Subtract(src, 8)
        }
        // Handle R8-R15 for destination (REX.B)
        IfCondition GreaterEqual(dst, 8) ThenBlock: {
            rex = BitwiseOr(rex, REX.B)
            dst_enc = Subtract(dst, 8)
        }
        
        Emit_Byte(rex)
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        // ModR/M: mod=11 (direct), reg=src, r/m=dst
        modrm = BitwiseOr(192, BitwiseOr(LeftShift(src_enc, 3), dst_enc))
        Emit_Byte(modrm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Convenience: MOV RAX, RBX
Function.X86_MovRaxRbx { Body: { X86_MovRegReg(Reg.RAX, Reg.RBX) } }
Function.X86_MovRbxRax { Body: { X86_MovRegReg(Reg.RBX, Reg.RAX) } }
Function.X86_MovRcxRax { Body: { X86_MovRegReg(Reg.RCX, Reg.RAX) } }
Function.X86_MovRaxRcx { Body: { X86_MovRegReg(Reg.RAX, Reg.RCX) } }
Function.X86_MovRdxRax { Body: { X86_MovRegReg(Reg.RDX, Reg.RAX) } }
Function.X86_MovRaxRdx { Body: { X86_MovRegReg(Reg.RAX, Reg.RDX) } }
Function.X86_MovRdiRax { Body: { X86_MovRegReg(Reg.RDI, Reg.RAX) } }
Function.X86_MovRsiRax { Body: { X86_MovRegReg(Reg.RSI, Reg.RAX) } }
Function.X86_MovRaxRdi { Body: { X86_MovRegReg(Reg.RAX, Reg.RDI) } }
Function.X86_MovRaxRsi { Body: { X86_MovRegReg(Reg.RAX, Reg.RSI) } }

// =============================================================================
// MOVZX - Zero extend
// =============================================================================

// MOVZX RAX, AL (zero-extend AL to RAX)
Function.X86_MovzxRaxAl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(192)   // 0xC0 ModR/M: RAX, AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// XOR reg, reg - Zero a register efficiently
// =============================================================================

// XOR RAX, RAX (zero RAX)
Function.X86_XorRaxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(192)   // 0xC0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RBX, RBX
Function.X86_XorRbxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(49)
        Emit_Byte(219)   // 0xDB
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RCX, RCX
Function.X86_XorRcxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(49)
        Emit_Byte(201)   // 0xC9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RDX, RDX
Function.X86_XorRdxRdx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(49)
        Emit_Byte(210)   // 0xD2
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// XOR reg, reg - Zero syscall argument registers
// Add these to Library.CEmitX86Reg.ailang after existing XOR functions
// =============================================================================

// XOR RDI, RDI (zero RDI - syscall arg1)
Function.X86_XorRdiRdi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(255)   // 0xFF ModR/M: RDI, RDI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RSI, RSI (zero RSI - syscall arg2)
Function.X86_XorRsiRsi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(246)   // 0xF6 ModR/M: RSI, RSI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R8, R8 (zero R8 - syscall arg5)
Function.X86_XorR8R8 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(192)   // 0xC0 ModR/M: R8, R8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R9, R9 (zero R9 - syscall arg6)
Function.X86_XorR9R9 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(201)   // 0xC9 ModR/M: R9, R9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R10, R10 (zero R10 - syscall arg4)
Function.X86_XorR10R10 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(210)   // 0xD2 ModR/M: R10, R10
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// ARITHMETIC INSTRUCTIONS
// =============================================================================

// ADD RAX, RBX
Function.X86_AddRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(1)     // 0x01 ADD r/m64, r64
        Emit_Byte(216)   // 0xD8 ModR/M: mod=11, reg=RBX, r/m=RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RAX, imm32
Function.X86_AddRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(5)     // 0x05 ADD RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RAX, RBX
Function.X86_SubRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(41)    // 0x29 SUB r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RAX, imm32
Function.X86_SubRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(45)    // 0x2D SUB RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RSP, imm32 (allocate stack)
Function.X86_SubRspImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(129)   // 0x81 SUB r/m64, imm32
        Emit_Byte(236)   // 0xEC ModR/M for RSP
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RSP, imm32 (deallocate stack)
Function.X86_AddRspImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(129)   // 0x81 ADD r/m64, imm32
        Emit_Byte(196)   // 0xC4 ModR/M for RSP
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IMUL RAX, RBX (signed multiply, result in RAX)
Function.X86_ImulRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(175)   // 0xAF IMUL r64, r/m64
        Emit_Byte(195)   // 0xC3 ModR/M: RAX, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CQO - sign extend RAX into RDX:RAX for division
Function.X86_Cqo {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(153)   // 0x99 CQO
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IDIV RBX - signed divide RDX:RAX by RBX, quotient in RAX
Function.X86_IdivRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 IDIV r/m64
        Emit_Byte(251)   // 0xFB ModR/M: /7, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NEG RAX
Function.X86_NegRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 NEG r/m64
        Emit_Byte(216)   // 0xD8 ModR/M: /3, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// COMPARE INSTRUCTIONS
// =============================================================================

// CMP RAX, RBX
Function.X86_CmpRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(57)    // 0x39 CMP r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP RAX, imm32
Function.X86_CmpRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(61)    // 0x3D CMP RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// TEST RAX, RAX
Function.X86_TestRaxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(133)   // 0x85 TEST r/m64, r64
        Emit_Byte(192)   // 0xC0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// SET INSTRUCTIONS (set byte based on flags)
// =============================================================================

// SETE AL (set if equal/zero)
Function.X86_Sete {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(148)   // 0x94 SETE r/m8
        Emit_Byte(192)   // 0xC0 ModR/M: AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETNE AL
Function.X86_Setne {
    Body: {
        Emit_Byte(15)
        Emit_Byte(149)   // 0x95
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETL AL (set if less, signed)
Function.X86_Setl {
    Body: {
        Emit_Byte(15)
        Emit_Byte(156)   // 0x9C
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETLE AL
Function.X86_Setle {
    Body: {
        Emit_Byte(15)
        Emit_Byte(158)   // 0x9E
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETG AL (set if greater, signed)
Function.X86_Setg {
    Body: {
        Emit_Byte(15)
        Emit_Byte(159)   // 0x9F
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETGE AL
Function.X86_Setge {
    Body: {
        Emit_Byte(15)
        Emit_Byte(157)   // 0x9D
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOVZX RAX, AL (zero-extend AL to RAX)
Function.X86_MovzxRaxAl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(192)   // 0xC0 ModR/M: RAX, AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// JUMP INSTRUCTIONS
// =============================================================================

// JMP rel32 to label
Function.X86_Jmp {
    Input: label_id: Integer
    Body: {
        Emit_Byte(233)   // 0xE9 JMP rel32
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)    // Placeholder
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Jcc rel32 to label (conditional jump)
Function.X86_Jcc {
    Input: cc: Integer
    Input: label_id: Integer
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(Add(128, cc))   // 0x80 + cc
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// JE (jump if equal/zero)
Function.X86_Je {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.E, label_id)
    }
}

// JNE (jump if not equal)
Function.X86_Jne {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.NE, label_id)
    }
}

// JL (jump if less, signed)
Function.X86_Jl {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.L, label_id)
    }
}

// JLE (jump if less or equal)
Function.X86_Jle {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.LE, label_id)
    }
}

// JG (jump if greater, signed)
Function.X86_Jg {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.G, label_id)
    }
}

// JGE (jump if greater or equal)
Function.X86_Jge {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.GE, label_id)
    }
}

// =============================================================================
// CALL / RETURN
// =============================================================================

// CALL rel32 to label
Function.X86_Call {
    Input: label_id: Integer
    Body: {
        Emit_Byte(232)   // 0xE8 CALL rel32
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CALL RAX (indirect call)
Function.X86_CallRax {
    Body: {
        Emit_Byte(255)   // 0xFF
        Emit_Byte(208)   // 0xD0 CALL r/m64 (RAX)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// RET
Function.X86_Ret {
    Body: {
        Emit_Byte(195)   // 0xC3
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// STACK OPERATIONS
// =============================================================================

// PUSH RAX
Function.X86_PushRax {
    Body: {
        Emit_Byte(80)    // 0x50
        Emit.stack_depth = Add(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// PUSH RBX
Function.X86_PushRbx {
    Body: {
        Emit_Byte(83)    // 0x53
        Emit.stack_depth = Add(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// PUSH RBP
Function.X86_PushRbp {
    Body: {
        Emit_Byte(85)    // 0x55
        Emit.stack_depth = Add(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POP RAX
Function.X86_PopRax {
    Body: {
        Emit_Byte(88)    // 0x58
        Emit.stack_depth = Subtract(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POP RBX
Function.X86_PopRbx {
    Body: {
        Emit_Byte(91)    // 0x5B
        Emit.stack_depth = Subtract(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POP RBP
Function.X86_PopRbp {
    Body: {
        Emit_Byte(93)    // 0x5D
        Emit.stack_depth = Subtract(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// FUNCTION PROLOGUE / EPILOGUE
// =============================================================================

// Standard function prologue
Function.X86_Prologue {
    Input: stack_size: Integer
    Body: {
        X86_PushRbp()
        X86_MovRegReg(Reg.RBP, Reg.RSP)
        IfCondition GreaterThan(stack_size, 0) ThenBlock: {
            X86_SubRspImm32(stack_size)
        }
    }
}

// Standard function epilogue
Function.X86_Epilogue {
    Body: {
        X86_MovRegReg(Reg.RSP, Reg.RBP)
        X86_PopRbp()
        X86_Ret()
    }
}

// =============================================================================
// MISC INSTRUCTIONS
// =============================================================================

// XOR RAX, RAX (zero RAX)
Function.X86_XorRaxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(192)   // 0xC0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NOP
Function.X86_Nop {
    Body: {
        Emit_Byte(144)   // 0x90
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// =============================================================================
// BITWISE INSTRUCTIONS
// =============================================================================

// AND RAX, RBX
Function.X86_AndRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(33)    // 0x21 AND r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// OR RAX, RBX
Function.X86_OrRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(9)     // 0x09 OR r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RAX, RBX
Function.X86_XorRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NOT RAX
Function.X86_NotRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 NOT r/m64
        Emit_Byte(208)   // 0xD0 ModR/M: /2, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHL RAX, CL (shift left by CL)
Function.X86_ShlRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 SHL r/m64, CL
        Emit_Byte(224)   // 0xE0 ModR/M: /4, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHR RAX, CL (shift right by CL)
Function.X86_ShrRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 SHR r/m64, CL
        Emit_Byte(232)   // 0xE8 ModR/M: /5, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

