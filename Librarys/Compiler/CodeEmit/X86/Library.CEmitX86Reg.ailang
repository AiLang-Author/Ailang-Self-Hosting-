// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CEmitX86Reg.ailang
// x86-64 register move instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Reg.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// MOV reg, imm64 - Load immediate into register
// =============================================================================

// MOV RAX, imm64
Function.X86_MovRaxImm64 {
    Input: imm: Integer
    Body: {
        // REX.W + B8+rd (0x48 0xB8) then 8 bytes
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(184)   // 0xB8 MOV RAX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RBX, imm64
Function.X86_MovRbxImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(187)   // 0xBB MOV RBX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RCX, imm64
Function.X86_MovRcxImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(185)   // 0xB9 MOV RCX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDX, imm64
Function.X86_MovRdxImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(186)   // 0xBA MOV RDX
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RDI, imm64
Function.X86_MovRdiImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(191)   // 0xBF MOV RDI
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV RSI, imm64
Function.X86_MovRsiImm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(190)   // 0xBE MOV RSI
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R8, imm64
Function.X86_MovR8Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(184)   // 0xB8 MOV R8
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R9, imm64
Function.X86_MovR9Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(185)   // 0xB9 MOV R9
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R10, imm64
Function.X86_MovR10Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(186)   // 0xBA MOV R10
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOV R11, imm64
Function.X86_MovR11Imm64 {
    Input: imm: Integer
    Body: {
        Emit_Byte(73)    // 0x49 REX.WB
        Emit_Byte(187)   // 0xBB MOV R11
        Emit_QWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MOV reg, reg - Register to register moves
// =============================================================================

// General MOV r64, r64
Function.X86_MovRegReg {
    Input: dst: Integer
    Input: src: Integer
    Body: {
        // REX.W MOV r/m64, r64 = 48 89 /r
        rex = 72    // 0x48 base REX.W
        src_enc = src
        dst_enc = dst
        
        // Handle R8-R15 for source (REX.R)
        IfCondition GreaterEqual(src, 8) ThenBlock: {
            rex = BitwiseOr(rex, REX.R)
            src_enc = Subtract(src, 8)
        }
        // Handle R8-R15 for destination (REX.B)
        IfCondition GreaterEqual(dst, 8) ThenBlock: {
            rex = BitwiseOr(rex, REX.B)
            dst_enc = Subtract(dst, 8)
        }
        
        Emit_Byte(rex)
        Emit_Byte(137)   // 0x89 MOV r/m64, r64
        // ModR/M: mod=11 (direct), reg=src, r/m=dst
        modrm = BitwiseOr(192, BitwiseOr(LeftShift(src_enc, 3), dst_enc))
        Emit_Byte(modrm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Convenience: MOV RAX, RBX
Function.X86_MovRaxRbx { Body: { X86_MovRegReg(Reg.RAX, Reg.RBX) } }
Function.X86_MovRbxRax { Body: { X86_MovRegReg(Reg.RBX, Reg.RAX) } }
Function.X86_MovRcxRax { Body: { X86_MovRegReg(Reg.RCX, Reg.RAX) } }
Function.X86_MovRaxRcx { Body: { X86_MovRegReg(Reg.RAX, Reg.RCX) } }
Function.X86_MovRdxRax { Body: { X86_MovRegReg(Reg.RDX, Reg.RAX) } }
Function.X86_MovRaxRdx { Body: { X86_MovRegReg(Reg.RAX, Reg.RDX) } }
Function.X86_MovRdiRax { Body: { X86_MovRegReg(Reg.RDI, Reg.RAX) } }
Function.X86_MovRsiRax { Body: { X86_MovRegReg(Reg.RSI, Reg.RAX) } }
Function.X86_MovRaxRdi { Body: { X86_MovRegReg(Reg.RAX, Reg.RDI) } }
Function.X86_MovRaxRsi { Body: { X86_MovRegReg(Reg.RAX, Reg.RSI) } }

// =============================================================================
// MOVZX - Zero extend
// =============================================================================

// MOVZX RAX, AL (zero-extend AL to RAX)
Function.X86_MovzxRaxAl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(192)   // 0xC0 ModR/M: RAX, AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// XOR reg, reg - Zero a register efficiently
// =============================================================================

// XOR RAX, RAX (zero RAX)
Function.X86_XorRaxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(192)   // 0xC0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RBX, RBX
Function.X86_XorRbxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(49)
        Emit_Byte(219)   // 0xDB
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RCX, RCX
Function.X86_XorRcxRcx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(49)
        Emit_Byte(201)   // 0xC9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RDX, RDX
Function.X86_XorRdxRdx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(49)
        Emit_Byte(210)   // 0xD2
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// XOR reg, reg - Zero syscall argument registers
// Add these to Library.CEmitX86Reg.ailang after existing XOR functions
// =============================================================================

// XOR RDI, RDI (zero RDI - syscall arg1)
Function.X86_XorRdiRdi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(255)   // 0xFF ModR/M: RDI, RDI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RSI, RSI (zero RSI - syscall arg2)
Function.X86_XorRsiRsi {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(246)   // 0xF6 ModR/M: RSI, RSI
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R8, R8 (zero R8 - syscall arg5)
Function.X86_XorR8R8 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(192)   // 0xC0 ModR/M: R8, R8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R9, R9 (zero R9 - syscall arg6)
Function.X86_XorR9R9 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(201)   // 0xC9 ModR/M: R9, R9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR R10, R10 (zero R10 - syscall arg4)
Function.X86_XorR10R10 {
    Body: {
        Emit_Byte(77)    // 0x4D REX.WRB
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(210)   // 0xD2 ModR/M: R10, R10
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// ARITHMETIC INSTRUCTIONS
// =============================================================================

// ADD RAX, RBX
Function.X86_AddRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(1)     // 0x01 ADD r/m64, r64
        Emit_Byte(216)   // 0xD8 ModR/M: mod=11, reg=RBX, r/m=RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RAX, imm32
Function.X86_AddRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(5)     // 0x05 ADD RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RAX, RBX
Function.X86_SubRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(41)    // 0x29 SUB r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RAX, imm32
Function.X86_SubRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(45)    // 0x2D SUB RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SUB RSP, imm32 (allocate stack)
Function.X86_SubRspImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(129)   // 0x81 SUB r/m64, imm32
        Emit_Byte(236)   // 0xEC ModR/M for RSP
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// ADD RSP, imm32 (deallocate stack)
Function.X86_AddRspImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(129)   // 0x81 ADD r/m64, imm32
        Emit_Byte(196)   // 0xC4 ModR/M for RSP
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IMUL RAX, RBX (signed multiply, result in RAX)
Function.X86_ImulRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(175)   // 0xAF IMUL r64, r/m64
        Emit_Byte(195)   // 0xC3 ModR/M: RAX, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CQO - sign extend RAX into RDX:RAX for division
Function.X86_Cqo {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(153)   // 0x99 CQO
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// IDIV RBX - signed divide RDX:RAX by RBX, quotient in RAX
Function.X86_IdivRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 IDIV r/m64
        Emit_Byte(251)   // 0xFB ModR/M: /7, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NEG RAX
Function.X86_NegRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 NEG r/m64
        Emit_Byte(216)   // 0xD8 ModR/M: /3, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// COMPARE INSTRUCTIONS
// =============================================================================

// CMP RAX, RBX
Function.X86_CmpRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(57)    // 0x39 CMP r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMP RAX, imm32
Function.X86_CmpRaxImm32 {
    Input: imm: Integer
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(61)    // 0x3D CMP RAX, imm32
        Emit_DWord(imm)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// TEST RAX, RAX
Function.X86_TestRaxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(133)   // 0x85 TEST r/m64, r64
        Emit_Byte(192)   // 0xC0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// SET INSTRUCTIONS (set byte based on flags)
// =============================================================================

// SETE AL (set if equal/zero)
Function.X86_Sete {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(148)   // 0x94 SETE r/m8
        Emit_Byte(192)   // 0xC0 ModR/M: AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETNE AL
Function.X86_Setne {
    Body: {
        Emit_Byte(15)
        Emit_Byte(149)   // 0x95
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETL AL (set if less, signed)
Function.X86_Setl {
    Body: {
        Emit_Byte(15)
        Emit_Byte(156)   // 0x9C
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETLE AL
Function.X86_Setle {
    Body: {
        Emit_Byte(15)
        Emit_Byte(158)   // 0x9E
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETG AL (set if greater, signed)
Function.X86_Setg {
    Body: {
        Emit_Byte(15)
        Emit_Byte(159)   // 0x9F
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SETGE AL
Function.X86_Setge {
    Body: {
        Emit_Byte(15)
        Emit_Byte(157)   // 0x9D
        Emit_Byte(192)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// MOVZX RAX, AL (zero-extend AL to RAX)
Function.X86_MovzxRaxAl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(182)   // 0xB6 MOVZX r64, r/m8
        Emit_Byte(192)   // 0xC0 ModR/M: RAX, AL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// JUMP INSTRUCTIONS
// =============================================================================

// JMP rel32 to label
Function.X86_Jmp {
    Input: label_id: Integer
    Body: {
        Emit_Byte(233)   // 0xE9 JMP rel32
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)    // Placeholder
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Jcc rel32 to label (conditional jump)
Function.X86_Jcc {
    Input: cc: Integer
    Input: label_id: Integer
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(Add(128, cc))   // 0x80 + cc
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// JE (jump if equal/zero)
Function.X86_Je {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.E, label_id)
    }
}

// JNE (jump if not equal)
Function.X86_Jne {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.NE, label_id)
    }
}

// JL (jump if less, signed)
Function.X86_Jl {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.L, label_id)
    }
}

// JLE (jump if less or equal)
Function.X86_Jle {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.LE, label_id)
    }
}

// JG (jump if greater, signed)
Function.X86_Jg {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.G, label_id)
    }
}

// JGE (jump if greater or equal)
Function.X86_Jge {
    Input: label_id: Integer
    Body: {
        X86_Jcc(CC.GE, label_id)
    }
}

// =============================================================================
// CALL / RETURN
// =============================================================================

// CALL rel32 to label
Function.X86_Call {
    Input: label_id: Integer
    Body: {
        Emit_Byte(232)   // 0xE8 CALL rel32
        Emit_AddFixup(label_id, FixupType.REL32)
        Emit_DWord(0)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CALL RAX (indirect call)
Function.X86_CallRax {
    Body: {
        Emit_Byte(255)   // 0xFF
        Emit_Byte(208)   // 0xD0 CALL r/m64 (RAX)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// RET
Function.X86_Ret {
    Body: {
        Emit_Byte(195)   // 0xC3
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// STACK OPERATIONS
// =============================================================================

// PUSH RAX
Function.X86_PushRax {
    Body: {
        Emit_Byte(80)    // 0x50
        Emit.stack_depth = Add(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// PUSH RBX
Function.X86_PushRbx {
    Body: {
        Emit_Byte(83)    // 0x53
        Emit.stack_depth = Add(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// PUSH RBP
Function.X86_PushRbp {
    Body: {
        Emit_Byte(85)    // 0x55
        Emit.stack_depth = Add(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POP RAX
Function.X86_PopRax {
    Body: {
        Emit_Byte(88)    // 0x58
        Emit.stack_depth = Subtract(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POP RBX
Function.X86_PopRbx {
    Body: {
        Emit_Byte(91)    // 0x5B
        Emit.stack_depth = Subtract(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POP RBP
Function.X86_PopRbp {
    Body: {
        Emit_Byte(93)    // 0x5D
        Emit.stack_depth = Subtract(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// FUNCTION PROLOGUE / EPILOGUE
// =============================================================================

// Standard function prologue
Function.X86_Prologue {
    Input: stack_size: Integer
    Body: {
        X86_PushRbp()
        X86_MovRegReg(Reg.RBP, Reg.RSP)
        IfCondition GreaterThan(stack_size, 0) ThenBlock: {
            X86_SubRspImm32(stack_size)
        }
    }
}

// Standard function epilogue
Function.X86_Epilogue {
    Body: {
        X86_MovRegReg(Reg.RSP, Reg.RBP)
        X86_PopRbp()
        X86_Ret()
    }
}

// =============================================================================
// MISC INSTRUCTIONS
// =============================================================================

// XOR RAX, RAX (zero RAX)
Function.X86_XorRaxRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(192)   // 0xC0
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NOP
Function.X86_Nop {
    Body: {
        Emit_Byte(144)   // 0x90
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}


// =============================================================================
// BITWISE INSTRUCTIONS
// =============================================================================

// AND RAX, RBX
Function.X86_AndRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(33)    // 0x21 AND r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// OR RAX, RBX
Function.X86_OrRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(9)     // 0x09 OR r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// XOR RAX, RBX
Function.X86_XorRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(49)    // 0x31 XOR r/m64, r64
        Emit_Byte(216)   // 0xD8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// NOT RAX
Function.X86_NotRax {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(247)   // 0xF7 NOT r/m64
        Emit_Byte(208)   // 0xD0 ModR/M: /2, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHL RAX, CL (shift left by CL)
Function.X86_ShlRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 SHL r/m64, CL
        Emit_Byte(224)   // 0xE0 ModR/M: /4, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SHR RAX, CL (shift right by CL)
Function.X86_ShrRaxCl {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(211)   // 0xD3 SHR r/m64, CL
        Emit_Byte(232)   // 0xE8 ModR/M: /5, RAX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// DATA ADDRESS LOADING
// =============================================================================

// LEA RAX, [RIP + offset] - load data section address
Function.X86_LoadDataAddress {
    Input: offset: Integer
    Body: {
        // LEA RAX, [RIP + disp32]
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(141)   // 0x8D LEA
        Emit_Byte(5)     // 0x05 ModR/M: RAX, [RIP+disp32]
        // The offset here will need to be fixed up based on final layout
        // For now we emit the data section offset directly
        Emit_DWord(offset)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}