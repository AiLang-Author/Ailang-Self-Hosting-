// Library.CEmitX86Sys.ailang
// x86-64 system call and miscellaneous instructions
// Location: Librarys/Compiler/CodeEmit/X86/Library.CEmitX86Sys.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg

// =============================================================================
// SYSCALL
// =============================================================================

// SYSCALL - invoke system call
// RAX = syscall number, RDI/RSI/RDX/R10/R8/R9 = args
// Returns result in RAX
Function.X86_Syscall {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(5)     // 0x05 SYSCALL
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// SYSCALL WRAPPERS
// These set up registers and invoke syscall
// =============================================================================

// sys_exit(code) - syscall 60
Function.X86_SysExit {
    Input: code: Integer
    Body: {
        X86_MovRaxImm64(Syscall.EXIT)
        X86_MovRdiImm64(code)
        X86_Syscall()
    }
}

// sys_write(fd, buf, len) - syscall 1
// fd in RDI, buf in RSI, len in RDX already set by caller
Function.X86_SysWrite {
    Body: {
        X86_MovRaxImm64(Syscall.WRITE)
        X86_Syscall()
    }
}

// sys_read(fd, buf, len) - syscall 0
Function.X86_SysRead {
    Body: {
        X86_MovRaxImm64(Syscall.READ)
        X86_Syscall()
    }
}

// sys_brk(addr) - syscall 12
// addr in RDI
Function.X86_SysBrk {
    Body: {
        X86_MovRaxImm64(Syscall.BRK)
        X86_Syscall()
    }
}

// sys_mmap(addr, len, prot, flags, fd, offset) - syscall 9
Function.X86_SysMmap {
    Body: {
        X86_MovRaxImm64(Syscall.MMAP)
        X86_Syscall()
    }
}

// sys_munmap(addr, len) - syscall 11
Function.X86_SysMunmap {
    Body: {
        X86_MovRaxImm64(Syscall.MUNMAP)
        X86_Syscall()
    }
}

// =============================================================================
// NOP / PADDING
// =============================================================================

// NOP - single byte no-op
Function.X86_Nop {
    Body: {
        Emit_Byte(144)   // 0x90
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Multi-byte NOP (for alignment)
Function.X86_Nop2 {
    Body: {
        Emit_Byte(102)   // 0x66
        Emit_Byte(144)   // 0x90
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

Function.X86_Nop3 {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(31)    // 0x1F
        Emit_Byte(0)     // 0x00
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// Emit n bytes of padding
Function.X86_NopN {
    Input: n: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, n) {
            X86_Nop()
            i = Add(i, 1)
        }
    }
}

// Align code to boundary
Function.X86_AlignCode {
    Input: alignment: Integer
    Body: {
        current = Emit.code_size
        remainder = Modulo(current, alignment)
        IfCondition NotEqual(remainder, 0) ThenBlock: {
            padding = Subtract(alignment, remainder)
            X86_NopN(padding)
        }
    }
}

// =============================================================================
// INTERRUPT / DEBUG
// =============================================================================

// INT3 - breakpoint trap
Function.X86_Int3 {
    Body: {
        Emit_Byte(204)   // 0xCC
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// INT n - software interrupt
Function.X86_Int {
    Input: n: Integer
    Body: {
        Emit_Byte(205)   // 0xCD
        Emit_Byte(n)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// UD2 - undefined instruction (trap)
Function.X86_Ud2 {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(11)    // 0x0B UD2
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// FLAGS MANIPULATION
// =============================================================================

// CLC - clear carry flag
Function.X86_Clc {
    Body: {
        Emit_Byte(248)   // 0xF8
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// STC - set carry flag
Function.X86_Stc {
    Body: {
        Emit_Byte(249)   // 0xF9
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMC - complement carry flag
Function.X86_Cmc {
    Body: {
        Emit_Byte(245)   // 0xF5
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CLD - clear direction flag
Function.X86_Cld {
    Body: {
        Emit_Byte(252)   // 0xFC
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// STD - set direction flag
Function.X86_Std {
    Body: {
        Emit_Byte(253)   // 0xFD
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LAHF - load AH from flags
Function.X86_Lahf {
    Body: {
        Emit_Byte(159)   // 0x9F
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SAHF - store AH to flags
Function.X86_Sahf {
    Body: {
        Emit_Byte(158)   // 0x9E
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// PUSHFQ - push flags to stack
Function.X86_Pushfq {
    Body: {
        Emit_Byte(156)   // 0x9C
        Emit.stack_depth = Add(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// POPFQ - pop flags from stack
Function.X86_Popfq {
    Body: {
        Emit_Byte(157)   // 0x9D
        Emit.stack_depth = Subtract(Emit.stack_depth, 8)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// CONDITIONAL MOVE (CMOVcc)
// =============================================================================

// CMOVE RAX, RBX (move if equal)
Function.X86_CmoveRaxRbx {
    Body: {
        Emit_Byte(72)    // 0x48 REX.W
        Emit_Byte(15)    // 0x0F
        Emit_Byte(68)    // 0x44 CMOVE
        Emit_Byte(195)   // 0xC3 ModR/M: RAX, RBX
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMOVNE RAX, RBX (move if not equal)
Function.X86_CmovneRaxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(15)
        Emit_Byte(69)    // 0x45 CMOVNE
        Emit_Byte(195)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMOVL RAX, RBX (move if less, signed)
Function.X86_CmovlRaxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(15)
        Emit_Byte(76)    // 0x4C CMOVL
        Emit_Byte(195)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// CMOVG RAX, RBX (move if greater, signed)
Function.X86_CmovgRaxRbx {
    Body: {
        Emit_Byte(72)
        Emit_Byte(15)
        Emit_Byte(79)    // 0x4F CMOVG
        Emit_Byte(195)
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// CPUID / RDTSC (for debugging/profiling)
// =============================================================================

// CPUID - CPU identification
Function.X86_Cpuid {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(162)   // 0xA2 CPUID
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// RDTSC - read timestamp counter (result in EDX:EAX)
Function.X86_Rdtsc {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(49)    // 0x31 RDTSC
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// RDTSCP - read timestamp counter and processor ID
Function.X86_Rdtscp {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(1)     // 0x01
        Emit_Byte(249)   // 0xF9 RDTSCP
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// =============================================================================
// MEMORY FENCE
// =============================================================================

// MFENCE - memory fence
Function.X86_Mfence {
    Body: {
        Emit_Byte(15)    // 0x0F
        Emit_Byte(174)   // 0xAE
        Emit_Byte(240)   // 0xF0 MFENCE
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// LFENCE - load fence
Function.X86_Lfence {
    Body: {
        Emit_Byte(15)
        Emit_Byte(174)
        Emit_Byte(232)   // 0xE8 LFENCE
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}

// SFENCE - store fence
Function.X86_Sfence {
    Body: {
        Emit_Byte(15)
        Emit_Byte(174)
        Emit_Byte(248)   // 0xF8 SFENCE
        Emit.instructions_emitted = Add(Emit.instructions_emitted, 1)
    }
}