// Library.CCompileFile.ailang
// File I/O compilation for the AILang self-hosting compiler
// Stack-based approach - no R12-R15 juggling
// Location: Librarys/Compiler/Compile/Library.CCompileFile.ailang
// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// SPDX-License-Identifier: SCSL-1.0

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch
LibraryImport.Compiler.Compile.CCompileMain

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileFile_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        cmp = StringCompare(func_name, "FileOpen")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFile_Open(node))
        }
        
        cmp = StringCompare(func_name, "FileRead")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFile_Read(node))
        }
        
        cmp = StringCompare(func_name, "FileWrite")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFile_Write(node))
        }
        
        cmp = StringCompare(func_name, "FileClose")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFile_Close(node))
        }
        
        cmp = StringCompare(func_name, "FileSeek")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFile_Seek(node))
        }
        
        cmp = StringCompare(func_name, "FileGetSize")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFile_GetSize(node))
        }
        
        cmp = StringCompare(func_name, "FileExists")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFile_Exists(node))
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// FILE OPEN
// open(path, flags, mode) -> fd
// syscall 2: RDI=path, RSI=flags, RDX=mode
// =============================================================================
Function.CompileFile_Open {
    Input: node: Address
    Output: Integer
    Body: {
        args = AST_GetChildren(node)
        arg_count = XArray.XSize(args)
        
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            Compile_Error("FileOpen requires path argument")
            ReturnValue(0)
        }
        
        // Push args to stack (compile in order, pop in reverse)
        
        // Arg 0: path
        path_node = XArray.XGet(args, 0)
        Compile_Expression(path_node)
        Emit_PushRax()
        
        // Arg 1: flags (default O_RDONLY=0)
        IfCondition GreaterEqual(arg_count, 2) ThenBlock: {
            flags_node = XArray.XGet(args, 1)
            Compile_Expression(flags_node)
        } ElseBlock: {
            Emit_XorRaxRax()
        }
        Emit_PushRax()
        
        // Arg 2: mode (default 0644=420)
        IfCondition GreaterEqual(arg_count, 3) ThenBlock: {
            mode_node = XArray.XGet(args, 2)
            Compile_Expression(mode_node)
        } ElseBlock: {
            Emit_MovRaxImm64(420)
        }
        Emit_PushRax()
        
        // Pop into syscall regs (reverse order)
        Emit_PopRdx()    // mode
        Emit_PopRsi()    // flags
        Emit_PopRdi()    // path
        
        // syscall 2 = open
        Emit_MovRaxImm64(2)
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE READ
// read(fd, buf, count) -> bytes_read
// syscall 0: RDI=fd, RSI=buf, RDX=count
// =============================================================================
Function.CompileFile_Read {
    Input: node: Address
    Output: Integer
    Body: {
        args = AST_GetChildren(node)
        arg_count = XArray.XSize(args)
        
        IfCondition LessThan(arg_count, 3) ThenBlock: {
            Compile_Error("FileRead requires fd, buffer, count")
            ReturnValue(0)
        }
        
        // Compile and push all args
        fd_node = XArray.XGet(args, 0)
        Compile_Expression(fd_node)
        Emit_PushRax()
        
        buf_node = XArray.XGet(args, 1)
        Compile_Expression(buf_node)
        Emit_PushRax()
        
        count_node = XArray.XGet(args, 2)
        Compile_Expression(count_node)
        Emit_PushRax()
        
        // Pop into regs
        Emit_PopRdx()    // count
        Emit_PopRsi()    // buffer
        Emit_PopRdi()    // fd
        
        // syscall 0 = read
        Emit_MovRaxImm64(0)
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE WRITE
// write(fd, buf, count) -> bytes_written
// syscall 1: RDI=fd, RSI=buf, RDX=count
// =============================================================================
Function.CompileFile_Write {
    Input: node: Address
    Output: Integer
    Body: {
        args = AST_GetChildren(node)
        arg_count = XArray.XSize(args)
        
        IfCondition LessThan(arg_count, 3) ThenBlock: {
            Compile_Error("FileWrite requires fd, buffer, count")
            ReturnValue(0)
        }
        
        fd_node = XArray.XGet(args, 0)
        Compile_Expression(fd_node)
        Emit_PushRax()
        
        buf_node = XArray.XGet(args, 1)
        Compile_Expression(buf_node)
        Emit_PushRax()
        
        count_node = XArray.XGet(args, 2)
        Compile_Expression(count_node)
        Emit_PushRax()
        
        Emit_PopRdx()
        Emit_PopRsi()
        Emit_PopRdi()
        
        // syscall 1 = write
        Emit_MovRaxImm64(1)
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE CLOSE
// close(fd) -> result
// syscall 3: RDI=fd
// =============================================================================
Function.CompileFile_Close {
    Input: node: Address
    Output: Integer
    Body: {
        args = AST_GetChildren(node)
        arg_count = XArray.XSize(args)
        
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            Compile_Error("FileClose requires fd")
            ReturnValue(0)
        }
        
        fd_node = XArray.XGet(args, 0)
        Compile_Expression(fd_node)
        Emit_MovRdiRax()
        
        // syscall 3 = close
        Emit_MovRaxImm64(3)
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE SEEK
// lseek(fd, offset, whence) -> position
// syscall 8: RDI=fd, RSI=offset, RDX=whence
// =============================================================================
Function.CompileFile_Seek {
    Input: node: Address
    Output: Integer
    Body: {
        args = AST_GetChildren(node)
        arg_count = XArray.XSize(args)
        
        IfCondition LessThan(arg_count, 3) ThenBlock: {
            Compile_Error("FileSeek requires fd, offset, whence")
            ReturnValue(0)
        }
        
        fd_node = XArray.XGet(args, 0)
        Compile_Expression(fd_node)
        Emit_PushRax()
        
        offset_node = XArray.XGet(args, 1)
        Compile_Expression(offset_node)
        Emit_PushRax()
        
        whence_node = XArray.XGet(args, 2)
        Compile_Expression(whence_node)
        Emit_PushRax()
        
        Emit_PopRdx()    // whence
        Emit_PopRsi()    // offset
        Emit_PopRdi()    // fd
        
        // syscall 8 = lseek
        Emit_MovRaxImm64(8)
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE GET SIZE
// lseek to end, save size, lseek back to start
// Uses stack to preserve fd and size between syscalls
// =============================================================================
Function.CompileFile_GetSize {
    Input: node: Address
    Output: Integer
    Body: {
        args = AST_GetChildren(node)
        arg_count = XArray.XSize(args)
        
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            Compile_Error("FileGetSize requires fd")
            ReturnValue(0)
        }
        
        // Compile fd
        fd_node = XArray.XGet(args, 0)
        Compile_Expression(fd_node)
        Emit_PushRax()           // Stack: [fd]
        
        // lseek(fd, 0, SEEK_END=2)
        Emit_MovRdiRax()         // fd
        Emit_XorRsiRsi()         // offset = 0
        Emit_MovRaxImm64(2)
        Emit_PushRax()
        Emit_PopRdx()            // SEEK_END = 2
        Emit_MovRaxImm64(8)      // lseek syscall
        Emit_SysInstr()
        
        // Save size, restore fd
        Emit_PopRbx()            // fd -> RBX
        Emit_PushRax()           // Stack: [size]
        Emit_PushRbx()           // Stack: [size, fd]
        
        // lseek(fd, 0, SEEK_SET=0) to reset position
        Emit_PushRbx()
        Emit_PopRdi()            // fd -> RDI
        Emit_XorRsiRsi()         // offset = 0
        Emit_XorRdxRdx()         // SEEK_SET = 0
        Emit_MovRaxImm64(8)
        Emit_SysInstr()
        
        // Discard fd, return size
        Emit_PopRbx()            // discard fd
        Emit_PopRax()            // size -> RAX
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE EXISTS
// access(path, F_OK=0) -> 0 if exists
// Returns 1 if exists, 0 if not
// =============================================================================
Function.CompileFile_Exists {
    Input: node: Address
    Output: Integer
    Body: {
        args = AST_GetChildren(node)
        arg_count = XArray.XSize(args)
        
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            Compile_Error("FileExists requires path")
            ReturnValue(0)
        }
        
        exists_label = Emit_CreateLabel()
        done_label = Emit_CreateLabel()
        
        path_node = XArray.XGet(args, 0)
        Compile_Expression(path_node)
        
        // access(path, F_OK=0)
        Emit_MovRdiRax()
        Emit_XorRsiRsi()         // F_OK = 0
        Emit_MovRaxImm64(21)     // access
        Emit_SysInstr()
        
        // RAX == 0 means exists
        Emit_TestRaxRax()
        Emit_Jz(exists_label)
        
        // Doesn't exist -> return 0
        Emit_XorRaxRax()
        Emit_Jmp(done_label)
        
        // Exists -> return 1
        Emit_MarkLabel(exists_label)
        Emit_MovRaxImm64(1)
        
        Emit_MarkLabel(done_label)
        
        ReturnValue(1)
    }
}