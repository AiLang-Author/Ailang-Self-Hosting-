// Library.CCompileMain.ailang
// Main compilation dispatcher for the AILang self-hosting compiler
// Mirrors ailang_compiler.py dispatch mechanism
// Location: Librarys/Compiler/Compile/Library.CCompileMain.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore

// CodeEmit - architecture agnostic
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// CodeEmit - x86-64 target
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys


// =============================================================================
// COMPILER STATE
// =============================================================================
FixedPool.Compile {
    "ast": Initialize=0, CanChange=True
    "functions": Initialize=0, CanChange=True
    "variables": Initialize=0, CanChange=True
    "pools": Initialize=0, CanChange=True
    "current_func": Initialize=0, CanChange=True
    "current_scope": Initialize=0, CanChange=True
    "stack_size": Initialize=0, CanChange=True
    "stack_offset": Initialize=0, CanChange=True
    "label_counter": Initialize=0, CanChange=True
    "loop_stack": Initialize=0, CanChange=True
    "loop_depth": Initialize=0, CanChange=True
    "error": Initialize=0, CanChange=True
    "error_msg": Initialize=0, CanChange=True
    "error_line": Initialize=0, CanChange=True
    "nodes_compiled": Initialize=0, CanChange=True
    "bytes_emitted": Initialize=0, CanChange=True
}

// =============================================================================
// VARIABLE TYPES
// =============================================================================
FixedPool.VarType {
    "LOCAL": Initialize=0
    "PARAM": Initialize=1
    "POOL": Initialize=2
    "GLOBAL": Initialize=3
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Compile_Init {
    Body: {
        Compile.ast = 0
        Compile.functions = XArray.XCreate(256)
        Compile.variables = XArray.XCreate(512)
        Compile.pools = XArray.XCreate(64)
        Compile.current_func = 0
        Compile.current_scope = 0
        Compile.stack_size = 0
        Compile.stack_offset = 0
        Compile.label_counter = 0
        Compile.loop_stack = XArray.XCreate(32)
        Compile.loop_depth = 0
        Compile.error = 0
        Compile.error_msg = 0
        Compile.error_line = 0
        Compile.nodes_compiled = 0
        Compile.bytes_emitted = 0
        
        // Initialize emit layer
        Emit_Init()
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.Compile_Free {
    Body: {
        Emit_Free()
        
        IfCondition NotEqual(Compile.functions, 0) ThenBlock: {
            XArray.XDestroy(Compile.functions)
            Compile.functions = 0
        }
        IfCondition NotEqual(Compile.variables, 0) ThenBlock: {
            XArray.XDestroy(Compile.variables)
            Compile.variables = 0
        }
        IfCondition NotEqual(Compile.pools, 0) ThenBlock: {
            XArray.XDestroy(Compile.pools)
            Compile.pools = 0
        }
        IfCondition NotEqual(Compile.loop_stack, 0) ThenBlock: {
            XArray.XDestroy(Compile.loop_stack)
            Compile.loop_stack = 0
        }
        
        Compile.ast = 0
        Compile.current_func = 0
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================
Function.Compile_Error {
    Input: msg: Address
    Input: line: Integer
    Body: {
        Compile.error = 1
        Compile.error_msg = msg
        Compile.error_line = line
        
        PrintMessage("COMPILE ERROR at line ")
        PrintNumber(line)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

Function.Compile_HasError {
    Output: Integer
    Body: {
        ReturnValue(Compile.error)
    }
}

// =============================================================================
// LABEL MANAGEMENT
// =============================================================================
Function.Compile_NewLabel {
    Output: Integer
    Body: {
        label = Compile.label_counter
        Compile.label_counter = Add(Compile.label_counter, 1)
        ReturnValue(label)
    }
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================
Function.Compile_Program {
    Input: ast: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            Compile_Error("Null AST", 0)
            ReturnValue(0)
        }
        
        Compile.ast = ast
        
        PrintMessage("[COMPILE] Starting code generation...\n")
        
        // Pass 1: Discover declarations (functions, pools, variables)
        PrintMessage("[COMPILE] Pass 1: Discovering declarations...\n")
        Compile_DiscoverDeclarations(ast)
        
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            PrintMessage("[COMPILE] Failed in discovery pass\n")
            ReturnValue(0)
        }
        
        // Pass 2: Generate code
        PrintMessage("[COMPILE] Pass 2: Generating code...\n")
        Compile_GenerateCode(ast)
        
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            PrintMessage("[COMPILE] Failed in code generation pass\n")
            ReturnValue(0)
        }
        
        // Pass 3: Resolve fixups (labels, jumps)
        PrintMessage("[COMPILE] Pass 3: Resolving fixups...\n")
        Emit_ResolveFixups()
        
        PrintMessage("[COMPILE] Code generation complete: ")
        PrintNumber(Compile.nodes_compiled)
        PrintMessage(" nodes, ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// PASS 1: DISCOVER DECLARATIONS
// Registers all functions, pools, and top-level structures before codegen
// =============================================================================
Function.Compile_DiscoverDeclarations {
    Input: ast: Address
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(ast)
        
        // Program - iterate all children
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                child = AST_GetChild(ast, i)
                Compile_DiscoverDeclarations(child)
                i = Add(i, 1)
            }
            ReturnValue(1)
        }
        
        // Function - register with new label
        IfCondition EqualTo(node_type, AST.FUNCTION) ThenBlock: {
            name = AST_GetData1(ast)
            label = Compile_NewLabel()
            Compile_RegisterFunction(name, label)
            ReturnValue(1)
        }
        
        // SubRoutine - register with new label
        IfCondition EqualTo(node_type, AST.SUBROUTINE) ThenBlock: {
            name = AST_GetData1(ast)
            label = Compile_NewLabel()
            Compile_RegisterFunction(name, label)
            ReturnValue(1)
        }
        
        // FixedPool - register pool variables
        IfCondition EqualTo(node_type, AST.POOL_FIXED) ThenBlock: {
            Compile_RegisterPool(ast)
            ReturnValue(1)
        }
        
        // DynamicPool
        IfCondition EqualTo(node_type, AST.POOL_DYNAMIC) ThenBlock: {
            Compile_RegisterPool(ast)
            ReturnValue(1)
        }
        
        // Library imports - no codegen, handled at parse time
        IfCondition EqualTo(node_type, AST.LIBRARY_IMPORT) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// PASS 2: GENERATE CODE
// =============================================================================
Function.Compile_GenerateCode {
    Input: ast: Address
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(ast)
        
        // Program - compile all children
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                    ExitLoop
                }
                child = AST_GetChild(ast, i)
                Compile_Node(child)
                i = Add(i, 1)
            }
            ReturnValue(1)
        }
        
        // Single node
        Compile_Node(ast)
        ReturnValue(1)
    }
}

// =============================================================================
// NODE DISPATCHER
// Routes AST nodes to appropriate compile handlers
// Mirrors _node_dispatch dict in ailang_compiler.py
// =============================================================================
Function.Compile_Node {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(node)
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        
        // ─────────────────────────────────────────────────────────────────
        // Top-Level Declarations
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            ReturnValue(Compile_GenerateCode(node))
        }
        
        IfCondition EqualTo(node_type, AST.FUNCTION) ThenBlock: {
            ReturnValue(CompileFunc_Function(node))
        }
        
        IfCondition EqualTo(node_type, AST.SUBROUTINE) ThenBlock: {
            ReturnValue(CompileFunc_SubRoutine(node))
        }
        
        IfCondition EqualTo(node_type, AST.POOL_FIXED) ThenBlock: {
            // Pool data already registered in pass 1
            ReturnValue(1)
        }
        
        IfCondition EqualTo(node_type, AST.POOL_DYNAMIC) ThenBlock: {
            ReturnValue(1)
        }
        
        IfCondition EqualTo(node_type, AST.LIBRARY_IMPORT) ThenBlock: {
            // Imports handled at parse time
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Statements
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.BLOCK) ThenBlock: {
            ReturnValue(CompileStmt_Block(node))
        }
        
        IfCondition EqualTo(node_type, AST.BODY) ThenBlock: {
            ReturnValue(CompileStmt_Block(node))
        }
        
        IfCondition EqualTo(node_type, AST.ASSIGNMENT) ThenBlock: {
            ReturnValue(CompileStmt_Assignment(node))
        }
        
        IfCondition EqualTo(node_type, AST.IF) ThenBlock: {
            ReturnValue(CompileStmt_If(node))
        }
        
        IfCondition EqualTo(node_type, AST.WHILE) ThenBlock: {
            ReturnValue(CompileStmt_While(node))
        }
        
        IfCondition EqualTo(node_type, AST.RETURN) ThenBlock: {
            ReturnValue(CompileStmt_Return(node))
        }
        
        IfCondition EqualTo(node_type, AST.EXIT_LOOP) ThenBlock: {
            ReturnValue(CompileStmt_Break(node))
        }
        
        IfCondition EqualTo(node_type, AST.CONTINUE_LOOP) ThenBlock: {
            ReturnValue(CompileStmt_Continue(node))
        }
        
        IfCondition EqualTo(node_type, AST.TRY) ThenBlock: {
            ReturnValue(CompileStmt_Try(node))
        }
        
        IfCondition EqualTo(node_type, AST.FOR_EVERY) ThenBlock: {
            ReturnValue(CompileStmt_ForEvery(node))
        }
        
        IfCondition EqualTo(node_type, AST.FORK) ThenBlock: {
            ReturnValue(CompileStmt_Fork(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Expressions (when used as statements)
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            ReturnValue(Compile_FunctionCall(node))
        }
        
        IfCondition EqualTo(node_type, AST.PRINT) ThenBlock: {
            ReturnValue(CompileIO_Print(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Literals (when used as standalone statements - rare but valid)
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
            ReturnValue(Compile_Expression(node))
        }
        
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            ReturnValue(Compile_Expression(node))
        }
        
        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
            ReturnValue(Compile_Expression(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Unknown - warning and continue
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("[COMPILE] WARNING: Unknown node type ")
        PrintNumber(node_type)
        PrintMessage("\n")
        ReturnValue(0)
    }
}

// =============================================================================
// FUNCTION CALL DISPATCHER
// Tries each module until one handles the call
// Mirrors compile_function_call in ailang_compiler.py
// =============================================================================
Function.Compile_FunctionCall {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            Compile_Error("Function call with null name", 0)
            ReturnValue(0)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Try each module in order - first match wins
        // Each module's TryCompile returns 1 if handled, 0 to try next
        // ─────────────────────────────────────────────────────────────────
        
        // Arithmetic: Add, Subtract, Multiply, Divide, Modulo, Negate
        result = CompileArith_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Comparison: EqualTo, NotEqual, LessThan, GreaterThan, etc.
        result = CompileCompare_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Logical: And, Or, Not
        result = CompileLogic_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Bitwise: BitwiseAnd, BitwiseOr, BitwiseXor, BitwiseNot, LeftShift, RightShift
        result = CompileBitwise_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // I/O: PrintMessage, PrintNumber, PrintChar, ReadInput
        result = CompileIO_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Strings: StringLength, StringConcat, StringCompare, etc.
        result = CompileString_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Memory: Allocate, Deallocate, StoreValue, Dereference, etc.
        result = CompileMem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Arrays: ArrayCreate, ArrayGet, ArraySet, ArrayLength, ArrayDestroy
        result = CompileArray_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // XArrays (dynamic arrays)
        result = CompileXArray_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // System: SystemCall, Exit, etc.
        result = CompileSystem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // User-defined function call
        // ─────────────────────────────────────────────────────────────────
        result = CompileFunc_UserCall(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Unknown function
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("[COMPILE] ERROR: Unknown function: ")
        PrintMessage(func_name)
        PrintMessage("\n")
        Compile_Error("Unknown function", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// EXPRESSION COMPILER
// Compiles any expression, leaving result in RAX
// =============================================================================
Function.Compile_Expression {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(node)
        
        // ─────────────────────────────────────────────────────────────────
        // Literals
        // ─────────────────────────────────────────────────────────────────
        
        // Number literal -> MOV RAX, value
        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
            value = AST_GetData1(node)
            X86_MovRaxImm64(value)
            ReturnValue(1)
        }
        
        // String literal -> load data section address
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            str_ptr = AST_GetData1(node)
            offset = Emit_AddString(str_ptr)
            X86_LoadDataAddress(offset)
            ReturnValue(1)
        }
        
        // Boolean literal
        IfCondition EqualTo(node_type, AST.BOOLEAN) ThenBlock: {
            value = AST_GetData1(node)
            X86_MovRaxImm64(value)
            ReturnValue(1)
        }
        
        // Null literal
        IfCondition EqualTo(node_type, AST.NULL) ThenBlock: {
            X86_XorRaxRax()
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Identifier - load variable value
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
            name = AST_GetData1(node)
            ReturnValue(CompileExpr_LoadVariable(name))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Function call - result in RAX
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            ReturnValue(Compile_FunctionCall(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Operators
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.BINARY_OP) ThenBlock: {
            ReturnValue(CompileExpr_BinaryOp(node))
        }
        
        IfCondition EqualTo(node_type, AST.UNARY_OP) ThenBlock: {
            ReturnValue(CompileExpr_UnaryOp(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Member access (Pool.field)
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.MEMBER_ACCESS) ThenBlock: {
            ReturnValue(CompileExpr_MemberAccess(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Index access (array[index])
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.INDEX_ACCESS) ThenBlock: {
            ReturnValue(CompileExpr_IndexAccess(node))
        }
        
        // Unknown expression type
        PrintMessage("[COMPILE] WARNING: Unknown expression type ")
        PrintNumber(node_type)
        PrintMessage("\n")
        ReturnValue(0)
    }
}

// =============================================================================
// REGISTRATION HELPERS
// =============================================================================

Function.Compile_RegisterFunction {
    Input: name: Address
    Input: label: Integer
    Body: {
        // Store in functions array as: {name, label, param_count, stack_size}
        entry = Allocate(32)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), label)
        StoreValue(Add(entry, 16), 0)
        StoreValue(Add(entry, 24), 0)
        XArray.XPush(Compile.functions, entry)
        
        // Also register with emit layer for label resolution
        Emit_RegisterLabel(name, label)
    }
}

Function.Compile_RegisterPool {
    Input: pool_node: Address
    Body: {
        pool_name = AST_GetData1(pool_node)
        
        // Iterate pool members and register each
        count = AST_GetChildCount(pool_node)
        offset = 0
        i = 0
        WhileLoop LessThan(i, count) {
            member = AST_GetChild(pool_node, i)
            IfCondition EqualTo(AST_GetType(member), AST.POOL_MEMBER) ThenBlock: {
                member_name = AST_GetData1(member)
                Compile_RegisterPoolVariable(pool_name, member_name, offset)
                offset = Add(offset, 8)
            }
            i = Add(i, 1)
        }
    }
}

Function.Compile_RegisterPoolVariable {
    Input: pool_name: Address
    Input: var_name: Address
    Input: offset: Integer
    Body: {
        // Store in variables array
        entry = Allocate(32)
        StoreValue(entry, var_name)
        StoreValue(Add(entry, 8), offset)
        StoreValue(Add(entry, 16), VarType.POOL)
        StoreValue(Add(entry, 24), pool_name)
        XArray.XPush(Compile.variables, entry)
    }
}

// =============================================================================
// STATISTICS
// =============================================================================
Function.Compile_PrintStats {
    Body: {
        PrintMessage("[COMPILE STATS]\n")
        PrintMessage("  Nodes compiled: ")
        PrintNumber(Compile.nodes_compiled)
        PrintMessage("\n")
        PrintMessage("  Functions registered: ")
        PrintNumber(XArray.XSize(Compile.functions))
        PrintMessage("\n")
        PrintMessage("  Variables registered: ")
        PrintNumber(XArray.XSize(Compile.variables))
        PrintMessage("\n")
        PrintMessage("  Code size: ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Data size: ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Labels: ")
        PrintNumber(Emit.label_count)
        PrintMessage("\n")
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            PrintMessage("  ERRORS: Yes\n")
        }
    }
}

// =============================================================================
// FORWARD DECLARATIONS / STUBS
// These are implemented in separate module files:
//   - CCompileFunc.ailang     (functions, subroutines, user calls)
//   - CCompileStmt.ailang     (statements: if, while, assignment, etc.)
//   - CCompileExpr.ailang     (expressions, operators, member access)
//   - CCompileArith.ailang    (Add, Subtract, Multiply, Divide, etc.)
//   - CCompileCompare.ailang  (EqualTo, LessThan, GreaterThan, etc.)
//   - CCompileLogic.ailang    (And, Or, Not)
//   - CCompileBitwise.ailang  (BitwiseAnd, BitwiseOr, BitwiseXor, shifts)
//   - CCompileIO.ailang       (PrintMessage, PrintNumber, etc.)
//   - CCompileString.ailang   (String operations)
//   - CCompileMem.ailang      (Allocate, StoreValue, Dereference, etc.)
//   - CCompileArray.ailang    (Array operations)
//   - CCompileXArray.ailang   (XArray operations)
//   - CCompileSystem.ailang   (SystemCall, Exit)
// =============================================================================

// --- Functions module (CCompileFunc.ailang) ---
Function.CompileFunc_Function { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileFunc_SubRoutine { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileFunc_UserCall { Input: node: Address Output: Integer Body: { ReturnValue(0) } }

// --- Statements module (CCompileStmt.ailang) ---
Function.CompileStmt_Block { Input: node: Address Output: Integer Body: { 
    count = AST_GetChildCount(node)
    i = 0
    WhileLoop LessThan(i, count) {
        IfCondition EqualTo(Compile.error, 1) ThenBlock: { ExitLoop }
        child = AST_GetChild(node, i)
        Compile_Node(child)
        i = Add(i, 1)
    }
    ReturnValue(1)
} }
Function.CompileStmt_Assignment { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_If { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_While { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_Return { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_Break { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_Continue { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_Try { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_ForEvery { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileStmt_Fork { Input: node: Address Output: Integer Body: { ReturnValue(0) } }

// --- Expression module (CCompileExpr.ailang) ---
Function.CompileExpr_LoadVariable { Input: name: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileExpr_BinaryOp { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileExpr_UnaryOp { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileExpr_MemberAccess { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileExpr_IndexAccess { Input: node: Address Output: Integer Body: { ReturnValue(0) } }

// --- Module TryCompile dispatchers (returns 1 if handled, 0 if not) ---
Function.CompileArith_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileCompare_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileLogic_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileBitwise_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileIO_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileIO_Print { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileString_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileMem_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileArray_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileXArray_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }
Function.CompileSystem_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }