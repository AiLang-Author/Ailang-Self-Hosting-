// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileMain.ailang
// Main compilation dispatcher for the AILang self-hosting compiler
// Mirrors ailang_compiler.py dispatch mechanism
// Location: Librarys/Compiler/Compile/Library.CCompileMain.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore

// CodeEmit - architecture agnostic
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

LibraryImport.Compiler.Compile.CCompileFile

//Compile - modules each module has a compiler method for each function or primitive

LibraryImport.Compiler.Compile.Modules.CCompileIO
LibraryImport.Compiler.Compile.Modules.CCompileArith
LibraryImport.Compiler.Compile.Modules.CCompileFunc
LibraryImport.Compiler.Compile.Modules.CCompileExpr
LibraryImport.Compiler.Compile.Modules.CCompileStmt
LibraryImport.Compiler.Compile.Modules.CCompileStringCore
LibraryImport.Compiler.Compile.Modules.CCompileCompare
LibraryImport.Compiler.Compile.Modules.CCompileLogic
LibraryImport.Compiler.Compile.Modules.CCompileBitwise
LibraryImport.Compiler.Compile.Modules.CCompileArray    
LibraryImport.Compiler.Compile.Modules.CCompileMem









// =============================================================================
// COMPILER STATE
// =============================================================================
FixedPool.Compile {
    "ast": Initialize=0, CanChange=True
    "functions": Initialize=0, CanChange=True
    "variables": Initialize=0, CanChange=True
    "pools": Initialize=0, CanChange=True
    "current_func": Initialize=0, CanChange=True
    "current_scope": Initialize=0, CanChange=True
    "current_return_label": Initialize=0, CanChange=True
    "stack_size": Initialize=0, CanChange=True
    "stack_offset": Initialize=0, CanChange=True
    "label_counter": Initialize=0, CanChange=True
    "loop_stack": Initialize=0, CanChange=True   
    "loop_depth": Initialize=0, CanChange=True   
    "error": Initialize=0, CanChange=True
    "error_msg": Initialize=0, CanChange=True
    "error_line": Initialize=0, CanChange=True
    "nodes_compiled": Initialize=0, CanChange=True
    "bytes_emitted": Initialize=0, CanChange=True
    "binary_op_depth": Initialize=0, CanChange=True
    "pool_member_count": Initialize=0, CanChange=True
}

// =============================================================================
// VARIABLE TYPES
// =============================================================================
FixedPool.VarType {
    "UNKNOWN": Initialize=-1
    "LOCAL": Initialize=0
    "PARAM": Initialize=1
    "POOL": Initialize=2
    "GLOBAL": Initialize=3
}

FixedPool.VarFlags {
    "NONE": Initialize=0
    "PARAM": Initialize=1
    "LOCAL": Initialize=2
    "GLOBAL": Initialize=4
    "CONST": Initialize=8
}

FixedPool.UnaryOp {
    "NEGATE": Initialize=1
    "NOT": Initialize=2
    "BITNOT": Initialize=3
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Compile_Init {
    Body: {
        Compile.ast = 0
        Compile.functions = XArray.XCreate(256)
        Compile.variables = XArray.XCreate(512)
        Compile.pools = XArray.XCreate(64)
        Compile.current_func = 0
        Compile.current_scope = 0
        Compile.stack_size = 0
        Compile.stack_offset = 0
        Compile.label_counter = 0
        // Initialize loop tracking
        Compile.loop_stack = XArray.XCreate(64)  // 32 nested loops max
        Compile.loop_depth = 0
        Compile.error = 0
        Compile.error_msg = 0
        Compile.error_line = 0
        Compile.nodes_compiled = 0
        Compile.bytes_emitted = 0
        Compile.pool_member_count = 0
        
        
        // Initialize emit layer
        Emit_Init()
         // Initialize scope manager for function compilation
        Scope_Init()
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.Compile_Free {
    Body: {
        // Free scope manager FIRST (before variables array)
        Scope_Free()

        Emit_Free()
        
        IfCondition NotEqual(Compile.functions, 0) ThenBlock: {
            XArray.XDestroy(Compile.functions)
            Compile.functions = 0
        }
        IfCondition NotEqual(Compile.variables, 0) ThenBlock: {
            XArray.XDestroy(Compile.variables)
            Compile.variables = 0
        }
        IfCondition NotEqual(Compile.pools, 0) ThenBlock: {
            XArray.XDestroy(Compile.pools)
            Compile.pools = 0
        }
        IfCondition NotEqual(Compile.loop_stack, 0) ThenBlock: {
            XArray.XDestroy(Compile.loop_stack)
            Compile.loop_stack = 0
        }
        
        Compile.ast = 0
        Compile.current_func = 0
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================
Function.Compile_Error {
    Input: msg: Address
    Input: line: Integer
    Body: {
        Compile.error = 1
        Compile.error_msg = msg
        Compile.error_line = line
        
        PrintMessage("COMPILE ERROR at line ")
        PrintNumber(line)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

Function.Compile_HasError {
    Output: Integer
    Body: {
        ReturnValue(Compile.error)
    }
}

// =============================================================================
// LABEL MANAGEMENT
// =============================================================================
Function.Compile_NewLabel {
    Output: Integer
    Body: {
        label = Emit_CreateLabel()
        ReturnValue(label)
    }
}
// =============================================================================
// MAIN ENTRY POINT
// =============================================================================
Function.Compile_Program {
    Input: ast: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            Compile_Error("Null AST", 0)
            ReturnValue(0)
        }
        
        Compile.ast = ast
        
        PrintMessage("[COMPILE] Starting code generation...\n")
        
        // Pass 1: Discover declarations (functions, pools, variables)
        PrintMessage("[COMPILE] Pass 1: Discovering declarations...\n")
        Compile_DiscoverDeclarations(ast)

        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            PrintMessage("[COMPILE] Failed in discovery pass\n")
            ReturnValue(0)
        }

        // Pass 1.5: Emit pool table initialization (R15)
        Compile_EmitPoolTableInit()
        Compile_EmitPoolInitializers()

        // Pass 2: Generate code
        PrintMessage("[COMPILE] Pass 2: Generating code...\n")
        Compile_GenerateCode(ast)
        
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            PrintMessage("[COMPILE] Failed in code generation pass\n")
            ReturnValue(0)
        }
        
        // Pass 3: Resolve fixups (labels, jumps)
        PrintMessage("[COMPILE] Pass 3: Resolving fixups...\n")
        Emit_ResolveFixups()
        
        PrintMessage("[COMPILE] Code generation complete: ")
        PrintNumber(Compile.nodes_compiled)
        PrintMessage(" nodes, ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// PASS 1: DISCOVER DECLARATIONS
// Registers all functions, pools, and top-level structures before codegen
// =============================================================================
Function.Compile_DiscoverDeclarations {
    Input: ast: Address
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        PrintMessage("[DISCOVER] Called with node type: ")
        PrintNumber(AST_GetType(ast))
        PrintMessage(" AST.POOL_FIXED=")
        PrintNumber(AST.POOL_FIXED)
        PrintMessage(" AST.PROGRAM=")
        PrintNumber(AST.PROGRAM)
        PrintMessage("\n")

        node_type = AST_GetType(ast)
        
        // Program - iterate all children
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                child = AST_GetChild(ast, i)
                Compile_DiscoverDeclarations(child)
                i = Add(i, 1)
            }
            ReturnValue(1)
        }
        
        // Function - register with new label
        IfCondition EqualTo(node_type, AST.FUNCTION) ThenBlock: {
            name = AST_GetData1(ast)
            label = Compile_NewLabel()
            Compile_RegisterFunction(name, label)
            ReturnValue(1)
        }
        
        // SubRoutine - register with new label
        IfCondition EqualTo(node_type, AST.SUBROUTINE) ThenBlock: {
            name = AST_GetData1(ast)
            label = Compile_NewLabel()
            Compile_RegisterFunction(name, label)
            ReturnValue(1)
        }
        
        // FixedPool - register pool variables
        IfCondition EqualTo(node_type, AST.POOL_FIXED) ThenBlock: {
            Compile_RegisterPool(ast)
            ReturnValue(1)
        }
        
        // DynamicPool
        IfCondition EqualTo(node_type, AST.POOL_DYNAMIC) ThenBlock: {
            Compile_RegisterPool(ast)
            ReturnValue(1)
        }
        
        // Library imports - no codegen, handled at parse time
        IfCondition EqualTo(node_type, AST.LIBRARY_IMPORT) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// PASS 2: GENERATE CODE
// =============================================================================
Function.Compile_GenerateCode {
    Input: ast: Address
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(ast)
        
        // Program - compile all children
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                    ExitLoop
                }
                child = AST_GetChild(ast, i)
                Compile_Node(child)
                i = Add(i, 1)
            }
            ReturnValue(1)
        }
        
        // Single node
        Compile_Node(ast)
        ReturnValue(1)
    }
}

// =============================================================================
// NODE DISPATCHER
// Routes AST nodes to appropriate compile handlers
// Mirrors _node_dispatch dict in ailang_compiler.py
// =============================================================================
Function.Compile_Node {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(node)
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        
        // ─────────────────────────────────────────────────────────────────
        // Top-Level Declarations
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            ReturnValue(Compile_GenerateCode(node))
        }
        
        IfCondition EqualTo(node_type, AST.FUNCTION) ThenBlock: {
            ReturnValue(CompileFunc_Function(node))
        }
        
        IfCondition EqualTo(node_type, AST.SUBROUTINE) ThenBlock: {
            ReturnValue(CompileFunc_SubRoutine(node))
        }
        
        IfCondition EqualTo(node_type, AST.POOL_FIXED) ThenBlock: {
            // Pool data already registered in pass 1
            ReturnValue(1)
        }
        
        IfCondition EqualTo(node_type, AST.POOL_DYNAMIC) ThenBlock: {
            ReturnValue(1)
        }
        
        IfCondition EqualTo(node_type, AST.LIBRARY_IMPORT) ThenBlock: {
            // Imports handled at parse time
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Statements
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.BLOCK) ThenBlock: {
            ReturnValue(CompileStmt_Block(node))
        }
        
        IfCondition EqualTo(node_type, AST.BODY) ThenBlock: {
            ReturnValue(CompileStmt_Block(node))
        }
        
        IfCondition EqualTo(node_type, AST.ASSIGNMENT) ThenBlock: {
            ReturnValue(CompileStmt_Assignment(node))
        }
        
        IfCondition EqualTo(node_type, AST.IF) ThenBlock: {
            ReturnValue(CompileStmt_If(node))
        }
        
        IfCondition EqualTo(node_type, AST.WHILE) ThenBlock: {
            ReturnValue(CompileStmt_While(node))
        }
        
        IfCondition EqualTo(node_type, AST.RETURN) ThenBlock: {
            ReturnValue(CompileStmt_Return(node))
        }
        
        IfCondition EqualTo(node_type, AST.EXIT_LOOP) ThenBlock: {
            ReturnValue(CompileStmt_Break(node))
        }
        
        IfCondition EqualTo(node_type, AST.CONTINUE_LOOP) ThenBlock: {
            ReturnValue(CompileStmt_Continue(node))
        }
        
        IfCondition EqualTo(node_type, AST.TRY) ThenBlock: {
            ReturnValue(CompileStmt_Try(node))
        }
        
        IfCondition EqualTo(node_type, AST.FOR_EVERY) ThenBlock: {
            ReturnValue(CompileStmt_ForEvery(node))
        }
        
        IfCondition EqualTo(node_type, AST.SWITCH) ThenBlock: {
            ReturnValue(CompileStmt_Switch(node))
        }

        IfCondition EqualTo(node_type, AST.FORK) ThenBlock: {
            ReturnValue(CompileStmt_Fork(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Expressions (when used as statements)
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            ReturnValue(Compile_FunctionCall(node))
        }
        
    
        // ─────────────────────────────────────────────────────────────────
        // Literals (when used as standalone statements - rare but valid)
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
            ReturnValue(Compile_Expression(node))
        }
        
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            ReturnValue(Compile_Expression(node))
        }
        
        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
            ReturnValue(Compile_Expression(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Functions    
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.RUN_TASK) ThenBlock: {
            ReturnValue(CompileFunc_RunTask(node))
        }


        // ─────────────────────────────────────────────────────────────────
        // Unknown - warning and continue
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("[COMPILE] WARNING: Unknown node type ")
        PrintNumber(node_type)
        PrintMessage("\n")
        ReturnValue(0)
    }
}

// =============================================================================
// FUNCTION CALL DISPATCHER
// Tries each module until one handles the call
// Mirrors compile_function_call in ailang_compiler.py
// =============================================================================
Function.Compile_FunctionCall {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            Compile_Error("Function call with null name", 0)
            ReturnValue(0)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Try each module in order - first match wins
        // Each module's TryCompile returns 1 if handled, 0 to try next
        // ─────────────────────────────────────────────────────────────────
        
        // Arithmetic: Add, Subtract, Multiply, Divide, Modulo, Negate
        result = CompileArith_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Comparison: EqualTo, NotEqual, LessThan, GreaterThan, etc.
        result = CompileCompare_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Logical: And, Or, Not
        result = CompileLogic_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Bitwise: BitwiseAnd, BitwiseOr, BitwiseXor, BitwiseNot, LeftShift, RightShift
        result = CompileBitwise_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // I/O: PrintMessage, PrintNumber, PrintChar, ReadInput
        result = CompileIO_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Strings: StringLength, StringConcat, StringCompare, etc.
        result = CompileString_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Memory: Allocate, Deallocate, StoreValue, Dereference, etc.
        result = CompileMem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Arrays: ArrayCreate, ArrayGet, ArraySet, ArrayLength, ArrayDestroy
        result = CompileArray_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
            
        // System: SystemCall, Exit, etc.
        result = CompileSystem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Functions: RunTask, ReturnValue, user-defined function calls
        result = CompileFunc_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }

        // ─────────────────────────────────────────────────────────────────
        // User-defined function call
        // ─────────────────────────────────────────────────────────────────
        result = CompileFunc_UserCall(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Unknown function
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("[COMPILE] ERROR: Unknown function: ")
        PrintMessage(func_name)
        PrintMessage("\n")
        Compile_Error("Unknown function", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// EXPRESSION COMPILER
// Compiles any expression, leaving result in RAX
// =============================================================================
Function.Compile_Expression {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(node)
        
        // ─────────────────────────────────────────────────────────────────
        // Literals
        // ─────────────────────────────────────────────────────────────────
        
        
        // Number literal -> MOV RAX, value
        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
            value_str = AST_GetData1(node)
            value = StringToNumber(value_str) 
            Emit_MovRaxImm64(value)
            ReturnValue(1)
        }
                
        // String literal -> load data section address
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            str_ptr = AST_GetData1(node)
            offset = Emit_AddString(str_ptr)
            Emit_LoadDataAddress(offset)
            ReturnValue(1)
        }
        
        // Boolean literal
        IfCondition EqualTo(node_type, AST.BOOLEAN) ThenBlock: {
            value = AST_GetData1(node)
            Emit_MovRaxImm64(value)
            ReturnValue(1)
        }
        
        // Null literal
        IfCondition EqualTo(node_type, AST.NULL) ThenBlock: {
            Emit_XorRaxRax()
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Identifier - load variable value
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
            name = AST_GetData1(node)
           ReturnValue(CompileExpr_LoadVariable(name))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Function call - result in RAX
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            ReturnValue(Compile_FunctionCall(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Operators
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.BINARY_OP) ThenBlock: {
            ReturnValue(CompileExpr_BinaryOp(node))
        }
        
        IfCondition EqualTo(node_type, AST.UNARY_OP) ThenBlock: {
            ReturnValue(CompileExpr_UnaryOp(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Member access (Pool.field)
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.MEMBER_ACCESS) ThenBlock: {
            ReturnValue(CompileExpr_MemberAccess(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Index access (array[index])
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.INDEX_ACCESS) ThenBlock: {
            ReturnValue(CompileExpr_IndexAccess(node))
        }
        
        // Unknown expression type
        PrintMessage("[COMPILE] WARNING: Unknown expression type ")
        PrintNumber(node_type)
        PrintMessage("\n")
        ReturnValue(0)
    }
}


// =============================================================================
// StringCompiler Dispatcher
// Compiles strings
// =============================================================================
Function.CompileString_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileStringCore_TryCompile(node))
    }
}


// =============================================================================
// REGISTRATION HELPERS
// =============================================================================

Function.Compile_RegisterFunction {
    Input: name: Address
    Input: label: Integer
    Body: {
        // Store in functions array as: {name, label, param_count, stack_size}
        entry = Allocate(32)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), label)
        StoreValue(Add(entry, 16), 0)
        StoreValue(Add(entry, 24), 0)
        XArray.XPush(Compile.functions, entry)
        
        // Also register with emit layer for label resolution
        Emit_RegisterLabel(name, label)
    }
}



Function.Compile_RegisterPool {
    Input: pool_node: Address
    Body: {
        pool_name = AST_GetData1(pool_node)
        
        PrintMessage("[POOL] Registering pool: ")
        PrintString(pool_name)
        PrintMessage("\n")
        
        // Iterate pool members and register each
        count = AST_GetChildCount(pool_node)
        
        // DEBUG: Show child count
        PrintMessage("[POOL] Child count: ")
        PrintNumber(count)
        PrintMessage("\n")
        
        i = 0
        WhileLoop LessThan(i, count) {
            member = AST_GetChild(pool_node, i)
            member_type = AST_GetType(member)
            
            // DEBUG: Show each child's type
            PrintMessage("[POOL] Child ")
            PrintNumber(i)
            PrintMessage(" type=")
            PrintNumber(member_type)
            PrintMessage(" AST.POOL_MEMBER=")
            PrintNumber(AST.POOL_MEMBER)
            PrintMessage("\n")
            
            IfCondition EqualTo(member_type, AST.POOL_MEMBER) ThenBlock: {
                member_name = AST_GetData1(member)
                // DATA2 is a pointer to a NUMBER node containing the init value
                init_node = AST_GetData2(member)
                init_value = 0
                
                PrintMessage("[POOL-DEBUG] member=")
                PrintString(member_name)
                PrintMessage(" init_node=")
                PrintNumber(init_node)
                
                IfCondition NotEqual(init_node, 0) ThenBlock: {
                    node_type = AST_GetType(init_node)
                    PrintMessage(" node_type=")
                    PrintNumber(node_type)
                    PrintMessage(" AST.NUMBER=")
                    PrintNumber(AST.NUMBER)
                    
                    IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
                        init_str = AST_GetData1(init_node)
                        PrintMessage(" init_str=")
                        PrintString(init_str)
                        init_value = StringToNumber(init_str)
                    }
                }
                PrintMessage("\n")
                
                Compile_RegisterPoolVariable(pool_name, member_name, Compile.pool_member_count, init_value)
                Compile.pool_member_count = Add(Compile.pool_member_count, 1)
            }
            i = Add(i, 1)
        }
    }
}

Function.Compile_RegisterPoolVariable {
    Input: pool_name: Address
    Input: var_name: Address
    Input: index: Integer
    Input: init_value: Integer
    Body: {
        // Build full name: "PoolName.member"
        full_name = StringConcat(pool_name, ".")
        full_name = StringConcat(full_name, var_name)
        
        // Mark index with POOL_MARKER (0x80000000 = 2147483648)
        marked_index = BitwiseOr(index, 2147483648)
        
        // Store in variables array (now 40 bytes to include init_value)
        entry = Allocate(40)
        StoreValue(entry, full_name)
        StoreValue(Add(entry, 8), marked_index)
        StoreValue(Add(entry, 16), VarType.POOL)
        StoreValue(Add(entry, 24), pool_name)
        StoreValue(Add(entry, 32), init_value)
        XArray.XPush(Compile.variables, entry)
        
        PrintMessage("  [POOL] ")
        PrintString(full_name)
        PrintMessage(" index=")
        PrintNumber(index)
        PrintMessage(" init=")
        PrintNumber(init_value)
        PrintMessage("\n")
    }
}


// =============================================================================
// POOL TABLE INIT - Emit mmap at _start to initialize R15
// =============================================================================
Function.Compile_EmitPoolTableInit {
    Body: {
        IfCondition EqualTo(Compile.pool_member_count, 0) ThenBlock: {
            // No pools - zero R15 for safety
            Emit_XorR15R15()
            ReturnValue(0)
        }
        
        PrintMessage("[POOL] Emitting mmap for R15 (")
        PrintNumber(Compile.pool_member_count)
        PrintMessage(" slots)\n")
        
        // mmap(0, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
        Emit_MovRaxImm64(9)
        Emit_XorRdiRdi()
        Emit_MovRsiImm64(4096)
        Emit_MovRdxImm64(3)
        Emit_MovR10Imm64(34)
        Emit_MovR8Imm64(-1)
        Emit_XorR9R9()
        Emit_SysInstr()
        Emit_MovR15Rax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// POOL INITIALIZERS - Emit code to store Initialize= values
// =============================================================================
Function.Compile_EmitPoolInitializers {
    Body: {
        count = XArray.XSize(Compile.variables)
        emitted = 0
        
        i = 0
        WhileLoop LessThan(i, count) {
            entry = XArray.XGet(Compile.variables, i)
            var_type = Dereference(Add(entry, 16))
            
            IfCondition EqualTo(var_type, VarType.POOL) ThenBlock: {
                marked_index = Dereference(Add(entry, 8))
                init_value = Dereference(Add(entry, 32))
                
                // Get actual index (clear high bit)
                index = BitwiseAnd(marked_index, 2147483647)
                pool_offset = Multiply(index, 8)
                
                // Emit: MOV RAX, init_value; MOV [R15+offset], RAX
                PrintMessage("[POOL-EMIT] index=")
                PrintNumber(index)
                PrintMessage(" offset=")
                PrintNumber(pool_offset)
                PrintMessage(" init_value=")
                PrintNumber(init_value)
                PrintMessage("\n")
                Emit_MovRaxImm64(init_value)
                Emit_MovR15OffsetRax(pool_offset)
                emitted = Add(emitted, 1)
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[POOL] Emitted ")
        PrintNumber(emitted)
        PrintMessage(" initializers\n")
    }
}


// =============================================================================
// DEPTH TRACKING FOR REGISTER ALLOCATION
// =============================================================================
Function.Compile_DepthPush {
    Body: {
        Compile.binary_op_depth = Add(Compile.binary_op_depth, 1)
    }
}

Function.Compile_DepthPop {
    Body: {
        IfCondition GreaterThan(Compile.binary_op_depth, 0) ThenBlock: {
            Compile.binary_op_depth = Subtract(Compile.binary_op_depth, 1)
        }
    }
}

Function.Compile_GetDepth {
    Output: Integer
    Body: {
        ReturnValue(Compile.binary_op_depth)
    }
}

Function.Compile_ShouldUseStack {
    Output: Integer
    Body: {
        // Depth 2+ uses stack to avoid R14/R15 collision
        IfCondition GreaterEqual(Compile.binary_op_depth, 2) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// STATISTICS
// =============================================================================
Function.Compile_PrintStats {
    Body: {
        PrintMessage("[COMPILE STATS]\n")
        PrintMessage("  Nodes compiled: ")
        PrintNumber(Compile.nodes_compiled)
        PrintMessage("\n")
        PrintMessage("  Functions registered: ")
        PrintNumber(XArray.XSize(Compile.functions))
        PrintMessage("\n")
        PrintMessage("  Variables registered: ")
        PrintNumber(XArray.XSize(Compile.variables))
        PrintMessage("\n")
        PrintMessage("  Code size: ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Data size: ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Labels: ")
        PrintNumber(Emit.label_count)
        PrintMessage("\n")
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            PrintMessage("  ERRORS: Yes\n")
        }
    }
}

// =============================================================================
// FORWARD DECLARATIONS / STUBS
// These are implemented in separate module files:
//   - CCompileFunc.ailang     (functions, subroutines, user calls)
//   - CCompileStmt.ailang     (statements: if, while, assignment, etc.)
//   - CCompileExpr.ailang     (expressions, operators, member access)
//   - CCompileArith.ailang    (Add, Subtract, Multiply, Divide, etc.)
//   - CCompileCompare.ailang  (EqualTo, LessThan, GreaterThan, etc.)
//   - CCompileLogic.ailang    (And, Or, Not)
//   - CCompileBitwise.ailang  (BitwiseAnd, BitwiseOr, BitwiseXor, shifts)
//   - CCompileIO.ailang       (PrintMessage, PrintNumber, etc.)
//   - CCompileString.ailang   (String operations)
//   - CCompileMem.ailang      (Allocate, StoreValue, Dereference, etc.)
//   - CCompileArray.ailang    (Array operations)
//   - CCompileXArray.ailang   (XArray operations)
//   - CCompileSystem.ailang   (SystemCall, Exit)
// =============================================================================

























Function.CompileSystem_TryCompile { Input: node: Address Output: Integer Body: { ReturnValue(0) } }