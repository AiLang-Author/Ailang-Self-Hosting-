// Library.CCompileArith.ailang
// Arithmetic operations compiler module for the AILang self-hosting compiler
// Mirrors arithmetic_ops.py from the Python implementation
//
// Handles: Add, Subtract, Multiply, Divide, Modulo, Power
// Uses depth-based register allocation: R12 (depth 0), R13 (depth 1), Stack (depth 2+)

LibraryImport.Compiler.Compile.CCompileTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack

// =============================================================================
// DISPATCHER
// Returns 1 if operation was handled, 0 if not our responsibility
// =============================================================================
Function.CompileArith_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        // Get function name from node
        func_name = AST_GetFunctionName(node)
        
        // Check each arithmetic operation
        IfCondition EqualTo(StringCompare(func_name, "Add"), 0) ThenBlock: {
            ReturnValue(CompileArith_Add(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Subtract"), 0) ThenBlock: {
            ReturnValue(CompileArith_Subtract(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Multiply"), 0) ThenBlock: {
            ReturnValue(CompileArith_Multiply(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Divide"), 0) ThenBlock: {
            ReturnValue(CompileArith_Divide(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Modulo"), 0) ThenBlock: {
            ReturnValue(CompileArith_Modulo(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Power"), 0) ThenBlock: {
            ReturnValue(CompileArith_Power(node))
        }
        
        // Not an arithmetic operation
        ReturnValue(0)
    }
}

// =============================================================================
// GENERIC BINARY OPERATION COMPILER
// Handles depth-based register allocation matching Python pattern exactly:
// - Depth 0: Use R12
// - Depth 1: Use R13  
// - Depth 2+: Use stack (to avoid R14/R15 pool register collision)
//
// Operand evaluation order: RIGHT first, then LEFT (matches Python)
// Result ends up in RAX
// =============================================================================
Function.CompileArith_BinaryOp {
    Input: node: Address
    Input: op_type: Integer
    Output: Integer
    Body: {
        // Validate 2 arguments
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("Binary operation requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Get current depth and determine register allocation strategy
        depth = Compile_GetDepth()
        use_stack = Compile_ShouldUseStack()
        
        // Increment depth for nested expression compilation
        Compile_DepthPush()
        
        // Get argument nodes
        arg0 = AST_GetArg(node, 0)
        arg1 = AST_GetArg(node, 1)
        
        IfCondition EqualTo(use_stack, 1) ThenBlock: {
            // Depth 2+: Use stack to avoid R14/R15 collision
            
            // Compile RIGHT operand first
            Compile_Expression(arg1)
            X86_PushRax()
            
            // Compile LEFT operand
            Compile_Expression(arg0)
            
            // Pop RIGHT into RBX
            X86_PopRbx()
        } ElseBlock: {
            // Depth 0-1: Use R12 or R13
            reg = Compile_GetDepthReg()
            
            IfCondition EqualTo(reg, 12) ThenBlock: {
                // Depth 0: Use R12
                X86_PushR12()
                
                // Compile RIGHT operand
                Compile_Expression(arg1)
                X86_MovR12Rax()
                
                // Compile LEFT operand
                Compile_Expression(arg0)
                
                // Move RIGHT from R12 to RBX
                X86_MovRbxR12()
                
                X86_PopR12()
            } ElseBlock: {
                // Depth 1: Use R13
                X86_PushR13()
                
                // Compile RIGHT operand
                Compile_Expression(arg1)
                X86_MovR13Rax()
                
                // Compile LEFT operand
                Compile_Expression(arg0)
                
                // Move RIGHT from R13 to RBX
                X86_MovRbxR13()
                
                X86_PopR13()
            }
        }
        
        // Decrement depth
        Compile_DepthPop()
        
        // Now RAX = LEFT, RBX = RIGHT
        // Emit the actual operation based on op_type
        IfCondition EqualTo(op_type, ArithOp.ADD) ThenBlock: {
            X86_AddRaxRbx()
        }
        IfCondition EqualTo(op_type, ArithOp.SUB) ThenBlock: {
            X86_SubRaxRbx()
        }
        IfCondition EqualTo(op_type, ArithOp.MUL) ThenBlock: {
            X86_ImulRaxRbx()
        }
        IfCondition EqualTo(op_type, ArithOp.DIV) ThenBlock: {
            // Sign extend RAX into RDX:RAX
            X86_Cqo()
            // IDIV RBX: RAX = quotient, RDX = remainder
            X86_IdivRbx()
        }
        IfCondition EqualTo(op_type, ArithOp.MOD) ThenBlock: {
            X86_Cqo()
            X86_IdivRbx()
            // Move remainder to RAX
            X86_MovRaxRdx()
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// OPERATION TYPE CONSTANTS
// =============================================================================
FixedPool.ArithOp {
    "ADD": Initialize=1, CanChange=False
    "SUB": Initialize=2, CanChange=False
    "MUL": Initialize=3, CanChange=False
    "DIV": Initialize=4, CanChange=False
    "MOD": Initialize=5, CanChange=False
}

// =============================================================================
// INDIVIDUAL OPERATION COMPILERS
// =============================================================================

Function.CompileArith_Add {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileArith_BinaryOp(node, ArithOp.ADD))
    }
}

Function.CompileArith_Subtract {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileArith_BinaryOp(node, ArithOp.SUB))
    }
}

Function.CompileArith_Multiply {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileArith_BinaryOp(node, ArithOp.MUL))
    }
}

Function.CompileArith_Divide {
    Input: node: Address
    Output: Integer
    Body: {
        // Basic division - could add optimizations later
        // (power-of-2 shift, magic multiply for constants)
        ReturnValue(CompileArith_BinaryOp(node, ArithOp.DIV))
    }
}

Function.CompileArith_Modulo {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileArith_BinaryOp(node, ArithOp.MOD))
    }
}

// =============================================================================
// POWER OPERATION
// Special case: requires loop, always uses R12/R13 regardless of depth
// =============================================================================
Function.CompileArith_Power {
    Input: node: Address
    Output: Integer
    Body: {
        // Validate 2 arguments
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("Power requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Power is special - always saves and uses R12 for base, R13 for exponent
        X86_PushR12()
        X86_PushR13()
        
        Compile_DepthPush()
        
        arg0 = AST_GetArg(node, 0)
        arg1 = AST_GetArg(node, 1)
        
        // Compile exponent into R13
        Compile_Expression(arg1)
        X86_MovR13Rax()
        
        // Compile base into R12
        Compile_Expression(arg0)
        X86_MovR12Rax()
        
        // Result = 1
        X86_MovRaxImm64(1)
        
        // Create loop labels
        loop_start = Compile_NewLabel()
        loop_end = Compile_NewLabel()
        
        // Loop: while (R13 != 0) { RAX *= R12; R13--; }
        Emit_MarkLabel(loop_start)
        
        // TEST R13, R13
        X86_TestR13R13()
        
        // JZ loop_end
        Emit_JumpToLabel(loop_end, CC.Z)
        
        // IMUL RAX, R12
        X86_ImulRaxR12()
        
        // DEC R13
        X86_DecR13()
        
        // JMP loop_start
        Emit_JumpToLabel(loop_start, CC.ALWAYS)
        
        Emit_MarkLabel(loop_end)
        
        Compile_DepthPop()
        
        X86_PopR13()
        X86_PopR12()
        
        ReturnValue(1)
    }
}

// =============================================================================
// UNARY OPERATIONS
// =============================================================================
Function.CompileArith_Negate {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("Negate requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetArg(node, 0)
        Compile_Expression(arg0)
        X86_NegRax()
        
        ReturnValue(1)
    }
}

Function.CompileArith_Abs {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("Abs requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetArg(node, 0)
        Compile_Expression(arg0)
        
        // Compute absolute value:
        // MOV RBX, RAX
        // SAR RBX, 63  (RBX = -1 if negative, 0 if positive)
        // XOR RAX, RBX
        // SUB RAX, RBX
        X86_MovRbxRax()
        X86_SarRbxImm(63)
        X86_XorRaxRbx()
        X86_SubRaxRbx()
        
        ReturnValue(1)
    }
}