// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileArith.ailang
// Arithmetic operations: Add, Subtract, Multiply, Divide, Modulo, Negate
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileArith.ailang
//
// Pattern: Each operation compiles arguments, then emits x86 instructions.
// Result is always left in RAX.
// 
// References Python: ailang_compiler/modules/arithmetic_ops.py

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack

// =============================================================================
// ARITHMETIC FUNCTION NAMES
// =============================================================================
FixedPool.ArithName {
    "ADD": Initialize="Add"
    "SUBTRACT": Initialize="Subtract"
    "MULTIPLY": Initialize="Multiply"
    "DIVIDE": Initialize="Divide"
    "MODULO": Initialize="Modulo"
    "NEGATE": Initialize="Negate"
    "INCREMENT": Initialize="Increment"
    "DECREMENT": Initialize="Decrement"
}

// =============================================================================
// TRY COMPILE - Main dispatch for arithmetic operations
// Returns 1 if handled, 0 if not an arithmetic operation
// =============================================================================
Function.CompileArith_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        PrintMessage("[ARITH] TryCompile called\n")
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("[ARITH] node is null\n")
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            PrintMessage("[ARITH] func_name is null\n")
            ReturnValue(0)
        }
        
        PrintMessage("[ARITH] Checking: ")
        PrintString(func_name)
        PrintMessage("\n")
        
        // Check each arithmetic operation
        cmp = StringCompare(func_name, ArithName.ADD)
        PrintMessage("[ARITH] vs ADD: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[ARITH] Matched Add!\n")
            ReturnValue(CompileArith_Add(node))
        }
        
        cmp = StringCompare(func_name, ArithName.SUBTRACT)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Subtract(node))
        }
        
        cmp = StringCompare(func_name, ArithName.MULTIPLY)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Multiply(node))
        }
        
        cmp = StringCompare(func_name, ArithName.DIVIDE)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Divide(node))
        }
        
        cmp = StringCompare(func_name, ArithName.MODULO)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Modulo(node))
        }
        
        cmp = StringCompare(func_name, ArithName.NEGATE)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Negate(node))
        }
        
        cmp = StringCompare(func_name, ArithName.INCREMENT)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Increment(node))
        }
        
        cmp = StringCompare(func_name, ArithName.DECREMENT)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Decrement(node))
        }
        
        // Not an arithmetic operation
        ReturnValue(0)
    }
}

// =============================================================================
// ADD(a, b) → a + b
// Compile both args, add them, result in RAX
// =============================================================================
Function.CompileArith_Add {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Add requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Get arguments
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile first argument → RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push RAX to save first operand
        X86_PushRax()
        
        // Compile second argument → RAX
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Move second operand to RBX
        X86_MovRegReg(Reg.RBX, Reg.RAX)
        
        // Pop first operand back to RAX
        X86_PopRax()
        
        // RAX = RAX + RBX
        X86_AddRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// SUBTRACT(a, b) → a - b
// =============================================================================
Function.CompileArith_Subtract {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Subtract requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile first argument → RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push RAX
        X86_PushRax()
        
        // Compile second argument → RAX
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Move second operand to RBX
        X86_MovRegReg(Reg.RBX, Reg.RAX)
        
        // Pop first operand back to RAX
        X86_PopRax()
        
        // RAX = RAX - RBX
        X86_SubRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// MULTIPLY(a, b) → a * b
// Uses IMUL instruction
// =============================================================================
Function.CompileArith_Multiply {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Multiply requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile first argument → RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push RAX
        X86_PushRax()
        
        // Compile second argument → RAX
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Move second operand to RBX
        X86_MovRegReg(Reg.RBX, Reg.RAX)
        
        // Pop first operand back to RAX
        X86_PopRax()
        
        // RAX = RAX * RBX (signed)
        X86_ImulRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// DIVIDE(a, b) → a / b
// Uses IDIV: RAX = RDX:RAX / operand, remainder in RDX
// =============================================================================
Function.CompileArith_Divide {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Divide requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile divisor (second arg) first
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push divisor
        X86_PushRax()
        
        // Compile dividend (first arg) → RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Pop divisor to RBX
        X86_PopRbx()
        
        // Sign-extend RAX to RDX:RAX (CQO instruction)
        X86_Cqo()
        
        // IDIV RBX: RAX = RDX:RAX / RBX, RDX = remainder
        X86_IdivRbx()
        
        // Result (quotient) is in RAX
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// MODULO(a, b) → a % b
// Same as divide, but we want the remainder (RDX)
// =============================================================================
Function.CompileArith_Modulo {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Modulo requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile divisor first
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        X86_PushRax()
        
        // Compile dividend → RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        X86_PopRbx()
        
        // Sign-extend
        X86_Cqo()
        
        // IDIV RBX
        X86_IdivRbx()
        
        // Move remainder from RDX to RAX
        X86_MovRegReg(Reg.RAX, Reg.RDX)
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// NEGATE(a) → -a
// =============================================================================
Function.CompileArith_Negate {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("Negate requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile argument → RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // NEG RAX
        X86_NegRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// INCREMENT(a) → a + 1
// =============================================================================
Function.CompileArith_Increment {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("Increment requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // INC RAX
        X86_IncRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// DECREMENT(a) → a - 1
// =============================================================================
Function.CompileArith_Decrement {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("Decrement requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // DEC RAX
        X86_DecRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}