// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// Licensed under the Sean Collins Software License (SCSL).

// Library.CCompileArith.ailang
// Arithmetic operations: Add, Subtract, Multiply, Divide, Modulo, Negate
// NO FIXEDPOOL - uses string literals directly to avoid pool collisions

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// TRY COMPILE - Main dispatch for arithmetic operations
// Returns 1 if handled, 0 if not an arithmetic operation
// =============================================================================
Function.CompileArith_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        PrintMessage("[ARITH] TryCompile called\n")
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("[ARITH] node is null\n")
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            PrintMessage("[ARITH] func_name is null\n")
            ReturnValue(0)
        }
        
        PrintMessage("[ARITH] Checking: ")
        PrintString(func_name)
        PrintMessage("\n")
        
        // Check each arithmetic operation using string literals
        cmp = StringCompare(func_name, "Add")
        PrintMessage("[ARITH] vs Add: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[ARITH] Matched Add!\n")
            ReturnValue(CompileArith_Add(node))
        }
        
        cmp = StringCompare(func_name, "Subtract")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Subtract(node))
        }
        
        cmp = StringCompare(func_name, "Multiply")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Multiply(node))
        }
        
        cmp = StringCompare(func_name, "Divide")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Divide(node))
        }
        
        cmp = StringCompare(func_name, "Modulo")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Modulo(node))
        }
        
        cmp = StringCompare(func_name, "Negate")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Negate(node))
        }
        
        cmp = StringCompare(func_name, "Increment")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Increment(node))
        }
        
        cmp = StringCompare(func_name, "Decrement")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileArith_Decrement(node))
        }
        
        // Add to the TryCompile dispatcher:
        cmp = StringCompare(func_name, "Power")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[ARITH] Matched Power!\n")
            ReturnValue(CompileArith_Power(node))
        }

        // Not an arithmetic operation
        ReturnValue(0)
    }
}

// =============================================================================
// ADD(a, b) → a + b
// =============================================================================
Function.CompileArith_Add {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Add requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_PushRax()
        
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        Emit_AddRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// SUBTRACT(a, b) → a - b
// =============================================================================
Function.CompileArith_Subtract {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Subtract requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_PushRax()
        
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        Emit_SubRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// MULTIPLY(a, b) → a * b
// =============================================================================
Function.CompileArith_Multiply {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Multiply requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_PushRax()
        
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        Emit_ImulRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// DIVIDE(a, b) → a / b  (FIXED: preserves RDX)
// =============================================================================
Function.CompileArith_Divide {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Divide requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile dividend (a) -> RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_PushRax()
        
        // Compile divisor (b) -> RAX, then move to RBX
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        
        // === FIX: Save RDX before CQO/IDIV clobbers it ===
        Emit_PushRdx()
        
        // Sign extend RAX into RDX:RAX, then divide
        Emit_Cqo()
        Emit_IdivRbx()
        
        // Quotient is in RAX - save it temporarily
        Emit_MovRegReg(Reg.RCX, Reg.RAX)  // Save quotient to RCX
        Emit_PopRdx()                       // Restore original RDX
        Emit_MovRegReg(Reg.RAX, Reg.RCX)  // Put quotient back in RAX
        // === END FIX ===
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// MODULO(a, b) → a % b (remainder)  (FIXED: preserves RDX)
// =============================================================================
Function.CompileArith_Modulo {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Modulo requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile dividend (a) -> RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_PushRax()
        
        // Compile divisor (b) -> RAX, then move to RBX
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        
        // === FIX: Save RDX before CQO/IDIV clobbers it ===
        Emit_PushRdx()
        
        // Sign extend RAX into RDX:RAX, then divide
        Emit_Cqo()
        Emit_IdivRbx()
        
        // Remainder is in RDX - save it before restoring original RDX
        Emit_MovRegReg(Reg.RCX, Reg.RDX)  // Save remainder to RCX
        Emit_PopRdx()                       // Restore original RDX  
        Emit_MovRegReg(Reg.RAX, Reg.RCX)  // Put remainder in RAX
        // === END FIX ===
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// NEGATE(a) → -a
// =============================================================================
Function.CompileArith_Negate {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("Negate requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_NegRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// INCREMENT(a) → a + 1
// =============================================================================
Function.CompileArith_Increment {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("Increment requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_IncRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// DECREMENT(a) → a - 1
// =============================================================================
Function.CompileArith_Decrement {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("Decrement requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_DecRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// CompileArith_Power
// Power(base, exponent)
// =============================================================================

// The implementation:
Function.CompileArith_Power {
    Input: node: Address
    Output: Integer
    Body: {
        // Power uses R12 for base, R13 for exponent
        Emit_PushR12()
        Emit_PushR13()
        
        // Compile exponent -> RAX, move to R13
        arg1 = AST_GetChild(node, 1)
        Compile_Expression(arg1)
        Emit_MovR13Rax()
        
        // Compile base -> RAX, move to R12
        arg0 = AST_GetChild(node, 0)
        Compile_Expression(arg0)
        Emit_MovR12Rax()
        
        // Result = 1
        Emit_MovRaxImm64(1)
        
        // Create loop labels
        loop_start = Emit_CreateLabel()
        loop_end = Emit_CreateLabel()
        
        // Loop start
        Emit_MarkLabel(loop_start)
        
        // TEST R13, R13
        Emit_TestR13R13()
        
        // JZ loop_end (if exponent == 0, done)
        Emit_Jz(loop_end)
        
        // IMUL RAX, R12 (result *= base)
        Emit_ImulRaxR12()
        
        // DEC R13 (exponent--)
        Emit_DecR13()
        
        // JMP loop_start
        Emit_Jmp(loop_start)
        
        // Loop end
        Emit_MarkLabel(loop_end)
        
        // Restore registers
        Emit_PopR13()
        Emit_PopR12()
        
        ReturnValue(1)
    }
}