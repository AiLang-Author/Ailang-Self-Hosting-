// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// Library.CCompileArray.ailang
// Array operations compiler module for the AILang self-hosting compiler
// Handles: ArrayCreate, ArrayGet, ArraySet, ArrayLength, ArrayDestroy
//
// Array Memory Layout:
//   [0-7]   = capacity (number of elements)
//   [8-15]  = element 0
//   [16-23] = element 1
//   ...
// Size formula: 8 + (capacity * 8) bytes
LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileArray_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition StringEquals(func_name, "ArrayCreate") ThenBlock: {
            ReturnValue(CompileArray_Create(node))
        }
        
        IfCondition StringEquals(func_name, "ArrayGet") ThenBlock: {
            ReturnValue(CompileArray_Get(node))
        }
        
        IfCondition StringEquals(func_name, "ArraySet") ThenBlock: {
            ReturnValue(CompileArray_Set(node))
        }
        
        IfCondition StringEquals(func_name, "ArrayLength") ThenBlock: {
            ReturnValue(CompileArray_Length(node))
        }
        
        IfCondition StringEquals(func_name, "ArrayDestroy") ThenBlock: {
            ReturnValue(CompileArray_Destroy(node))
        }
        
        // Not an array operation
        ReturnValue(0)
    }
}

// =============================================================================
// ARRAYCREATE
// ArrayCreate(size) - allocates array via mmap
// Returns: address of new array (or error if < 0)
// Memory: 8 bytes header + (size * 8) bytes for elements
// =============================================================================
Function.CompileArray_Create {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        
        // Get size argument (default to 10 if not provided)
        IfCondition GreaterThan(arg_count, 0) ThenBlock: {
            arg0 = AST_GetChild(node, 0)
            Compile_Expression(arg0)
        } ElseBlock: {
            Emit_MovRaxImm64(10)
        }
        
        // Save size on stack for header storage
        Emit_PushRax()
        
        // Calculate bytes: (size * 8) + 8
        Emit_MovRcxImm64(3)
        Emit_ShlRaxCl()
        Emit_AddRegImm32(Reg.RAX, 8)
        
        // Save total byte size in RSI for mmap
        Emit_MovRsiRax()
        
        // mmap(NULL, size_bytes, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
        Emit_MovRaxImm64(9)
        Emit_MovRdiImm64(0)
        Emit_MovRdxImm64(3)
        Emit_MovR10Imm64(34)
        Emit_MovR8Imm64(-1)
        Emit_MovR9Imm64(0)
        Emit_Syscall()
        
        // Store capacity in header
        Emit_MovRbxRax()
        Emit_PopRcx()
        Emit_MovDerefRbxRcx()
        
        // Return array pointer
        Emit_MovRaxRbx()
        
        ReturnValue(1)
    }
}

// =============================================================================
// ARRAYGET
// ArrayGet(array, index) - get element at index
// =============================================================================
Function.CompileArray_Get {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition LessThan(arg_count, 2) ThenBlock: {
            PrintMessage("[ERROR] ArrayGet requires 2 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile array pointer
        Compile_Expression(arg0)
        Emit_PushRax()
        
        // Compile index
        Compile_Expression(arg1)
        
        // Calculate offset: (index * 8) + 8
        Emit_MovRcxImm64(3)
        Emit_ShlRaxCl()
        Emit_AddRegImm32(Reg.RAX, 8)
        
        // Add to array base
        Emit_PopRbx()
        Emit_AddRaxRbx()
        
        // Load value
        Emit_MovRaxDerefRax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// ARRAYSET
// ArraySet(array, index, value) - set element at index
// =============================================================================
Function.CompileArray_Set {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition LessThan(arg_count, 3) ThenBlock: {
            PrintMessage("[ERROR] ArraySet requires 3 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        arg2 = AST_GetChild(node, 2)
        
        // Compile array pointer
        Compile_Expression(arg0)
        Emit_PushRax()
        
        // Compile index
        Compile_Expression(arg1)
        Emit_PushRax()
        
        // Compile value
        Compile_Expression(arg2)
        Emit_PushRax()
        
        // Pop value into RCX
        Emit_PopRcx()
        
        // Pop index, calculate offset
        Emit_PopRax()
        Emit_PushRcx()
        Emit_MovRcxImm64(3)
        Emit_ShlRaxCl()
        Emit_AddRegImm32(Reg.RAX, 8)
        Emit_PopRcx()
        
        // Add to array base
        Emit_PopRbx()
        Emit_AddRaxRbx()
        
        // Store value
        Emit_MovDerefRaxRcx()
        
        ReturnValue(1)
    }
}

// =============================================================================
// ARRAYLENGTH
// ArrayLength(array) - get capacity from header
// =============================================================================
Function.CompileArray_Length {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            PrintMessage("[ERROR] ArrayLength requires 1 argument\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        Compile_Expression(arg0)
        Emit_MovRaxDerefRax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// ARRAYDESTROY
// ArrayDestroy(array) - free array memory via munmap
// =============================================================================
Function.CompileArray_Destroy {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            PrintMessage("[ERROR] ArrayDestroy requires 1 argument\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        Compile_Expression(arg0)
        
        // Check for null pointer
        Emit_TestRaxRax()
        null_label = Emit_CreateLabel()
        done_label = Emit_CreateLabel()
        Emit_Jz(null_label)
        
        // Save array pointer
        Emit_PushRbx()
        Emit_MovRbxRax()
        
        // Get capacity, calculate size
        Emit_MovRaxDerefRbx()
        Emit_MovRcxImm64(3)
        Emit_ShlRaxCl()
        Emit_AddRegImm32(Reg.RAX, 8)
        
        // munmap(addr, size)
        Emit_MovRsiRax()
        Emit_MovRdiRbx()
        Emit_MovRaxImm64(11)
        Emit_Syscall()
        
        Emit_PopRbx()
        Emit_Jmp(done_label)
        
        // Null case
        Emit_MarkLabel(null_label)
        Emit_XorRaxRax()
        
        Emit_MarkLabel(done_label)
        
        ReturnValue(1)
    }
}