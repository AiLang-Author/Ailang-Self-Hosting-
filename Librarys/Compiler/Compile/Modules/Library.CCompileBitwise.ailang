// Library.CCompileBitwise.ailang
// Bitwise operations: BitwiseAnd, BitwiseOr, BitwiseXor, BitwiseNot, LeftShift, RightShift

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileBitwise_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        cmp = StringCompare(func_name, "BitwiseAnd")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileBitwise_And(node))
        }
        
        cmp = StringCompare(func_name, "BitwiseOr")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileBitwise_Or(node))
        }
        
        cmp = StringCompare(func_name, "BitwiseXor")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileBitwise_Xor(node))
        }
        
        cmp = StringCompare(func_name, "BitwiseNot")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileBitwise_Not(node))
        }
        
        cmp = StringCompare(func_name, "LeftShift")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileBitwise_LeftShift(node))
        }
        
        cmp = StringCompare(func_name, "RightShift")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileBitwise_RightShift(node))
        }
        
        // Not a bitwise operation
        ReturnValue(0)
    }
}

// =============================================================================
// BitwiseAnd(a, b) -> a & b
// =============================================================================
Function.CompileBitwise_And {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("BitwiseAnd requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        Compile_Expression(arg0)
        Emit_PushRax()
        Compile_Expression(arg1)
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        Emit_AndRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// BitwiseOr(a, b) -> a | b
// =============================================================================
Function.CompileBitwise_Or {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("BitwiseOr requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        Compile_Expression(arg0)
        Emit_PushRax()
        Compile_Expression(arg1)
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        Emit_OrRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// BitwiseXor(a, b) -> a ^ b (XOR, not power!)
// =============================================================================
Function.CompileBitwise_Xor {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("BitwiseXor requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        Compile_Expression(arg0)
        Emit_PushRax()
        Compile_Expression(arg1)
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_PopRax()
        Emit_XorRaxRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// BitwiseNot(a) -> ~a
// =============================================================================
Function.CompileBitwise_Not {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("BitwiseNot requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        Compile_Expression(arg0)
        Emit_NotRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// LeftShift(value, count) -> value << count
// =============================================================================
Function.CompileBitwise_LeftShift {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("LeftShift requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile shift count first -> CL
        Compile_Expression(arg1)
        Emit_MovRegReg(Reg.RCX, Reg.RAX)
        
        // Compile value -> RAX
        Compile_Expression(arg0)
        
        // SHL RAX, CL
        Emit_ShlRaxCl()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// RightShift(value, count) -> value >> count (arithmetic shift)
// =============================================================================
Function.CompileBitwise_RightShift {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("RightShift requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile shift count first -> CL
        Compile_Expression(arg1)
        Emit_MovRegReg(Reg.RCX, Reg.RAX)
        
        // Compile value -> RAX
        Compile_Expression(arg0)
        
        // SAR RAX, CL (arithmetic right shift, preserves sign)
        Emit_SarRaxCl()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}