// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileBitwise.ailang
// Bitwise operations compiler module for the AILang self-hosting compiler
// Handles: BitwiseAnd, BitwiseOr, BitwiseXor, BitwiseNot, LeftShift, RightShift

LibraryImport.Compiler.Compile.Modules.CCompileTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileBitwise_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseAnd"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_And(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseAnd"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_And(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseOr"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_Or(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseOr"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_Or(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseXor"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_Xor(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseXor"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_Xor(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseNot"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_Not(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "BitwiseNot"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_Not(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "LeftShift"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_LeftShift(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Shl"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_LeftShift(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "RightShift"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_RightShift(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Shr"), 0) ThenBlock: {
            ReturnValue(CompileBitwise_RightShift(node))
        }
        
        // Not a bitwise operation
        ReturnValue(0)
    }
}

// =============================================================================
// GENERIC BITWISE BINARY OP
// Same depth-based allocation as arithmetic
// =============================================================================
Function.CompileBitwise_BinaryOp {
    Input: node: Address
    Input: op_type: Integer
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("Bitwise operation requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        depth = Compile_GetDepth()
        use_stack = Compile_ShouldUseStack()
        
        Compile_DepthPush()
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        IfCondition EqualTo(use_stack, 1) ThenBlock: {
            Compile_Expression(arg1)
            Emit_PushRax()
            Compile_Expression(arg0)
            Emit_PopRbx()
        } ElseBlock: {
            reg = Compile_GetDepthReg()
            
            IfCondition EqualTo(reg, 12) ThenBlock: {
                Emit_PushR12()
                Compile_Expression(arg1)
                Emit_MovR12Rax()
                Compile_Expression(arg0)
                Emit_MovRbxR12()
                Emit_PopR12()
            } ElseBlock: {
                Emit_PushR13()
                Compile_Expression(arg1)
                Emit_MovR13Rax()
                Compile_Expression(arg0)
                Emit_MovRbxR13()
                Emit_PopR13()
            }
        }
        
        Compile_DepthPop()
        
        // Apply bitwise operation
        IfCondition EqualTo(op_type, BitwiseOp.AND) ThenBlock: {
            Emit_AndRaxRbx()
        }
        IfCondition EqualTo(op_type, BitwiseOp.OR) ThenBlock: {
            Emit_OrRaxRbx()
        }
        IfCondition EqualTo(op_type, BitwiseOp.XOR) ThenBlock: {
            Emit_XorRaxRbx()
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// BITWISE OPERATION CONSTANTS
// =============================================================================
FixedPool.BitwiseOp {
    "AND": Initialize=1, CanChange=False
    "OR": Initialize=2, CanChange=False
    "XOR": Initialize=3, CanChange=False
}

// =============================================================================
// INDIVIDUAL BITWISE OPERATIONS
// =============================================================================

Function.CompileBitwise_And {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileBitwise_BinaryOp(node, BitwiseOp.AND))
    }
}

Function.CompileBitwise_Or {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileBitwise_BinaryOp(node, BitwiseOp.OR))
    }
}

Function.CompileBitwise_Xor {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileBitwise_BinaryOp(node, BitwiseOp.XOR))
    }
}

Function.CompileBitwise_Not {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("BitwiseNot requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        Compile_Expression(arg0)
        Emit_NotRax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// SHIFT OPERATIONS
// Shift amount goes in CL (low byte of RCX)
// =============================================================================

Function.CompileBitwise_LeftShift {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("LeftShift requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        use_stack = Compile_ShouldUseStack()
        
        Compile_DepthPush()
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        IfCondition EqualTo(use_stack, 1) ThenBlock: {
            // Compile shift amount
            Compile_Expression(arg1)
            Emit_PushRax()
            // Compile value to shift
            Compile_Expression(arg0)
            // Pop shift amount into RCX
            Emit_PopRcx()
        } ElseBlock: {
            reg = Compile_GetDepthReg()
            
            IfCondition EqualTo(reg, 12) ThenBlock: {
                Emit_PushR12()
                Compile_Expression(arg1)
                Emit_MovR12Rax()
                Compile_Expression(arg0)
                Emit_MovRcxR12()
                Emit_PopR12()
            } ElseBlock: {
                Emit_PushR13()
                Compile_Expression(arg1)
                Emit_MovR13Rax()
                Compile_Expression(arg0)
                Emit_MovRcxR13()
                Emit_PopR13()
            }
        }
        
        Compile_DepthPop()
        
        // SHL RAX, CL
        Emit_ShlRaxCl()
        
        ReturnValue(1)
    }
}

Function.CompileBitwise_RightShift {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("RightShift requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        use_stack = Compile_ShouldUseStack()
        
        Compile_DepthPush()
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        IfCondition EqualTo(use_stack, 1) ThenBlock: {
            Compile_Expression(arg1)
            Emit_PushRax()
            Compile_Expression(arg0)
            Emit_PopRcx()
        } ElseBlock: {
            reg = Compile_GetDepthReg()
            
            IfCondition EqualTo(reg, 12) ThenBlock: {
                Emit_PushR12()
                Compile_Expression(arg1)
                Emit_MovR12Rax()
                Compile_Expression(arg0)
                Emit_MovRcxR12()
                Emit_PopR12()
            } ElseBlock: {
                Emit_PushR13()
                Compile_Expression(arg1)
                Emit_MovR13Rax()
                Compile_Expression(arg0)
                Emit_MovRcxR13()
                Emit_PopR13()
            }
        }
        
        Compile_DepthPop()
        
        // SAR RAX, CL (arithmetic right shift - preserves sign)
        Emit_SarRaxCl()
        
        ReturnValue(1)
    }
}