// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileCompare.ailang
// Comparison operations compiler module for the AILang self-hosting compiler
// Handles: EqualTo, NotEqual, LessThan, GreaterThan, LessEqual, GreaterEqual
// Result: 1 (true) or 0 (false) in RAX

LibraryImport.Compiler.CodeEmit.CEmitCore

LibraryImport.Compiler.Compile.Modules.CCompileTypes
LibraryImport.Compiler.CodeEmit.CEmitCoreArch
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileCompare_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(StringCompare(func_name, "EqualTo"), 0) ThenBlock: {
            ReturnValue(CompileCompare_EqualTo(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "NotEqual"), 0) ThenBlock: {
            ReturnValue(CompileCompare_NotEqual(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "LessThan"), 0) ThenBlock: {
            ReturnValue(CompileCompare_LessThan(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "GreaterThan"), 0) ThenBlock: {
            ReturnValue(CompileCompare_GreaterThan(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "LessEqual"), 0) ThenBlock: {
            ReturnValue(CompileCompare_LessEqual(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "GreaterEqual"), 0) ThenBlock: {
            ReturnValue(CompileCompare_GreaterEqual(node))
        }
        
        // Not a comparison operation
        ReturnValue(0)
    }
}

// =============================================================================
// GENERIC COMPARISON COMPILER
// Uses same depth-based register allocation as arithmetic
// Emits CMP then SETcc to produce 0 or 1 in RAX
// =============================================================================
Function.CompileCompare_BinaryOp {
    Input: node: Address
    Input: cc_type: Integer
    Output: Integer
    Body: {
        // Validate 2 arguments
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("Comparison requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        depth = Compile_GetDepth()
        use_stack = Compile_ShouldUseStack()
        
        Compile_DepthPush()
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        IfCondition EqualTo(use_stack, 1) ThenBlock: {
            // Depth 2+: Use stack
            Compile_Expression(arg1)
            Emit_PushRax()
            Compile_Expression(arg0)
            Emit_PopRbx()
        } ElseBlock: {
            reg = Compile_GetDepthReg()
            
            IfCondition EqualTo(reg, 12) ThenBlock: {
                Emit_PushR12()
                Compile_Expression(arg1)
                Emit_MovR12Rax()
                Compile_Expression(arg0)
                Emit_MovRbxR12()
                Emit_PopR12()
            } ElseBlock: {
                Emit_PushR13()
                Compile_Expression(arg1)
                Emit_MovR13Rax()
                Compile_Expression(arg0)
                Emit_MovRbxR13()
                Emit_PopR13()
            }
        }
        
        Compile_DepthPop()
        
        // CMP RAX, RBX
        Emit_CmpRaxRbx()
        
        // SETcc AL based on condition code
        IfCondition EqualTo(cc_type, CC.E) ThenBlock: {
            Emit_Sete()
        }
        IfCondition EqualTo(cc_type, CC.NE) ThenBlock: {
            Emit_Setne()
        }
        IfCondition EqualTo(cc_type, CC.L) ThenBlock: {
            Emit_Setl()
        }
        IfCondition EqualTo(cc_type, CC.G) ThenBlock: {
            Emit_Setg()
        }
        IfCondition EqualTo(cc_type, CC.LE) ThenBlock: {
            Emit_Setle()
        }
        IfCondition EqualTo(cc_type, CC.GE) ThenBlock: {
            Emit_Setge()
        }
        
        // MOVZX RAX, AL (zero-extend to 64-bit)
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}

// =============================================================================
// INDIVIDUAL COMPARISON OPERATIONS
// =============================================================================

Function.CompileCompare_EqualTo {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileCompare_BinaryOp(node, CC.E))
    }
}

Function.CompileCompare_NotEqual {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileCompare_BinaryOp(node, CC.NE))
    }
}

Function.CompileCompare_LessThan {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileCompare_BinaryOp(node, CC.L))
    }
}

Function.CompileCompare_GreaterThan {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileCompare_BinaryOp(node, CC.G))
    }
}

Function.CompileCompare_LessEqual {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileCompare_BinaryOp(node, CC.LE))
    }
}

Function.CompileCompare_GreaterEqual {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(CompileCompare_BinaryOp(node, CC.GE))
    }
}