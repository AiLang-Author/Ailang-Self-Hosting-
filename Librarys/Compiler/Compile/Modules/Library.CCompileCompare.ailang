// Library.CCompileCompare.ailang
// Comparison operations: EqualTo, NotEqual, LessThan, GreaterThan, LessEqual, GreaterEqual
// Result: 1 (true) or 0 (false) in RAX

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileCompare_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        cmp = StringCompare(func_name, "EqualTo")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileCompare_EqualTo(node))
        }
        
        cmp = StringCompare(func_name, "NotEqual")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileCompare_NotEqual(node))
        }
        
        cmp = StringCompare(func_name, "LessThan")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileCompare_LessThan(node))
        }
        
        cmp = StringCompare(func_name, "GreaterThan")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileCompare_GreaterThan(node))
        }
        
        cmp = StringCompare(func_name, "LessEqual")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileCompare_LessEqual(node))
        }
        
        cmp = StringCompare(func_name, "GreaterEqual")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileCompare_GreaterEqual(node))
        }
        
        // Not a comparison operation
        ReturnValue(0)
    }
}

// =============================================================================
// HELPER: Compile binary comparison
// Pattern: compile args, CMP, SETcc, MOVZX
// =============================================================================
Function.CompileCompare_Binary {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("Comparison requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile first argument → RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push first arg
        Emit_PushRax()
        
        // Compile second argument → RAX
        result = Compile_Expression(arg1)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Move second to RBX
        Emit_MovRbxRax()
        
        // Pop first to RAX
        Emit_PopRax()
        
        // CMP RAX, RBX
        Emit_CmpRaxRbx()
        
        // Caller will emit the specific SETcc
        ReturnValue(1)
    }
}

// =============================================================================
// INDIVIDUAL COMPARISONS
// =============================================================================

Function.CompileCompare_EqualTo {
    Input: node: Address
    Output: Integer
    Body: {
        result = CompileCompare_Binary(node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // SETE AL
        Emit_Sete()
        // MOVZX RAX, AL
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}

Function.CompileCompare_NotEqual {
    Input: node: Address
    Output: Integer
    Body: {
        result = CompileCompare_Binary(node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // SETNE AL
        Emit_Setne()
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}

Function.CompileCompare_LessThan {
    Input: node: Address
    Output: Integer
    Body: {
        result = CompileCompare_Binary(node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // SETL AL (signed less than)
        Emit_Setl()
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}

Function.CompileCompare_GreaterThan {
    Input: node: Address
    Output: Integer
    Body: {
        result = CompileCompare_Binary(node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // SETG AL (signed greater than)
        Emit_Setg()
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}

Function.CompileCompare_LessEqual {
    Input: node: Address
    Output: Integer
    Body: {
        result = CompileCompare_Binary(node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // SETLE AL
        Emit_Setle()
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}

Function.CompileCompare_GreaterEqual {
    Input: node: Address
    Output: Integer
    Body: {
        result = CompileCompare_Binary(node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // SETGE AL
        Emit_Setge()
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}