// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileExpr.ailang
// Expression compiler for the AILang self-hosting compiler
// Handles: Numbers, Identifiers, Strings, Function Calls
// Result of expression evaluation is always in RAX

//compiler modules
LibraryImport.Compiler.Compile.Modules.CCompileTypes
LibraryImport.Compiler.Compile.Modules.CCompileArith
LibraryImport.Compiler.Compile.Modules.CCompileIO
LibraryImport.Compiler.Compile.Modules.CCompileCompare
LibraryImport.Compiler.Compile.Modules.CCompileLogic
LibraryImport.Compiler.Compile.Modules.CCompileFunc

//emit methods
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem

// =============================================================================
// MAIN EXPRESSION COMPILER
// Dispatches based on AST node type, result always in RAX
// =============================================================================
// =============================================================================
// EXPRESSION COMPILER
// Compiles any expression, leaving result in RAX
// =============================================================================
Function.Compile_Expression {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(node)
        
        // ─────────────────────────────────────────────────────────────────
        // Literals
        // ─────────────────────────────────────────────────────────────────
        
        
        // Number literal -> MOV RAX, value
        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
            value_str = AST_GetData1(node)
            value = StringToNumber(value_str)  // Not StringToInteger!
            Emit_MovRaxImm64(value)
            ReturnValue(1)
        }
                
        // String literal -> load data section address
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            str_ptr = AST_GetData1(node)
            offset = Emit_AddString(str_ptr)
            Emit_LoadDataAddress(offset)
            ReturnValue(1)
        }
        
        // Boolean literal
        IfCondition EqualTo(node_type, AST.BOOLEAN) ThenBlock: {
            value = AST_GetData1(node)
            Emit_MovRaxImm64(value)
            ReturnValue(1)
        }
        
        // Null literal
        IfCondition EqualTo(node_type, AST.NULL) ThenBlock: {
            Emit_XorRaxRax()
            ReturnValue(1)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Identifier - load variable value
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
            ReturnValue(CompileExpr_Identifier(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Function call - result in RAX
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            ReturnValue(Compile_FunctionCall(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Operators
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.BINARY_OP) ThenBlock: {
            ReturnValue(CompileExpr_BinaryOp(node))
        }
        
        IfCondition EqualTo(node_type, AST.UNARY_OP) ThenBlock: {
            ReturnValue(CompileExpr_UnaryOp(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Member access (Pool.field)
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.MEMBER_ACCESS) ThenBlock: {
            ReturnValue(CompileExpr_MemberAccess(node))
        }
        
        // ─────────────────────────────────────────────────────────────────
        // Index access (array[index])
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(node_type, AST.INDEX_ACCESS) ThenBlock: {
            ReturnValue(CompileExpr_IndexAccess(node))
        }
        
        // Unknown expression type
        PrintMessage("[COMPILE] WARNING: Unknown expression type ")
        PrintNumber(node_type)
        PrintMessage("\n")
        ReturnValue(0)
    }
}

// =============================================================================
// NUMBER LITERAL
// Loads immediate value into RAX
// =============================================================================
Function.CompileExpr_Number {
    Input: node: Address
    Output: Integer
    Body: {
        value = AST_GetData1(node)
        Emit_MovRaxImm64(value)
        ReturnValue(1)
    }
}

// =============================================================================
// STRING LITERAL
// Adds string to data section, loads address into RAX
// =============================================================================
Function.CompileExpr_String {
    Input: node: Address
    Output: Integer
    Body: {
        str_value = AST_GetData1(node)
        
        // Add string to data section
        str_offset = Emit_AddString(str_value)
        
        // Load data section address into RAX
        Emit_LoadDataAddress(Reg.RAX, str_offset)
        
        ReturnValue(1)
    }
}

// =============================================================================
// IDENTIFIER (Variable Reference)
// Loads variable value from stack frame into RAX
// =============================================================================
Function.CompileExpr_Identifier {
    Input: node: Address
    Output: Integer
    Body: {
        var_name = AST_GetData1(node)
        
        // Look up variable in symbol table
        stack_offset = Compile_FindVariable(var_name)
        
        IfCondition EqualTo(stack_offset, 0) ThenBlock: {
            // Variable not found - might be a pool variable or undefined
            // Try pool access
            result = CompileExpr_PoolAccess(var_name)
            IfCondition EqualTo(result, 1) ThenBlock: {
                ReturnValue(1)
            }
            
            // Undefined variable error
            Compile_SetError("Undefined variable", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Load from [RBP + offset]
        Emit_MovRaxRbpOffset(stack_offset)
        
        ReturnValue(1)
    }
}

// =============================================================================
// BOOLEAN LITERAL
// True = 1, False = 0
// =============================================================================
Function.CompileExpr_Boolean {
    Input: node: Address
    Output: Integer
    Body: {
        bool_value = AST_GetData1(node)
        
        IfCondition EqualTo(bool_value, 1) ThenBlock: {
            Emit_MovRaxImm64(1)
        } ElseBlock: {
            Emit_MovRaxImm64(0)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// UNARY OPERATION
// Handles prefix operators like Not, Negate
// =============================================================================
Function.CompileExpr_Unary {
    Input: node: Address
    Output: Integer
    Body: {
        op_type = AST_GetData1(node)
        operand = AST_GetChild(node, 0)
        
        // Compile operand first
        Compile_Expression(operand)
        
        // Apply unary operator
        IfCondition EqualTo(op_type, UnaryOp.NEGATE) ThenBlock: {
            Emit_NegRax()
            ReturnValue(1)
        }
        
        IfCondition EqualTo(op_type, UnaryOp.NOT) ThenBlock: {
            // Logical not: 0 -> 1, non-zero -> 0
            Emit_TestRaxRax()
            Emit_Setz()
            Emit_MovzxRaxAl()
            ReturnValue(1)
        }
        
        IfCondition EqualTo(op_type, UnaryOp.BITNOT) ThenBlock: {
            Emit_NotRax()
            ReturnValue(1)
        }
        
        Compile_SetError("Unknown unary operator", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// POOL ACCESS
// Handles PoolName.field syntax
// =============================================================================
Function.CompileExpr_PoolAccess {
    Input: name: Address
    Output: Integer
    Body: {
        // Check if name contains a dot (pool access)
        dot_pos = StringIndexOf(name, ".")
        IfCondition LessThan(dot_pos, 0) ThenBlock: {
            // No dot - not a pool access
            ReturnValue(0)
        }
        
        // Extract pool name and field name
        pool_name = StringSubstring(name, 0, dot_pos)
        field_name = StringSubstring(name, Add(dot_pos, 1), StringLength(name))
        
        // Look up pool in pool table
        pool_offset = Compile_FindPool(pool_name)
        IfCondition LessThan(pool_offset, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Look up field within pool
        field_offset = Compile_FindPoolField(pool_name, field_name)
        IfCondition LessThan(field_offset, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Load pool base from R15 (pool table base register)
        // Then add field offset and load value
        Emit_MovRaxR15Offset(pool_offset)
        Emit_MovRaxRaxOffset(field_offset)
        
        ReturnValue(1)
    }
}

// =============================================================================
// FUNCTION CALL DISPATCHER
// Tries each compile module until one handles the call
// =============================================================================
Function.Compile_FunctionCall {
    Input: node: Address
    Output: Integer
    Body: {
        // Try arithmetic operations
        result = CompileArith_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try I/O operations
        result = CompileIO_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try comparison operations
        result = CompileCompare_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try logical operations
        result = CompileLogic_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try bitwise operations
        result = CompileBitwise_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try string operations
        result = CompileString_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try memory operations
        result = CompileMem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try array operations
        result = CompileArray_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try system operations
        result = CompileSystem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try user-defined functions
        result = CompileFunc_UserCall(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Unknown function
        func_name = AST_GetData1(node)
        Compile_SetError("Unknown function", AST_GetLine(node))
        ReturnValue(0)
    }
}

