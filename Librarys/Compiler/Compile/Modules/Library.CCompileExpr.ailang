// Library.CCompileExpr.ailang
// Expression compilation - variable loading, storing, member access
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileExpr.ailang
//
// Architecture:
//   - Imports CCompileMain (like CCompileArith does)
//   - Uses existing functions from CCompileTypes (Compile_FindVariable, etc.)
//   - Provides CompileExpr_* functions called by CCompileMain dispatcher
//   - Calls Emit_* wrappers, NOT X86_* directly

LibraryImport.XArrays



LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore


LibraryImport.Compiler.CodeEmit.CEmitCoreArch

LibraryImport.Compiler.Compile.Modules.CCompileScope



// =============================================================================
// VARIABLE LOAD - Emit code to load variable value into RAX
// Uses Compile_FindVariable from CCompileTypes (returns stack offset)
// =============================================================================

Function.CompileExpr_LoadVariable {
    Input: name: Address
    Output: Integer
    Body: {
        PrintMessage("[LOAD] LoadVariable called for: ")
        PrintString(name)
        PrintMessage("\n")
        
        PrintMessage("[LOAD] Compile.variables size: ")
        PrintNumber(XArray.XSize(Compile.variables))
        PrintMessage("\n")
        
        offset = Scope_Resolve(name)
        
        PrintMessage("[LOAD] Scope_Resolve returned: ")
        PrintNumber(offset)
        PrintMessage(" resolve_type: ")
        PrintNumber(Scope.resolve_type)
        PrintMessage("\n")
        
        IfCondition EqualTo(Scope.resolve_type, 0) ThenBlock: {
            PrintMessage("[LOAD ERROR] Undefined variable: ")
            PrintString(name)
            PrintMessage("\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        IfCondition EqualTo(Scope.resolve_type, 3) ThenBlock: {
            pool_index = BitwiseAnd(offset, 2147483647)
            pool_offset = Multiply(pool_index, 8)
            Emit_MovRaxR15Offset(pool_offset)
            ReturnValue(1)
        }
        
        Emit_MovRaxRbpOffset(offset)
        ReturnValue(1)
    }
}
// =============================================================================
// VARIABLE STORE - Emit code to store RAX into variable
// Uses Compile_FindVariable and Compile_AddVariable from CCompileTypes
// =============================================================================

Function.CompileExpr_StoreVariable {
    Input: name: Address
    Output: Integer
    Body: {
        PrintMessage("[STORE] StoreVariable called for: ")
        PrintString(name)
        PrintMessage("\n")
        
        offset = Scope_Resolve(name)
        
        PrintMessage("[STORE] Scope_Resolve returned: ")
        PrintNumber(offset)
        PrintMessage(" resolve_type: ")
        PrintNumber(Scope.resolve_type)
        PrintMessage("\n")
        
        IfCondition EqualTo(Scope.resolve_type, 0) ThenBlock: {
            PrintMessage("[STORE] Creating new variable, stack_offset was: ")
            PrintNumber(Compile.stack_offset)
            PrintMessage("\n")
            
            Compile.stack_offset = Add(Compile.stack_offset, 8)
            offset = Subtract(0, Compile.stack_offset)
            
            PrintMessage("[STORE] New offset: ")
            PrintNumber(offset)
            PrintMessage("\n")
            
            Compile_RegisterLocal(name, offset)
            PrintMessage("[STORE] Registered, now emitting store\n")
        }
        
        // Check if pool variable
        IfCondition EqualTo(Scope.resolve_type, 3) ThenBlock: {
            PrintMessage("[STORE] Pool variable, index: ")
            pool_index = BitwiseAnd(offset, 2147483647)
            PrintNumber(pool_index)
            PrintMessage("\n")
            
            pool_offset = Multiply(pool_index, 8)
            Emit_MovR15OffsetRax(pool_offset)
            ReturnValue(1)
        }
        
        // Param or local - store to RBP-relative
        PrintMessage("[STORE] Local/param, emitting MOV [RBP")
        PrintNumber(offset)
        PrintMessage("], RAX\n")
        
        Emit_MovRbpOffsetRax(offset)
        ReturnValue(1)
    }
}

// =============================================================================
// VARIABLE MANAGEMENT
// =============================================================================

Function.Compile_FindVariable {
    Input: name: Address
    Output: Integer
    Body: {
        count = XArray.XSize(Compile.variables)
        i = 0
        WhileLoop LessThan(i, count) {
            entry = XArray.XGet(Compile.variables, i)
            entry_name = Dereference(entry)
            
            IfCondition EqualTo(StringCompare(name, entry_name), 0) ThenBlock: {
                // Return stack offset (stored at entry + 8)
                ReturnValue(Dereference(Add(entry, 8)))
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

Function.Compile_AddVariable {
    Input: name: Address
    Input: var_type: Integer
    Input: var_size: Integer
    Input: flags: Integer
    Output: Integer
    Body: {
        // Align size to 8 bytes
        aligned_size = var_size
        remainder = Modulo(var_size, 8)
        IfCondition NotEqual(remainder, 0) ThenBlock: {
            aligned_size = Add(var_size, Subtract(8, remainder))
        }
        
        // Update stack offset (negative for locals)
        Compile.stack_offset = Subtract(Compile.stack_offset, aligned_size)
        
        // Create entry: [name, offset, type, size, flags]
        entry = Allocate(40)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), Compile.stack_offset)
        StoreValue(Add(entry, 16), var_type)
        StoreValue(Add(entry, 24), aligned_size)
        StoreValue(Add(entry, 32), flags)
        
        XArray.XPush(Compile.variables, entry)
        
        ReturnValue(Compile.stack_offset)
    }
}


// =============================================================================
// MEMBER ACCESS - Pool.field or object.member
// =============================================================================

Function.CompileExpr_MemberAccess {
    Input: node: Address
    Output: Integer
    Body: {
        // Member access node: DATA1 = member name, child[0] = base
        member_name = AST_GetData1(node)
        base = AST_GetChild(node, 0)
        
        IfCondition EqualTo(base, 0) ThenBlock: {
            PrintMessage("[COMPILE ERROR] Member access with null base\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // Get base type
        base_type = AST_GetType(base)
        
        // If base is identifier, could be Pool.field
        IfCondition EqualTo(base_type, AST.IDENTIFIER) ThenBlock: {
            base_name = AST_GetData1(base)
            
            // Try loading base as variable, then access member
            offset = Compile_FindVariable(base_name)
            IfCondition NotEqual(offset, 0) ThenBlock: {
                // Load pointer from variable
                Emit_MovRaxRbpOffset(offset)
                // Load first field (offset 0) - TODO: proper field lookup
                Emit_MovRaxDerefRax()
                ReturnValue(1)
            }
            
            // Not found as variable - might be a FixedPool reference
            // TODO: Handle FixedPool.field access via R15
            PrintMessage("[COMPILE ERROR] Unknown base in member access: ")
            PrintString(base_name)
            PrintMessage("\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // TODO: Handle other base types (nested member access, etc.)
        PrintMessage("[COMPILE ERROR] Unsupported member access base type\n")
        Compile.error = 1
        ReturnValue(0)
    }
}

// =============================================================================
// INDEX ACCESS - array[index]
// =============================================================================

Function.CompileExpr_IndexAccess {
    Input: node: Address
    Output: Integer
    Body: {
        // Index access: child[0] = base, child[1] = index
        base = AST_GetChild(node, 0)
        index = AST_GetChild(node, 1)
        
        IfCondition Or(EqualTo(base, 0), EqualTo(index, 0)) ThenBlock: {
            PrintMessage("[COMPILE ERROR] Index access with null base or index\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // For now, handle simple case: identifier[number]
        index_type = AST_GetType(index)
        
        IfCondition EqualTo(index_type, AST.NUMBER) ThenBlock: {
            // Simple numeric index
            index_str = AST_GetData1(index)
            index_value = StringToNumber(index_str)
            
            // Compile base - load pointer to RAX
            base_type = AST_GetType(base)
            
            IfCondition EqualTo(base_type, AST.IDENTIFIER) ThenBlock: {
                base_name = AST_GetData1(base)
                result = CompileExpr_LoadVariable(base_name)
                IfCondition EqualTo(result, 0) ThenBlock: {
                    ReturnValue(0)
                }
            } ElseBlock: {
                PrintMessage("[COMPILE ERROR] Unsupported index base type\n")
                Compile.error = 1
                ReturnValue(0)
            }
            
            // RAX has base pointer, compute offset (index * 8 for 64-bit elements)
            byte_offset = Multiply(index_value, 8)
            
            // Load [RAX + offset] into RAX
            Emit_MovRaxDerefRaxOffset(byte_offset)
            ReturnValue(1)
        }
        
        // For non-constant indices, need runtime computation
        // TODO: Implement dynamic index support
        PrintMessage("[COMPILE ERROR] Non-constant array index not yet supported\n")
        Compile.error = 1
        ReturnValue(0)
    }
}

// =============================================================================
// BINARY OPERATORS (fallback - most handled by CCompileArith, etc.)
// =============================================================================

Function.CompileExpr_BinaryOp {
    Input: node: Address
    Output: Integer
    Body: {
        // Binary op: DATA1 = operator type, child[0] = left, child[1] = right
        // Most binary ops are handled by specialized modules (CCompileArith, etc.)
        // This handles any that fall through
        
        op_type = AST_GetData1(node)
        
        // Unknown/unhandled operator
        PrintMessage("[COMPILE ERROR] Unhandled binary operator: ")
        PrintNumber(op_type)
        PrintMessage("\n")
        Compile.error = 1
        ReturnValue(0)
    }
}

// =============================================================================
// UNARY OPERATORS
// =============================================================================

Function.CompileExpr_UnaryOp {
    Input: node: Address
    Output: Integer
    Body: {
        // Unary op: DATA1 = operator type, child[0] = operand
        op_type = AST_GetData1(node)
        operand = AST_GetChild(node, 0)
        
        IfCondition EqualTo(operand, 0) ThenBlock: {
            PrintMessage("[COMPILE ERROR] Unary op with null operand\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // Compile operand - result in RAX
        operand_type = AST_GetType(operand)
        
        IfCondition EqualTo(operand_type, AST.IDENTIFIER) ThenBlock: {
            name = AST_GetData1(operand)
            result = CompileExpr_LoadVariable(name)
            IfCondition EqualTo(result, 0) ThenBlock: {
                ReturnValue(0)
            }
        } ElseBlock: {
            IfCondition EqualTo(operand_type, AST.NUMBER) ThenBlock: {
                num_str = AST_GetData1(operand)
                num_val = StringToNumber(num_str)
                Emit_MovRaxImm64(num_val)
            } ElseBlock: {
                // Try compiling as general expression
                result = Compile_Expression(operand)
                IfCondition EqualTo(result, 0) ThenBlock: {
                    ReturnValue(0)
                }
            }
        }
        
        // Apply unary operation
        IfCondition EqualTo(op_type, UnaryOp.NEGATE) ThenBlock: {
            // NEG RAX
            Emit_NegRax()
            ReturnValue(1)
        }
        
        IfCondition EqualTo(op_type, UnaryOp.NOT) ThenBlock: {
            // Logical NOT: compare to 0, set to 1 if zero
            Emit_TestRaxRax()
            Emit_Sete()       // AL = 1 if RAX was 0 (ZF set)
            Emit_MovzxRaxAl() // Zero-extend AL to RAX
            ReturnValue(1)
        }
        
        IfCondition EqualTo(op_type, UnaryOp.BITNOT) ThenBlock: {
            // NOT RAX (bitwise complement)
            Emit_NotRax()
            ReturnValue(1)
        }
        
        PrintMessage("[COMPILE ERROR] Unknown unary operator: ")
        PrintNumber(op_type)
        PrintMessage("\n")
        Compile.error = 1
        ReturnValue(0)
    }
}