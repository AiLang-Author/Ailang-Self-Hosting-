// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileExpr.ailang
// Expression compiler for the AILang self-hosting compiler
// Handles: Numbers, Identifiers, Strings, Function Calls
// Result of expression evaluation is always in RAX

//compiler modules
LibraryImport.Compiler.Compile.Modules.CCompileTypes
LibraryImport.Compiler.Compile.Modules.CCompileArith
LibraryImport.Compiler.Compile.Modules.CCompileIO
//LibraryImport.Compiler.Compile.Modules.CCompileCompare
//LibraryImport.Compiler.Compile.Modules.CCompileLogic
//LibraryImport.Compiler.Compile.Modules.CCompileFunc

//Ast node imports
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore

//emit methods
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem



// =============================================================================
// NUMBER LITERAL
// Loads immediate value into RAX
// =============================================================================
Function.CompileExpr_Number {
    Input: node: Address
    Output: Integer
    Body: {
        value = AST_GetData1(node)
        Emit_MovRaxImm64(value)
        ReturnValue(1)
    }
}

// =============================================================================
// STRING LITERAL
// Adds string to data section, loads address into RAX
// =============================================================================
Function.CompileExpr_String {
    Input: node: Address
    Output: Integer
    Body: {
        str_value = AST_GetData1(node)
        
        // Add string to data section
        str_offset = Emit_AddString(str_value)
        
        // Load data section address into RAX
        Emit_LoadDataAddress(Reg.RAX, str_offset)
        
        ReturnValue(1)
    }
}

// =============================================================================
// IDENTIFIER (Variable Reference)
// Loads variable value from stack frame into RAX
// =============================================================================
Function.CompileExpr_Identifier {
    Input: node: Address
    Output: Integer
    Body: {
        ReturnValue(0)
    }
}
// =============================================================================
// BOOLEAN LITERAL
// True = 1, False = 0
// =============================================================================
Function.CompileExpr_Boolean {
    Input: node: Address
    Output: Integer
    Body: {
        bool_value = AST_GetData1(node)
        
        IfCondition EqualTo(bool_value, 1) ThenBlock: {
            Emit_MovRaxImm64(1)
        } ElseBlock: {
            Emit_MovRaxImm64(0)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// UNARY OPERATION
// Handles prefix operators like Not, Negate
// =============================================================================
Function.CompileExpr_Unary {
    Input: node: Address
    Output: Integer
    Body: {
        op_type = AST_GetData1(node)
        operand = AST_GetChild(node, 0)
        
        // Compile operand first
        Compile_Expression(operand)
        
        // Apply unary operator
        IfCondition EqualTo(op_type, UnaryOp.NEGATE) ThenBlock: {
            Emit_NegRax()
            ReturnValue(1)
        }
        
        IfCondition EqualTo(op_type, UnaryOp.NOT) ThenBlock: {
            // Logical not: 0 -> 1, non-zero -> 0
            Emit_TestRaxRax()
            Emit_Setz()
            Emit_MovzxRaxAl()
            ReturnValue(1)
        }
        
        IfCondition EqualTo(op_type, UnaryOp.BITNOT) ThenBlock: {
            Emit_NotRax()
            ReturnValue(1)
        }
        
        Compile_SetError("Unknown unary operator", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// POOL ACCESS
// Handles PoolName.field syntax
// =============================================================================
Function.CompileExpr_PoolAccess {
    Input: name: Address
    Output: Integer
    Body: {
        // Check if name contains a dot (pool access)
        dot_pos = StringIndexOf(name, ".")
        IfCondition LessThan(dot_pos, 0) ThenBlock: {
            // No dot - not a pool access
            ReturnValue(0)
        }
        
        // Extract pool name and field name
        pool_name = StringSubstring(name, 0, dot_pos)
        field_name = StringSubstring(name, Add(dot_pos, 1), StringLength(name))
        
        // Look up pool in pool table
        pool_offset = Compile_FindPool(pool_name)
        IfCondition LessThan(pool_offset, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Look up field within pool
        field_offset = Compile_FindPoolField(pool_name, field_name)
        IfCondition LessThan(field_offset, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Load pool base from R15 (pool table base register)
        // Then add field offset and load value
        Emit_MovRaxR15Offset(pool_offset)
        Emit_MovRaxRaxOffset(field_offset)
        
        ReturnValue(1)
    }
}

// =============================================================================
// FUNCTION CALL DISPATCHER
// Tries each compile module until one handles the call
// =============================================================================
Function.Compile_FunctionCall {
    Input: node: Address
    Output: Integer
    Body: {
        // Try arithmetic operations
        result = CompileArith_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try I/O operations
        result = CompileIO_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try comparison operations
        result = CompileCompare_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try logical operations
        result = CompileLogic_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try bitwise operations
        result = CompileBitwise_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try string operations
        result = CompileString_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try memory operations
        result = CompileMem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try array operations
        result = CompileArray_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try system operations
        result = CompileSystem_TryCompile(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try user-defined functions
        result = CompileFunc_UserCall(node)
        IfCondition EqualTo(result, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Unknown function
        func_name = AST_GetData1(node)
        Compile_SetError("Unknown function", AST_GetLine(node))
        ReturnValue(0)
    }
}

