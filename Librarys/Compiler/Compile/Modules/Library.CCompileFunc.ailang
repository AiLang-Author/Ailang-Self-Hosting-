// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// Library.CCompileFunc.ailang
// Function, SubRoutine, and call compilation for the AILang self-hosting compiler
// Mirrors user_functions.py from the Python compiler
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileFunc.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
LibraryImport.Compiler.Compile.CCompileMain

// =============================================================================
// FUNCTION DEFINITION COMPILATION
// Function.Name { Input: params Output: type Body: { ... } }
// Mirrors user_functions.py compile_function_definition()
// =============================================================================
Function.CompileFunc_Function {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get function name
        func_name = AST_GetData1(node)
        
        // Look up the label (registered in pass 1)
        func_label = Compile_FindFunction(func_name)
        IfCondition LessThan(func_label, 0) ThenBlock: {
            Compile_Error("Function not registered", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Save previous function context
        prev_func = Compile.current_func
        prev_stack_offset = Compile.stack_offset
        Compile.current_func = node
        Compile.stack_offset = 0
        
        // CRITICAL: Jump over function definition during normal execution
        skip_label = Emit_CreateLabel()
        X86_Jmp(skip_label)
        
        // Mark function entry point
        Emit_MarkLabel(func_label)
        
        // === FUNCTION PROLOGUE ===
        // PUSH RBP; MOV RBP, RSP
        X86_PushRbp()
        X86_MovRegReg(Reg.RBP, Reg.RSP)
        
        // Save callee-saved registers (AMD64 ABI: RBX, R12, R13, R14)
        X86_PushRbx()
        X86_PushR12()
        X86_PushR13()
        X86_PushR14()
        
        // Count parameters and find body
        param_count = 0
        body_node = 0
        
        child_count = AST_GetChildCount(node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            child = AST_GetChild(node, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.PARAMETER) ThenBlock: {
                param_count = Add(param_count, 1)
            }
            
            IfCondition EqualTo(child_type, AST.BODY) ThenBlock: {
                body_node = child
            }
            
            i = Add(i, 1)
        }
        
        // Allocate stack space for parameters + locals + saved regs
        // 32 bytes for 4 callee-saved regs already pushed
        // Estimate 8 locals * 8 bytes = 64 for locals
        // Round up to 16-byte alignment
        local_space = 64
        param_space = Multiply(param_count, 8)
        total_space = Add(local_space, param_space)
        // Align to 16 bytes
        stack_space = BitwiseAnd(Add(total_space, 15), -16)
        
        IfCondition GreaterThan(stack_space, 0) ThenBlock: {
            X86_SubRspImm32(stack_space)
        }
        Compile.stack_size = stack_space
        
        // Save parameters from registers to stack
        // System V AMD64: RDI, RSI, RDX, RCX, R8, R9
        IfCondition GreaterEqual(param_count, 1) ThenBlock: {
            X86_MovRegReg(Reg.RAX, Reg.RDI)
            X86_MovRbpOffsetRax(-8)
        }
        IfCondition GreaterEqual(param_count, 2) ThenBlock: {
            X86_MovRegReg(Reg.RAX, Reg.RSI)
            X86_MovRbpOffsetRax(-16)
        }
        IfCondition GreaterEqual(param_count, 3) ThenBlock: {
            X86_MovRegReg(Reg.RAX, Reg.RDX)
            X86_MovRbpOffsetRax(-24)
        }
        IfCondition GreaterEqual(param_count, 4) ThenBlock: {
            X86_MovRegReg(Reg.RAX, Reg.RCX)
            X86_MovRbpOffsetRax(-32)
        }
        IfCondition GreaterEqual(param_count, 5) ThenBlock: {
            X86_MovRegReg(Reg.RAX, Reg.R8)
            X86_MovRbpOffsetRax(-40)
        }
        IfCondition GreaterEqual(param_count, 6) ThenBlock: {
            X86_MovRegReg(Reg.RAX, Reg.R9)
            X86_MovRbpOffsetRax(-48)
        }
        
        // Register parameters as local variables
        CompileFunc_RegisterParams(node, param_count)
        
        // Compile the body
        IfCondition NotEqual(body_node, 0) ThenBlock: {
            CompileFunc_CompileBody(body_node)
        }
        
        // If no explicit return, add default return 0
        X86_XorRaxRax()
        
        // === FUNCTION EPILOGUE ===
        // Restore callee-saved registers in REVERSE order
        X86_PopR14()
        X86_PopR13()
        X86_PopR12()
        X86_PopRbx()
        
        // MOV RSP, RBP; POP RBP; RET
        X86_MovRegReg(Reg.RSP, Reg.RBP)
        X86_PopRbp()
        X86_Ret()
        
        // Mark skip label - continue normal execution
        Emit_MarkLabel(skip_label)
        
        // Restore previous context
        Compile.current_func = prev_func
        Compile.stack_offset = prev_stack_offset
        
        ReturnValue(1)
    }
}

// =============================================================================
// SUBROUTINE DEFINITION COMPILATION
// SubRoutine.Name { ... }
// Mirrors ailang_compiler.py compile_subroutine()
// =============================================================================
Function.CompileFunc_SubRoutine {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get subroutine name
        sub_name = AST_GetData1(node)
        
        // Look up the label (registered in pass 1)
        sub_label = Compile_FindFunction(sub_name)
        IfCondition LessThan(sub_label, 0) ThenBlock: {
            Compile_Error("SubRoutine not registered", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Save context
        prev_func = Compile.current_func
        Compile.current_func = node
        
        // CRITICAL: Jump over subroutine definition
        skip_label = Emit_CreateLabel()
        X86_Jmp(skip_label)
        
        // Mark subroutine entry point
        Emit_MarkLabel(sub_label)
        
        // === SUBROUTINE PROLOGUE ===
        // Save callee-saved registers (AMD64 ABI)
        X86_PushRbx()
        X86_PushR12()
        X86_PushR13()
        X86_PushR14()
        
        // Create return label for early ReturnValue calls
        return_label = Emit_CreateLabel()
        Compile.current_return_label = return_label
        
        // Compile the body - all children are statements
        child_count = AST_GetChildCount(node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                ExitLoop
            }
            
            child = AST_GetChild(node, i)
            child_type = AST_GetType(child)
            
            // Compile each statement
            IfCondition EqualTo(child_type, AST.BODY) ThenBlock: {
                CompileFunc_CompileBody(child)
            } ElseBlock: {
                Compile_Node(child)
            }
            
            i = Add(i, 1)
        }
        
        // Mark return point (for early returns)
        Emit_MarkLabel(return_label)
        
        // === SUBROUTINE EPILOGUE ===
        // Restore callee-saved registers in REVERSE order
        X86_PopR14()
        X86_PopR13()
        X86_PopR12()
        X86_PopRbx()
        
        X86_Ret()
        
        // Mark skip label - continue normal execution
        Emit_MarkLabel(skip_label)
        
        // Restore context
        Compile.current_func = prev_func
        Compile.current_return_label = 0
        
        ReturnValue(1)
    }
}

// =============================================================================
// COMPILE BODY BLOCK
// =============================================================================
Function.CompileFunc_CompileBody {
    Input: body_node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(body_node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        child_count = AST_GetChildCount(body_node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                ExitLoop
            }
            
            child = AST_GetChild(body_node, i)
            Compile_Node(child)
            
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// REGISTER FUNCTION PARAMETERS AS LOCAL VARIABLES
// =============================================================================
Function.CompileFunc_RegisterParams {
    Input: func_node: Address
    Input: param_count: Integer
    Body: {
        child_count = AST_GetChildCount(func_node)
        param_index = 0
        i = 0
        
        WhileLoop LessThan(i, child_count) {
            child = AST_GetChild(func_node, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.PARAMETER) ThenBlock: {
                param_name = AST_GetData1(child)
                // Stack offset: -8, -16, -24, etc.
                offset = Multiply(Add(param_index, 1), -8)
                Compile_RegisterLocal(param_name, offset)
                param_index = Add(param_index, 1)
            }
            
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// REGISTER A LOCAL VARIABLE
// =============================================================================
Function.Compile_RegisterLocal {
    Input: name: Address
    Input: offset: Integer
    Body: {
        entry = Allocate(24)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), offset)
        StoreValue(Add(entry, 16), VarType.LOCAL)
        XArray.XPush(Compile.variables, entry)
    }
}

// =============================================================================
// RUNTASK COMPILATION
// RunTask(SubRoutineName) - calls a subroutine by name
// Mirrors ailang_compiler.py compile_run_task()
// =============================================================================
Function.CompileFunc_RunTask {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get the task name - can be in DATA1 or first child
        task_name = AST_GetData1(node)
        
        IfCondition EqualTo(task_name, 0) ThenBlock: {
            // Try getting from first argument
            arg_count = AST_GetChildCount(node)
            IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
                arg = AST_GetChild(node, 0)
                task_name = AST_GetData1(arg)
            }
        }
        
        IfCondition EqualTo(task_name, 0) ThenBlock: {
            Compile_Error("RunTask requires a task name", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Look up the subroutine label
        task_label = Compile_FindFunction(task_name)
        IfCondition LessThan(task_label, 0) ThenBlock: {
            Compile_Error("Unknown subroutine for RunTask", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Emit CALL to the subroutine
        X86_Call(task_label)
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// USER-DEFINED FUNCTION CALL
// result = FunctionName(arg1, arg2, ...)
// Mirrors user_functions.py compile_function_call()
// =============================================================================
Function.CompileFunc_UserCall {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get function name
        func_name = AST_GetData1(node)
        
        // Look up the function label
        func_label = Compile_FindFunction(func_name)
        IfCondition LessThan(func_label, 0) ThenBlock: {
            // Not a user function - return 0 to try other dispatchers
            ReturnValue(0)
        }
        
        // Count arguments
        arg_count = AST_GetChildCount(node)
        
        // === ARGUMENT PASSING ===
        // Push arguments in REVERSE order, then pop into registers in forward order
        // This is the pattern from user_functions.py
        
        IfCondition GreaterThan(arg_count, 0) ThenBlock: {
            // Push args in reverse order (rightmost first)
            i = Subtract(arg_count, 1)
            WhileLoop GreaterEqual(i, 0) {
                arg = AST_GetChild(node, i)
                Compile_Expression(arg)
                X86_PushRax()
                i = Subtract(i, 1)
            }
            
            // Pop into registers in forward order
            // System V AMD64: RDI, RSI, RDX, RCX, R8, R9
            IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
                X86_PopRdi()
            }
            IfCondition GreaterEqual(arg_count, 2) ThenBlock: {
                X86_PopRsi()
            }
            IfCondition GreaterEqual(arg_count, 3) ThenBlock: {
                X86_PopRdx()
            }
            IfCondition GreaterEqual(arg_count, 4) ThenBlock: {
                X86_PopRcx()
            }
            IfCondition GreaterEqual(arg_count, 5) ThenBlock: {
                X86_PopR8()
            }
            IfCondition GreaterEqual(arg_count, 6) ThenBlock: {
                X86_PopR9()
            }
        }
        
        // Align stack to 16 bytes before CALL
        // AND RSP, -16 (0xF0 as signed byte)
        X86_AndRspImm8(240)  // 240 = 0xF0 = -16 as unsigned byte
        
        // CALL the function
        X86_Call(func_label)
        
        // Result is in RAX
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// DISPATCHER FOR FUNCTION-RELATED CALLS
// Called from Compile_FunctionCall
// =============================================================================
Function.CompileFunc_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        // Check for RunTask
        cmp = StringCompare(func_name, "RunTask")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFunc_RunTask(node))
        }
        
        // Check for ReturnValue
        cmp = StringCompare(func_name, "ReturnValue")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFunc_ReturnValue(node))
        }
        
        // Try as user function call
        ReturnValue(CompileFunc_UserCall(node))
    }
}

// =============================================================================
// RETURNVALUE COMPILATION
// ReturnValue(expr) - return from function/subroutine with value
// Mirrors user_functions.py compile_return()
// =============================================================================
Function.CompileFunc_ReturnValue {
    Input: node: Address
    Output: Integer
    Body: {
        // Compile the return expression into RAX
        arg_count = AST_GetChildCount(node)
        IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
            arg = AST_GetChild(node, 0)
            Compile_Expression(arg)
        } ElseBlock: {
            // No argument - return 0
            X86_XorRaxRax()
        }
        
        // Check if we're in a SubRoutine (has return label)
        IfCondition NotEqual(Compile.current_return_label, 0) ThenBlock: {
            // SubRoutine context - jump to return label
            X86_Jmp(Compile.current_return_label)
        } ElseBlock: {
            // Function context - emit full epilogue
            // Restore callee-saved registers
            X86_PopR14()
            X86_PopR13()
            X86_PopR12()
            X86_PopRbx()
            
            // Function epilogue
            X86_MovRegReg(Reg.RSP, Reg.RBP)
            X86_PopRbp()
            X86_Ret()
        }
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// HELPER: FIND FUNCTION BY NAME
// Returns label ID or -1 if not found
// =============================================================================
Function.Compile_FindFunction {
    Input: name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        count = XArray.XSize(Compile.functions)
        i = 0
        
        WhileLoop LessThan(i, count) {
            entry = XArray.XGet(Compile.functions, i)
            stored_name = Dereference(entry)
            
            cmp = StringCompare(name, stored_name)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                label = Dereference(Add(entry, 8))
                ReturnValue(label)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(-1)
    }
}

// =============================================================================
// REGISTER FUNCTION (called from pass 1)
// =============================================================================
Function.Compile_RegisterFunction {
    Input: name: Address
    Input: label: Integer
    Body: {
        entry = Allocate(16)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), label)
        XArray.XPush(Compile.functions, entry)
    }
}