// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileFunc.ailang
// Function and SubRoutine compiler module for the AILang self-hosting compiler
// Handles: Function definitions, SubRoutine definitions, user function calls

LibraryImport.Compiler.Compile.CCompileTypes
LibraryImport.Compiler.Compile.Modules.CCompileStmt
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump

// =============================================================================
// CURRENT FUNCTION STATE
// =============================================================================
FixedPool.FuncState {
    "exit_label": Initialize=-1, CanChange=True
    "param_count": Initialize=0, CanChange=True
    "local_size": Initialize=0, CanChange=True
}

// =============================================================================
// GET FUNCTION EXIT LABEL (for ReturnValue)
// =============================================================================
Function.Compile_GetFunctionExitLabel {
    Output: Integer
    Body: {
        ReturnValue(FuncState.exit_label)
    }
}

// =============================================================================
// COMPILE FUNCTION DEFINITION
// Function.Name { Input: ... Output: ... Body: { ... } }
// =============================================================================
Function.CompileFunc_Function {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetFunctionName(node)
        params = AST_GetFunctionParams(node)
        body = AST_GetFunctionBody(node)
        param_count = AST_GetFunctionParamCount(node)
        
        // Create label for function entry
        func_label = Compile_NewLabel()
        exit_label = Compile_NewLabel()
        
        // Register function
        Compile_AddFunction(func_name, func_label, param_count, VarType.INTEGER)
        
        // Set current function context
        Compile_EnterFunction(func_name)
        FuncState.exit_label = exit_label
        FuncState.param_count = param_count
        
        // Emit function label
        Emit_MarkLabel(func_label)
        
        // Emit prologue
        // PUSH RBP
        X86_PushRbp()
        // MOV RBP, RSP
        X86_MovRbpRsp()
        
        // Reserve space for locals (will patch later)
        local_space_fixup = Emit_GetCodePos()
        // SUB RSP, imm32 (placeholder)
        X86_SubRspImm(0)
        
        // Process parameters - they come in registers or on stack
        // System V AMD64 ABI: RDI, RSI, RDX, RCX, R8, R9
        i = 0
        WhileLoop LessThan(i, param_count) {
            param = AST_GetParam(params, i)
            param_name = AST_GetParamName(param)
            param_type = AST_GetParamType(param)
            
            // Allocate stack space for parameter
            param_offset = Compile_AddVariable(param_name, param_type, 8, VarFlags.PARAM)
            
            // Move from register to stack
            IfCondition EqualTo(i, 0) ThenBlock: {
                X86_MovRbpOffsetRdi(param_offset)
            }
            IfCondition EqualTo(i, 1) ThenBlock: {
                X86_MovRbpOffsetRsi(param_offset)
            }
            IfCondition EqualTo(i, 2) ThenBlock: {
                X86_MovRbpOffsetRdx(param_offset)
            }
            IfCondition EqualTo(i, 3) ThenBlock: {
                X86_MovRbpOffsetRcx(param_offset)
            }
            IfCondition EqualTo(i, 4) ThenBlock: {
                X86_MovRbpOffsetR8(param_offset)
            }
            IfCondition EqualTo(i, 5) ThenBlock: {
                X86_MovRbpOffsetR9(param_offset)
            }
            // Parameters 7+ would be on stack (not handled yet)
            
            i = Add(i, 1)
        }
        
        // Compile function body
        result = CompileStmt_Block(body)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_ExitFunction()
            ReturnValue(0)
        }
        
        // Exit label
        Emit_MarkLabel(exit_label)
        
        // Emit epilogue
        // MOV RSP, RBP
        X86_MovRspRbp()
        // POP RBP
        X86_PopRbp()
        // RET
        X86_Ret()
        
        // Patch local space reservation
        local_size = Compile_GetStackSize()
        FuncState.local_size = local_size
        Emit_PatchImm32(local_space_fixup, local_size)
        
        // Exit function context
        Compile_ExitFunction()
        FuncState.exit_label = -1
        
        ReturnValue(1)
    }
}

// =============================================================================
// COMPILE SUBROUTINE DEFINITION
// SubRoutine.Name { ... }
// Like Function but no return value
// =============================================================================
Function.CompileFunc_SubRoutine {
    Input: node: Address
    Output: Integer
    Body: {
        sub_name = AST_GetSubRoutineName(node)
        params = AST_GetSubRoutineParams(node)
        body = AST_GetSubRoutineBody(node)
        param_count = AST_GetSubRoutineParamCount(node)
        
        // Create labels
        sub_label = Compile_NewLabel()
        exit_label = Compile_NewLabel()
        
        // Register subroutine (return type = 0 means void)
        Compile_AddFunction(sub_name, sub_label, param_count, 0)
        
        // Set context
        Compile_EnterFunction(sub_name)
        FuncState.exit_label = exit_label
        FuncState.param_count = param_count
        
        // Emit label
        Emit_MarkLabel(sub_label)
        
        // Prologue
        X86_PushRbp()
        X86_MovRbpRsp()
        
        local_space_fixup = Emit_GetCodePos()
        X86_SubRspImm(0)
        
        // Process parameters
        i = 0
        WhileLoop LessThan(i, param_count) {
            param = AST_GetParam(params, i)
            param_name = AST_GetParamName(param)
            param_type = AST_GetParamType(param)
            
            param_offset = Compile_AddVariable(param_name, param_type, 8, VarFlags.PARAM)
            
            IfCondition EqualTo(i, 0) ThenBlock: {
                X86_MovRbpOffsetRdi(param_offset)
            }
            IfCondition EqualTo(i, 1) ThenBlock: {
                X86_MovRbpOffsetRsi(param_offset)
            }
            IfCondition EqualTo(i, 2) ThenBlock: {
                X86_MovRbpOffsetRdx(param_offset)
            }
            IfCondition EqualTo(i, 3) ThenBlock: {
                X86_MovRbpOffsetRcx(param_offset)
            }
            IfCondition EqualTo(i, 4) ThenBlock: {
                X86_MovRbpOffsetR8(param_offset)
            }
            IfCondition EqualTo(i, 5) ThenBlock: {
                X86_MovRbpOffsetR9(param_offset)
            }
            
            i = Add(i, 1)
        }
        
        // Compile body
        result = CompileStmt_Block(body)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_ExitFunction()
            ReturnValue(0)
        }
        
        // Exit label
        Emit_MarkLabel(exit_label)
        
        // Epilogue
        X86_MovRspRbp()
        X86_PopRbp()
        X86_Ret()
        
        // Patch locals
        local_size = Compile_GetStackSize()
        Emit_PatchImm32(local_space_fixup, local_size)
        
        Compile_ExitFunction()
        FuncState.exit_label = -1
        
        ReturnValue(1)
    }
}

// =============================================================================
// COMPILE USER FUNCTION CALL
// FunctionName(arg1, arg2, ...)
// =============================================================================
Function.CompileFunc_UserCall {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetFunctionName(node)
        
        // Look up function in registry
        func_label = Compile_FindFunction(func_name)
        IfCondition LessThan(func_label, 0) ThenBlock: {
            // Function not found
            ReturnValue(0)
        }
        
        arg_count = AST_GetArgCount(node)
        
        // Evaluate arguments and place in registers (System V ABI order)
        // RDI, RSI, RDX, RCX, R8, R9
        
        // For more than 6 args, we'd push to stack (not implemented)
        IfCondition GreaterThan(arg_count, 6) ThenBlock: {
            Compile_SetError("More than 6 arguments not supported", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Compile arguments in reverse order, save to temp registers or stack
        // Then move to correct ABI registers
        
        // Simple approach: compile each arg and push, then pop into correct regs
        i = 0
        WhileLoop LessThan(i, arg_count) {
            arg = AST_GetArg(node, i)
            Compile_Expression(arg)
            X86_PushRax()
            i = Add(i, 1)
        }
        
        // Pop into registers in correct order
        // Args were pushed 0, 1, 2... so pop in reverse to get correct order
        IfCondition GreaterEqual(arg_count, 6) ThenBlock: {
            X86_PopR9()
        }
        IfCondition GreaterEqual(arg_count, 5) ThenBlock: {
            X86_PopR8()
        }
        IfCondition GreaterEqual(arg_count, 4) ThenBlock: {
            X86_PopRcx()
        }
        IfCondition GreaterEqual(arg_count, 3) ThenBlock: {
            X86_PopRdx()
        }
        IfCondition GreaterEqual(arg_count, 2) ThenBlock: {
            X86_PopRsi()
        }
        IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
            X86_PopRdi()
        }
        
        // CALL function
        Emit_CallToLabel(func_label)
        
        // Result is in RAX
        ReturnValue(1)
    }
}

// =============================================================================
// RUNTASK
// RunTask(SubRoutineName) - calls a subroutine as entry point
// =============================================================================
Function.CompileFunc_RunTask {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("RunTask requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg = AST_GetArg(node, 0)
        task_name = AST_GetIdentifierName(arg)
        
        // Look up the subroutine
        task_label = Compile_FindFunction(task_name)
        IfCondition LessThan(task_label, 0) ThenBlock: {
            Compile_SetError("Unknown subroutine for RunTask", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // CALL the subroutine
        Emit_CallToLabel(task_label)
        
        ReturnValue(1)
    }
}

// =============================================================================
// DISPATCHER FOR FUNCTION-RELATED CALLS
// =============================================================================
Function.CompileFunc_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetFunctionName(node)
        
        IfCondition EqualTo(StringCompare(func_name, "RunTask"), 0) ThenBlock: {
            ReturnValue(CompileFunc_RunTask(node))
        }
        
        // Try as user function call
        ReturnValue(CompileFunc_UserCall(node))
    }
}