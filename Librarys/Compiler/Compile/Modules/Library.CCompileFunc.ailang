// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// Library.CCompileFunc.ailang
// Function, SubRoutine, and call compilation for the AILang self-hosting compiler
// Mirrors user_functions.py from the Python compiler
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileFunc.ailang
//
// CRITICAL FIX: Stack frame layout now matches SubRoutine pattern
// - SUB RSP for locals BEFORE pushing callee-saved registers
// - POP callee-saved BEFORE ADD RSP to deallocate
// - Parameters stored at RBP-8, RBP-16, etc. (within allocated space)

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch
LibraryImport.Compiler.Compile.Modules.CCompileScope

// =============================================================================
// Library.CCompileFunc.ailang
// Function, SubRoutine, and call compilation for the AILang self-hosting compiler
// =============================================================================
//
// ARCHITECTURE NOTES - READ BEFORE MODIFYING
// =============================================================================
//
// STACK ALIGNMENT (System V AMD64 ABI):
//
//   Call sites: RSP must be 16-byte aligned at CALL instruction.
//   Currently handled in CompileFunc_UserCall via:
//     MOV R11, RSP      ; Save original RSP
//     AND RSP, -16      ; Align to 16 bytes
//     CALL target
//     MOV RSP, R11      ; Restore RSP (critical for nested expressions)
//
//   R11 is caller-saved, safe to use as scratch without preservation.
//
// FUTURE: SIMD/FPU ALIGNMENT
//
//   When adding SSE/AVX/AVX-512 support, alignment requirements increase:
//
//   | Type    | Registers | Required Alignment |
//   |---------|-----------|-------------------|
//   | SSE     | XMM0-15   | 16-byte (current) |
//   | AVX     | YMM0-15   | 32-byte           |
//   | AVX-512 | ZMM0-31   | 64-byte           |
//
//   CALLER responsibility (call sites): Always 16-byte - no change needed.
//   CALLEE responsibility (function prologue): Align to 32/64 if using AVX/512.
//
//   Implementation plan for AVX functions:
//   1. Add Function attribute: Alignment: 32 or Alignment: 64
//   2. In CompileFunc_Function prologue, after PUSH RBP; MOV RBP, RSP:
//        IfCondition GreaterThan(func_alignment, 16) ThenBlock: {
//            Emit_AndRspAlignment(func_alignment)  // AND RSP, -32 or -64
//        }
//   3. Epilogue must restore via RBP since RSP was modified:
//        MOV RSP, RBP  (already doing this)
//        POP RBP
//        RET
//
//   Alternative: Auto-detect alignment from SIMD instruction usage in body.
//   Alternative: AVXBlock: { } syntax for scoped alignment regions.
//
//   DO NOT add larger alignment at call sites - that breaks nested expressions.
//   The callee handles its own alignment needs in its prologue.
//
// STACK FRAME LAYOUT (after prologue):
//
//   RBP+8   = return address
//   RBP+0   = saved RBP
//   RBP-8   = param 1 / local 1
//   RBP-16  = param 2 / local 2
//   ...
//   RBP-N   = end of allocated space (N = stack_space)
//   [pushed callee-saved registers below this]
//   RSP ->
//
// CALLEE-SAVED REGISTERS (must preserve across calls):
//   RBX, R12, R13, R14, R15, RBP
//   Currently saving: RBX, R12, R13, R14 (R15 reserved for pool base)
//
// CALLER-SAVED REGISTERS (scratch, not preserved):
//   RAX, RCX, RDX, RSI, RDI, R8, R9, R10, R11
//   R11 is used for RSP preservation during aligned calls.
//
// =============================================================================

// =============================================================================
// FUNCTION DEFINITION COMPILATION
// Function.Name { Input: params Output: type Body: { ... } }
// Mirrors user_functions.py compile_function_definition()
//
// STACK FRAME LAYOUT (after prologue):
//   RBP+8   = return address
//   RBP+0   = saved RBP
//   RBP-8   = param 1 / local 1
//   RBP-16  = param 2 / local 2
//   ...
//   RBP-N   = end of allocated space (N = stack_space)
//   RBP-N-8 = saved RBX  (pushed AFTER SUB)
//   RBP-N-16= saved R12
//   RBP-N-24= saved R13
//   RBP-N-32= saved R14
//   RSP ->
// =============================================================================
Function.CompileFunc_Function {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get function name
        func_name = AST_GetData1(node)
        
        PrintMessage("[FUNCDEF] Compiling function: ")
        PrintString(func_name)
        PrintMessage("\n")
        
        // Look up the label (registered in pass 1)
        func_label = Compile_FindFunction(func_name)
        IfCondition LessThan(func_label, 0) ThenBlock: {
            Compile_Error("Function not registered", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Save previous function context
        prev_func = Compile.current_func
        prev_stack_offset = Compile.stack_offset
        prev_return_label = Compile.current_return_label
        Compile.current_func = node
        
        // CRITICAL: Save global scope and create fresh function scope
        Scope_SaveAndClear(func_name)
        
        // CRITICAL: Jump over function definition during normal execution
        skip_label = Emit_CreateLabel()
        Emit_Jmp(skip_label)
        
        // Mark function entry point
        Emit_MarkLabel(func_label)
        
        // === FUNCTION PROLOGUE ===
        Emit_PushRbp()
        Emit_MovRegReg(Reg.RBP, Reg.RSP)
        
        // Count parameters and find body BEFORE allocating stack
        param_count = 0
        body_node = 0
        
        child_count = AST_GetChildCount(node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            child = AST_GetChild(node, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.PARAMETER) ThenBlock: {
                param_count = Add(param_count, 1)
            }
            
            IfCondition EqualTo(child_type, AST.BLOCK) ThenBlock: {
                body_node = child
            }
            
            i = Add(i, 1)
        }
        
        // Calculate stack space
        local_space = 64
        param_space = Multiply(param_count, 8)
        total_space = Add(local_space, param_space)
        stack_space = BitwiseAnd(Add(total_space, 15), -16)
        
        // Allocate stack space FIRST
        IfCondition GreaterThan(stack_space, 0) ThenBlock: {
            Emit_SubRspImm32(stack_space)
        }
        Compile.stack_size = stack_space
        
        // THEN save callee-saved registers
        Emit_PushRbx()
        Emit_PushR12()
        Emit_PushR13()
        Emit_PushR14()
        
        // === SPILL ARGUMENT REGISTERS TO STACK ===
        // Caller passes args in RDI, RSI, RDX, RCX, R8, R9
        // Body expects them at [RBP-8], [RBP-16], [RBP-24], etc.
        PrintMessage("[FUNCDEF] Spilling ")
        PrintNumber(param_count)
        PrintMessage(" params to stack\n")
        
        IfCondition GreaterEqual(param_count, 1) ThenBlock: {
            Emit_MovRaxRdi()
            Emit_MovRbpOffsetRax(-8)
            PrintMessage("[FUNCDEF] Spilled param 1: RDI -> [RBP-8]\n")
        }
        IfCondition GreaterEqual(param_count, 2) ThenBlock: {
            Emit_MovRaxRsi()
            Emit_MovRbpOffsetRax(-16)
            PrintMessage("[FUNCDEF] Spilled param 2: RSI -> [RBP-16]\n")
        }
        IfCondition GreaterEqual(param_count, 3) ThenBlock: {
            Emit_MovRaxRdx()
            Emit_MovRbpOffsetRax(-24)
            PrintMessage("[FUNCDEF] Spilled param 3: RDX -> [RBP-24]\n")
        }
        IfCondition GreaterEqual(param_count, 4) ThenBlock: {
            Emit_MovRaxRcx()
            Emit_MovRbpOffsetRax(-32)
            PrintMessage("[FUNCDEF] Spilled param 4: RCX -> [RBP-32]\n")
        }
        IfCondition GreaterEqual(param_count, 5) ThenBlock: {
            Emit_MovRaxR8()
            Emit_MovRbpOffsetRax(-40)
            PrintMessage("[FUNCDEF] Spilled param 5: R8 -> [RBP-40]\n")
        }
        IfCondition GreaterEqual(param_count, 6) ThenBlock: {
            Emit_MovRaxR9()
            Emit_MovRbpOffsetRax(-48)
            PrintMessage("[FUNCDEF] Spilled param 6: R9 -> [RBP-48]\n")
        }
        // === END SPILL ===
        
        // Register parameters as local variables
        CompileFunc_RegisterParams(node, param_count)
        
        // === FIX: Set stack_offset to start AFTER parameters ===
        // Parameters are at -8, -16, -24, etc.
        // Locals should start at -(param_count*8 + 8), -(param_count*8 + 16), etc.
        Compile.stack_offset = Multiply(param_count, 8)
        PrintMessage("[FUNCDEF] stack_offset set to ")
        PrintNumber(Compile.stack_offset)
        PrintMessage(" (after ")
        PrintNumber(param_count)
        PrintMessage(" params)\n")
        // === END FIX ===
        
        // === Create return label for ReturnValue calls ===
        return_label = Emit_CreateLabel()
        Compile.current_return_label = return_label
        PrintMessage("[FUNCDEF] Created return_label = ")
        PrintNumber(return_label)
        PrintMessage("\n")
        // === END ADD ===
        
        // Compile the body
        IfCondition NotEqual(body_node, 0) ThenBlock: {
            CompileFunc_CompileBody(body_node)
        }
        
        // Default return 0 for fall-through (no explicit ReturnValue)
        // This is BEFORE the return_label so ReturnValue jumps skip it
        Emit_XorRaxRax()
        
        // === Mark the return label - ReturnValue jumps land HERE ===
        // RAX already contains the return value from ReturnValue
        Emit_MarkLabel(return_label)
        
        // === FUNCTION EPILOGUE ===
        Emit_PopR14()
        Emit_PopR13()
        Emit_PopR12()
        Emit_PopRbx()
        
        IfCondition GreaterThan(stack_space, 0) ThenBlock: {
            Emit_AddRspImm32(stack_space)
        }
        
        Emit_PopRbp()
        Emit_Ret()
        
        // Mark skip label
        Emit_MarkLabel(skip_label)
        
        // Restore previous scope
        Scope_ClearFunctionParams(func_name)
        Scope_Restore()
        
        // Restore previous context
        Compile.current_func = prev_func
        Compile.current_return_label = prev_return_label
        
        ReturnValue(1)
    }
}
// =============================================================================
// SUBROUTINE DEFINITION COMPILATION
// SubRoutine.Name { ... }
// Mirrors ailang_compiler.py compile_subroutine()
// NOTE: SubRoutine already has correct stack frame order
// =============================================================================
Function.CompileFunc_SubRoutine {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get subroutine name
        sub_name = AST_GetData1(node)
        
        // Look up the label (registered in pass 1)
        sub_label = Compile_FindFunction(sub_name)
        IfCondition LessThan(sub_label, 0) ThenBlock: {
            Compile_Error("SubRoutine not registered", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Save context
        prev_func = Compile.current_func
        prev_stack_offset = Compile.stack_offset
        Compile.current_func = node
        Compile.stack_offset = 0
        
        // CRITICAL: Jump over subroutine definition
        skip_label = Emit_CreateLabel()
        Emit_Jmp(skip_label)
        
        // Mark subroutine entry point
        Emit_MarkLabel(sub_label)
        
        // === SUBROUTINE PROLOGUE ===
        Emit_PushRbp()
        Emit_MovRbpRsp()
        
        // Allocate stack space FIRST (64 bytes default)
        Emit_SubRspImm32(64)
        
        // THEN save callee-saved registers
        Emit_PushRbx()
        Emit_PushR12()
        Emit_PushR13()
        Emit_PushR14()
        
        // Create return label for early ReturnValue calls
        return_label = Emit_CreateLabel()
        Compile.current_return_label = return_label
        
        // Compile the body
        child_count = AST_GetChildCount(node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                ExitLoop
            }
            
            child = AST_GetChild(node, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.BODY) ThenBlock: {
                CompileFunc_CompileBody(child)
            } ElseBlock: {
                Compile_Node(child)
            }
            
            i = Add(i, 1)
        }
        
        // Mark return point
        Emit_MarkLabel(return_label)
        
        // === SUBROUTINE EPILOGUE ===
        // Pop callee-saved FIRST (correct order)
        Emit_PopR14()
        Emit_PopR13()
        Emit_PopR12()
        Emit_PopRbx()
        
        // THEN deallocate stack space
        Emit_AddRspImm32(64)
        Emit_PopRbp()
        
        Emit_Ret()
        
        // Mark skip label
        Emit_MarkLabel(skip_label)
        
        // Restore context
        Compile.current_func = prev_func
        Compile.stack_offset = prev_stack_offset
        Compile.current_return_label = 0
        
        ReturnValue(1)
    }
}

// =============================================================================
// COMPILE BODY BLOCK
// =============================================================================
Function.CompileFunc_CompileBody {
    Input: body_node: Address
    Output: Integer
    Body: {
        PrintMessage("[BODY] CompileBody called, node=")
        PrintNumber(body_node)
        PrintMessage("\n")
        
        IfCondition EqualTo(body_node, 0) ThenBlock: {
            PrintMessage("[BODY] Body node is NULL!\n")
            ReturnValue(1)
        }
        
        child_count = AST_GetChildCount(body_node)
        PrintMessage("[BODY] Child count: ")
        PrintNumber(child_count)
        PrintMessage("\n")
        
        i = 0
        WhileLoop LessThan(i, child_count) {
            PrintMessage("[BODY] Compiling child ")
            PrintNumber(i)
            PrintMessage("\n")
            
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                ExitLoop
            }
            
            child = AST_GetChild(body_node, i)
            Compile_Node(child)
            i = Add(i, 1)
        }
        
        PrintMessage("[BODY] Done\n")
        ReturnValue(1)
    }
}

// =============================================================================
// REGISTER FUNCTION PARAMETERS AS LOCAL VARIABLES
// UPDATED: Parameters now at RBP-8, RBP-16, etc. (within allocated space)
// Also registers with scope manager for proper resolution
// =============================================================================
Function.CompileFunc_RegisterParams {
    Input: func_node: Address
    Input: param_count: Integer
    Body: {
        child_count = AST_GetChildCount(func_node)
        param_index = 0
        i = 0

        WhileLoop LessThan(i, child_count) {
            child = AST_GetChild(func_node, i)
            child_type = AST_GetType(child)

            IfCondition EqualTo(child_type, AST.PARAMETER) ThenBlock: {
                param_name = AST_GetData1(child)
                // FIXED: Stack offset now starts at -8, -16, -24, etc.
                offset = Multiply(Add(param_index, 1), -8)
                
                // Register as local variable
                Compile_RegisterLocal(param_name, offset)
                
                // ALSO register with scope manager for resolution
                Scope_AddParameter(param_name, offset)
                
                param_index = Add(param_index, 1)
            }

            i = Add(i, 1)
        }
    }
}

// =============================================================================
// REGISTER A LOCAL VARIABLE
// =============================================================================
Function.Compile_RegisterLocal {
    Input: name: Address
    Input: offset: Integer
    Body: {
        entry = Allocate(24)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), offset)
        StoreValue(Add(entry, 16), VarType.LOCAL)
        XArray.XPush(Compile.variables, entry)
    }
}

// =============================================================================
// RUNTASK COMPILATION
// RunTask(SubRoutineName) - calls a subroutine by name
// =============================================================================
Function.CompileFunc_RunTask {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get the task name
        task_name = AST_GetData1(node)
        
        IfCondition EqualTo(task_name, 0) ThenBlock: {
            arg_count = AST_GetChildCount(node)
            IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
                arg = AST_GetChild(node, 0)
                task_name = AST_GetData1(arg)
            }
        }
        
        IfCondition EqualTo(task_name, 0) ThenBlock: {
            Compile_Error("RunTask requires a task name", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Look up the subroutine label
        task_label = Compile_FindFunction(task_name)
        IfCondition LessThan(task_label, 0) ThenBlock: {
            Compile_Error("Unknown subroutine for RunTask", AST_GetLine(node))
            ReturnValue(0)
        }
        
        // Emit CALL to the subroutine
        Emit_Call(task_label)
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// USER-DEFINED FUNCTION CALL - FIXED
// result = FunctionName(arg1, arg2, ...)
// =============================================================================
// =============================================================================
// USER-DEFINED FUNCTION CALL - FIXED
// result = FunctionName(arg1, arg2, ...)
// =============================================================================
// =============================================================================
// USER-DEFINED FUNCTION CALL - FIXED FOR NESTED CALLS
// result = FunctionName(arg1, arg2, ...)
//
// The key insight: nested function calls can happen DURING argument evaluation.
// If Multiply(n, Factorial(x)) is called, when we evaluate the second argument
// (Factorial(x)), that inner call will do AND RSP, -16 which corrupts the stack
// BEFORE the outer Multiply even gets to its alignment step.
//
// Solution: Save RSP at the START of UserCall, before ANY argument evaluation.
// =============================================================================
Function.CompileFunc_UserCall {
    Input: node: Address
    Output: Integer
    Body: {
        PrintMessage("[USERCALL] CompileFunc_UserCall entered\n")
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("[USERCALL] node is NULL, returning 0\n")
            ReturnValue(0)
        }
        
        // Get function name
        func_name = AST_GetData1(node)
        PrintMessage("[USERCALL] func_name = ")
        PrintMessage(func_name)
        PrintMessage("\n")
        
        // Look up the function label
        func_label = Compile_FindFunction(func_name)
        PrintMessage("[USERCALL] func_label = ")
        PrintNumber(func_label)
        PrintMessage("\n")
        
        IfCondition LessThan(func_label, 0) ThenBlock: {
            PrintMessage("[USERCALL] Not a user function, returning 0\n")
            ReturnValue(0)
        }
        
        // === CRITICAL FIX: Use RBX (callee-saved) instead of R11 (caller-saved) ===
        // R11 is caller-saved and gets clobbered by the callee!
        // RBX is callee-saved, so it survives across the CALL.
        PrintMessage("[USERCALL] Saving RBX, setting RBX=RSP\n")
        Emit_PushRbx()
        Emit_MovRegReg(Reg.RBX, Reg.RSP)    // RBX = RSP
        
        // Count arguments
        arg_count = AST_GetChildCount(node)
        PrintMessage("[USERCALL] arg_count = ")
        PrintNumber(arg_count)
        PrintMessage("\n")
        
        // Evaluate and push arguments in REVERSE order
        IfCondition GreaterThan(arg_count, 0) ThenBlock: {
            i = Subtract(arg_count, 1)
            WhileLoop GreaterEqual(i, 0) {
                PrintMessage("[USERCALL] Compiling arg ")
                PrintNumber(i)
                PrintMessage("\n")
                arg = AST_GetChild(node, i)
                Compile_Expression(arg)
                Emit_PushRax()
                i = Subtract(i, 1)
            }
            
            // Pop into registers: RDI, RSI, RDX, RCX, R8, R9
            PrintMessage("[USERCALL] Popping into registers...\n")
            IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
                PrintMessage("[USERCALL] Pop -> RDI\n")
                Emit_PopRdi()
            }
            IfCondition GreaterEqual(arg_count, 2) ThenBlock: {
                PrintMessage("[USERCALL] Pop -> RSI\n")
                Emit_PopRsi()
            }
            IfCondition GreaterEqual(arg_count, 3) ThenBlock: {
                PrintMessage("[USERCALL] Pop -> RDX\n")
                Emit_PopRdx()
            }
            IfCondition GreaterEqual(arg_count, 4) ThenBlock: {
                PrintMessage("[USERCALL] Pop -> RCX\n")
                Emit_PopRcx()
            }
            IfCondition GreaterEqual(arg_count, 5) ThenBlock: {
                PrintMessage("[USERCALL] Pop -> R8\n")
                Emit_PopR8()
            }
            IfCondition GreaterEqual(arg_count, 6) ThenBlock: {
                PrintMessage("[USERCALL] Pop -> R9\n")
                Emit_PopR9()
            }
        }
        
        // Align stack to 16 bytes before CALL
        PrintMessage("[USERCALL] Aligning stack (AND RSP, -16)\n")
        Emit_AndRspImm8(240)      // AND RSP, -16
        
        // CALL the function
        PrintMessage("[USERCALL] Emitting CALL to label ")
        PrintNumber(func_label)
        PrintMessage("\n")
        Emit_Call(func_label)
        
        // === CRITICAL FIX: Restore RSP from RBX (which survived the call!) ===
        PrintMessage("[USERCALL] Restoring RSP from RBX\n")
        Emit_MovRegReg(Reg.RSP, Reg.RBX)    // RSP = RBX
        Emit_PopRbx()                        // Restore caller's RBX
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        PrintMessage("[USERCALL] Done, returning 1\n")
        ReturnValue(1)
    }
}

// =============================================================================
// DISPATCHER FOR FUNCTION-RELATED CALLS
// =============================================================================
Function.CompileFunc_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        cmp = StringCompare(func_name, "RunTask")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFunc_RunTask(node))
        }
        
        cmp = StringCompare(func_name, "ReturnValue")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFunc_ReturnValue(node))
        }
        
        ReturnValue(CompileFunc_UserCall(node))
    }
}


// =============================================================================// 
// RETURNVALUE COMPILATION - PATCHED
// ReturnValue(expr) - return from function/subroutine with value
// =============================================================================
Function.CompileFunc_ReturnValue {
    Input: node: Address
    Output: Integer
    Body: {
        // Compile the return expression into RAX
        arg_count = AST_GetChildCount(node)
        IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
            arg = AST_GetChild(node, 0)
            Compile_Expression(arg)
        } ElseBlock: {
            Emit_XorRaxRax()
        }
        
        // Jump to the return label (epilogue handles cleanup)
        IfCondition NotEqual(Compile.current_return_label, 0) ThenBlock: {
            Emit_Jmp(Compile.current_return_label)
        } ElseBlock: {
            // Should never happen now, but fallback just in case
            PrintMessage("[RETVAL] WARNING: No return label set!\n")
            Emit_Ret()
        }
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// HELPER: FIND FUNCTION BY NAME
// Returns label ID or -1 if not found
// =============================================================================
Function.Compile_FindFunction {
    Input: name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        count = XArray.XSize(Compile.functions)
        i = 0
        
        WhileLoop LessThan(i, count) {
            entry = XArray.XGet(Compile.functions, i)
            stored_name = Dereference(entry)
            
            cmp = StringCompare(name, stored_name)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                label = Dereference(Add(entry, 8))
                ReturnValue(label)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(-1)
    }
}

// =============================================================================
// REGISTER FUNCTION (called from pass 1)
// =============================================================================
Function.Compile_RegisterFunction {
    Input: name: Address
    Input: label: Integer
    Body: {
        entry = Allocate(16)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), label)
        XArray.XPush(Compile.functions, entry)
    }
}