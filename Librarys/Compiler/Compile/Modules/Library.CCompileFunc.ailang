// Library.CCompileFunc.ailang
// Function, SubRoutine, and call compilation for the AILang self-hosting compiler
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileFunc.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore

// CodeEmit - architecture agnostic layer
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// Shared compile state

LibraryImport.Compiler.Compile.Modules.CCompileTypes


// =============================================================================
// DISPATCHER - Called from CCompileMain's Compile_FunctionCall
// Returns 1 if handled, 0 to try next dispatcher
// =============================================================================
Function.CompileFunc_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        // Check for RunTask
        cmp = StringCompare(func_name, "RunTask")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFunc_RunTask(node))
        }
        
        // Check for ReturnValue
        cmp = StringCompare(func_name, "ReturnValue")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileFunc_ReturnValue(node))
        }
        
        // Try as user function call (returns 0 if not found)
        ReturnValue(CompileFunc_UserCall(node))
    }
}

// =============================================================================
// FUNCTION DEFINITION COMPILATION
// Called directly from Compile_Node for AST.FUNCTION nodes
// =============================================================================
Function.CompileFunc_Function {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        
        // Look up the label (registered in pass 1)
        func_label = CompileFunc_FindFunction(func_name)
        IfCondition LessThan(func_label, 0) ThenBlock: {
            PrintMessage("[COMPILE] ERROR: Function not registered: ")
            PrintMessage(func_name)
            PrintMessage("\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // Save previous function context
        prev_func = Compile.current_func
        prev_stack_offset = Compile.stack_offset
        Compile.current_func = node
        Compile.stack_offset = 0
        
        // Jump over function body during linear execution
        skip_label = Emit_CreateLabel()
        Emit_Jmp(skip_label)
        
        // Mark function entry point
        Emit_MarkLabel(func_label)
        
        // === PROLOGUE ===
        Emit_PushRbp()
        Emit_MovRegReg(Reg.RBP, Reg.RSP)
        
        // Save callee-saved registers
        Emit_PushRbx()
        Emit_PushR12()
        Emit_PushR13()
        Emit_PushR14()
        
        // Count parameters and find body
        param_count = 0
        body_node = 0
        
        child_count = AST_GetChildCount(node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            child = AST_GetChild(node, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.PARAMETER) ThenBlock: {
                param_count = Add(param_count, 1)
            }
            
            IfCondition EqualTo(child_type, AST.BODY) ThenBlock: {
                body_node = child
            }
            
            i = Add(i, 1)
        }
        
        // Allocate stack space (aligned to 16 bytes)
        local_space = 64
        param_space = Multiply(param_count, 8)
        total_space = Add(local_space, param_space)
        // Align: (total + 15) & ~15
        stack_space = BitwiseAnd(Add(total_space, 15), BitwiseNot(15))
        
        IfCondition GreaterThan(stack_space, 0) ThenBlock: {
            Emit_SubRspImm32(stack_space)
        }
        Compile.stack_size = stack_space
        
        // Save parameters from registers to stack (System V AMD64 ABI)
        // RDI, RSI, RDX, RCX, R8, R9
        IfCondition GreaterEqual(param_count, 1) ThenBlock: {
            Emit_MovRaxRdi()
            Emit_MovRbpOffsetRax(-8)
        }
        IfCondition GreaterEqual(param_count, 2) ThenBlock: {
            Emit_MovRaxRsi()
            Emit_MovRbpOffsetRax(-16)
        }
        IfCondition GreaterEqual(param_count, 3) ThenBlock: {
            Emit_MovRaxRdx()
            Emit_MovRbpOffsetRax(-24)
        }
        IfCondition GreaterEqual(param_count, 4) ThenBlock: {
            Emit_MovRaxRcx()
            Emit_MovRbpOffsetRax(-32)
        }
        // R8, R9 would need additional Emit_ functions
        
        // Register parameters as local variables
        CompileFunc_RegisterParams(node, param_count)
        
        // Compile the body
        IfCondition NotEqual(body_node, 0) ThenBlock: {
            CompileFunc_CompileBody(body_node)
        }
        
        // Default return 0
        Emit_XorRaxRax()
        
        // === EPILOGUE ===
        Emit_PopR14()
        Emit_PopR13()
        Emit_PopR12()
        Emit_PopRbx()
        Emit_MovRegReg(Reg.RSP, Reg.RBP)
        Emit_PopRbp()
        Emit_Ret()
        
        // Skip label - continue normal execution
        Emit_MarkLabel(skip_label)
        
        // Restore context
        Compile.current_func = prev_func
        Compile.stack_offset = prev_stack_offset
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// SUBROUTINE DEFINITION COMPILATION
// =============================================================================
Function.CompileFunc_SubRoutine {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        sub_name = AST_GetData1(node)
        
        sub_label = CompileFunc_FindFunction(sub_name)
        IfCondition LessThan(sub_label, 0) ThenBlock: {
            PrintMessage("[COMPILE] ERROR: SubRoutine not registered: ")
            PrintMessage(sub_name)
            PrintMessage("\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        prev_func = Compile.current_func
        Compile.current_func = node
        
        // Jump over body
        skip_label = Emit_CreateLabel()
        Emit_Jmp(skip_label)
        
        // Entry point
        Emit_MarkLabel(sub_label)
        
        // === PROLOGUE ===
        Emit_PushRbx()
        Emit_PushR12()
        Emit_PushR13()
        Emit_PushR14()
        
        // Compile body children
        child_count = AST_GetChildCount(node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                ExitLoop
            }
            
            child = AST_GetChild(node, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.BODY) ThenBlock: {
                CompileFunc_CompileBody(child)
            }
            
            i = Add(i, 1)
        }
        
        // === EPILOGUE ===
        Emit_PopR14()
        Emit_PopR13()
        Emit_PopR12()
        Emit_PopRbx()
        Emit_Ret()
        
        Emit_MarkLabel(skip_label)
        
        Compile.current_func = prev_func
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// COMPILE BODY BLOCK
// =============================================================================
Function.CompileFunc_CompileBody {
    Input: body_node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(body_node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        child_count = AST_GetChildCount(body_node)
        i = 0
        WhileLoop LessThan(i, child_count) {
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                ExitLoop
            }
            
            child = AST_GetChild(body_node, i)
            Compile_Node(child)
            
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// REGISTER FUNCTION PARAMETERS AS LOCAL VARIABLES
// =============================================================================
Function.CompileFunc_RegisterParams {
    Input: func_node: Address
    Input: param_count: Integer
    Body: {
        child_count = AST_GetChildCount(func_node)
        param_index = 0
        i = 0
        
        WhileLoop LessThan(i, child_count) {
            child = AST_GetChild(func_node, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.PARAMETER) ThenBlock: {
                param_name = AST_GetData1(child)
                offset = Multiply(Add(param_index, 1), 8)
                CompileFunc_RegisterLocal(param_name, offset, VarType.PARAM)
                param_index = Add(param_index, 1)
            }
            
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// REGISTER A LOCAL VARIABLE (internal to this module)
// =============================================================================
Function.CompileFunc_RegisterLocal {
    Input: name: Address
    Input: offset: Integer
    Input: var_type: Integer
    Body: {
        entry = Allocate(24)
        StoreValue(entry, name)
        StoreValue(Add(entry, 8), offset)
        StoreValue(Add(entry, 16), var_type)
        XArray.XPush(Compile.variables, entry)
    }
}

// =============================================================================
// RUNTASK COMPILATION
// =============================================================================
Function.CompileFunc_RunTask {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get task name from first argument
        arg_count = AST_GetChildCount(node)
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            PrintMessage("[COMPILE] ERROR: RunTask requires task name\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg = AST_GetChild(node, 0)
        task_name = AST_GetData1(arg)
        
        task_label = CompileFunc_FindFunction(task_name)
        IfCondition LessThan(task_label, 0) ThenBlock: {
            PrintMessage("[COMPILE] ERROR: Unknown subroutine: ")
            PrintMessage(task_name)
            PrintMessage("\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // CALL the subroutine
        Emit_Call(task_label)
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// USER-DEFINED FUNCTION CALL
// Returns 0 if not a user function (to allow fallthrough)
// =============================================================================
Function.CompileFunc_UserCall {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        
        func_label = CompileFunc_FindFunction(func_name)
        IfCondition LessThan(func_label, 0) ThenBlock: {
            // Not a user function - let other dispatchers try
            ReturnValue(0)
        }
        
        arg_count = AST_GetChildCount(node)
        
        // Push args in reverse order
        IfCondition GreaterThan(arg_count, 0) ThenBlock: {
            i = Subtract(arg_count, 1)
            WhileLoop GreaterEqual(i, 0) {
                arg = AST_GetChild(node, i)
           //     Compile_Expression(arg)
                Emit_PushRax()
                i = Subtract(i, 1)
            }
            
            // Pop into argument registers (System V AMD64)
            IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
                Emit_PopRdi()
            }
            IfCondition GreaterEqual(arg_count, 2) ThenBlock: {
                Emit_PopRsi()
            }
            IfCondition GreaterEqual(arg_count, 3) ThenBlock: {
                Emit_PopRdx()
            }
            IfCondition GreaterEqual(arg_count, 4) ThenBlock: {
                Emit_PopRcx()
            }
            IfCondition GreaterEqual(arg_count, 5) ThenBlock: {
                Emit_PopR8()
            }
            IfCondition GreaterEqual(arg_count, 6) ThenBlock: {
                Emit_PopR9()
            }
        }
        
        Emit_Call(func_label)
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// RETURNVALUE COMPILATION
// =============================================================================
Function.CompileFunc_ReturnValue {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition GreaterEqual(arg_count, 1) ThenBlock: {
            arg = AST_GetChild(node, 0)
       //     Compile_Expression(arg)
        } ElseBlock: {
            Emit_XorRaxRax()
        }
        
        // Emit epilogue and return
        Emit_PopR14()
        Emit_PopR13()
        Emit_PopR12()
        Emit_PopRbx()
        Emit_MovRegReg(Reg.RSP, Reg.RBP)
        Emit_PopRbp()
        Emit_Ret()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// FIND FUNCTION BY NAME (internal helper)
// Returns label ID or -1 if not found
// =============================================================================
Function.CompileFunc_FindFunction {
    Input: name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        count = XArray.XSize(Compile.functions)
        i = 0
        
        WhileLoop LessThan(i, count) {
            entry = XArray.XGet(Compile.functions, i)
            stored_name = Dereference(entry)
            
            cmp = StringCompare(name, stored_name)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                label = Dereference(Add(entry, 8))
                ReturnValue(label)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(-1)
    }
}