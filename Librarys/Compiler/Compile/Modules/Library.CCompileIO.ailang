// Library.CCompileIO.ailang
// I/O operations compiler module for the AILang self-hosting compiler
// Handles: PrintMessage, PrintNumber, PrintString, ReadInput

LibraryImport.Compiler.Compile.CCompileTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys

// =============================================================================
// DISPATCHER
// Returns 1 if operation was handled, 0 if not our responsibility
// =============================================================================
Function.CompileIO_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetFunctionName(node)
        
        IfCondition EqualTo(StringCompare(func_name, "PrintMessage"), 0) ThenBlock: {
            ReturnValue(CompileIO_PrintMessage(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "PrintNumber"), 0) ThenBlock: {
            ReturnValue(CompileIO_PrintNumber(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "PrintString"), 0) ThenBlock: {
            ReturnValue(CompileIO_PrintString(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "ReadInput"), 0) ThenBlock: {
            ReturnValue(CompileIO_ReadInput(node))
        }
        
        // Not an I/O operation
        ReturnValue(0)
    }
}

// =============================================================================
// PRINT MESSAGE
// PrintMessage("string literal") - prints string with newline
// =============================================================================
Function.CompileIO_PrintMessage {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("PrintMessage requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetArg(node, 0)
        arg_type = AST_GetNodeType(arg0)
        
        // Handle string literal directly
        IfCondition EqualTo(arg_type, NodeType.STRING) ThenBlock: {
            str_value = AST_GetStringValue(arg0)
            str_len = StringLength(str_value)
            
            // Add string to data section
            str_offset = Emit_AddString(str_value)
            
            // sys_write(1, string_addr, length)
            X86_MovRaxImm64(Syscall.WRITE)
            X86_MovRdiImm64(1)  // stdout
            Emit_LoadDataAddress(Reg.RSI, str_offset)
            X86_MovRdxImm64(str_len)
            X86_Syscall()
            
            // Print newline
            CompileIO_EmitNewline()
            
            ReturnValue(1)
        }
        
        // Handle identifier or expression - evaluate then smart print
        Compile_Expression(arg0)
        CompileIO_EmitSmartPrint()
        CompileIO_EmitNewline()
        
        ReturnValue(1)
    }
}

// =============================================================================
// PRINT NUMBER
// PrintNumber(expr) - prints numeric value with newline
// =============================================================================
Function.CompileIO_PrintNumber {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("PrintNumber requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetArg(node, 0)
        
        // Compile the argument - result in RAX
        Compile_Expression(arg0)
        
        // Emit number printing code
        CompileIO_EmitPrintNumber()
        
        // Print newline
        CompileIO_EmitNewline()
        
        ReturnValue(1)
    }
}

// =============================================================================
// PRINT STRING
// PrintString(string_var) - prints string at address in variable
// =============================================================================
Function.CompileIO_PrintString {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetArgCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("PrintString requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetArg(node, 0)
        
        // Compile the argument - result (string address) in RAX
        Compile_Expression(arg0)
        
        // Emit string printing code
        CompileIO_EmitPrintStringAtAddress()
        
        ReturnValue(1)
    }
}

// =============================================================================
// READ INPUT
// ReadInput() - reads line from stdin, returns string address
// =============================================================================
Function.CompileIO_ReadInput {
    Input: node: Address
    Output: Integer
    Body: {
        // Allocate buffer (256 bytes) using mmap
        buffer_size = 256
        
        // mmap syscall
        X86_MovRaxImm64(Syscall.MMAP)
        X86_MovRdiImm64(0)  // addr = NULL
        X86_MovRsiImm64(buffer_size)
        X86_MovRdxImm64(3)  // PROT_READ | PROT_WRITE
        X86_MovR10Imm64(0x22)  // MAP_PRIVATE | MAP_ANONYMOUS
        X86_MovR8Imm64(-1)  // fd = -1
        X86_MovR9Imm64(0)  // offset = 0
        X86_Syscall()
        
        // Save buffer address in RBX
        X86_MovRbxRax()
        
        // sys_read(0, buffer, size-1)
        X86_MovRdiImm64(0)  // stdin
        X86_MovRsiRbx()  // buffer
        X86_MovRdxImm64(Subtract(buffer_size, 1))
        X86_MovRaxImm64(Syscall.READ)
        X86_Syscall()
        
        // RAX = bytes read
        // Find and strip newline, null terminate
        
        // Create labels
        has_input = Compile_NewLabel()
        strip_loop = Compile_NewLabel()
        strip_done = Compile_NewLabel()
        done = Compile_NewLabel()
        
        // Check if we read anything
        X86_TestRaxRax()
        Emit_JumpToLabel(has_input, CC.NZ)
        
        // No input - null terminate at start
        X86_MovByteRbxImm(0)
        Emit_JumpToLabel(done, CC.ALWAYS)
        
        Emit_MarkLabel(has_input)
        
        // RDI = buffer + bytes_read - 1 (last char)
        X86_MovRdiRbx()
        X86_AddRdiRax()
        X86_DecRdi()
        
        // Strip trailing newlines/carriage returns
        Emit_MarkLabel(strip_loop)
        
        // Compare RDI to RBX (buffer start)
        X86_CmpRdiRbx()
        Emit_JumpToLabel(strip_done, CC.L)
        
        // Load byte at [RDI]
        X86_MovAlByteRdi()
        
        // Check for newline (10) or carriage return (13)
        X86_CmpAlImm(10)
        skip_strip = Compile_NewLabel()
        Emit_JumpToLabel(skip_strip, CC.NE)
        X86_MovByteRdiImm(0)
        X86_DecRdi()
        Emit_JumpToLabel(strip_loop, CC.ALWAYS)
        
        Emit_MarkLabel(skip_strip)
        X86_CmpAlImm(13)
        Emit_JumpToLabel(strip_done, CC.NE)
        X86_MovByteRdiImm(0)
        X86_DecRdi()
        Emit_JumpToLabel(strip_loop, CC.ALWAYS)
        
        Emit_MarkLabel(strip_done)
        // Null terminate after last non-newline char
        X86_IncRdi()
        X86_MovByteRdiImm(0)
        
        Emit_MarkLabel(done)
        // Return buffer address
        X86_MovRaxRbx()
        
        ReturnValue(1)
    }
}

// =============================================================================
// HELPER: PRINT NUMBER
// Converts integer in RAX to decimal string and prints it
// =============================================================================
SubRoutine.CompileIO_EmitPrintNumber {
    // Save callee-saved registers
    X86_PushRbx()
    X86_PushR12()
    
    // Save original value for sign check
    X86_PushRax()
    
    // Allocate buffer on stack (32 bytes for digits + sign)
    X86_SubRspImm(32)
    
    // R12 = buffer end (we build string backwards)
    X86_MovR12Rsp()
    X86_AddR12Imm(31)
    
    // Null terminate
    X86_MovByteR12Imm(0)
    X86_DecR12()
    
    // Handle zero case
    zero_case = Compile_NewLabel()
    not_zero = Compile_NewLabel()
    convert_loop = Compile_NewLabel()
    convert_done = Compile_NewLabel()
    positive_done = Compile_NewLabel()
    print_it = Compile_NewLabel()
    
    X86_TestRaxRax()
    Emit_JumpToLabel(not_zero, CC.NZ)
    
    // Zero case: just store '0'
    Emit_MarkLabel(zero_case)
    X86_MovByteR12Imm(48)  // '0'
    X86_DecR12()
    Emit_JumpToLabel(print_it, CC.ALWAYS)
    
    Emit_MarkLabel(not_zero)
    
    // Handle negative: make positive, remember sign
    X86_TestRaxRax()
    Emit_JumpToLabel(positive_done, CC.NS)  // Jump if not negative
    X86_NegRax()
    
    Emit_MarkLabel(positive_done)
    
    // RBX = 10 (divisor)
    X86_MovRbxImm64(10)
    
    // Convert loop: extract digits
    Emit_MarkLabel(convert_loop)
    X86_TestRaxRax()
    Emit_JumpToLabel(convert_done, CC.Z)
    
    // RAX / 10: quotient in RAX, remainder in RDX
    X86_XorRdxRdx()  // Clear RDX for division
    X86_DivRbx()  // Unsigned div for positive number
    
    // Convert remainder to ASCII and store
    X86_AddRdxImm(48)  // Add '0'
    X86_MovByteR12Dl()
    X86_DecR12()
    
    Emit_JumpToLabel(convert_loop, CC.ALWAYS)
    
    Emit_MarkLabel(convert_done)
    
    // Check if original was negative
    // Original is at [RSP + 32] now
    X86_MovRaxRspOffset(32)
    X86_TestRaxRax()
    Emit_JumpToLabel(print_it, CC.NS)
    
    // Add minus sign
    X86_MovByteR12Imm(45)  // '-'
    X86_DecR12()
    
    Emit_MarkLabel(print_it)
    
    // R12 points one before the string start, so increment
    X86_IncR12()
    
    // Calculate string length
    X86_MovRaxRsp()
    X86_AddRaxImm(31)  // End of buffer
    X86_SubRaxR12()    // Length = end - start
    X86_MovRdxRax()    // Length in RDX
    
    // sys_write(1, string, length)
    X86_MovRaxImm64(Syscall.WRITE)
    X86_MovRdiImm64(1)  // stdout
    X86_MovRsiR12()     // string address
    // RDX already has length
    X86_Syscall()
    
    // Clean up stack
    X86_AddRspImm(32)
    X86_PopRax()  // Discard saved original
    
    // Restore registers
    X86_PopR12()
    X86_PopRbx()
}

// =============================================================================
// HELPER: PRINT NEWLINE
// =============================================================================
SubRoutine.CompileIO_EmitNewline {
    // Add newline to data section
    newline_offset = Emit_AddString("\n")
    
    // sys_write(1, newline, 1)
    X86_MovRaxImm64(Syscall.WRITE)
    X86_MovRdiImm64(1)  // stdout
    Emit_LoadDataAddress(Reg.RSI, newline_offset)
    X86_MovRdxImm64(1)
    X86_Syscall()
}

// =============================================================================
// HELPER: SMART PRINT
// Checks if value looks like a string address or a number and prints accordingly
// =============================================================================
SubRoutine.CompileIO_EmitSmartPrint {
    // RAX contains value to print
    // Heuristic: if < 1000000, treat as number; otherwise as string address
    
    string_path = Compile_NewLabel()
    number_path = Compile_NewLabel()
    end_print = Compile_NewLabel()
    
    // Compare with 1000000
    X86_CmpRaxImm(1000000)
    Emit_JumpToLabel(number_path, CC.L)
    
    // Check if in data section (>= 0x400000)
    X86_CmpRaxImm(0x400000)
    Emit_JumpToLabel(string_path, CC.GE)
    
    // Number path
    Emit_MarkLabel(number_path)
    CompileIO_EmitPrintNumber()
    Emit_JumpToLabel(end_print, CC.ALWAYS)
    
    // String path
    Emit_MarkLabel(string_path)
    CompileIO_EmitPrintStringAtAddress()
    
    Emit_MarkLabel(end_print)
}

// =============================================================================
// HELPER: PRINT STRING AT ADDRESS
// Prints null-terminated string at address in RAX
// =============================================================================
SubRoutine.CompileIO_EmitPrintStringAtAddress {
    // Save string address
    X86_PushRax()
    X86_MovRbxRax()
    
    // NULL check
    null_done = Compile_NewLabel()
    X86_TestRbxRbx()
    Emit_JumpToLabel(null_done, CC.Z)
    
    // Calculate string length (strlen)
    X86_MovRcxImm64(0)
    
    strlen_loop = Compile_NewLabel()
    strlen_end = Compile_NewLabel()
    
    Emit_MarkLabel(strlen_loop)
    X86_MovAlByteRbxRcx()  // Load byte at [RBX + RCX]
    X86_TestAlAl()
    Emit_JumpToLabel(strlen_end, CC.Z)
    X86_IncRcx()
    Emit_JumpToLabel(strlen_loop, CC.ALWAYS)
    
    Emit_MarkLabel(strlen_end)
    // RCX = length
    
    // sys_write(1, string, length)
    X86_MovRaxImm64(Syscall.WRITE)
    X86_MovRdiImm64(1)  // stdout
    X86_MovRsiRbx()     // string address
    X86_MovRdxRcx()     // length
    X86_Syscall()
    
    Emit_MarkLabel(null_done)
    
    // Restore RAX
    X86_PopRax()
}

// =============================================================================
// SYSCALL CONSTANTS
// =============================================================================
FixedPool.Syscall {
    "READ": Initialize=0, CanChange=False
    "WRITE": Initialize=1, CanChange=False
    "MMAP": Initialize=9, CanChange=False
    "EXIT": Initialize=60, CanChange=False
}