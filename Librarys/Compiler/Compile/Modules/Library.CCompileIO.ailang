// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileIO.ailang
// I/O operations: PrintMessage, PrintNumber, PrintChar, ReadInput
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileIO.ailang
//
// PrintNumber is complex: must convert integer to string at runtime
// We embed a small number-to-string routine and call it.
//
// References Python: ailang_compiler/modules/io_ops.py

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Compile.CCompileMain
//LibraryImport.Compiler.Compile.Modules.CCompileExpr
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys

// =============================================================================
// IO FUNCTION NAMES
// =============================================================================
FixedPool.IOName {
    "PRINT_MESSAGE": Initialize="PrintMessage"
    "PRINT_NUMBER": Initialize="PrintNumber"
    "PRINT_CHAR": Initialize="PrintChar"
    "READ_LINE": Initialize="ReadLine"
}

// =============================================================================
// IO STATE - Track if we've emitted helper routines
// =============================================================================
FixedPool.IOState {
    "print_number_label": Initialize=0, CanChange=True
    "print_number_emitted": Initialize=0, CanChange=True
    "number_buffer_offset": Initialize=0, CanChange=True
}

// =============================================================================
// TRY COMPILE - Main dispatch for I/O operations
// Returns 1 if handled, 0 if not an I/O operation
// =============================================================================
Function.CompileIO_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        PrintMessage("[IO] TryCompile called\n")
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("[IO] node is null\n")
            ReturnValue(0)
        }

        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            PrintMessage("[IO] func_name is null\n")
            ReturnValue(0)
        }
        
        PrintMessage("[IO] Checking function: ")
        PrintString(func_name)
        PrintMessage("\n")

        // Check each I/O operation
        cmp = StringCompare(func_name, IOName.PRINT_MESSAGE)
        PrintMessage("[IO] vs PRINT_MESSAGE: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[IO] Matched PrintMessage!\n")
            ReturnValue(CompileIO_PrintMessage(node))
        }

        cmp = StringCompare(func_name, IOName.PRINT_NUMBER)
        PrintMessage("[IO] vs PRINT_NUMBER: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[IO] Matched PrintNumber!\n")
            ReturnValue(CompileIO_PrintNumber(node))
        }

        cmp = StringCompare(func_name, IOName.PRINT_CHAR)
        PrintMessage("[IO] vs PRINT_CHAR: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[IO] Matched PrintChar!\n")
            ReturnValue(CompileIO_PrintChar(node))
        }

        // Not an I/O operation
        PrintMessage("[IO] No match, returning 0\n")
        ReturnValue(0)
    }
}

// =============================================================================
// PRINTMESSAGE(string)
// Emit: sys_write(1, string_addr, string_len)
// =============================================================================
Function.CompileIO_PrintMessage {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintMessage requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        node_type = AST_GetType(arg0)
        
        // Handle string literal
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            str_value = AST_GetData1(arg0)
            str_len = StringLength(str_value)
            
            // Add string to data section
            str_offset = Emit_AddString(str_value)
            
            // sys_write(1, addr, len)
            // RAX = 1 (write syscall)
            // RDI = 1 (stdout)
            // RSI = string address (data section base + offset)
            // RDX = length
            
            Emit_MovRaxImm64(1)        // syscall: write
            Emit_MovRdiImm64(1)        // fd: stdout
            
            // String address will be: data_base + str_offset
            // ELF builder handles this - we emit a relocation placeholder
            // For now, calculate based on expected data address
            // The ELF builder uses: data_vaddr = text_vaddr + text_size (page aligned)
            // We'll use Emit_AddDataReloc to mark this needs patching
            
            // Emit load of data address (will be fixed by ELF)
            // For simple case, use immediate with relocation
            Emit_MovRsiDataOffset(str_offset)
            
            Emit_MovRdxImm64(str_len)  // length
            Emit_Syscall()
            
            Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
            ReturnValue(1)
        }
        
        // Handle expression (variable or function call returning string)
        // For now, compile expression and assume it returns string address in RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // RAX has string address - need to calculate length
        // For runtime strings, we'd need strlen - defer this for now
        Compile_Error("PrintMessage with non-literal strings not yet implemented", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// PRINTNUMBER(integer)
// Most complex: must convert integer to decimal string at runtime
// Strategy: Emit inline conversion code
// =============================================================================
// =============================================================================
// PRINTNUMBER(integer)
// Converts integer in RAX to decimal string and prints it
// Uses ONLY Emit_* abstractions - architecture agnostic
// =============================================================================
Function.CompileIO_PrintNumber {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintNumber requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }

        arg0 = AST_GetChild(node, 0)

        // Compile the argument - result will be in RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }

        // Reserve stack space for digit buffer (32 bytes)
        Emit_AllocStack(32)

        // Save number in R12 (callee-saved)
        Emit_MovRegReg(Reg.R12, Reg.RAX)

        // RBX = 10 (divisor)
        Emit_MovRegImm64(Reg.RBX, 10)

        // R13 = 0 (digit count)
        Emit_XorRegReg(Reg.R13, Reg.R13)

        // R14 = RSP + 31 (buffer end pointer, we build string backwards)
        Emit_MovRegReg(Reg.R14, Reg.RSP)
        Emit_AddRegImm32(Reg.R14, 31)

        // Check if negative: TEST R12, R12
        Emit_TestRegReg(Reg.R12, Reg.R12)
        
        label_not_neg = Emit_CreateLabel()
        Emit_JumpToLabel(label_not_neg, CC.NS)

        // --- Number is negative: print '-' and negate ---
        // Store '-' at [RSP]
        Emit_StoreByteAtRegOffset(Reg.RSP, 0, 45)
        
        // sys_write(1, RSP, 1)
        Emit_MovRegImm64(Reg.RAX, 1)
        Emit_MovRegImm64(Reg.RDI, 1)
        Emit_MovRegReg(Reg.RSI, Reg.RSP)
        Emit_MovRegImm64(Reg.RDX, 1)
        Emit_Syscall()

        // Negate R12
        Emit_NegReg(Reg.R12)

        // --- label_not_neg ---
        Emit_MarkLabel(label_not_neg)

        // Check if zero: TEST R12, R12
        Emit_TestRegReg(Reg.R12, Reg.R12)
        
        label_not_zero = Emit_CreateLabel()
        Emit_JumpToLabel(label_not_zero, CC.NZ)

        // --- Number is zero: just store '0' ---
        Emit_StoreByteAtRegOffset(Reg.R14, 0, 48)
        Emit_IncReg(Reg.R13)
        
        label_print = Emit_CreateLabel()
        Emit_JumpToLabel(label_print, CC.ALWAYS)

        // --- label_not_zero: conversion loop ---
        Emit_MarkLabel(label_not_zero)

        label_loop = Emit_CreateLabel()
        Emit_MarkLabel(label_loop)

        // Check if done: TEST R12, R12
        Emit_TestRegReg(Reg.R12, Reg.R12)
        
        label_done = Emit_CreateLabel()
        Emit_JumpToLabel(label_done, CC.Z)

        // RAX = R12 (copy number for division)
        Emit_MovRegReg(Reg.RAX, Reg.R12)

        // Sign extend RAX into RDX:RAX
        Emit_SignExtendRaxToRdx()

        // IDIV RBX: RAX = quotient, RDX = remainder
        Emit_IdivReg(Reg.RBX)

        // Save quotient back to R12
        Emit_MovRegReg(Reg.R12, Reg.RAX)

        // Convert remainder to ASCII: RDX = RDX + '0'
        Emit_AddRegImm32(Reg.RDX, 48)

        // Store digit at [R14]
        Emit_StoreByteAtRegFromReg(Reg.R14, Reg.RDX)

        // Move buffer pointer back
        Emit_DecReg(Reg.R14)

        // Increment digit count
        Emit_IncReg(Reg.R13)

        // Loop
        Emit_JumpToLabel(label_loop, CC.ALWAYS)

        // --- label_done: finished extracting digits ---
        Emit_MarkLabel(label_done)

        // R14 points one before first digit, so increment
        Emit_IncReg(Reg.R14)

        // --- label_print: print the number ---
        Emit_MarkLabel(label_print)

        // sys_write(1, R14, R13)
        Emit_MovRegImm64(Reg.RAX, 1)
        Emit_MovRegImm64(Reg.RDI, 1)
        Emit_MovRegReg(Reg.RSI, Reg.R14)
        Emit_MovRegReg(Reg.RDX, Reg.R13)
        Emit_Syscall()

        // Print newline: store '\n' at [RSP]
        Emit_StoreByteAtRegOffset(Reg.RSP, 0, 10)
        
        // sys_write(1, RSP, 1)
        Emit_MovRegImm64(Reg.RAX, 1)
        Emit_MovRegImm64(Reg.RDI, 1)
        Emit_MovRegReg(Reg.RSI, Reg.RSP)
        Emit_MovRegImm64(Reg.RDX, 1)
        Emit_Syscall()

        // Free stack space
        Emit_FreeStack(32)

        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// PRINTCHAR(char)
// Print a single character
// =============================================================================
Function.CompileIO_PrintChar {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintChar requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile argument (char code) â†’ RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push char to stack and print from there
        Emit_PushRax()
        
        // sys_write(1, rsp, 1)
        Emit_MovRaxImm64(1)        // write
        Emit_MovRdiImm64(1)        // stdout
        Emit_MovRegReg(Reg.RSI, Reg.RSP)
        Emit_MovRdxImm64(1)        // 1 byte
        Emit_Syscall()
        
        Emit_PopRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// HELPER: Emit wrapper for printing (used by CompileIO_Print stub)
// =============================================================================
Function.CompileIO_Print {
    Input: node: Address
    Output: Integer
    Body: {
        // Dispatch based on node type
        node_type = AST_GetType(node)
        
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            func_name = AST_GetData1(node)
            
            cmp = StringCompare(func_name, IOName.PRINT_MESSAGE)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(CompileIO_PrintMessage(node))
            }
            
            cmp = StringCompare(func_name, IOName.PRINT_NUMBER)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(CompileIO_PrintNumber(node))
            }
        }
        
        ReturnValue(0)
    }
}