// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// Licensed under the Sean Collins Software License (SCSL).

// Library.CCompileIO.ailang
// I/O operations: PrintMessage, PrintNumber, PrintChar, ReadInput
// NO FixedPool for function names - uses string literals to avoid pool collisions

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch


// =============================================================================
// IO STATE - Track if we've emitted helper routines
// NOTE: This is mutable state, NOT function name constants, so it's OK to keep
// =============================================================================
FixedPool.IOState {
    "print_number_label": Initialize=0, CanChange=True
    "print_number_emitted": Initialize=0, CanChange=True
    "number_buffer_offset": Initialize=0, CanChange=True
}

// =============================================================================
// TRY COMPILE - Main dispatch for I/O operations
// Returns 1 if handled, 0 if not an I/O operation
// =============================================================================
Function.CompileIO_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        PrintMessage("[IO] TryCompile called\n")
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("[IO] node is null\n")
            ReturnValue(0)
        }

        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            PrintMessage("[IO] func_name is null\n")
            ReturnValue(0)
        }
        
        PrintMessage("[IO] Checking function: ")
        PrintString(func_name)
        PrintMessage("\n")

        // Check each I/O operation using string literals
        cmp = StringCompare(func_name, "PrintMessage")
        PrintMessage("[IO] vs PrintMessage: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[IO] Matched PrintMessage!\n")
            ReturnValue(CompileIO_PrintMessage(node))
        }

        cmp = StringCompare(func_name, "PrintNumber")
        PrintMessage("[IO] vs PrintNumber: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[IO] Matched PrintNumber!\n")
            ReturnValue(CompileIO_PrintNumber(node))
        }

        cmp = StringCompare(func_name, "PrintChar")
        PrintMessage("[IO] vs PrintChar: ")
        PrintNumber(cmp)
        PrintMessage("\n")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            PrintMessage("[IO] Matched PrintChar!\n")
            ReturnValue(CompileIO_PrintChar(node))
        }
        
        cmp = StringCompare(func_name, "PrintString")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileIO_PrintMessage(node))
        }
        
        cmp = StringCompare(func_name, "ReadLine")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileIO_ReadLine(node))
        }

        // Not an I/O operation
        PrintMessage("[IO] No match, returning 0\n")
        ReturnValue(0)
    }
}

// =============================================================================
// PRINTMESSAGE(string)
// Emit: sys_write(1, string_addr, string_len)
// =============================================================================
Function.CompileIO_PrintMessage {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintMessage requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        node_type = AST_GetType(arg0)
        
        // Handle string literal
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            str_value = AST_GetData1(arg0)
            str_len = StringLength(str_value)
            
            // Add string to data section
            str_offset = Emit_AddString(str_value)
            
            // sys_write(1, addr, len)
            Emit_MovRaxImm64(1)        // syscall: write
            Emit_MovRdiImm64(1)        // fd: stdout
            Emit_MovRsiDataOffset(str_offset)
            Emit_MovRdxImm64(str_len)  // length
            Emit_Syscall()
            
            Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
            ReturnValue(1)
        }
        
        // Handle expression (variable or function call returning string)
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Compile_Error("PrintMessage with non-literal strings not yet implemented", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// PRINTNUMBER(integer)
// Converts integer in RAX to decimal string and prints it
// =============================================================================
Function.CompileIO_PrintNumber {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintNumber requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }

        arg0 = AST_GetChild(node, 0)

        // Compile the argument - result will be in RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }

        // Reserve stack space for digit buffer (32 bytes)
        Emit_AllocStack(32)

        // Save number in R12 (callee-saved)
        Emit_MovRegReg(Reg.R12, Reg.RAX)

        // RBX = 10 (divisor)
        Emit_MovRegImm64(Reg.RBX, 10)

        // R13 = 0 (digit count)
        Emit_XorRegReg(Reg.R13, Reg.R13)

        // R14 = RSP + 31 (buffer end pointer)
        Emit_MovRegReg(Reg.R14, Reg.RSP)
        Emit_AddRegImm32(Reg.R14, 31)

        // Check if negative
        Emit_TestRegReg(Reg.R12, Reg.R12)
        
        label_not_neg = Emit_CreateLabel()
        Emit_JumpToLabel(label_not_neg, CC.NS)

        // Number is negative: print '-' and negate
        Emit_StoreByteAtRegOffset(Reg.RSP, 0, 45)
        
        Emit_MovRegImm64(Reg.RAX, 1)
        Emit_MovRegImm64(Reg.RDI, 1)
        Emit_MovRegReg(Reg.RSI, Reg.RSP)
        Emit_MovRegImm64(Reg.RDX, 1)
        Emit_Syscall()

        Emit_NegReg(Reg.R12)

        Emit_MarkLabel(label_not_neg)

        // Check if zero
        Emit_TestRegReg(Reg.R12, Reg.R12)
        
        label_not_zero = Emit_CreateLabel()
        Emit_JumpToLabel(label_not_zero, CC.NZ)

        // Number is zero: just store '0'
        Emit_StoreByteAtRegOffset(Reg.R14, 0, 48)
        Emit_IncReg(Reg.R13)
        
        label_print = Emit_CreateLabel()
        Emit_JumpToLabel(label_print, CC.ALWAYS)

        Emit_MarkLabel(label_not_zero)

        // Digit extraction loop
        label_loop = Emit_CreateLabel()
        label_loop_end = Emit_CreateLabel()
        
        Emit_MarkLabel(label_loop)

        Emit_TestRegReg(Reg.R12, Reg.R12)
        Emit_JumpToLabel(label_loop_end, CC.Z)

        // RAX = R12
        Emit_MovRegReg(Reg.RAX, Reg.R12)
        
        // XOR RDX, RDX
        Emit_XorRegReg(Reg.RDX, Reg.RDX)
        
        // DIV RBX
        Emit_DivReg(Reg.RBX)

        // R12 = RAX (quotient)
        Emit_MovRegReg(Reg.R12, Reg.RAX)

        // RDX = remainder (digit)
        // digit + '0' = digit + 48
        Emit_AddRegImm32(Reg.RDX, 48)

        // Store digit at R14
        Emit_StoreByteAtRegFromReg(Reg.R14, Reg.RDX)

        // Decrement R14, increment R13
        Emit_DecReg(Reg.R14)
        Emit_IncReg(Reg.R13)

        Emit_JumpToLabel(label_loop, CC.ALWAYS)

        Emit_MarkLabel(label_loop_end)

        // Adjust R14 to point to first digit
        Emit_IncReg(Reg.R14)

        Emit_MarkLabel(label_print)

        // sys_write(1, R14, R13)
        Emit_MovRegImm64(Reg.RAX, 1)
        Emit_MovRegImm64(Reg.RDI, 1)
        Emit_MovRegReg(Reg.RSI, Reg.R14)
        Emit_MovRegReg(Reg.RDX, Reg.R13)
        Emit_Syscall()

        // Restore stack
        Emit_FreeStack(32)

        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// PRINTCHAR(char)
// Print a single character
// =============================================================================
Function.CompileIO_PrintChar {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintChar requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push char to stack and print from there
        Emit_PushRax()
        
        // sys_write(1, rsp, 1)
        Emit_MovRaxImm64(1)
        Emit_MovRdiImm64(1)
        Emit_MovRegReg(Reg.RSI, Reg.RSP)
        Emit_MovRdxImm64(1)
        Emit_Syscall()
        
        Emit_PopRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// READLINE - Stub for future implementation
// =============================================================================
Function.CompileIO_ReadLine {
    Input: node: Address
    Output: Integer
    Body: {
        Compile_Error("ReadLine not yet implemented", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// HELPER: Emit wrapper for printing (used by CompileIO_Print stub)
// =============================================================================
Function.CompileIO_Print {
    Input: node: Address
    Output: Integer
    Body: {
        node_type = AST_GetType(node)
        
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            func_name = AST_GetData1(node)
            
            cmp = StringCompare(func_name, "PrintMessage")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(CompileIO_PrintMessage(node))
            }
            
            cmp = StringCompare(func_name, "PrintNumber")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(CompileIO_PrintNumber(node))
            }
        }
        
        ReturnValue(0)
    }
}