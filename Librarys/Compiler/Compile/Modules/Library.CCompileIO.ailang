// Library.CCompileIO.ailang
// I/O operations: PrintMessage, PrintNumber, PrintChar, ReadInput
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileIO.ailang
//
// PrintNumber is complex: must convert integer to string at runtime
// We embed a small number-to-string routine and call it.
//
// References Python: ailang_compiler/modules/io_ops.py

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys

// =============================================================================
// IO FUNCTION NAMES
// =============================================================================
FixedPool.IOName {
    "PRINT_MESSAGE": Initialize="PrintMessage"
    "PRINT_NUMBER": Initialize="PrintNumber"
    "PRINT_CHAR": Initialize="PrintChar"
    "READ_LINE": Initialize="ReadLine"
}

// =============================================================================
// IO STATE - Track if we've emitted helper routines
// =============================================================================
FixedPool.IOState {
    "print_number_label": Initialize=0, CanChange=True
    "print_number_emitted": Initialize=0, CanChange=True
    "number_buffer_offset": Initialize=0, CanChange=True
}

// =============================================================================
// TRY COMPILE - Main dispatch for I/O operations
// Returns 1 if handled, 0 if not an I/O operation
// =============================================================================
Function.CompileIO_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check each I/O operation
        cmp = StringCompare(func_name, IOName.PRINT_MESSAGE)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileIO_PrintMessage(node))
        }
        
        cmp = StringCompare(func_name, IOName.PRINT_NUMBER)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileIO_PrintNumber(node))
        }
        
        cmp = StringCompare(func_name, IOName.PRINT_CHAR)
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(CompileIO_PrintChar(node))
        }
        
        // Not an I/O operation
        ReturnValue(0)
    }
}

// =============================================================================
// PRINTMESSAGE(string)
// Emit: sys_write(1, string_addr, string_len)
// =============================================================================
Function.CompileIO_PrintMessage {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintMessage requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        node_type = AST_GetType(arg0)
        
        // Handle string literal
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            str_value = AST_GetData1(arg0)
            str_len = StringLength(str_value)
            
            // Add string to data section
            str_offset = Emit_AddString(str_value)
            
            // sys_write(1, addr, len)
            // RAX = 1 (write syscall)
            // RDI = 1 (stdout)
            // RSI = string address (data section base + offset)
            // RDX = length
            
            X86_MovRaxImm64(1)        // syscall: write
            X86_MovRdiImm64(1)        // fd: stdout
            
            // String address will be: data_base + str_offset
            // ELF builder handles this - we emit a relocation placeholder
            // For now, calculate based on expected data address
            // The ELF builder uses: data_vaddr = text_vaddr + text_size (page aligned)
            // We'll use Emit_AddDataReloc to mark this needs patching
            
            // Emit load of data address (will be fixed by ELF)
            // For simple case, use immediate with relocation
            X86_MovRsiDataOffset(str_offset)
            
            X86_MovRdxImm64(str_len)  // length
            X86_SysInstr()
            
            Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
            ReturnValue(1)
        }
        
        // Handle expression (variable or function call returning string)
        // For now, compile expression and assume it returns string address in RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // RAX has string address - need to calculate length
        // For runtime strings, we'd need strlen - defer this for now
        Compile_Error("PrintMessage with non-literal strings not yet implemented", AST_GetLine(node))
        ReturnValue(0)
    }
}

// =============================================================================
// PRINTNUMBER(integer)
// Most complex: must convert integer to decimal string at runtime
// Strategy: Emit inline conversion code
// =============================================================================
Function.CompileIO_PrintNumber {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintNumber requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile the argument - result will be in RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Now RAX contains the number to print
        // We need to convert it to a string and print it
        
        // Emit inline number-to-string conversion and print
        // This is the algorithm:
        //   1. Handle negative: if RAX < 0, print '-', negate RAX
        //   2. Divide by 10 repeatedly, push remainders
        //   3. Pop and print each digit (+ '0')
        
        // Reserve stack space for digit buffer (max 20 digits for 64-bit)
        X86_SubRspImm32(32)
        
        // Save number in R12 (callee-saved)
        X86_MovRegReg(Reg.R12, Reg.RAX)
        
        // RBX = 10 (divisor)
        X86_MovRbxImm64(10)
        
        // R13 = digit count
        X86_XorR13R13()
        
        // R14 = pointer to buffer end (we build string backwards)
        X86_MovRegReg(Reg.R14, Reg.RSP)
        X86_AddR14Imm32(31)
        
        // Check if negative
        X86_TestRaxRax()
        label_not_neg = Emit_CreateLabel()
        X86_Jns(label_not_neg)  // Jump if not sign (positive)
        
        // It's negative - print minus sign
        X86_MovRaxImm64(1)       // write syscall
        X86_MovRdiImm64(1)       // stdout
        X86_PushRax()
        X86_MovByteRspImm8(45)   // '-' character
        X86_MovRegReg(Reg.RSI, Reg.RSP)
        X86_MovRdxImm64(1)       // length 1
        X86_MovRaxImm64(1)
        X86_SysInstr()
        X86_PopRax()
        
        // Negate the number
        X86_MovRegReg(Reg.RAX, Reg.R12)
        X86_NegRax()
        X86_MovRegReg(Reg.R12, Reg.RAX)
        
        Emit_DefineLabel(label_not_neg)
        
        // Handle zero specially
        X86_MovRegReg(Reg.RAX, Reg.R12)
        X86_TestRaxRax()
        label_not_zero = Emit_CreateLabel()
        X86_Jnz(label_not_zero)
        
        // Number is zero - just print '0'
        X86_MovByteR14Imm8(48)   // '0'
        X86_IncR13()
        label_print = Emit_CreateLabel()
        X86_Jmp(label_print)
        
        Emit_DefineLabel(label_not_zero)
        
        // Conversion loop: extract digits
        label_loop = Emit_CreateLabel()
        Emit_DefineLabel(label_loop)
        
        X86_MovRegReg(Reg.RAX, Reg.R12)
        X86_TestRaxRax()
        label_done = Emit_CreateLabel()
        X86_Jz(label_done)       // Done when quotient is 0
        
        // RAX = number, divide by 10
        X86_Cqo()                // Sign extend RAX to RDX:RAX
        X86_IdivRbx()            // RAX = quotient, RDX = remainder
        
        // Save quotient back
        X86_MovRegReg(Reg.R12, Reg.RAX)
        
        // Convert remainder to ASCII and store
        X86_AddRdxImm32(48)      // remainder + '0'
        X86_MovByteR14Rdx()      // Store at buffer position
        X86_DecR14()             // Move buffer pointer back
        X86_IncR13()             // Increment digit count
        
        X86_Jmp(label_loop)
        
        Emit_DefineLabel(label_done)
        
        // R14 points one before first digit, R13 has count
        X86_IncR14()             // Point to first digit
        
        Emit_DefineLabel(label_print)
        
        // sys_write(1, R14, R13)
        X86_MovRaxImm64(1)       // write
        X86_MovRdiImm64(1)       // stdout
        X86_MovRegReg(Reg.RSI, Reg.R14)
        X86_MovRegReg(Reg.RDX, Reg.R13)
        X86_SysInstr()
        
        // Print newline
        X86_MovByteRspImm8(10)   // '\n'
        X86_MovRaxImm64(1)
        X86_MovRdiImm64(1)
        X86_MovRegReg(Reg.RSI, Reg.RSP)
        X86_MovRdxImm64(1)
        X86_SysInstr()
        
        // Restore stack
        X86_AddRspImm32(32)
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// PRINTCHAR(char)
// Print a single character
// =============================================================================
Function.CompileIO_PrintChar {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("PrintChar requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile argument (char code) â†’ RAX
        result = Compile_Expression(arg0)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Push char to stack and print from there
        X86_PushRax()
        
        // sys_write(1, rsp, 1)
        X86_MovRaxImm64(1)        // write
        X86_MovRdiImm64(1)        // stdout
        X86_MovRegReg(Reg.RSI, Reg.RSP)
        X86_MovRdxImm64(1)        // 1 byte
        X86_SysInstr()
        
        X86_PopRax()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// HELPER: Emit wrapper for printing (used by CompileIO_Print stub)
// =============================================================================
Function.CompileIO_Print {
    Input: node: Address
    Output: Integer
    Body: {
        // Dispatch based on node type
        node_type = AST_GetType(node)
        
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            func_name = AST_GetData1(node)
            
            cmp = StringCompare(func_name, IOName.PRINT_MESSAGE)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(CompileIO_PrintMessage(node))
            }
            
            cmp = StringCompare(func_name, IOName.PRINT_NUMBER)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(CompileIO_PrintNumber(node))
            }
        }
        
        ReturnValue(0)
    }
}