// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileLogic.ailang
// Logical operations compiler module for the AILang self-hosting compiler
// Handles: And, Or, Not (with short-circuit evaluation for And/Or)
// Result: 1 (true) or 0 (false) in RAX

LibraryImport.Compiler.Compile.CCompileTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileLogic_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(StringCompare(func_name, "And"), 0) ThenBlock: {
            ReturnValue(CompileLogic_And(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Or"), 0) ThenBlock: {
            ReturnValue(CompileLogic_Or(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Not"), 0) ThenBlock: {
            ReturnValue(CompileLogic_Not(node))
        }
        
        // Not a logical operation
        ReturnValue(0)
    }
}

// =============================================================================
// LOGICAL AND (Short-Circuit)
// If first operand is false, skip second operand
// =============================================================================
Function.CompileLogic_And {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("And requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        false_label = Compile_NewLabel()
        end_label = Compile_NewLabel()
        
        Compile_DepthPush()
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Evaluate first operand
        Compile_Expression(arg0)
        
        // TEST RAX, RAX - check if zero (false)
        Emit_TestRaxRax()
        
        // If zero, short-circuit to false
        Emit_JumpToLabel(false_label, CC.Z)
        
        // Evaluate second operand
        Compile_Expression(arg1)
        
        // TEST RAX, RAX
        Emit_TestRaxRax()
        
        // If zero, result is false
        Emit_JumpToLabel(false_label, CC.Z)
        
        // Both were true - result is 1
        Emit_MovRaxImm64(1)
        Emit_JumpToLabel(end_label, CC.ALWAYS)
        
        // False path
        Emit_MarkLabel(false_label)
        Emit_MovRaxImm64(0)
        
        Emit_MarkLabel(end_label)
        
        Compile_DepthPop()
        
        ReturnValue(1)
    }
}

// =============================================================================
// LOGICAL OR (Short-Circuit)
// If first operand is true, skip second operand
// =============================================================================
Function.CompileLogic_Or {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("Or requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        true_label = Compile_NewLabel()
        end_label = Compile_NewLabel()
        
        Compile_DepthPush()
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Evaluate first operand
        Compile_Expression(arg0)
        
        // TEST RAX, RAX
        Emit_TestRaxRax()
        
        // If non-zero, short-circuit to true
        Emit_JumpToLabel(true_label, CC.NZ)
        
        // Evaluate second operand
        Compile_Expression(arg1)
        
        // TEST RAX, RAX
        Emit_TestRaxRax()
        
        // If non-zero, result is true
        Emit_JumpToLabel(true_label, CC.NZ)
        
        // Both were false - result is 0
        Emit_MovRaxImm64(0)
        Emit_JumpToLabel(end_label, CC.ALWAYS)
        
        // True path
        Emit_MarkLabel(true_label)
        Emit_MovRaxImm64(1)
        
        Emit_MarkLabel(end_label)
        
        Compile_DepthPop()
        
        ReturnValue(1)
    }
}

// =============================================================================
// LOGICAL NOT
// Returns 1 if operand is 0, returns 0 if operand is non-zero
// =============================================================================
Function.CompileLogic_Not {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("Not requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Evaluate operand
        Compile_Expression(arg0)
        
        // TEST RAX, RAX
        Emit_TestRaxRax()
        
        // SETZ AL (set AL to 1 if ZF=1, i.e., RAX was 0)
        Emit_SetZAl()
        
        // MOVZX RAX, AL (zero-extend)
        Emit_MovzxRaxAl()
        
        ReturnValue(1)
    }
}