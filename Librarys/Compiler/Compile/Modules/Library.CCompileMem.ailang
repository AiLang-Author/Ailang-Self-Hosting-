// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileMem.ailang
// Memory operations compiler module for the AILang self-hosting compiler
// Handles: Allocate, Deallocate, StoreValue, Dereference, GetByte, SetByte

LibraryImport.Compiler.Compile.CCompileTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileMem_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(StringCompare(func_name, "Allocate"), 0) ThenBlock: {
            ReturnValue(CompileMem_Allocate(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Deallocate"), 0) ThenBlock: {
            ReturnValue(CompileMem_Deallocate(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "StoreValue"), 0) ThenBlock: {
            ReturnValue(CompileMem_StoreValue(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Dereference"), 0) ThenBlock: {
            ReturnValue(CompileMem_Dereference(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "GetByte"), 0) ThenBlock: {
            ReturnValue(CompileMem_GetByte(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "SetByte"), 0) ThenBlock: {
            ReturnValue(CompileMem_SetByte(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "MemoryCopy"), 0) ThenBlock: {
            ReturnValue(CompileMem_MemoryCopy(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "MemorySet"), 0) ThenBlock: {
            ReturnValue(CompileMem_MemorySet(node))
        }
        
        // Not a memory operation
        ReturnValue(0)
    }
}

// =============================================================================
// ALLOCATE
// Allocate(size) - allocates memory using mmap, returns address
// =============================================================================
Function.CompileMem_Allocate {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("Allocate requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile size argument - result in RAX
        Compile_Expression(arg0)
        
        // Move size to RSI for mmap
        X86_MovRsiRax()
        
        // mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
        X86_MovRaxImm64(9)      // syscall: mmap
        X86_MovRdiImm64(0)      // addr = NULL
        // RSI already has size
        X86_MovRdxImm64(3)      // PROT_READ | PROT_WRITE
        X86_MovR10Imm64(0x22)   // MAP_PRIVATE | MAP_ANONYMOUS
        X86_MovR8Imm64(-1)      // fd = -1
        X86_MovR9Imm64(0)       // offset = 0
        X86_SysInstr()
        
        // RAX now contains allocated address (or error if < 0)
        
        ReturnValue(1)
    }
}

// =============================================================================
// DEALLOCATE
// Deallocate(addr, size) - frees memory using munmap
// =============================================================================
Function.CompileMem_Deallocate {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("Deallocate requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile size first (save in temp)
        Compile_Expression(arg1)
        X86_PushRax()
        
        // Compile address
        Compile_Expression(arg0)
        X86_MovRdiRax()  // addr in RDI
        
        // Pop size into RSI
        X86_PopRsi()
        
        // munmap(addr, size)
        X86_MovRaxImm64(11)  // syscall: munmap
        X86_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// STOREVALUE
// StoreValue(addr, value) - stores 64-bit value at address
// =============================================================================
Function.CompileMem_StoreValue {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("StoreValue requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        use_stack = Compile_ShouldUseStack()
        Compile_DepthPush()
        
        IfCondition EqualTo(use_stack, 1) ThenBlock: {
            // Compile value
            Compile_Expression(arg1)
            X86_PushRax()
            
            // Compile address
            Compile_Expression(arg0)
            X86_MovRdiRax()
            
            // Pop value
            X86_PopRax()
        } ElseBlock: {
            reg = Compile_GetDepthReg()
            
            IfCondition EqualTo(reg, 12) ThenBlock: {
                X86_PushR12()
                Compile_Expression(arg1)
                X86_MovR12Rax()
                Compile_Expression(arg0)
                X86_MovRdiRax()
                X86_MovRaxR12()
                X86_PopR12()
            } ElseBlock: {
                X86_PushR13()
                Compile_Expression(arg1)
                X86_MovR13Rax()
                Compile_Expression(arg0)
                X86_MovRdiRax()
                X86_MovRaxR13()
                X86_PopR13()
            }
        }
        
        Compile_DepthPop()
        
        // MOV [RDI], RAX
        X86_MovRdiDerefRax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// DEREFERENCE
// Dereference(addr) - loads 64-bit value from address
// =============================================================================
Function.CompileMem_Dereference {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_SetError("Dereference requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile address
        Compile_Expression(arg0)
        
        // MOV RAX, [RAX]
        X86_MovRaxRaxDeref()
        
        ReturnValue(1)
    }
}

// =============================================================================
// GETBYTE
// GetByte(addr, offset) - loads byte at addr+offset
// =============================================================================
Function.CompileMem_GetByte {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_SetError("GetByte requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        use_stack = Compile_ShouldUseStack()
        Compile_DepthPush()
        
        IfCondition EqualTo(use_stack, 1) ThenBlock: {
            Compile_Expression(arg1)
            X86_PushRax()
            Compile_Expression(arg0)
            X86_PopRbx()
        } ElseBlock: {
            reg = Compile_GetDepthReg()
            
            IfCondition EqualTo(reg, 12) ThenBlock: {
                X86_PushR12()
                Compile_Expression(arg1)
                X86_MovR12Rax()
                Compile_Expression(arg0)
                X86_MovRbxR12()
                X86_PopR12()
            } ElseBlock: {
                X86_PushR13()
                Compile_Expression(arg1)
                X86_MovR13Rax()
                Compile_Expression(arg0)
                X86_MovRbxR13()
                X86_PopR13()
            }
        }
        
        Compile_DepthPop()
        
        // RAX = addr, RBX = offset
        // MOVZX RAX, BYTE [RAX + RBX]
        X86_AddRaxRbx()
        X86_MovzxRaxByteRax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// SETBYTE
// SetByte(addr, offset, value) - stores byte at addr+offset
// =============================================================================
Function.CompileMem_SetByte {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 3) ThenBlock: {
            Compile_SetError("SetByte requires 3 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        arg2 = AST_GetChild(node, 2)
        
        // Compile value
        Compile_Expression(arg2)
        X86_PushRax()
        
        // Compile offset
        Compile_Expression(arg1)
        X86_PushRax()
        
        // Compile address
        Compile_Expression(arg0)
        
        // Pop offset into RBX
        X86_PopRbx()
        
        // Add offset to address
        X86_AddRaxRbx()
        X86_MovRdiRax()
        
        // Pop value
        X86_PopRax()
        
        // MOV BYTE [RDI], AL
        X86_MovByteRdiAl()
        
        ReturnValue(1)
    }
}

// =============================================================================
// MEMORYCOPY
// MemoryCopy(dest, src, count) - copies count bytes
// =============================================================================
Function.CompileMem_MemoryCopy {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 3) ThenBlock: {
            Compile_SetError("MemoryCopy requires 3 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        arg2 = AST_GetChild(node, 2)
        
        // Compile count
        Compile_Expression(arg2)
        X86_PushRax()
        
        // Compile source
        Compile_Expression(arg1)
        X86_PushRax()
        
        // Compile destination
        Compile_Expression(arg0)
        X86_MovRdiRax()  // dest in RDI
        
        // Pop source into RSI
        X86_PopRsi()
        
        // Pop count into RCX
        X86_PopRcx()
        
        // REP MOVSB
        X86_RepMovsb()
        
        ReturnValue(1)
    }
}

// =============================================================================
// MEMORYSET
// MemorySet(dest, value, count) - sets count bytes to value
// =============================================================================
Function.CompileMem_MemorySet {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 3) ThenBlock: {
            Compile_SetError("MemorySet requires 3 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        arg2 = AST_GetChild(node, 2)
        
        // Compile count
        Compile_Expression(arg2)
        X86_PushRax()
        
        // Compile value
        Compile_Expression(arg1)
        X86_PushRax()
        
        // Compile destination
        Compile_Expression(arg0)
        X86_MovRdiRax()  // dest in RDI
        
        // Pop value into RAX
        X86_PopRax()
        
        // Pop count into RCX
        X86_PopRcx()
        
        // REP STOSB (stores AL to [RDI], increments RDI, decrements RCX)
        X86_RepStosb()
        
        ReturnValue(1)
    }
}