// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// Library.CCompileMem.ailang
// Memory operations compiler module for the AILang self-hosting compiler
// Handles: Allocate, Deallocate, StoreValue, Dereference, GetByte, SetByte, MemoryCopy, MemorySet

LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// DISPATCHER
// =============================================================================
Function.CompileMem_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(StringCompare(func_name, "Allocate"), 0) ThenBlock: {
            ReturnValue(CompileMem_Allocate(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Deallocate"), 0) ThenBlock: {
            ReturnValue(CompileMem_Deallocate(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "StoreValue"), 0) ThenBlock: {
            ReturnValue(CompileMem_StoreValue(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "Dereference"), 0) ThenBlock: {
            ReturnValue(CompileMem_Dereference(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "GetByte"), 0) ThenBlock: {
            ReturnValue(CompileMem_GetByte(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "SetByte"), 0) ThenBlock: {
            ReturnValue(CompileMem_SetByte(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "MemoryCopy"), 0) ThenBlock: {
            ReturnValue(CompileMem_MemoryCopy(node))
        }
        
        IfCondition EqualTo(StringCompare(func_name, "MemorySet"), 0) ThenBlock: {
            ReturnValue(CompileMem_MemorySet(node))
        }
        
        // Not a memory operation
        ReturnValue(0)
    }
}

// =============================================================================
// ALLOCATE
// Allocate(size) - allocates memory using mmap, returns address in RAX
// =============================================================================
Function.CompileMem_Allocate {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            PrintMessage("[ERROR] Allocate requires 1 argument\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile size argument - result in RAX
        Compile_Expression(arg0)
        
        // Move size to RSI for mmap
        Emit_MovRsiRax()
        
        // mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
        Emit_MovRaxImm64(9)       // syscall: mmap
        Emit_MovRdiImm64(0)       // addr = NULL
        // RSI already has size
        Emit_MovRdxImm64(3)       // PROT_READ | PROT_WRITE
        Emit_MovR10Imm64(34)      // 0x22 = MAP_PRIVATE | MAP_ANONYMOUS
        Emit_MovR8Imm64(-1)       // fd = -1
        Emit_MovR9Imm64(0)        // offset = 0
        Emit_Syscall()
        
        // RAX now contains allocated address (or -1 on error)
        ReturnValue(1)
    }
}

// =============================================================================
// DEALLOCATE
// Deallocate(addr, size) - frees memory using munmap
// =============================================================================
Function.CompileMem_Deallocate {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            PrintMessage("[ERROR] Deallocate requires 2 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile size first, save on stack
        Compile_Expression(arg1)
        Emit_PushRax()
        
        // Compile address
        Compile_Expression(arg0)
        Emit_MovRdiRax()          // addr in RDI
        
        // Pop size into RSI
        Emit_PopRax()
        Emit_MovRsiRax()
        
        // munmap(addr, size)
        Emit_MovRaxImm64(11)      // syscall: munmap
        Emit_Syscall()
        
        ReturnValue(1)
    }
}

// =============================================================================
// STOREVALUE
// StoreValue(addr, value) - stores 64-bit value at address
// =============================================================================
Function.CompileMem_StoreValue {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            PrintMessage("[ERROR] StoreValue requires 2 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile address first, save on stack
        Compile_Expression(arg0)
        Emit_PushRax()
        
        // Compile value
        Compile_Expression(arg1)
        Emit_MovRbxRax()          // value in RBX
        
        // Pop address into RAX
        Emit_PopRax()
        
        // MOV [RAX], RBX
        Emit_MovDerefRaxRbx()
        
        ReturnValue(1)
    }
}

// =============================================================================
// DEREFERENCE
// Dereference(addr) - loads 64-bit value from address, returns in RAX
// =============================================================================
Function.CompileMem_Dereference {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            PrintMessage("[ERROR] Dereference requires 1 argument\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile address
        Compile_Expression(arg0)
        
        // MOV RAX, [RAX]
        Emit_MovRaxDerefRax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// GETBYTE
// GetByte(addr, offset) - loads byte at addr+offset, zero-extended to RAX
// =============================================================================
Function.CompileMem_GetByte {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            PrintMessage("[ERROR] GetByte requires 2 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Compile address, save on stack
        Compile_Expression(arg0)
        Emit_PushRax()
        
        // Compile offset
        Compile_Expression(arg1)
        Emit_MovRbxRax()          // offset in RBX
        
        // Pop address
        Emit_PopRax()
        
        // Add offset to address
        Emit_AddRaxRbx()
        
        // MOVZX RAX, BYTE [RAX]
        Emit_MovzxRaxByteDerefRax()
        
        ReturnValue(1)
    }
}

// =============================================================================
// SETBYTE
// SetByte(addr, offset, value) - stores low byte of value at addr+offset
// =============================================================================
Function.CompileMem_SetByte {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 3) ThenBlock: {
            PrintMessage("[ERROR] SetByte requires 3 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        arg2 = AST_GetChild(node, 2)
        
        // Compile value first, save
        Compile_Expression(arg2)
        Emit_PushRax()
        
        // Compile offset, save
        Compile_Expression(arg1)
        Emit_PushRax()
        
        // Compile address
        Compile_Expression(arg0)
        // RAX = address
        
        // Pop offset into RBX
        Emit_PopRbx()
        
        // Add offset to address: RAX = addr + offset
        Emit_AddRaxRbx()
        
        // Move target address to RDI
        Emit_MovRdiRax()
        
        // Pop value into RAX (will use AL)
        Emit_PopRax()
        
        // MOV [RDI], AL
        Emit_MovByteDerefRdiAl()
        
        ReturnValue(1)
    }
}

// =============================================================================
// MEMORYCOPY
// MemoryCopy(dest, src, count) - copies count bytes from src to dest
// =============================================================================
Function.CompileMem_MemoryCopy {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 3) ThenBlock: {
            PrintMessage("[ERROR] MemoryCopy requires 3 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        arg2 = AST_GetChild(node, 2)
        
        // Compile dest, save on stack
        Compile_Expression(arg0)
        Emit_PushRax()
        
        // Compile src, save on stack
        Compile_Expression(arg1)
        Emit_PushRax()
        
        // Compile count
        Compile_Expression(arg2)
        Emit_MovRcxRax()          // count in RCX
        
        // Pop src into RSI
        Emit_PopRax()
        Emit_MovRsiRax()
        
        // Pop dest into RDI
        Emit_PopRax()
        Emit_MovRdiRax()
        
        // REP MOVSB
        Emit_RepMovsb()
        
        ReturnValue(1)
    }
}

// =============================================================================
// MEMORYSET
// MemorySet(dest, value, count) - sets count bytes at dest to value
// =============================================================================
Function.CompileMem_MemorySet {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 3) ThenBlock: {
            PrintMessage("[ERROR] MemorySet requires 3 arguments\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        arg2 = AST_GetChild(node, 2)
        
        // Compile dest, save on stack
        Compile_Expression(arg0)
        Emit_PushRax()
        
        // Compile value
        Compile_Expression(arg1)
        Emit_PushRax()
        
        // Compile count
        Compile_Expression(arg2)
        Emit_MovRcxRax()          // count in RCX
        
        // Pop value into RAX, save to RBX
        Emit_PopRax()
        Emit_MovRbxRax()          // Save value in RBX (BL = byte)
        
        // Pop dest into RDI
        Emit_PopRax()
        Emit_MovRdiRax()
        
        // Restore value to RAX (AL used by STOSB)
        Emit_MovRaxRbx()
        
        // REP STOSB (stores AL to [RDI], increments RDI, decrements RCX)
        Emit_RepStosb()
        
        ReturnValue(1)
    }
}