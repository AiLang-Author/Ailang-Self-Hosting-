// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// Library.CCompileScope.ailang
// Scope management for the AILang self-hosting compiler
// Mirrors scope_manager.py and the scope save/restore logic in user_functions.py
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileScope.ailang
//
// CRITICAL: Functions need isolated variable scopes
// - Parameters and locals must not pollute global scope
// - Pool variables (high bit set) must be preserved across scopes
// - Stack offsets reset for each function

LibraryImport.XArrays

// =============================================================================
// SCOPE STATE - FixedPool for module state
// =============================================================================
FixedPool.Scope {
    "saved_scopes": Initialize=0
    "func_params": Initialize=0
    "current_func": Initialize=0
    "resolve_type": Initialize=0
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Scope_Init {
    Output: Integer
    Body: {
        Scope.saved_scopes = XArray.XCreate(16)
        Scope.func_params = XArray.XCreate(64)
        Scope.current_func = 0
        Scope.resolve_type = 0
        ReturnValue(1)
    }
}

Function.Scope_Free {
    Output: Integer
    Body: {
        IfCondition NotEqual(Scope.saved_scopes, 0) ThenBlock: {
            // Free any saved scope records
            count = XArray.XSize(Scope.saved_scopes)
            i = 0
            WhileLoop LessThan(i, count) {
                record = XArray.XGet(Scope.saved_scopes, i)
                IfCondition NotEqual(record, 0) ThenBlock: {
                    // Free the saved variables XArray in the record
                    saved_vars = Dereference(record)
                    IfCondition NotEqual(saved_vars, 0) ThenBlock: {
                        XArray.XDestroy(saved_vars)
                    }
                    Deallocate(record, 32)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Scope.saved_scopes)
            Scope.saved_scopes = 0
        }
        
        IfCondition NotEqual(Scope.func_params, 0) ThenBlock: {
            // Free param records
            count = XArray.XSize(Scope.func_params)
            i = 0
            WhileLoop LessThan(i, count) {
                record = XArray.XGet(Scope.func_params, i)
                IfCondition NotEqual(record, 0) ThenBlock: {
                    Deallocate(record, 24)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Scope.func_params)
            Scope.func_params = 0
        }
        
        Scope.current_func = 0
        ReturnValue(1)
    }
}

// =============================================================================
// SCOPE SAVE/RESTORE
// Called when entering/exiting a function to isolate variables
// =============================================================================

// Save current scope and create fresh scope for function
// Preserves pool variables (high bit set in offset)
Function.Scope_SaveAndClear {
    Input: func_name: Address
    Output: Integer
    Body: {
        // Allocate scope record: [saved_vars, stack_size, stack_offset, func_name]
        record = Allocate(32)
        
        // Copy current variables to saved XArray
        saved_vars = XArray.XCreate(128)
        var_count = XArray.XSize(Compile.variables)
        i = 0
        WhileLoop LessThan(i, var_count) {
            entry = XArray.XGet(Compile.variables, i)
            IfCondition NotEqual(entry, 0) ThenBlock: {
                // Copy the variable entry (24 bytes: name, offset, type)
                copy = Allocate(24)
                StoreValue(copy, Dereference(entry))
                StoreValue(Add(copy, 8), Dereference(Add(entry, 8)))
                StoreValue(Add(copy, 16), Dereference(Add(entry, 16)))
                XArray.XPush(saved_vars, copy)
            }
            i = Add(i, 1)
        }
        
        // Store in record
        StoreValue(record, saved_vars)
        StoreValue(Add(record, 8), Compile.stack_size)
        StoreValue(Add(record, 16), Compile.stack_offset)
        StoreValue(Add(record, 24), Scope.current_func)
        
        // Push to scope stack
        XArray.XPush(Scope.saved_scopes, record)
        
        // Set current function
        Scope.current_func = func_name
        
        // Collect pool variables to preserve before clearing
        pool_vars = XArray.XCreate(32)
        i = 0
        WhileLoop LessThan(i, var_count) {
            entry = XArray.XGet(Compile.variables, i)
            IfCondition NotEqual(entry, 0) ThenBlock: {
                offset = Dereference(Add(entry, 8))
                // Check high bit for pool variable marker (0x80000000)
                high_bit = BitwiseAnd(offset, 2147483648)
                IfCondition NotEqual(high_bit, 0) ThenBlock: {
                    // This is a pool variable - preserve it
                    XArray.XPush(pool_vars, entry)
                }
            }
            i = Add(i, 1)
        }
        
        // Clear the variables array
        XArray.XClear(Compile.variables)
        
        // Add pool variables back
        pool_count = XArray.XSize(pool_vars)
        i = 0
        WhileLoop LessThan(i, pool_count) {
            entry = XArray.XGet(pool_vars, i)
            XArray.XPush(Compile.variables, entry)
            i = Add(i, 1)
        }
        XArray.XDestroy(pool_vars)
        
        // Reset stack tracking for function scope
        Compile.stack_size = 0
        Compile.stack_offset = 0
        
        ReturnValue(1)
    }
}

// Restore previous scope after function compilation
Function.Scope_Restore {
    Output: Integer
    Body: {
        scope_count = XArray.XSize(Scope.saved_scopes)
        IfCondition EqualTo(scope_count, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Pop the saved scope record
        record = XArray.XGet(Scope.saved_scopes, Subtract(scope_count, 1))
        XArray.XPop(Scope.saved_scopes)
        
        IfCondition EqualTo(record, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Clear current variables (free entries that aren't pool vars)
        var_count = XArray.XSize(Compile.variables)
        i = 0
        WhileLoop LessThan(i, var_count) {
            entry = XArray.XGet(Compile.variables, i)
            IfCondition NotEqual(entry, 0) ThenBlock: {
                offset = Dereference(Add(entry, 8))
                high_bit = BitwiseAnd(offset, 2147483648)
                // Only free non-pool variables (they were allocated fresh)
                IfCondition EqualTo(high_bit, 0) ThenBlock: {
                    Deallocate(entry, 24)
                }
            }
            i = Add(i, 1)
        }
        XArray.XClear(Compile.variables)
        
        // Restore saved variables
        saved_vars = Dereference(record)
        saved_count = XArray.XSize(saved_vars)
        i = 0
        WhileLoop LessThan(i, saved_count) {
            entry = XArray.XGet(saved_vars, i)
            XArray.XPush(Compile.variables, entry)
            i = Add(i, 1)
        }
        
        // Restore stack state
        Compile.stack_size = Dereference(Add(record, 8))
        Compile.stack_offset = Dereference(Add(record, 16))
        Scope.current_func = Dereference(Add(record, 24))
        
        // Free the saved_vars array (but not entries - they're now in Compile.variables)
        XArray.XDestroy(saved_vars)
        Deallocate(record, 32)
        
        ReturnValue(1)
    }
}

// =============================================================================
// PARAMETER REGISTRATION
// Track function parameters for resolution
// =============================================================================

// Register a parameter for the current function
Function.Scope_AddParameter {
    Input: param_name: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(Scope.current_func, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Create param record: [func_name, param_name, offset] (24 bytes)
        record = Allocate(24)
        StoreValue(record, Scope.current_func)
        StoreValue(Add(record, 8), param_name)
        StoreValue(Add(record, 16), offset)
        
        XArray.XPush(Scope.func_params, record)
        
        ReturnValue(1)
    }
}

// Resolve a variable name - check params first, then globals
// Returns: offset (valid offset for found, -1 for not found)
// Sets Scope.resolve_type: 0=not found, 1=param, 2=global, 3=pool
Function.Scope_Resolve {
    Input: name: Address
    Output: Integer
    Body: {
        Scope.resolve_type = 0
        
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        // 1. Check function parameters first (if in a function)
        IfCondition NotEqual(Scope.current_func, 0) ThenBlock: {
            param_count = XArray.XSize(Scope.func_params)
            i = 0
            WhileLoop LessThan(i, param_count) {
                record = XArray.XGet(Scope.func_params, i)
                IfCondition NotEqual(record, 0) ThenBlock: {
                    rec_func = Dereference(record)
                    rec_name = Dereference(Add(record, 8))
                    rec_offset = Dereference(Add(record, 16))
                    
                    // Check if this param belongs to current function
                    func_cmp = StringCompare(rec_func, Scope.current_func)
                    IfCondition EqualTo(func_cmp, 0) ThenBlock: {
                        name_cmp = StringCompare(rec_name, name)
                        IfCondition EqualTo(name_cmp, 0) ThenBlock: {
                            Scope.resolve_type = 1
                            ReturnValue(rec_offset)
                        }
                    }
                }
                i = Add(i, 1)
            }
        }
        
        // 2. Check Compile.variables (includes globals and pool vars)
        var_count = XArray.XSize(Compile.variables)
        i = 0
        WhileLoop LessThan(i, var_count) {
            entry = XArray.XGet(Compile.variables, i)
            IfCondition NotEqual(entry, 0) ThenBlock: {
                var_name = Dereference(entry)
                var_offset = Dereference(Add(entry, 8))
                
                cmp = StringCompare(var_name, name)
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    // Check if pool variable
                    var_type = Dereference(Add(entry, 16))
                IfCondition EqualTo(var_type, VarType.POOL) ThenBlock: {
                    Scope.resolve_type = 3
                } ElseBlock: {
                    Scope.resolve_type = 2
                }
                ReturnValue(var_offset)
                }
            }
            i = Add(i, 1)
        }
        
        // 3. Not found
        Scope.resolve_type = 0
        ReturnValue(-1)
    }
}

// =============================================================================
// CONVENIENCE FUNCTIONS
// =============================================================================

// Check if currently inside a function scope
Function.Scope_InFunction {
    Output: Integer
    Body: {
        IfCondition NotEqual(Scope.current_func, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Get current function name (or 0 if not in function)
Function.Scope_GetCurrentFunc {
    Output: Address
    Body: {
        ReturnValue(Scope.current_func)
    }
}

// Clear all parameters for a function (called when exiting function)
Function.Scope_ClearFunctionParams {
    Input: func_name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Mark params for this function as invalid (set func to 0)
        param_count = XArray.XSize(Scope.func_params)
        i = 0
        WhileLoop LessThan(i, param_count) {
            record = XArray.XGet(Scope.func_params, i)
            IfCondition NotEqual(record, 0) ThenBlock: {
                rec_func = Dereference(record)
                IfCondition NotEqual(rec_func, 0) ThenBlock: {
                    cmp = StringCompare(rec_func, func_name)
                    IfCondition EqualTo(cmp, 0) ThenBlock: {
                        // Invalidate by setting func_name to 0
                        StoreValue(record, 0)
                    }
                }
            }
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}