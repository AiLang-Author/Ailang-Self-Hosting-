// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileStmt.ailang
// Statement compiler module for the AILang self-hosting compiler
// Handles: Assignment, Return, If, While, For, Block, Break, Continue

LibraryImport.Compiler.Compile.CCompileTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp

// =============================================================================
// MAIN STATEMENT COMPILER
// Dispatches based on node type
// =============================================================================
Function.Compile_Statement {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(1)  // Empty statement is OK
        }
        
        node_type = AST_GetNodeType(node)
        
        IfCondition EqualTo(node_type, NodeType.ASSIGNMENT) ThenBlock: {
            ReturnValue(CompileStmt_Assignment(node))
        }
        
        IfCondition EqualTo(node_type, NodeType.RETURN) ThenBlock: {
            ReturnValue(CompileStmt_Return(node))
        }
        
        IfCondition EqualTo(node_type, NodeType.IF) ThenBlock: {
            ReturnValue(CompileStmt_If(node))
        }
        
        IfCondition EqualTo(node_type, NodeType.WHILE) ThenBlock: {
            ReturnValue(CompileStmt_While(node))
        }
        
        IfCondition EqualTo(node_type, NodeType.FOR) ThenBlock: {
            ReturnValue(CompileStmt_For(node))
        }
        
        IfCondition EqualTo(node_type, NodeType.BLOCK) ThenBlock: {
            ReturnValue(CompileStmt_Block(node))
        }
        
        IfCondition EqualTo(node_type, NodeType.CALL) ThenBlock: {
            // Expression statement (function call with no assignment)
            ReturnValue(Compile_FunctionCall(node))
        }
        
        // Check for break/continue by function name
        IfCondition EqualTo(node_type, NodeType.CALL) ThenBlock: {
            func_name = AST_GetFunctionName(node)
            
            IfCondition EqualTo(StringCompare(func_name, "BreakLoop"), 0) ThenBlock: {
                ReturnValue(CompileStmt_Break(node))
            }
            
            IfCondition EqualTo(StringCompare(func_name, "ContinueLoop"), 0) ThenBlock: {
                ReturnValue(CompileStmt_Continue(node))
            }
        }
        
        // Try as expression statement
        ReturnValue(Compile_Expression(node))
    }
}

// =============================================================================
// ASSIGNMENT
// target = value
// =============================================================================
Function.CompileStmt_Assignment {
    Input: node: Address
    Output: Integer
    Body: {
        target_name = AST_GetAssignTarget(node)
        value_node = AST_GetAssignValue(node)
        
        // Compile the value expression - result in RAX
        result = Compile_Expression(value_node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if variable exists
        stack_offset = Compile_FindVariable(target_name)
        
        IfCondition EqualTo(stack_offset, 0) ThenBlock: {
            // New variable - allocate on stack
            // Default type is INTEGER, size 8
            stack_offset = Compile_AddVariable(target_name, VarType.INTEGER, 8, VarFlags.LOCAL)
            IfCondition EqualTo(stack_offset, -1) ThenBlock: {
                Compile_SetError("Failed to allocate variable", AST_GetLine(node))
                ReturnValue(0)
            }
        }
        
        // Store RAX to [RBP + offset]
        X86_MovRbpOffsetRax(stack_offset)
        
        ReturnValue(1)
    }
}

// =============================================================================
// RETURN
// ReturnValue(expr)
// =============================================================================
Function.CompileStmt_Return {
    Input: node: Address
    Output: Integer
    Body: {
        // Get return value expression
        return_value = AST_GetReturnValue(node)
        
        IfCondition NotEqual(return_value, 0) ThenBlock: {
            // Compile return value - result in RAX
            result = Compile_Expression(return_value)
            IfCondition EqualTo(result, 0) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        // Emit function epilogue and return
        // (The actual epilogue will be emitted by the function compiler)
        // For now, just emit the jump to the function's exit label
        
        // Get function exit label
        exit_label = Compile_GetFunctionExitLabel()
        IfCondition GreaterEqual(exit_label, 0) ThenBlock: {
            Emit_JumpToLabel(exit_label, CC.ALWAYS)
        } ElseBlock: {
            // Direct return if no exit label (shouldn't happen in practice)
            X86_Ret()
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// IF STATEMENT
// IfCondition expr ThenBlock: { ... } ElseBlock: { ... }
// =============================================================================
Function.CompileStmt_If {
    Input: node: Address
    Output: Integer
    Body: {
        condition = AST_GetIfCondition(node)
        then_block = AST_GetIfThenBlock(node)
        else_block = AST_GetIfElseBlock(node)
        
        else_label = Compile_NewLabel()
        end_label = Compile_NewLabel()
        
        // Compile condition - result in RAX
        result = Compile_Expression(condition)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // TEST RAX, RAX
        X86_TestRaxRax()
        
        // JZ else_label (if condition is 0, jump to else)
        Emit_JumpToLabel(else_label, CC.Z)
        
        // Compile then block
        result = CompileStmt_Block(then_block)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // If there's an else block, jump over it
        IfCondition NotEqual(else_block, 0) ThenBlock: {
            Emit_JumpToLabel(end_label, CC.ALWAYS)
        }
        
        // Else label
        Emit_MarkLabel(else_label)
        
        // Compile else block if present
        IfCondition NotEqual(else_block, 0) ThenBlock: {
            result = CompileStmt_Block(else_block)
            IfCondition EqualTo(result, 0) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        // End label
        Emit_MarkLabel(end_label)
        
        ReturnValue(1)
    }
}

// =============================================================================
// WHILE LOOP
// WhileLoop condition { ... }
// =============================================================================
Function.CompileStmt_While {
    Input: node: Address
    Output: Integer
    Body: {
        condition = AST_GetWhileCondition(node)
        body = AST_GetWhileBody(node)
        
        loop_start = Compile_NewLabel()
        loop_end = Compile_NewLabel()
        
        // Push loop context for break/continue
        Compile_PushLoop(loop_end, loop_start)
        
        // Loop start label
        Emit_MarkLabel(loop_start)
        
        // Compile condition
        result = Compile_Expression(condition)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_PopLoop()
            ReturnValue(0)
        }
        
        // TEST RAX, RAX
        X86_TestRaxRax()
        
        // JZ loop_end (if condition is 0, exit loop)
        Emit_JumpToLabel(loop_end, CC.Z)
        
        // Compile body
        result = CompileStmt_Block(body)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_PopLoop()
            ReturnValue(0)
        }
        
        // Jump back to start
        Emit_JumpToLabel(loop_start, CC.ALWAYS)
        
        // Loop end label
        Emit_MarkLabel(loop_end)
        
        // Pop loop context
        Compile_PopLoop()
        
        ReturnValue(1)
    }
}

// =============================================================================
// FOR LOOP
// ForEvery var in collection { ... }
// (Simplified - assumes integer range for now)
// =============================================================================
Function.CompileStmt_For {
    Input: node: Address
    Output: Integer
    Body: {
        var_name = AST_GetForVariable(node)
        start_expr = AST_GetForStart(node)
        end_expr = AST_GetForEnd(node)
        body = AST_GetForBody(node)
        
        loop_start = Compile_NewLabel()
        loop_continue = Compile_NewLabel()
        loop_end = Compile_NewLabel()
        
        // Compile start value and assign to loop variable
        result = Compile_Expression(start_expr)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Create or find loop variable
        var_offset = Compile_FindVariable(var_name)
        IfCondition EqualTo(var_offset, 0) ThenBlock: {
            var_offset = Compile_AddVariable(var_name, VarType.INTEGER, 8, VarFlags.LOCAL)
        }
        
        // Store initial value
        X86_MovRbpOffsetRax(var_offset)
        
        // Push loop context
        Compile_PushLoop(loop_end, loop_continue)
        
        // Loop start
        Emit_MarkLabel(loop_start)
        
        // Load loop variable
        X86_MovRaxRbpOffset(var_offset)
        X86_PushRax()
        
        // Compile end expression
        result = Compile_Expression(end_expr)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_PopLoop()
            ReturnValue(0)
        }
        
        // Compare: loop_var < end_value
        X86_MovRbxRax()
        X86_PopRax()
        X86_CmpRaxRbx()
        
        // JGE loop_end (if var >= end, exit)
        Emit_JumpToLabel(loop_end, CC.GE)
        
        // Compile body
        result = CompileStmt_Block(body)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_PopLoop()
            ReturnValue(0)
        }
        
        // Continue label (for ContinueLoop)
        Emit_MarkLabel(loop_continue)
        
        // Increment loop variable
        X86_MovRaxRbpOffset(var_offset)
        X86_IncRax()
        X86_MovRbpOffsetRax(var_offset)
        
        // Jump back to start
        Emit_JumpToLabel(loop_start, CC.ALWAYS)
        
        // Loop end
        Emit_MarkLabel(loop_end)
        
        Compile_PopLoop()
        
        ReturnValue(1)
    }
}

// =============================================================================
// BLOCK
// { statement; statement; ... }
// =============================================================================
Function.CompileStmt_Block {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(1)  // Empty block is OK
        }
        
        stmt_count = AST_GetBlockStatementCount(node)
        
        i = 0
        WhileLoop LessThan(i, stmt_count) {
            stmt = AST_GetBlockStatement(node, i)
            
            result = Compile_Statement(stmt)
            IfCondition EqualTo(result, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// BREAK
// BreakLoop
// =============================================================================
Function.CompileStmt_Break {
    Input: node: Address
    Output: Integer
    Body: {
        break_label = Compile_GetBreakLabel()
        
        IfCondition LessThan(break_label, 0) ThenBlock: {
            Compile_SetError("BreakLoop outside of loop", AST_GetLine(node))
            ReturnValue(0)
        }
        
        Emit_JumpToLabel(break_label, CC.ALWAYS)
        
        ReturnValue(1)
    }
}

// =============================================================================
// CONTINUE
// ContinueLoop
// =============================================================================
Function.CompileStmt_Continue {
    Input: node: Address
    Output: Integer
    Body: {
        continue_label = Compile_GetContinueLabel()
        
        IfCondition LessThan(continue_label, 0) ThenBlock: {
            Compile_SetError("ContinueLoop outside of loop", AST_GetLine(node))
            ReturnValue(0)
        }
        
        Emit_JumpToLabel(continue_label, CC.ALWAYS)
        
        ReturnValue(1)
    }
}