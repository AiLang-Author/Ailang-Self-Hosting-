// Library.CCompileStmt.ailang
// Statement compiler module for the AILang self-hosting compiler
// Handles: Assignment, Return, If, While, Block, Break, Continue

LibraryImport.XArrays

LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// ASSIGNMENT
// target = value
// =============================================================================
Function.CompileStmt_Assignment {
    Input: node: Address
    Output: Integer
    Body: {
        target_name = AST_GetData1(node)
        value_node = AST_GetChild(node, 0)
        
        IfCondition EqualTo(value_node, 0) ThenBlock: {
            PrintMessage("[COMPILE ERROR] Assignment with null value\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // Compile RHS expression → result in RAX
        result = Compile_Expression(value_node)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Store RAX to variable
        ReturnValue(CompileExpr_StoreVariable(target_name))
    }
}

// =============================================================================
// RETURN
// ReturnValue(expr)
// =============================================================================
Function.CompileStmt_Return {
    Input: node: Address
    Output: Integer
    Body: {
        // Get return value expression (first child)
        return_value = AST_GetChild(node, 0)
        
        IfCondition NotEqual(return_value, 0) ThenBlock: {
            // Compile return value → RAX
            result = Compile_Expression(return_value)
            IfCondition EqualTo(result, 0) ThenBlock: {
                ReturnValue(0)
            }
        }
        
        // Jump to function exit label
        exit_label = Compile.current_return_label
        IfCondition GreaterEqual(exit_label, 0) ThenBlock: {
            Emit_Jmp(exit_label)
        } ElseBlock: {
            // Direct return if no exit label
            Emit_Ret()
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// IF STATEMENT
// IfCondition expr ThenBlock: { ... } ElseBlock: { ... }
// =============================================================================
Function.CompileStmt_If {
    Input: node: Address
    Output: Integer
    Body: {
        condition = AST_GetChild(node, 0)
        then_block = AST_GetChild(node, 1)
        
        child_count = AST_GetChildCount(node)
        has_else = GreaterThan(child_count, 2)
        else_block = 0
        IfCondition EqualTo(has_else, 1) ThenBlock: {
            else_block = AST_GetChild(node, 2)
        }
        
        else_label = Compile_NewLabel()
        
        // Only create end_label if we have an else block
        end_label = 0
        IfCondition EqualTo(has_else, 1) ThenBlock: {
            end_label = Compile_NewLabel()
        }
        
        // Compile condition
        result = Compile_Expression(condition)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Emit_TestRaxRax()
        Emit_Jz(else_label)
        
        // Compile then block
        result = CompileStmt_Block(then_block)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Jump over else only if else exists
        IfCondition EqualTo(has_else, 1) ThenBlock: {
            Emit_Jmp(end_label)
        }
        
        // Mark else label (always - this is where we land if condition false)
        Emit_MarkLabel(else_label)
        
        // Compile else block if present
        IfCondition EqualTo(has_else, 1) ThenBlock: {
            result = CompileStmt_Block(else_block)
            IfCondition EqualTo(result, 0) ThenBlock: {
                ReturnValue(0)
            }
            Emit_MarkLabel(end_label)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// WHILE LOOP
// WhileLoop condition { ... }
// =============================================================================
Function.CompileStmt_While {
    Input: node: Address
    Output: Integer
    Body: {
        condition = AST_GetChild(node, 0)
        body = AST_GetChild(node, 1)
        
        loop_start = Compile_NewLabel()
        loop_end = Compile_NewLabel()
        
        // Push loop context for break/continue
        Compile_PushLoop(loop_end, loop_start)
        
        // Mark loop start
        Emit_MarkLabel(loop_start)
        
        // Compile condition → RAX
        result = Compile_Expression(condition)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_PopLoop()
            ReturnValue(0)
        }
        
        // TEST RAX, RAX
        Emit_TestRaxRax()
        
        // JZ loop_end (if condition is 0, exit loop)
        Emit_Jz(loop_end)
        
        // Compile body
        result = CompileStmt_Block(body)
        IfCondition EqualTo(result, 0) ThenBlock: {
            Compile_PopLoop()
            ReturnValue(0)
        }
        
        // Jump back to start
        Emit_Jmp(loop_start)
        
        // Mark loop end
        Emit_MarkLabel(loop_end)
        
        Compile_PopLoop()
        
        ReturnValue(1)
    }
}

// =============================================================================
// BLOCK
// { statement; statement; ... }
// =============================================================================
Function.CompileStmt_Block {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(1)  // Empty block OK
        }
        
        count = AST_GetChildCount(node)
        i = 0
        
        WhileLoop LessThan(i, count) {
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                ExitLoop
            }
            
            child = AST_GetChild(node, i)
            Compile_Node(child)
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// BREAK
// ExitLoop
// =============================================================================
Function.CompileStmt_Break {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(Compile.loop_depth, 0) ThenBlock: {
            PrintMessage("[COMPILE ERROR] ExitLoop outside of loop\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // Get break label from loop stack (first of pair)
        ctx_index = Subtract(Compile.loop_depth, 1)
        break_label = XArray.XGet(Compile.loop_stack, Multiply(ctx_index, 2))
        
        Emit_Jmp(break_label)
        ReturnValue(1)
    }
}

// =============================================================================
// CONTINUE
// ContinueLoop
// =============================================================================
Function.CompileStmt_Continue {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(Compile.loop_depth, 0) ThenBlock: {
            PrintMessage("[COMPILE ERROR] ContinueLoop outside of loop\n")
            Compile.error = 1
            ReturnValue(0)
        }
        
        // Get continue label from loop stack (second of pair)
        ctx_index = Subtract(Compile.loop_depth, 1)
        continue_label = XArray.XGet(Compile.loop_stack, Add(Multiply(ctx_index, 2), 1))
        
        Emit_Jmp(continue_label)
        ReturnValue(1)
    }
}

// =============================================================================
// LOOP CONTEXT HELPERS
// =============================================================================
Function.Compile_PushLoop {
    Input: break_label: Integer
    Input: continue_label: Integer
    Body: {
        XArray.XPush(Compile.loop_stack, break_label)
        XArray.XPush(Compile.loop_stack, continue_label)
        Compile.loop_depth = Add(Compile.loop_depth, 1)
    }
}

Function.Compile_PopLoop {
    Body: {
        IfCondition GreaterThan(Compile.loop_depth, 0) ThenBlock: {
            XArray.XPop(Compile.loop_stack)
            XArray.XPop(Compile.loop_stack)
            Compile.loop_depth = Subtract(Compile.loop_depth, 1)
        }
    }
}