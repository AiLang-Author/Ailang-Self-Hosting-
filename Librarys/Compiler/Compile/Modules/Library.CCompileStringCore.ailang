// Library.CCompileStringCore.ailang
// Core string operations: StringCompare, StringLength, StringCopy, StringEquals
// Uses EMIT_* macros for ISA abstraction
// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// SPDX-License-Identifier: SCSL-1.0

LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Macros

// =============================================================================
// INLINE STRING COMPARISON HELPER
// Used to avoid chicken-and-egg: can't use StringCompare to dispatch StringCompare!
// =============================================================================
// FIXED VERSION - No GetByte calls!
// Uses direct memory dereference instead

Function.StringCore_MatchName {
    Input: func_name: Address
    Input: target: Address
    Output: Integer
    Body: {
        // Safety checks - pointer equality first (fast path)
        IfCondition EqualTo(func_name, target) ThenBlock: { 
            ReturnValue(1) 
        }
        
        // Null checks
        IfCondition EqualTo(func_name, 0) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(target, 0) ThenBlock: { ReturnValue(0) }
        
        // Manual byte-by-byte comparison using DIRECT DEREFERENCE
        // This avoids GetByte() which may not be available at init time
        i = 0
        WhileLoop LessThan(i, 64) {  // Max 64 char names
            // Get pointers to current bytes
            ptr1 = Add(func_name, i)
            ptr2 = Add(target, i)
            
            // Dereference as single bytes
            // We use AND with 0xFF to mask to byte value
            c1 = And(Dereference(ptr1), 255)
            c2 = And(Dereference(ptr2), 255)
            
            // If both are null terminators, we have a match
            IfCondition EqualTo(c1, 0) ThenBlock: {
                IfCondition EqualTo(c2, 0) ThenBlock: {
                    ReturnValue(1)
                }
                // c1 is null but c2 isn't - no match
                ReturnValue(0)
            }
            
            // If c2 is null but c1 isn't - no match
            IfCondition EqualTo(c2, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            // Both non-null - compare them
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(0)
            }
            
            // Characters match, continue to next
            i = Add(i, 1)
        }
        
        // Hit max length without finding null terminators - assume no match
        ReturnValue(0)
    }
}

// =============================================================================
// MODULE DISPATCHER
// =============================================================================
Function.CompileStringCore_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // StringCompare
        match = StringCore_MatchName(func_name, "StringCompare")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Compare(node))
        }
        
        // StringLength
        match = StringCore_MatchName(func_name, "StringLength")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Length(node))
        }
        
        // StringEquals
        match = StringCore_MatchName(func_name, "StringEquals")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Equals(node))
        }
        
        // StringCopy
        match = StringCore_MatchName(func_name, "StringCopy")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Copy(node))
        }
        
        // Not a core string operation
        ReturnValue(0)
    }
}

// =============================================================================
// STRINGCOMPARE
// Compare two strings byte-by-byte
// Returns: 0 if equal, non-zero if different
// =============================================================================
Function.CompileStringCore_Compare {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringCompare requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Save registers using macro
        EMIT_SAVE_STRING_REGS()
        
        // Compile first string -> RAX, then setup PTR1
        Compile_Expression(arg0)
        EMIT_SETUP_STRING_PTR1()
        
        // Compile second string -> RAX, then setup PTR2
        Compile_Expression(arg1)
        EMIT_SETUP_STRING_PTR2()
        
        // Create labels
        cmp_loop = Emit_CreateLabel()
        cmp_equal = Emit_CreateLabel()
        cmp_not_equal = Emit_CreateLabel()
        done_label = Emit_CreateLabel()
        
        // Loop: compare byte by byte
        Emit_MarkLabel(cmp_loop)
        
        EMIT_LOAD_BYTE_PTR1()      // Load byte from first string
        EMIT_LOAD_BYTE_PTR2()      // Load byte from second string
        EMIT_COMPARE_BYTES()       // Compare them
        
        Emit_JumpToLabel(cmp_not_equal, CC.NE)  // Jump if not equal
        
        EMIT_TEST_BYTE_ZERO()      // Check if null terminator
        Emit_JumpToLabel(cmp_equal, CC.Z)  // If null, strings match
        
        EMIT_INCREMENT_PTR1()      // Advance first pointer
        EMIT_INCREMENT_PTR2()      // Advance second pointer
        Emit_JumpToLabel(cmp_loop, CC.ALWAYS)
        
        // Strings are equal
        Emit_MarkLabel(cmp_equal)
        EMIT_RETURN_VALUE(0)
        Emit_JumpToLabel(done_label, CC.ALWAYS)
        
        // Strings are not equal
        Emit_MarkLabel(cmp_not_equal)
        EMIT_RETURN_VALUE(1)
        
        // Done
        Emit_MarkLabel(done_label)
        
        // Restore registers using macro
        EMIT_RESTORE_STRING_REGS()
        
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGLENGTH
// Get length of null-terminated string
// Returns: Integer length
// =============================================================================
Function.CompileStringCore_Length {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("StringLength requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Save registers (minimal set for length)
        EMIT_SAVE_STRING_REGS()
        
        // Compile string -> RAX, then setup pointer
        Compile_Expression(arg0)
        EMIT_SETUP_LENGTH_PTR()
        
        // Initialize counter to 0
        EMIT_SETUP_LENGTH_COUNT()
        
        // Create labels
        len_loop = Emit_CreateLabel()
        len_done = Emit_CreateLabel()
        
        // Loop: count bytes until null
        Emit_MarkLabel(len_loop)
        
        EMIT_COMPARE_BYTE_NULL()   // Compare byte with null
        Emit_JumpToLabel(len_done, CC.E)  // Jump if null
        
        EMIT_INCREMENT_LENGTH()    // Increment counter
        Emit_JumpToLabel(len_loop, CC.ALWAYS)
        
        // Done - move length to return register
        Emit_MarkLabel(len_done)
        EMIT_RETURN_LENGTH()
        
        // Restore registers
        EMIT_RESTORE_STRING_REGS()
        
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGEQUALS - Stub for now
// =============================================================================
Function.CompileStringCore_Equals {
    Input: node: Address
    Output: Integer
    Body: {
        // For now, just call StringCompare (same implementation)
        ReturnValue(CompileStringCore_Compare(node))
    }
}

// =============================================================================
// STRINGCOPY - Stub for now
// =============================================================================
Function.CompileStringCore_Copy {
    Input: node: Address
    Output: Integer
    Body: {
        Compile_Error("StringCopy not yet implemented", AST_GetLine(node))
        ReturnValue(0)
    }
}