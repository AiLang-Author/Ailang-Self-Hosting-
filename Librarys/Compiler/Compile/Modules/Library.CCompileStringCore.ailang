// Library.CCompileStringCore.ailang
// Core string operations: StringCompare, StringLength, StringCopy, StringEquals
// Uses ONLY Emit_* functions - NO raw bytes in compile modules
// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// SPDX-License-Identifier: SCSL-1.0

LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// INLINE STRING COMPARISON HELPER
// Used to avoid chicken-and-egg: can't use StringCompare to dispatch StringCompare!
// =============================================================================
Function.StringCore_MatchName {
    Input: func_name: Address
    Input: target: Address
    Output: Integer
    Body: {
        // Safety checks - pointer equality first (fast path)
        IfCondition EqualTo(func_name, target) ThenBlock: { 
            ReturnValue(1) 
        }
        
        // Null checks
        IfCondition EqualTo(func_name, 0) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(target, 0) ThenBlock: { ReturnValue(0) }
        
        // Manual byte-by-byte comparison
        i = 0
        WhileLoop LessThan(i, 64) {
            ptr1 = Add(func_name, i)
            ptr2 = Add(target, i)
            
            c1 = BitwiseAnd(Dereference(ptr1), 255)
            c2 = BitwiseAnd(Dereference(ptr2), 255)
            
            IfCondition EqualTo(c1, 0) ThenBlock: {
                IfCondition EqualTo(c2, 0) ThenBlock: {
                    ReturnValue(1)
                }
                ReturnValue(0)
            }
            
            IfCondition EqualTo(c2, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(0)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// MODULE DISPATCHER
// =============================================================================
Function.CompileStringCore_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // StringCompare
        match = StringCore_MatchName(func_name, "StringCompare")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Compare(node))
        }
        
        // StringLength
        match = StringCore_MatchName(func_name, "StringLength")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Length(node))
        }
        
        // StringEquals
        match = StringCore_MatchName(func_name, "StringEquals")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Equals(node))
        }
        
        // StringCopy
        match = StringCore_MatchName(func_name, "StringCopy")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Copy(node))
        }
        

        // StringConcat
        match = StringCore_MatchName(func_name, "StringConcat")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Concat(node))
        }
        
        // Not a core string operation
        ReturnValue(0)
    }
}

// =============================================================================
// STRINGCOMPARE
// Compare two strings byte-by-byte
// Returns: 0 if equal, non-zero if different
// =============================================================================
Function.CompileStringCore_Compare {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringCompare requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Save callee-saved registers
        Emit_PushRbx()
        Emit_PushRcx()
        Emit_PushRdx()
        Emit_PushRsi()
        Emit_PushRdi()
        
        // Compile first string -> RAX, then move to RDI
        Compile_Expression(arg0)
        Emit_MovRdiRax()
        
        // Compile second string -> RAX, then move to RSI
        Compile_Expression(arg1)
        Emit_MovRsiRax()
        
        // Create labels
        cmp_loop = Emit_CreateLabel()
        cmp_equal = Emit_CreateLabel()
        cmp_not_equal = Emit_CreateLabel()
        done_label = Emit_CreateLabel()
        
        // Loop: compare byte by byte
        Emit_MarkLabel(cmp_loop)
        
        // Load bytes: AL = [RDI], BL = [RSI]
        Emit_MovAlDerefRdi()
        Emit_MovBlDerefRsi()
        
        // Compare: CMP AL, BL
        Emit_CmpAlBl()
        
        // Jump if not equal
        Emit_JumpToLabel(cmp_not_equal, CC.NE)
        
        // Check for null terminator: TEST AL, AL
        Emit_TestAlAl()
        
        // If null (ZF=1), strings are equal
        Emit_JumpToLabel(cmp_equal, CC.Z)
        
        // Advance pointers
        Emit_IncRdi()
        Emit_IncRsi()
        
        // Continue loop
        Emit_JumpToLabel(cmp_loop, CC.ALWAYS)
        
        // Strings are equal - return 0
        Emit_MarkLabel(cmp_equal)
        Emit_MovRaxImm64(0)
        Emit_JumpToLabel(done_label, CC.ALWAYS)
        
        // Strings are not equal - return 1
        Emit_MarkLabel(cmp_not_equal)
        Emit_MovRaxImm64(1)
        
        // Done
        Emit_MarkLabel(done_label)
        
        // Restore registers (reverse order)
        Emit_PopRdi()
        Emit_PopRsi()
        Emit_PopRdx()
        Emit_PopRcx()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGLENGTH
// Get length of null-terminated string
// Returns: Integer length in RAX
// =============================================================================
Function.CompileStringCore_Length {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("StringLength requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Save registers
        Emit_PushRbx()
        Emit_PushRcx()
        
        // Compile string -> RAX, then move to RBX
        Compile_Expression(arg0)
        Emit_MovRbxRax()
        
        // Initialize counter RAX = 0
        Emit_MovRaxImm64(0)
        
        // Create labels
        len_loop = Emit_CreateLabel()
        len_done = Emit_CreateLabel()
        
        // Loop: count bytes until null
        Emit_MarkLabel(len_loop)
        
        // Load byte: CL = [RBX]
        Emit_MovClDerefRbx()
        
        // Check for null: TEST CL, CL
        Emit_TestClCl()
        
        // If zero, we're done
        Emit_JumpToLabel(len_done, CC.Z)
        
        // Increment counter
        Emit_IncRax()
        
        // Advance pointer
        Emit_IncRbx()
        
        // Continue loop
        Emit_JumpToLabel(len_loop, CC.ALWAYS)
        
        // Done - RAX already contains length
        Emit_MarkLabel(len_done)
        
        // Restore registers
        Emit_PopRcx()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGEQUALS
// Compare two strings - returns 1 if equal, 0 if different
// (Semantically inverted from StringCompare for boolean use)
// =============================================================================
Function.CompileStringCore_Equals {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringEquals requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Save registers
        Emit_PushRcx()
        Emit_PushRdx()
        Emit_PushRsi()
        Emit_PushRdi()
        
        // Compile first string -> RDI
        Compile_Expression(arg0)
        Emit_MovRdiRax()
        
        // Compile second string -> RSI
        Compile_Expression(arg1)
        Emit_MovRsiRax()
        
        // Create labels
        cmp_loop = Emit_CreateLabel()
        strings_equal = Emit_CreateLabel()
        strings_not_equal = Emit_CreateLabel()
        done_label = Emit_CreateLabel()
        
        Emit_MarkLabel(cmp_loop)
        
        // Load bytes
        Emit_MovAlDerefRdi()
        Emit_MovDlDerefRsi()
        
        // Compare
        Emit_CmpAlDl()
        Emit_JumpToLabel(strings_not_equal, CC.NE)
        
        // Check for null terminator
        Emit_TestAlAl()
        Emit_JumpToLabel(strings_equal, CC.Z)
        
        // Advance pointers
        Emit_IncRdi()
        Emit_IncRsi()
        Emit_JumpToLabel(cmp_loop, CC.ALWAYS)
        
        // Strings are equal - return 1
        Emit_MarkLabel(strings_equal)
        Emit_MovRaxImm64(1)
        Emit_JumpToLabel(done_label, CC.ALWAYS)
        
        // Strings are not equal - return 0
        Emit_MarkLabel(strings_not_equal)
        Emit_MovRaxImm64(0)
        
        Emit_MarkLabel(done_label)
        
        // Restore registers
        Emit_PopRdi()
        Emit_PopRsi()
        Emit_PopRdx()
        Emit_PopRcx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGCOPY
// Copy source string to destination buffer
// StringCopy(dest, source) - returns dest
// =============================================================================
Function.CompileStringCore_Copy {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringCopy requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)  // dest
        arg1 = AST_GetChild(node, 1)  // source
        
        // Save registers
        Emit_PushRbx()
        Emit_PushRcx()
        Emit_PushRsi()
        Emit_PushRdi()
        
        // Compile dest -> RDI
        Compile_Expression(arg0)
        Emit_MovRdiRax()
        Emit_PushRdi()  // Save dest for return value
        
        // Compile source -> RSI
        Compile_Expression(arg1)
        Emit_MovRsiRax()
        
        // Create labels
        copy_loop = Emit_CreateLabel()
        copy_done = Emit_CreateLabel()
        
        Emit_MarkLabel(copy_loop)
        
        // Load byte from source: AL = [RSI]
        Emit_MovAlDerefRsi()
        
        // Store byte to dest: [RDI] = AL
        Emit_MovDerefRdiAl()
        
        // Check for null terminator
        Emit_TestAlAl()
        Emit_JumpToLabel(copy_done, CC.Z)
        
        // Advance pointers
        Emit_IncRdi()
        Emit_IncRsi()
        Emit_JumpToLabel(copy_loop, CC.ALWAYS)
        
        Emit_MarkLabel(copy_done)
        
        // Return original dest pointer
        Emit_PopRax()
        
        // Restore registers
        Emit_PopRdi()
        Emit_PopRsi()
        Emit_PopRcx()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGCONCAT
// Concatenate two strings into destination buffer
// StringConcat(dest, str1, str2) - returns dest
// =============================================================================
Function.CompileStringCore_Concat {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 3) ThenBlock: {
            Compile_Error("StringConcat requires 3 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)  // dest
        arg1 = AST_GetChild(node, 1)  // str1
        arg2 = AST_GetChild(node, 2)  // str2
        
        // Save registers
        Emit_PushRbx()
        Emit_PushRcx()
        Emit_PushRsi()
        Emit_PushRdi()
        
        // Compile dest -> RDI, save for return
        Compile_Expression(arg0)
        Emit_MovRdiRax()
        Emit_PushRdi()  // Save dest for return
        
        // Compile str1 -> RSI
        Compile_Expression(arg1)
        Emit_MovRsiRax()
        
        // Copy str1 to dest
        copy1_loop = Emit_CreateLabel()
        copy1_done = Emit_CreateLabel()
        
        Emit_MarkLabel(copy1_loop)
        Emit_MovAlDerefRsi()
        Emit_MovDerefRdiAl()
        Emit_TestAlAl()
        Emit_Jz(copy1_done)
        Emit_IncRdi()
        Emit_IncRsi()
        Emit_Jmp(copy1_loop)
        
        Emit_MarkLabel(copy1_done)
        // RDI now points to null terminator of first string
        
        // Compile str2 -> RSI
        Emit_PushRdi()  // Save current position
        Compile_Expression(arg2)
        Emit_MovRsiRax()
        Emit_PopRdi()   // Restore position
        
        // Copy str2 to dest (starting where str1 ended)
        copy2_loop = Emit_CreateLabel()
        copy2_done = Emit_CreateLabel()
        
        Emit_MarkLabel(copy2_loop)
        Emit_MovAlDerefRsi()
        Emit_MovDerefRdiAl()
        Emit_TestAlAl()
        Emit_Jz(copy2_done)
        Emit_IncRdi()
        Emit_IncRsi()
        Emit_Jmp(copy2_loop)
        
        Emit_MarkLabel(copy2_done)
        
        // Return original dest
        Emit_PopRax()
        
        // Restore registers
        Emit_PopRdi()
        Emit_PopRsi()
        Emit_PopRcx()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}