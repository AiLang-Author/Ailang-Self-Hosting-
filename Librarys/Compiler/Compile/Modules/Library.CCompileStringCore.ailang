// Library.CCompileStringCore.ailang
// Core string operations: StringCompare, StringLength, StringCopy, StringEquals
// Uses ONLY Emit_* functions - NO raw bytes in compile modules
// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// SPDX-License-Identifier: SCSL-1.0

LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CEmitCoreArch

// =============================================================================
// INLINE STRING COMPARISON HELPER
// Used to avoid chicken-and-egg: can't use StringCompare to dispatch StringCompare!
// =============================================================================
Function.StringCore_MatchName {
    Input: func_name: Address
    Input: target: Address
    Output: Integer
    Body: {
        // Safety checks - pointer equality first (fast path)
        IfCondition EqualTo(func_name, target) ThenBlock: { 
            ReturnValue(1) 
        }
        
        // Null checks
        IfCondition EqualTo(func_name, 0) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(target, 0) ThenBlock: { ReturnValue(0) }
        
        // Manual byte-by-byte comparison
        i = 0
        WhileLoop LessThan(i, 64) {
            ptr1 = Add(func_name, i)
            ptr2 = Add(target, i)
            
            c1 = BitwiseAnd(Dereference(ptr1), 255)
            c2 = BitwiseAnd(Dereference(ptr2), 255)
            
            IfCondition EqualTo(c1, 0) ThenBlock: {
                IfCondition EqualTo(c2, 0) ThenBlock: {
                    ReturnValue(1)
                }
                ReturnValue(0)
            }
            
            IfCondition EqualTo(c2, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(0)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// MODULE DISPATCHER
// =============================================================================
Function.CompileStringCore_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(node)
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // StringCompare
        match = StringCore_MatchName(func_name, "StringCompare")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Compare(node))
        }
        
        // StringLength
        match = StringCore_MatchName(func_name, "StringLength")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Length(node))
        }
        
        // StringEquals
        match = StringCore_MatchName(func_name, "StringEquals")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Equals(node))
        }
        
        // StringCopy
        match = StringCore_MatchName(func_name, "StringCopy")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Copy(node))
        }
        

        // StringConcat
        match = StringCore_MatchName(func_name, "StringConcat")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_Concat(node))
        }

        // NumberToString
        match = StringCore_MatchName(func_name, "NumberToString")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_NumberToString(node))
        }
        
        // StringToNumber
        match = StringCore_MatchName(func_name, "StringToNumber")
        IfCondition EqualTo(match, 1) ThenBlock: {
            ReturnValue(CompileStringCore_StringToNumber(node))
        }

        // Not a core string operation
        ReturnValue(0)
    }
}

// =============================================================================
// STRINGCOMPARE
// Compare two strings byte-by-byte
// Returns: 0 if equal, non-zero if different
// =============================================================================
Function.CompileStringCore_Compare {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringCompare requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Save callee-saved registers
        Emit_PushRbx()
        Emit_PushRcx()
        Emit_PushRdx()
        Emit_PushRsi()
        Emit_PushRdi()
        
        // Compile first string -> RAX, then move to RDI
        Compile_Expression(arg0)
        Emit_MovRdiRax()
        
        // Compile second string -> RAX, then move to RSI
        Compile_Expression(arg1)
        Emit_MovRsiRax()
        
        // Create labels
        cmp_loop = Emit_CreateLabel()
        cmp_equal = Emit_CreateLabel()
        cmp_not_equal = Emit_CreateLabel()
        done_label = Emit_CreateLabel()
        
        // Loop: compare byte by byte
        Emit_MarkLabel(cmp_loop)
        
        // Load bytes: AL = [RDI], BL = [RSI]
        Emit_MovAlDerefRdi()
        Emit_MovBlDerefRsi()
        
        // Compare: CMP AL, BL
        Emit_CmpAlBl()
        
        // Jump if not equal
        Emit_JumpToLabel(cmp_not_equal, CC.NE)
        
        // Check for null terminator: TEST AL, AL
        Emit_TestAlAl()
        
        // If null (ZF=1), strings are equal
        Emit_JumpToLabel(cmp_equal, CC.Z)
        
        // Advance pointers
        Emit_IncRdi()
        Emit_IncRsi()
        
        // Continue loop
        Emit_JumpToLabel(cmp_loop, CC.ALWAYS)
        
        // Strings are equal - return 0
        Emit_MarkLabel(cmp_equal)
        Emit_MovRaxImm64(0)
        Emit_JumpToLabel(done_label, CC.ALWAYS)
        
        // Strings are not equal - return 1
        Emit_MarkLabel(cmp_not_equal)
        Emit_MovRaxImm64(1)
        
        // Done
        Emit_MarkLabel(done_label)
        
        // Restore registers (reverse order)
        Emit_PopRdi()
        Emit_PopRsi()
        Emit_PopRdx()
        Emit_PopRcx()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGLENGTH
// Get length of null-terminated string
// Returns: Integer length in RAX
// =============================================================================
Function.CompileStringCore_Length {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("StringLength requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Save registers
        Emit_PushRbx()
        Emit_PushRcx()
        
        // Compile string -> RAX, then move to RBX
        Compile_Expression(arg0)
        Emit_MovRbxRax()
        
        // Initialize counter RAX = 0
        Emit_MovRaxImm64(0)
        
        // Create labels
        len_loop = Emit_CreateLabel()
        len_done = Emit_CreateLabel()
        
        // Loop: count bytes until null
        Emit_MarkLabel(len_loop)
        
        // Load byte: CL = [RBX]
        Emit_MovClDerefRbx()
        
        // Check for null: TEST CL, CL
        Emit_TestClCl()
        
        // If zero, we're done
        Emit_JumpToLabel(len_done, CC.Z)
        
        // Increment counter
        Emit_IncRax()
        
        // Advance pointer
        Emit_IncRbx()
        
        // Continue loop
        Emit_JumpToLabel(len_loop, CC.ALWAYS)
        
        // Done - RAX already contains length
        Emit_MarkLabel(len_done)
        
        // Restore registers
        Emit_PopRcx()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGEQUALS
// Compare two strings - returns 1 if equal, 0 if different
// (Semantically inverted from StringCompare for boolean use)
// =============================================================================
Function.CompileStringCore_Equals {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringEquals requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Save registers
        Emit_PushRcx()
        Emit_PushRdx()
        Emit_PushRsi()
        Emit_PushRdi()
        
        // Compile first string -> RDI
        Compile_Expression(arg0)
        Emit_MovRdiRax()
        
        // Compile second string -> RSI
        Compile_Expression(arg1)
        Emit_MovRsiRax()
        
        // Create labels
        cmp_loop = Emit_CreateLabel()
        strings_equal = Emit_CreateLabel()
        strings_not_equal = Emit_CreateLabel()
        done_label = Emit_CreateLabel()
        
        Emit_MarkLabel(cmp_loop)
        
        // Load bytes
        Emit_MovAlDerefRdi()
        Emit_MovDlDerefRsi()
        
        // Compare
        Emit_CmpAlDl()
        Emit_JumpToLabel(strings_not_equal, CC.NE)
        
        // Check for null terminator
        Emit_TestAlAl()
        Emit_JumpToLabel(strings_equal, CC.Z)
        
        // Advance pointers
        Emit_IncRdi()
        Emit_IncRsi()
        Emit_JumpToLabel(cmp_loop, CC.ALWAYS)
        
        // Strings are equal - return 1
        Emit_MarkLabel(strings_equal)
        Emit_MovRaxImm64(1)
        Emit_JumpToLabel(done_label, CC.ALWAYS)
        
        // Strings are not equal - return 0
        Emit_MarkLabel(strings_not_equal)
        Emit_MovRaxImm64(0)
        
        Emit_MarkLabel(done_label)
        
        // Restore registers
        Emit_PopRdi()
        Emit_PopRsi()
        Emit_PopRdx()
        Emit_PopRcx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGCOPY
// Copy source string to destination buffer
// StringCopy(dest, source) - returns dest
// =============================================================================
Function.CompileStringCore_Copy {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringCopy requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)  // dest
        arg1 = AST_GetChild(node, 1)  // source
        
        // Save registers
        Emit_PushRbx()
        Emit_PushRcx()
        Emit_PushRsi()
        Emit_PushRdi()
        
        // Compile dest -> RDI
        Compile_Expression(arg0)
        Emit_MovRdiRax()
        Emit_PushRdi()  // Save dest for return value
        
        // Compile source -> RSI
        Compile_Expression(arg1)
        Emit_MovRsiRax()
        
        // Create labels
        copy_loop = Emit_CreateLabel()
        copy_done = Emit_CreateLabel()
        
        Emit_MarkLabel(copy_loop)
        
        // Load byte from source: AL = [RSI]
        Emit_MovAlDerefRsi()
        
        // Store byte to dest: [RDI] = AL
        Emit_MovDerefRdiAl()
        
        // Check for null terminator
        Emit_TestAlAl()
        Emit_JumpToLabel(copy_done, CC.Z)
        
        // Advance pointers
        Emit_IncRdi()
        Emit_IncRsi()
        Emit_JumpToLabel(copy_loop, CC.ALWAYS)
        
        Emit_MarkLabel(copy_done)
        
        // Return original dest pointer
        Emit_PopRax()
        
        // Restore registers
        Emit_PopRdi()
        Emit_PopRsi()
        Emit_PopRcx()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGCONCAT (2 args, internal allocation via mmap)
// StringConcat(str1, str2) - allocates buffer, returns new string
// Matches Python compiler behavior
// =============================================================================
// =============================================================================
// STRINGCONCAT (2 args, stack-based, matches Python)
// =============================================================================
Function.CompileStringCore_Concat {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 2) ThenBlock: {
            Compile_Error("StringConcat requires 2 arguments", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        arg1 = AST_GetChild(node, 1)
        
        // Save callee-saved registers
        Emit_PushRbx()
        Emit_PushR12()
        
        // Compile args and save on stack (not registers across compile calls)
        Compile_Expression(arg0)
        Emit_PushRax()  // str1 on stack
        
        Compile_Expression(arg1)
        Emit_PushRax()  // str2 on stack
        
        // Pop into registers after all expressions evaluated
        Emit_PopR14()   // str2
        Emit_PopR13()   // str1
        
        // Calculate len1: RDI = R13, RCX = counter
        Emit_MovRdiR13()
        Emit_XorRcxRcx()
        
        len1_loop = Emit_CreateLabel()
        len1_done = Emit_CreateLabel()
        
        Emit_MarkLabel(len1_loop)
        Emit_CmpByteRdiRcxZero()  // CMP BYTE [RDI+RCX], 0
        Emit_Je(len1_done)
        Emit_IncRcx()
        Emit_Jmp(len1_loop)
        Emit_MarkLabel(len1_done)
        
        Emit_MovRbxRcx()  // RBX = len1
        
        // Calculate len2: RDI = R14, RCX = counter
        Emit_MovRdiR14()
        Emit_XorRcxRcx()
        
        len2_loop = Emit_CreateLabel()
        len2_done = Emit_CreateLabel()
        
        Emit_MarkLabel(len2_loop)
        Emit_CmpByteRdiRcxZero()
        Emit_Je(len2_done)
        Emit_IncRcx()
        Emit_Jmp(len2_loop)
        Emit_MarkLabel(len2_done)
        
        // RCX = len2, RBX = len1
        // Total = len1 + len2 + 1
        Emit_AddRcxRbx()
        Emit_IncRcx()
        
        // mmap allocation
        Emit_MovRaxImm64(9)
        Emit_MovRdiImm64(0)
        Emit_MovRsiRcx()
        Emit_MovRdxImm64(3)
        Emit_MovR10Imm64(34)
        Emit_MovR8Imm64(-1)
        Emit_MovR9Imm64(0)
        Emit_Syscall()
        
        // RAX = buffer, save in R12
        Emit_MovR12Rax()
        Emit_MovRdiRax()
        
        // Copy str1 from R13
        Emit_MovRsiR13()
        
        copy1_loop = Emit_CreateLabel()
        copy1_done = Emit_CreateLabel()
        
        Emit_MarkLabel(copy1_loop)
        Emit_MovClDerefRsi()
        Emit_TestClCl()
        Emit_Jz(copy1_done)
        Emit_MovDerefRdiCl()
        Emit_IncRsi()
        Emit_IncRdi()
        Emit_Jmp(copy1_loop)
        Emit_MarkLabel(copy1_done)
        
        // Copy str2 from R14
        Emit_MovRsiR14()
        
        copy2_loop = Emit_CreateLabel()
        copy2_done = Emit_CreateLabel()
        
        Emit_MarkLabel(copy2_loop)
        Emit_MovClDerefRsi()
        Emit_TestClCl()
        Emit_Jz(copy2_done)
        Emit_MovDerefRdiCl()
        Emit_IncRsi()
        Emit_IncRdi()
        Emit_Jmp(copy2_loop)
        Emit_MarkLabel(copy2_done)
        
        // Null terminate
        Emit_MovByteDerefRdiZero()
        
        // Return buffer from R12
        Emit_MovRaxR12()
        
        // Restore
        Emit_PopR12()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}


// =============================================================================
// NUMBERTOSTRING - STUB
// =============================================================================
Function.CompileStringCore_NumberToString {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("NumberToString requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile the number argument -> RAX
        Compile_Expression(arg0)
        
        // Save callee-saved registers
        Emit_PushRbx()
        Emit_PushR12()
        Emit_PushR13()
        Emit_PushR14()
        Emit_PushR15()
        
        // Allocate 32 bytes on stack for digit buffer
        Emit_SubRspImm32(32)
        
        // R12 = number to convert (absolute value)
        // R15 = 1 if negative, 0 if positive (sign flag)
        Emit_MovRegReg(Reg.R12, Reg.RAX)
        Emit_XorRegReg(Reg.R15, Reg.R15)    // R15 = 0 (assume positive)
        
        // Check if negative
        check_neg = Emit_CreateLabel()
        is_positive = Emit_CreateLabel()
        
        Emit_TestRegReg(Reg.R12, Reg.R12)
        Emit_Jns(is_positive)               // Jump if not sign (positive)
        
        // Negative: set flag, negate to get absolute value
        Emit_MovRegImm64(Reg.R15, 1)        // R15 = 1 (is negative)
        Emit_NegReg(Reg.R12)                // R12 = -R12 (absolute value)
        
        Emit_MarkLabel(is_positive)
        
        // R13 = 0 (digit count)
        Emit_XorRegReg(Reg.R13, Reg.R13)
        
        // R14 = buffer end pointer (RSP + 31)
        Emit_MovRegReg(Reg.R14, Reg.RSP)
        Emit_AddRegImm32(Reg.R14, 31)
        
        // RBX = 10 (divisor)
        Emit_MovRegImm64(Reg.RBX, 10)
        
        // Special case: if number is 0, just store '0'
        zero_check = Emit_CreateLabel()
        not_zero = Emit_CreateLabel()
        convert_loop = Emit_CreateLabel()
        loop_done = Emit_CreateLabel()
        allocate_label = Emit_CreateLabel()
        
        Emit_TestRegReg(Reg.R12, Reg.R12)
        Emit_Jne(not_zero)
        
        // Store '0' (ASCII 48)
        Emit_MovByteR14OffsetImm8(0, 48)
        Emit_MovRegImm64(Reg.R13, 1)        // digit count = 1
        Emit_Jmp(allocate_label)
        
        Emit_MarkLabel(not_zero)
        
        // Convert loop: divide by 10, store remainder as digit
        Emit_MarkLabel(convert_loop)
        Emit_TestRegReg(Reg.R12, Reg.R12)
        Emit_Je(loop_done)
        
        // RAX = R12, divide by RBX (10)
        Emit_MovRegReg(Reg.RAX, Reg.R12)
        Emit_XorRegReg(Reg.RDX, Reg.RDX)    // Clear RDX for division
        Emit_DivRbx()                        // RAX = quotient, RDX = remainder
        
        // Store digit: remainder + '0' (ASCII 48)
        Emit_AddRegImm32(Reg.RDX, 48)
        
        // Store at [R14], decrement R14
        Emit_MovByteR14Dl()
        Emit_DecReg(Reg.R14)
        Emit_IncReg(Reg.R13)                        // digit count++
        
        // R12 = quotient for next iteration
        Emit_MovRegReg(Reg.R12, Reg.RAX)
        Emit_Jmp(convert_loop)
        
        Emit_MarkLabel(loop_done)
        
        // R14 now points one before first digit, increment to point at first
        Emit_IncReg(Reg.R14)
        
        Emit_MarkLabel(allocate_label)
        
        // Calculate allocation size: digits + possible '-' + null
        // size = R13 + R15 + 1
        Emit_MovRegReg(Reg.RAX, Reg.R13)
        Emit_AddRegReg(Reg.RAX, Reg.R15)    // Add 1 if negative
        Emit_AddRegImm32(Reg.RAX, 1)        // Add 1 for null terminator
        
        // mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
        Emit_PushRax()                       // Save size
        Emit_MovRdiImm64(0)                  // addr = NULL
        Emit_MovRegReg(Reg.RSI, Reg.RAX)    // length = size
        Emit_MovRdxImm64(3)                  // prot = PROT_READ | PROT_WRITE
        Emit_MovR10Imm64(34)                 // flags = MAP_PRIVATE | MAP_ANONYMOUS
        Emit_MovR8Imm64(-1)                  // fd = -1 (use 0xFFFFFFFFFFFFFFFF)
        Emit_MovR9Imm64(0)                   // offset = 0
        Emit_MovRaxImm64(9)                  // syscall: mmap
        Emit_Syscall()
        Emit_PopRcx()                        // Discard saved size
        
        // RAX = allocated buffer pointer
        // Save it in RBX for return value
        Emit_MovRegReg(Reg.RBX, Reg.RAX)
        Emit_MovRegReg(Reg.RDI, Reg.RAX)    // RDI = dest pointer
        
        // If negative, write '-' first
        skip_minus = Emit_CreateLabel()
        Emit_TestRegReg(Reg.R15, Reg.R15)
        Emit_Je(skip_minus)
        
        Emit_MovRegImm64(Reg.RAX, 45)        // '-' = ASCII 45
        Emit_MovByteDerefRdiAl()
        Emit_IncRdi()
        
        Emit_MarkLabel(skip_minus)
        
        // Copy digits from stack buffer to allocated buffer
        // Source: R14 (first digit), Count: R13
        Emit_MovRegReg(Reg.RSI, Reg.R14)    // src = stack buffer
        Emit_MovRegReg(Reg.RCX, Reg.R13)    // count = digit count
        
        // Copy loop
        copy_loop = Emit_CreateLabel()
        copy_done = Emit_CreateLabel()
        
        Emit_MarkLabel(copy_loop)
        Emit_TestRegReg(Reg.RCX, Reg.RCX)
        Emit_Je(copy_done)
        
        Emit_MovAlDerefRsi()
        Emit_MovDerefRdiAl()
        Emit_IncRdi()
        Emit_IncRsi()
        Emit_DecReg(Reg.RCX)
        Emit_Jmp(copy_loop)
        
        Emit_MarkLabel(copy_done)
        
        // Null terminate
        Emit_MovByteDerefRdiImm8(0)
        
        // Result in RAX
        Emit_MovRegReg(Reg.RAX, Reg.RBX)
        
        // Cleanup stack
        Emit_AddRspImm32(32)
        
        // Restore callee-saved
        Emit_PopR15()
        Emit_PopR14()
        Emit_PopR13()
        Emit_PopR12()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// STRINGTONUMBER - STUB  
// =============================================================================
Function.CompileStringCore_StringToNumber {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        IfCondition NotEqual(arg_count, 1) ThenBlock: {
            Compile_Error("StringToNumber requires 1 argument", AST_GetLine(node))
            ReturnValue(0)
        }
        
        arg0 = AST_GetChild(node, 0)
        
        // Compile the string argument -> RAX (pointer to string)
        Compile_Expression(arg0)
        
        // Save callee-saved registers
        Emit_PushRbx()
        Emit_PushR12()
        Emit_PushR13()
        
        // RSI = string pointer
        Emit_MovRegReg(Reg.RSI, Reg.RAX)
        
        // R12 = result accumulator (starts at 0)
        Emit_XorRegReg(Reg.R12, Reg.R12)
        
        // R13 = sign (0 = positive, 1 = negative)
        Emit_XorRegReg(Reg.R13, Reg.R13)
        
        // RBX = 10 (multiplier)
        Emit_MovRegImm64(Reg.RBX, 10)
        
        // Skip leading whitespace
        skip_space = Emit_CreateLabel()
        check_sign = Emit_CreateLabel()
        next_char_skip = Emit_CreateLabel()
        
        Emit_MarkLabel(skip_space)
        Emit_MovzxRaxBytePtrRsi()            // RAX = *RSI (zero-extended byte)
        
        // Check for space (32) or tab (9)
        Emit_CmpRaxImm8(32)
        Emit_Je(next_char_skip)
        Emit_CmpRaxImm8(9)
        Emit_Je(next_char_skip)
        Emit_Jmp(check_sign)
        
        Emit_MarkLabel(next_char_skip)
        Emit_IncRsi()
        Emit_Jmp(skip_space)
        
        Emit_MarkLabel(check_sign)
        
        // Check for sign
        check_minus = Emit_CreateLabel()
        check_plus = Emit_CreateLabel()
        digit_loop = Emit_CreateLabel()
        
        Emit_CmpRaxImm8(45)                  // '-'
        Emit_Jne(check_plus)
        Emit_MovRegImm64(Reg.R13, 1)         // negative
        Emit_IncRsi()
        Emit_Jmp(digit_loop)
        
        Emit_MarkLabel(check_plus)
        Emit_CmpRaxImm8(43)                  // '+'
        Emit_Jne(digit_loop)
        Emit_IncRsi()                        // skip '+'
        
        // Digit parsing loop
        Emit_MarkLabel(digit_loop)
        Emit_MovzxRaxBytePtrRsi()            // RAX = *RSI
        
        // Check if digit (48 <= c <= 57)
        loop_done = Emit_CreateLabel()
        is_digit = Emit_CreateLabel()
        
        Emit_CmpRaxImm8(48)                  // < '0'?
        Emit_Jl(loop_done)
        Emit_CmpRaxImm8(57)                  // > '9'?
        Emit_Jg(loop_done)
        
        // It's a digit: result = result * 10 + (c - '0')
        Emit_SubRaxImm8(48)                  // c - '0'
        Emit_PushRax()                       // save digit
        
        // R12 = R12 * 10
        Emit_MovRegReg(Reg.RAX, Reg.R12)
        Emit_MulRbx()                        // RDX:RAX = RAX * RBX
        Emit_MovRegReg(Reg.R12, Reg.RAX)
        
        // R12 = R12 + digit
        Emit_PopRax()
        Emit_AddRegReg(Reg.R12, Reg.RAX)
        
        // Next character
        Emit_IncRsi()
        Emit_Jmp(digit_loop)
        
        Emit_MarkLabel(loop_done)
        
        // Apply sign
        apply_sign = Emit_CreateLabel()
        done = Emit_CreateLabel()
        
        Emit_TestRegReg(Reg.R13, Reg.R13)
        Emit_Je(done)
        Emit_NegReg(Reg.R12)                 // negate if negative
        
        Emit_MarkLabel(done)
        
        // Result in RAX
        Emit_MovRegReg(Reg.RAX, Reg.R12)
        
        // Restore callee-saved
        Emit_PopR13()
        Emit_PopR12()
        Emit_PopRbx()
        
        Compile.nodes_compiled = Add(Compile.nodes_compiled, 1)
        ReturnValue(1)
    }
}
