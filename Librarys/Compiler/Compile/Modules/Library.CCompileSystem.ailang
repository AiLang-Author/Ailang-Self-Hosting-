// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileSystem.ailang
// System call compilation for the AILang self-hosting compiler
// Mirrors syscall_handler.py logic using Emit_* emit functions
// Location: Librarys/Compiler/Compile/Modules/Library.CCompileSystem.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.CSyscallTable
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys
LibraryImport.Compiler.Compile.CCompileMain

// =============================================================================
// DISPATCHER
// Returns 1 if handled, 0 if not this module's responsibility
// =============================================================================

Function.CompileSystem_TryCompile {
    Input: node: Address
    Output: Integer
    Body: {
        func_name = AST_GetData1(node)
        
        IfCondition EqualTo(func_name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        cmp = StringCompare(func_name, "SystemCall")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            result = CompileSystem_Syscall(node)
            ReturnValue(result)
        }
        
        cmp = StringCompare(func_name, "Exit")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            result = CompileSystem_Exit(node)
            ReturnValue(result)
        }
        
        cmp = StringCompare(func_name, "HaltProgram")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            result = CompileSystem_Halt(node)
            ReturnValue(result)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// SYSCALL COMPILATION
// Mirrors syscall_handler.py exactly:
// 1. Zero all argument registers
// 2. Compile args and push to stack (prevents clobbering)
// 3. Pop into argument registers in reverse order
// 4. Load syscall number into RAX last
// 5. Execute syscall instruction
// Result left in RAX for caller
// =============================================================================

Function.CompileSystem_Syscall {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        
        IfCondition LessThan(arg_count, 1) ThenBlock: {
            Compile_Error("SystemCall requires at least syscall number", 0)
            ReturnValue(0)
        }
        
        num_syscall_args = Subtract(arg_count, 1)
        
        IfCondition GreaterThan(num_syscall_args, 6) ThenBlock: {
            Compile_Error("SystemCall supports max 6 arguments", 0)
            ReturnValue(0)
        }
        
        // Step 1: Zero ALL syscall argument registers
        Emit_XorRdiRdi()
        Emit_XorRsiRsi()
        Emit_XorRdxRdx()
        Emit_XorR10R10()
        Emit_XorR8R8()
        Emit_XorR9R9()
        
        // Step 2: Compile all arguments and push to stack
        // Args are at indices 1..num_syscall_args (index 0 is syscall number)
        i = 1
        push_limit = Add(num_syscall_args, 1)
        WhileLoop LessThan(i, push_limit) {
            arg = AST_GetChild(node, i)
            Compile_Expression(arg)
            Emit_PushRax()
            i = Add(i, 1)
        }
        
        // Step 3: Pop from stack into registers in REVERSE order
        // Syscall ABI: RDI=arg1, RSI=arg2, RDX=arg3, R10=arg4, R8=arg5, R9=arg6
        j = num_syscall_args
        WhileLoop GreaterThan(j, 0) {
            IfCondition EqualTo(j, 1) ThenBlock: {
                Emit_PopRdi()
            }
            IfCondition EqualTo(j, 2) ThenBlock: {
                Emit_PopRsi()
            }
            IfCondition EqualTo(j, 3) ThenBlock: {
                Emit_PopRdx()
            }
            IfCondition EqualTo(j, 4) ThenBlock: {
                Emit_PopR10()
            }
            IfCondition EqualTo(j, 5) ThenBlock: {
                Emit_PopR8()
            }
            IfCondition EqualTo(j, 6) ThenBlock: {
                Emit_PopR9()
            }
            j = Subtract(j, 1)
        }
        
        // Step 4: Load syscall number into RAX (do this LAST)
        syscall_num_node = AST_GetChild(node, 0)
        Compile_Expression(syscall_num_node)
        
        // Step 5: Execute syscall instruction
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// EXIT WRAPPER
// Exit(code) -> syscall 60
// Exit() with no args -> exit(0)
// =============================================================================

Function.CompileSystem_Exit {
    Input: node: Address
    Output: Integer
    Body: {
        arg_count = AST_GetChildCount(node)
        
        IfCondition EqualTo(arg_count, 0) ThenBlock: {
            Emit_XorRdiRdi()
        } ElseBlock: {
            code_node = AST_GetChild(node, 0)
            Compile_Expression(code_node)
            Emit_MovRdiRax()
        }
        
        Emit_MovRaxImm64(SysNum.EXIT)
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}

// =============================================================================
// HALT WRAPPER
// HaltProgram -> exit(0)
// =============================================================================

Function.CompileSystem_Halt {
    Input: node: Address
    Output: Integer
    Body: {
        Emit_XorRdiRdi()
        Emit_MovRaxImm64(SysNum.EXIT)
        Emit_SysInstr()
        
        ReturnValue(1)
    }
}