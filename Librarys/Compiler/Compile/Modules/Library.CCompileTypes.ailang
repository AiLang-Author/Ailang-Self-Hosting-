// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CCompileTypes.ailang
// Compile state and type definitions for the AILang self-hosting compiler
// Mirrors the Python compiler's state management patterns

LibraryImport.XArrays

// =============================================================================
// COMPILE STATE
// Central state for the compilation process
// =============================================================================
FixedPool.Compile {
   
    "ast": Initialize=0, CanChange=True
   
    "current_func": Initialize=0, CanChange=True
    "current_func_name": Initialize=0, CanChange=True
    
   
    "stack_offset": Initialize=0, CanChange=True
    "max_stack": Initialize=0, CanChange=True
    
    
    "label_counter": Initialize=0, CanChange=True
    
    
    "binary_op_depth": Initialize=0, CanChange=True
    
  
    "variables": Initialize=0, CanChange=True
    "var_count": Initialize=0, CanChange=True
    "functions": Initialize=0, CanChange=True
    "func_count": Initialize=0, CanChange=True
    
   
    "loop_stack": Initialize=0, CanChange=True
    "loop_depth": Initialize=0, CanChange=True
    
   
    "error": Initialize=0, CanChange=True
    "error_msg": Initialize=0, CanChange=True
    "error_line": Initialize=0, CanChange=True
    
   
    "debug_mode": Initialize=0, CanChange=True
    "optimize": Initialize=0, CanChange=True
}

// =============================================================================
// VARIABLE ENTRY STRUCTURE
// Layout: [name_ptr, offset, type, size, flags] = 40 bytes
// =============================================================================
FixedPool.VarEntry {
    "SIZE": Initialize=40, CanChange=False
    "NAME_OFFSET": Initialize=0, CanChange=False
    "STACK_OFFSET": Initialize=8, CanChange=False
    "TYPE_OFFSET": Initialize=16, CanChange=False
    "SIZE_OFFSET": Initialize=24, CanChange=False
    "FLAGS_OFFSET": Initialize=32, CanChange=False
}

// Variable types
FixedPool.VarType {
    "INTEGER": Initialize=1, CanChange=False
    "ADDRESS": Initialize=2, CanChange=False
    "STRING": Initialize=3, CanChange=False
    "BOOLEAN": Initialize=4, CanChange=False
    "UNKNOWN": Initialize=0, CanChange=False
}

// Variable flags
FixedPool.VarFlags {
    "NONE": Initialize=0, CanChange=False
    "PARAM": Initialize=1, CanChange=False
    "LOCAL": Initialize=2, CanChange=False
    "GLOBAL": Initialize=4, CanChange=False
    "CONST": Initialize=8, CanChange=False
}

// =============================================================================
// FUNCTION ENTRY STRUCTURE
// Layout: [name_ptr, label, param_count, return_type, stack_size] = 40 bytes
// =============================================================================
FixedPool.FuncEntry {
    "SIZE": Initialize=40, CanChange=False
    "NAME_OFFSET": Initialize=0, CanChange=False
    "LABEL_OFFSET": Initialize=8, CanChange=False
    "PARAM_COUNT_OFFSET": Initialize=16, CanChange=False
    "RETURN_TYPE_OFFSET": Initialize=24, CanChange=False
    "STACK_SIZE_OFFSET": Initialize=32, CanChange=False
}

// =============================================================================
// LOOP CONTEXT STRUCTURE
// For break/continue label tracking
// Layout: [break_label, continue_label] = 16 bytes
// =============================================================================
FixedPool.LoopContext {
    "SIZE": Initialize=16, CanChange=False
    "BREAK_LABEL_OFFSET": Initialize=0, CanChange=False
    "CONTINUE_LABEL_OFFSET": Initialize=8, CanChange=False
}

// =============================================================================
// REGISTER ALLOCATION CONSTANTS
// Depth-based allocation matching Python compiler pattern:
// - Depth 0: R12
// - Depth 1: R13
// - Depth 2+: Stack (to avoid R14/R15 pool register collision)
// =============================================================================
FixedPool.DepthReg {
    "MAX_REG_DEPTH": Initialize=2, CanChange=False
    "DEPTH_0_REG": Initialize=12, CanChange=False
    "DEPTH_1_REG": Initialize=13, CanChange=False
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Compile_Init {
    Output: Integer
    Body: {
        // Allocate variable registry (256 entries max)
        var_table_size = Multiply(256, VarEntry.SIZE)
        Compile.variables = Allocate(var_table_size)
        IfCondition EqualTo(Compile.variables, 0) ThenBlock: {
            ReturnValue(0)
        }
        Compile.var_count = 0
        
        // Allocate function registry (128 entries max)
        func_table_size = Multiply(128, FuncEntry.SIZE)
        Compile.functions = Allocate(func_table_size)
        IfCondition EqualTo(Compile.functions, 0) ThenBlock: {
            Deallocate(Compile.variables, var_table_size)
            ReturnValue(0)
        }
        Compile.func_count = 0
        
        // Allocate loop stack (32 levels max)
        loop_stack_size = Multiply(32, LoopContext.SIZE)
        Compile.loop_stack = Allocate(loop_stack_size)
        IfCondition EqualTo(Compile.loop_stack, 0) ThenBlock: {
            Deallocate(Compile.variables, var_table_size)
            Deallocate(Compile.functions, func_table_size)
            ReturnValue(0)
        }
        Compile.loop_depth = 0
        
        // Initialize other state
        Compile.ast = 0
        Compile.current_func = 0
        Compile.current_func_name = 0
        Compile.stack_offset = 0
        Compile.max_stack = 0
        Compile.label_counter = 0
        Compile.binary_op_depth = 0
        Compile.error = 0
        Compile.error_msg = 0
        Compile.error_line = 0
        Compile.debug_mode = 0
        Compile.optimize = 0
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
SubRoutine.Compile_Cleanup {
    IfCondition NotEqual(Compile.variables, 0) ThenBlock: {
        var_table_size = Multiply(256, VarEntry.SIZE)
        Deallocate(Compile.variables, var_table_size)
        Compile.variables = 0
    }
    
    IfCondition NotEqual(Compile.functions, 0) ThenBlock: {
        func_table_size = Multiply(128, FuncEntry.SIZE)
        Deallocate(Compile.functions, func_table_size)
        Compile.functions = 0
    }
    
    IfCondition NotEqual(Compile.loop_stack, 0) ThenBlock: {
        loop_stack_size = Multiply(32, LoopContext.SIZE)
        Deallocate(Compile.loop_stack, loop_stack_size)
        Compile.loop_stack = 0
    }
    
    Compile.var_count = 0
    Compile.func_count = 0
    Compile.loop_depth = 0
}

// =============================================================================
// LABEL GENERATION
// =============================================================================
Function.Compile_NewLabel {
    Output: Integer
    Body: {
        label = Compile.label_counter
        Compile.label_counter = Add(Compile.label_counter, 1)
        ReturnValue(label)
    }
}

// =============================================================================
// DEPTH TRACKING FOR REGISTER ALLOCATION
// =============================================================================
SubRoutine.Compile_DepthPush {
    Compile.binary_op_depth = Add(Compile.binary_op_depth, 1)
}

SubRoutine.Compile_DepthPop {
    IfCondition GreaterThan(Compile.binary_op_depth, 0) ThenBlock: {
        Compile.binary_op_depth = Subtract(Compile.binary_op_depth, 1)
    }
}

Function.Compile_GetDepth {
    Output: Integer
    Body: {
        ReturnValue(Compile.binary_op_depth)
    }
}

// Returns 1 if should use stack, 0 if can use register
Function.Compile_ShouldUseStack {
    Output: Integer
    Body: {
        IfCondition GreaterEqual(Compile.binary_op_depth, DepthReg.MAX_REG_DEPTH) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Returns register number for current depth (12 or 13), or 0 if should use stack
Function.Compile_GetDepthReg {
    Output: Integer
    Body: {
        IfCondition EqualTo(Compile.binary_op_depth, 0) ThenBlock: {
            ReturnValue(DepthReg.DEPTH_0_REG)
        }
        IfCondition EqualTo(Compile.binary_op_depth, 1) ThenBlock: {
            ReturnValue(DepthReg.DEPTH_1_REG)
        }
        // Depth 2+: use stack
        ReturnValue(0)
    }
}

// =============================================================================
// VARIABLE MANAGEMENT
// =============================================================================
Function.Compile_AddVariable {
    Input: name: Address
    Input: var_type: Integer
    Input: var_size: Integer
    Input: flags: Integer
    Output: Integer
    Body: {
        // Check capacity
        IfCondition GreaterEqual(Compile.var_count, 256) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Calculate entry address
        entry_offset = Multiply(Compile.var_count, VarEntry.SIZE)
        entry = Add(Compile.variables, entry_offset)
        
        // Allocate stack space (align to 8 bytes)
        aligned_size = var_size
        remainder = Modulo(var_size, 8)
        IfCondition NotEqual(remainder, 0) ThenBlock: {
            aligned_size = Add(var_size, Subtract(8, remainder))
        }
        
        Compile.stack_offset = Subtract(Compile.stack_offset, aligned_size)
        
        // Track max stack usage
        neg_offset = Subtract(0, Compile.stack_offset)
        IfCondition GreaterThan(neg_offset, Compile.max_stack) ThenBlock: {
            Compile.max_stack = neg_offset
        }
        
        // Store entry fields
        StoreValue(Add(entry, VarEntry.NAME_OFFSET), name)
        StoreValue(Add(entry, VarEntry.STACK_OFFSET), Compile.stack_offset)
        StoreValue(Add(entry, VarEntry.TYPE_OFFSET), var_type)
        StoreValue(Add(entry, VarEntry.SIZE_OFFSET), aligned_size)
        StoreValue(Add(entry, VarEntry.FLAGS_OFFSET), flags)
        
        // Increment count and return stack offset
        Compile.var_count = Add(Compile.var_count, 1)
        ReturnValue(Compile.stack_offset)
    }
}

Function.Compile_FindVariable {
    Input: name: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Compile.var_count) {
            entry_offset = Multiply(i, VarEntry.SIZE)
            entry = Add(Compile.variables, entry_offset)
            entry_name = Dereference(Add(entry, VarEntry.NAME_OFFSET))
            
            // Compare names
            IfCondition EqualTo(StringCompare(name, entry_name), 0) ThenBlock: {
                // Return stack offset
                ReturnValue(Dereference(Add(entry, VarEntry.STACK_OFFSET)))
            }
            
            i = Add(i, 1)
        }
        
        // Not found
        ReturnValue(0)
    }
}

Function.Compile_GetVariableType {
    Input: name: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Compile.var_count) {
            entry_offset = Multiply(i, VarEntry.SIZE)
            entry = Add(Compile.variables, entry_offset)
            entry_name = Dereference(Add(entry, VarEntry.NAME_OFFSET))
            
            IfCondition EqualTo(StringCompare(name, entry_name), 0) ThenBlock: {
                ReturnValue(Dereference(Add(entry, VarEntry.TYPE_OFFSET)))
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(VarType.UNKNOWN)
    }
}

// =============================================================================
// FUNCTION MANAGEMENT
// =============================================================================
Function.Compile_AddFunction {
    Input: name: Address
    Input: label: Integer
    Input: param_count: Integer
    Input: return_type: Integer
    Output: Integer
    Body: {
        // Check capacity
        IfCondition GreaterEqual(Compile.func_count, 128) ThenBlock: {
            ReturnValue(0)
        }
        
        // Calculate entry address
        entry_offset = Multiply(Compile.func_count, FuncEntry.SIZE)
        entry = Add(Compile.functions, entry_offset)
        
        // Store entry fields
        StoreValue(Add(entry, FuncEntry.NAME_OFFSET), name)
        StoreValue(Add(entry, FuncEntry.LABEL_OFFSET), label)
        StoreValue(Add(entry, FuncEntry.PARAM_COUNT_OFFSET), param_count)
        StoreValue(Add(entry, FuncEntry.RETURN_TYPE_OFFSET), return_type)
        StoreValue(Add(entry, FuncEntry.STACK_SIZE_OFFSET), 0)
        
        Compile.func_count = Add(Compile.func_count, 1)
        ReturnValue(1)
    }
}

Function.Compile_FindFunction {
    Input: name: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Compile.func_count) {
            entry_offset = Multiply(i, FuncEntry.SIZE)
            entry = Add(Compile.functions, entry_offset)
            entry_name = Dereference(Add(entry, FuncEntry.NAME_OFFSET))
            
            IfCondition EqualTo(StringCompare(name, entry_name), 0) ThenBlock: {
                // Return label
                ReturnValue(Dereference(Add(entry, FuncEntry.LABEL_OFFSET)))
            }
            
            i = Add(i, 1)
        }
        
        // Not found
        ReturnValue(-1)
    }
}

// =============================================================================
// LOOP CONTEXT MANAGEMENT
// =============================================================================
Function.Compile_PushLoop {
    Input: break_label: Integer
    Input: continue_label: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(Compile.loop_depth, 32) ThenBlock: {
            ReturnValue(0)
        }
        
        ctx_offset = Multiply(Compile.loop_depth, LoopContext.SIZE)
        ctx = Add(Compile.loop_stack, ctx_offset)
        
        StoreValue(Add(ctx, LoopContext.BREAK_LABEL_OFFSET), break_label)
        StoreValue(Add(ctx, LoopContext.CONTINUE_LABEL_OFFSET), continue_label)
        
        Compile.loop_depth = Add(Compile.loop_depth, 1)
        ReturnValue(1)
    }
}

SubRoutine.Compile_PopLoop {
    IfCondition GreaterThan(Compile.loop_depth, 0) ThenBlock: {
        Compile.loop_depth = Subtract(Compile.loop_depth, 1)
    }
}

Function.Compile_GetBreakLabel {
    Output: Integer
    Body: {
        IfCondition EqualTo(Compile.loop_depth, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        ctx_offset = Multiply(Subtract(Compile.loop_depth, 1), LoopContext.SIZE)
        ctx = Add(Compile.loop_stack, ctx_offset)
        ReturnValue(Dereference(Add(ctx, LoopContext.BREAK_LABEL_OFFSET)))
    }
}

Function.Compile_GetContinueLabel {
    Output: Integer
    Body: {
        IfCondition EqualTo(Compile.loop_depth, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        ctx_offset = Multiply(Subtract(Compile.loop_depth, 1), LoopContext.SIZE)
        ctx = Add(Compile.loop_stack, ctx_offset)
        ReturnValue(Dereference(Add(ctx, LoopContext.CONTINUE_LABEL_OFFSET)))
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================
SubRoutine.Compile_SetError {
    Input: msg: Address
    Input: line: Integer
    
    Compile.error = 1
    Compile.error_msg = msg
    Compile.error_line = line
}

Function.Compile_HasError {
    Output: Integer
    Body: {
        ReturnValue(Compile.error)
    }
}

SubRoutine.Compile_ClearError {
    Compile.error = 0
    Compile.error_msg = 0
    Compile.error_line = 0
}

// =============================================================================
// SCOPE MANAGEMENT
// =============================================================================
SubRoutine.Compile_EnterFunction {
    Input: name: Address
    
    Compile.current_func_name = name
    Compile.stack_offset = 0
    Compile.max_stack = 0
    // Note: We don't clear var_count here - variables accumulate
    // In a full implementation, we'd track scope boundaries
}

SubRoutine.Compile_ExitFunction {
    Compile.current_func_name = 0
}

Function.Compile_GetStackSize {
    Output: Integer
    Body: {
        // Return aligned stack size (16-byte aligned for ABI)
        size = Compile.max_stack
        remainder = Modulo(size, 16)
        IfCondition NotEqual(remainder, 0) ThenBlock: {
            size = Add(size, Subtract(16, remainder))
        }
        ReturnValue(size)
    }
}