// Library.CASTCore.ailang
// Core AST operations: create, access, modify, free
// No parsing logic - pure AST manipulation

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes



// =============================================================================
// SYMBOL TYPES
// =============================================================================
FixedPool.SymType {
    "SYM_UNKNOWN": Initialize=0
    "SYM_FUNCTION": Initialize=1
    "SYM_SUBROUTINE": Initialize=2
    "SYM_VARIABLE": Initialize=3
    "SYM_PARAMETER": Initialize=4
    "SYM_POOL": Initialize=5
    "SYM_POOL_VAR": Initialize=6
    "SYM_CONSTANT": Initialize=7
    "SYM_TYPE": Initialize=8
    "SYM_LABEL": Initialize=9
}

// =============================================================================
// SEMANTIC ANALYZER STATE
// =============================================================================
FixedPool.Semantic {
    "symbols": Initialize=0, CanChange=True
    "symbol_count": Initialize=0, CanChange=True
    "scopes": Initialize=0, CanChange=True
    "scope_depth": Initialize=0, CanChange=True
    "current_function": Initialize=0, CanChange=True
    "error": Initialize=0, CanChange=True
    "error_count": Initialize=0, CanChange=True
    "warning_count": Initialize=0, CanChange=True
    "error_msg": Initialize=0, CanChange=True
    "error_line": Initialize=0, CanChange=True
    "error_col": Initialize=0, CanChange=True
}

// =============================================================================
// SYMBOL RECORD STRUCTURE
// Each symbol: [name, type, data_type, scope_level, node_ref, flags]
// =============================================================================
FixedPool.SymField {
    "NAME": Initialize=0
    "TYPE": Initialize=1
    "DATA_TYPE": Initialize=2
    "SCOPE": Initialize=3
    "NODE": Initialize=4
    "FLAGS": Initialize=5
    "SYM_SIZE": Initialize=6
}

// =============================================================================
// SYMBOL FLAGS
// =============================================================================
FixedPool.SymFlag {
    "NONE": Initialize=0
    "DEFINED": Initialize=1
    "USED": Initialize=2
    "EXPORTED": Initialize=4
    "IMPORTED": Initialize=8
    "MUTABLE": Initialize=16
    "INITIALIZED": Initialize=32
}



// =============================================================================
// NODE CREATION
// =============================================================================

// Create a new AST node of given type
Function.AST_Create {
    Input: node_type: Integer
    Output: Address
    Body: {
        node = Allocate(ASTField.NODE_SIZE)
        
        // Initialize all fields to 0
        StoreValue(node, node_type)                              // TYPE
        StoreValue(Add(node, 8), 0)                              // LINE
        StoreValue(Add(node, 16), 0)                             // COL
        StoreValue(Add(node, 24), 0)                             // DATA1
        StoreValue(Add(node, 32), 0)                             // DATA2
        StoreValue(Add(node, 40), 0)                             // DATA3
        StoreValue(Add(node, 48), 0)                             // DATA4
        
        // Create children array
        children = XArray.XCreate(ASTState.max_children)
        StoreValue(Add(node, 56), children)                      // CHILDREN
        
        ASTState.node_count = Add(ASTState.node_count, 1)
        
        ReturnValue(node)
    }
}

// Create node with source location
Function.AST_CreateAt {
    Input: node_type: Integer
    Input: line: Integer
    Input: col: Integer
    Output: Address
    Body: {
        node = AST_Create(node_type)
        StoreValue(Add(node, 8), line)
        StoreValue(Add(node, 16), col)
        ReturnValue(node)
    }
}

// =============================================================================
// FIELD GETTERS
// =============================================================================

Function.AST_GetType {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(node))
    }
}

Function.AST_GetLine {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 8)))
    }
}

Function.AST_GetCol {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 16)))
    }
}

Function.AST_GetData1 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 24)))
    }
}

Function.AST_GetData2 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 32)))
    }
}

Function.AST_GetData3 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 40)))
    }
}

Function.AST_GetData4 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 48)))
    }
}

Function.AST_GetChildren {
    Input: node: Address
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 56)))
    }
}

// =============================================================================
// FIELD SETTERS
// =============================================================================

Function.AST_SetType {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(node, value)
        }
    }
}

Function.AST_SetLine {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 8), value)
        }
    }
}

Function.AST_SetCol {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 16), value)
        }
    }
}

Function.AST_SetData1 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 24), value)
        }
    }
}

Function.AST_SetData2 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 32), value)
        }
    }
}

Function.AST_SetData3 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 40), value)
        }
    }
}

Function.AST_SetData4 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 48), value)
        }
    }
}

// =============================================================================
// CHILD NODE MANAGEMENT
// =============================================================================

Function.AST_AddChild {
    Input: parent: Address
    Input: child: Address
    Body: {
        IfCondition And(NotEqual(parent, 0), NotEqual(child, 0)) ThenBlock: {
            children = Dereference(Add(parent, 56))
            XArray.XPush(children, child)
        }
    }
}

Function.AST_GetChild {
    Input: node: Address
    Input: index: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        children = Dereference(Add(node, 56))
        IfCondition EqualTo(children, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(XArray.XGet(children, index))
    }
}

Function.AST_GetChildCount {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        children = Dereference(Add(node, 56))
        IfCondition EqualTo(children, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(XArray.XSize(children))
    }
}

Function.AST_SetChild {
    Input: node: Address
    Input: index: Integer
    Input: child: Address
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            children = Dereference(Add(node, 56))
            IfCondition NotEqual(children, 0) ThenBlock: {
                XArray.XSet(children, index, child)
            }
        }
    }
}

// =============================================================================
// TYPE CHECKING
// =============================================================================

Function.AST_IsType {
    Input: node: Address
    Input: expected: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        actual = Dereference(node)
        IfCondition EqualTo(actual, expected) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

Function.AST_IsNull {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// NODE CLEANUP
// =============================================================================

Function.AST_Free {
    Input: node: Address
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            // Free all children recursively
            children = Dereference(Add(node, 56))
            IfCondition NotEqual(children, 0) ThenBlock: {
                count = XArray.XSize(children)
                i = 0
                WhileLoop LessThan(i, count) {
                    child = XArray.XGet(children, i)
                    AST_Free(child)
                    i = Add(i, 1)
                }
                XArray.XDestroy(children)
            }
            
            // Free the node itself
            Deallocate(node, ASTField.NODE_SIZE)
            ASTState.node_count = Subtract(ASTState.node_count, 1)
        }
    }
}

// Free node but keep children (for restructuring)
Function.AST_FreeShallow {
    Input: node: Address
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            children = Dereference(Add(node, 56))
            IfCondition NotEqual(children, 0) ThenBlock: {
                XArray.XDestroy(children)
            }
            Deallocate(node, ASTField.NODE_SIZE)
            ASTState.node_count = Subtract(ASTState.node_count, 1)
        }
    }
}