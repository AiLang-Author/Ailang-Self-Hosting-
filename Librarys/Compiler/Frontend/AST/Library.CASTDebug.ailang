// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CASTDebug.ailang
// AST debugging and visualization utilities
// Print, dump, validate AST structures

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore

// =============================================================================
// NODE TYPE NAME LOOKUP
// =============================================================================

Function.AST_TypeName {
    Input: node_type: Integer
    Output: Address
    Body: {
        // Program structure
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: { ReturnValue("PROGRAM") }
        IfCondition EqualTo(node_type, AST.LIBRARY_IMPORT) ThenBlock: { ReturnValue("LIBRARY_IMPORT") }
        
        // Functions
        IfCondition EqualTo(node_type, AST.FUNCTION) ThenBlock: { ReturnValue("FUNCTION") }
        IfCondition EqualTo(node_type, AST.SUBROUTINE) ThenBlock: { ReturnValue("SUBROUTINE") }
        IfCondition EqualTo(node_type, AST.PARAMETER) ThenBlock: { ReturnValue("PARAMETER") }
        IfCondition EqualTo(node_type, AST.OUTPUT_DECL) ThenBlock: { ReturnValue("OUTPUT") }
        IfCondition EqualTo(node_type, AST.BODY) ThenBlock: { ReturnValue("BODY") }
        
        // Pools
        IfCondition EqualTo(node_type, AST.POOL_FIXED) ThenBlock: { ReturnValue("FIXED_POOL") }
        IfCondition EqualTo(node_type, AST.POOL_DYNAMIC) ThenBlock: { ReturnValue("DYNAMIC_POOL") }
        IfCondition EqualTo(node_type, AST.POOL_MEMBER) ThenBlock: { ReturnValue("POOL_MEMBER") }
        
        // Statements
        IfCondition EqualTo(node_type, AST.ASSIGNMENT) ThenBlock: { ReturnValue("ASSIGNMENT") }
        IfCondition EqualTo(node_type, AST.BLOCK) ThenBlock: { ReturnValue("BLOCK") }
        IfCondition EqualTo(node_type, AST.IF) ThenBlock: { ReturnValue("IF") }
        IfCondition EqualTo(node_type, AST.WHILE) ThenBlock: { ReturnValue("WHILE") }
        IfCondition EqualTo(node_type, AST.RETURN) ThenBlock: { ReturnValue("RETURN") }
        IfCondition EqualTo(node_type, AST.EXIT_LOOP) ThenBlock: { ReturnValue("EXIT_LOOP") }
        IfCondition EqualTo(node_type, AST.CONTINUE_LOOP) ThenBlock: { ReturnValue("CONTINUE_LOOP") }
        IfCondition EqualTo(node_type, AST.FOR_EVERY) ThenBlock: { ReturnValue("FOR_EVERY") }
        IfCondition EqualTo(node_type, AST.SWITCH) ThenBlock: { ReturnValue("SWITCH") }
        IfCondition EqualTo(node_type, AST.CASE) ThenBlock: { ReturnValue("CASE") }
        IfCondition EqualTo(node_type, AST.FORK) ThenBlock: { ReturnValue("FORK") }
        
        // Expressions
        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: { ReturnValue("IDENTIFIER") }
        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: { ReturnValue("NUMBER") }
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: { ReturnValue("STRING") }
        IfCondition EqualTo(node_type, AST.BOOLEAN) ThenBlock: { ReturnValue("BOOLEAN") }
        IfCondition EqualTo(node_type, AST.NULL) ThenBlock: { ReturnValue("NULL") }
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: { ReturnValue("CALL") }
        IfCondition EqualTo(node_type, AST.BINARY_OP) ThenBlock: { ReturnValue("BINARY_OP") }
        IfCondition EqualTo(node_type, AST.UNARY_OP) ThenBlock: { ReturnValue("UNARY_OP") }
        IfCondition EqualTo(node_type, AST.MEMBER_ACCESS) ThenBlock: { ReturnValue("MEMBER_ACCESS") }
        IfCondition EqualTo(node_type, AST.INDEX_ACCESS) ThenBlock: { ReturnValue("INDEX_ACCESS") }
        
        // I/O
        IfCondition EqualTo(node_type, AST.PRINT) ThenBlock: { ReturnValue("PRINT") }
        IfCondition EqualTo(node_type, AST.RUN_TASK) ThenBlock: { ReturnValue("RUN_TASK") }
        IfCondition EqualTo(node_type, AST.HALT) ThenBlock: { ReturnValue("HALT") }
        
        // Operators
        IfCondition EqualTo(node_type, AST.OP_ADD) ThenBlock: { ReturnValue("OP_ADD") }
        IfCondition EqualTo(node_type, AST.OP_SUBTRACT) ThenBlock: { ReturnValue("OP_SUB") }
        IfCondition EqualTo(node_type, AST.OP_MULTIPLY) ThenBlock: { ReturnValue("OP_MUL") }
        IfCondition EqualTo(node_type, AST.OP_DIVIDE) ThenBlock: { ReturnValue("OP_DIV") }
        IfCondition EqualTo(node_type, AST.OP_MODULO) ThenBlock: { ReturnValue("OP_MOD") }
        IfCondition EqualTo(node_type, AST.OP_EQ) ThenBlock: { ReturnValue("OP_EQ") }
        IfCondition EqualTo(node_type, AST.OP_NE) ThenBlock: { ReturnValue("OP_NE") }
        IfCondition EqualTo(node_type, AST.OP_LT) ThenBlock: { ReturnValue("OP_LT") }
        IfCondition EqualTo(node_type, AST.OP_LE) ThenBlock: { ReturnValue("OP_LE") }
        IfCondition EqualTo(node_type, AST.OP_GT) ThenBlock: { ReturnValue("OP_GT") }
        IfCondition EqualTo(node_type, AST.OP_GE) ThenBlock: { ReturnValue("OP_GE") }
        IfCondition EqualTo(node_type, AST.OP_AND) ThenBlock: { ReturnValue("OP_AND") }
        IfCondition EqualTo(node_type, AST.OP_OR) ThenBlock: { ReturnValue("OP_OR") }
        IfCondition EqualTo(node_type, AST.OP_NOT) ThenBlock: { ReturnValue("OP_NOT") }
        
        // Debug
        IfCondition EqualTo(node_type, AST.DEBUG_BLOCK) ThenBlock: { ReturnValue("DEBUG_BLOCK") }
        IfCondition EqualTo(node_type, AST.DEBUG_ASSERT) ThenBlock: { ReturnValue("DEBUG_ASSERT") }
        
        // Error/special
        IfCondition EqualTo(node_type, AST.NODE_ERROR) ThenBlock: { ReturnValue("ERROR") }
        IfCondition EqualTo(node_type, AST.NODE_EMPTY) ThenBlock: { ReturnValue("EMPTY") }
        
        ReturnValue("UNKNOWN")
    }
}

// =============================================================================
// INDENTATION HELPER
// =============================================================================

Function.AST_PrintIndent {
    Input: level: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, level) {
            PrintMessage("  ")
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// NODE PRINTING
// =============================================================================

Function.AST_PrintNode {
    Input: node: Address
    Input: indent: Integer
    Body: {
        AST_PrintIndent(indent)
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("<null>\n")
            ReturnValue(0)
        }
        
        // Print type name
        node_type = AST_GetType(node)
        type_name = AST_TypeName(node_type)
        PrintMessage(type_name)
        
        // Print location
        PrintMessage(" [")
        PrintNumber(AST_GetLine(node))
        PrintMessage(":")
        PrintNumber(AST_GetCol(node))
        PrintMessage("]")
        
        // Print DATA1 if it looks like a string (address > 1000)
        data1 = AST_GetData1(node)
        IfCondition GreaterThan(data1, 1000) ThenBlock: {
            PrintMessage(" \"")
            PrintMessage(data1)
            PrintMessage("\"")
        } ElseBlock: {
            // Print numeric DATA1 for operators, etc.
            IfCondition NotEqual(data1, 0) ThenBlock: {
                PrintMessage(" data1=")
                PrintNumber(data1)
            }
        }
        
        PrintMessage("\n")
    }
}

// =============================================================================
// TREE PRINTING (RECURSIVE)
// =============================================================================

Function.AST_PrintTree {
    Input: node: Address
    Input: indent: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Print this node
        AST_PrintNode(node, indent)
        
        // Print children
        children = AST_GetChildren(node)
        IfCondition NotEqual(children, 0) ThenBlock: {
            count = XArray.XSize(children)
            i = 0
            next_indent = Add(indent, 1)
            WhileLoop LessThan(i, count) {
                child = XArray.XGet(children, i)
                AST_PrintTree(child, next_indent)
                i = Add(i, 1)
            }
        }
    }
}

// =============================================================================
// MAIN DUMP FUNCTION
// =============================================================================

Function.AST_Dump {
    Input: root: Address
    Body: {
        PrintMessage("\n")
        PrintMessage("╔══════════════════════════════════════╗\n")
        PrintMessage("║           AST DUMP                   ║\n")
        PrintMessage("╚══════════════════════════════════════╝\n")
        
        AST_PrintTree(root, 0)
        
        PrintMessage("────────────────────────────────────────\n")
        PrintMessage("Total nodes: ")
        PrintNumber(ASTState.node_count)
        PrintMessage("\n")
    }
}

// =============================================================================
// VALIDATION
// =============================================================================

Function.AST_Validate {
    Input: root: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(root, 0) ThenBlock: {
            PrintMessage("[VALIDATE] Error: null root\n")
            ReturnValue(0)
        }
        
        // Count declarations by type
        func_count = 0
        sub_count = 0
        pool_count = 0
        import_count = 0
        
        child_count = AST_GetChildCount(root)
        i = 0
        WhileLoop LessThan(i, child_count) {
            child = AST_GetChild(root, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.FUNCTION) ThenBlock: {
                func_count = Add(func_count, 1)
            }
            IfCondition EqualTo(child_type, AST.SUBROUTINE) ThenBlock: {
                sub_count = Add(sub_count, 1)
            }
            IfCondition EqualTo(child_type, AST.LIBRARY_IMPORT) ThenBlock: {
                import_count = Add(import_count, 1)
            }
            IfCondition And(GreaterEqual(child_type, AST.POOL), LessEqual(child_type, AST.POOL_LINKAGE)) ThenBlock: {
                pool_count = Add(pool_count, 1)
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[VALIDATE] Imports: ")
        PrintNumber(import_count)
        PrintMessage(", Functions: ")
        PrintNumber(func_count)
        PrintMessage(", SubRoutines: ")
        PrintNumber(sub_count)
        PrintMessage(", Pools: ")
        PrintNumber(pool_count)
        PrintMessage("\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// STATISTICS
// =============================================================================

Function.AST_PrintStats {
    Body: {
        PrintMessage("\n=== AST Statistics ===\n")
        PrintMessage("Total nodes: ")
        PrintNumber(ASTState.node_count)
        PrintMessage("\n")
        PrintMessage("Max children: ")
        PrintNumber(ASTState.max_children)
        PrintMessage("\n")
        IfCondition EqualTo(ASTState.error, 1) ThenBlock: {
            PrintMessage("Error: ")
            PrintMessage(ASTState.error_msg)
            PrintMessage("\n")
        }
        PrintMessage("======================\n")
    }
}