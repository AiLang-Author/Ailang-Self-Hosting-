// Library.CASTNodes.ailang
// Convenience functions for creating specific AST node types
// Each function creates a properly structured node

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore

// =============================================================================
// PROGRAM STRUCTURE
// =============================================================================

Function.AST_MakeProgram {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.PROGRAM))
    }
}

Function.AST_MakeLibraryImport {
    Input: path: Address
    Output: Address
    Body: {
        node = AST_Create(AST.LIBRARY_IMPORT)
        AST_SetData1(node, path)
        ReturnValue(node)
    }
}

// =============================================================================
// FUNCTIONS AND ROUTINES
// =============================================================================

// Function node: DATA1=name
Function.AST_MakeFunction {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_Create(AST.FUNCTION)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

// SubRoutine node: DATA1=name
Function.AST_MakeSubRoutine {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_Create(AST.SUBROUTINE)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

// Parameter node: DATA1=name, DATA2=type
Function.AST_MakeParameter {
    Input: name: Address
    Input: param_type: Address
    Output: Address
    Body: {
        node = AST_Create(AST.PARAMETER)
        AST_SetData1(node, name)
        AST_SetData2(node, param_type)
        ReturnValue(node)
    }
}

// Output declaration: DATA1=type
Function.AST_MakeOutput {
    Input: output_type: Address
    Output: Address
    Body: {
        node = AST_Create(AST.OUTPUT_DECL)
        AST_SetData1(node, output_type)
        ReturnValue(node)
    }
}

// Body block
Function.AST_MakeBody {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.BODY))
    }
}

// =============================================================================
// POOLS
// =============================================================================

// FixedPool: DATA1=name
Function.AST_MakeFixedPool {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_Create(AST.POOL_FIXED)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

// DynamicPool: DATA1=name
Function.AST_MakeDynamicPool {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_Create(AST.POOL_DYNAMIC)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

// Pool member: DATA1=name, DATA2=value/init
Function.AST_MakePoolMember {
    Input: name: Address
    Input: init_value: Address
    Output: Address
    Body: {
        node = AST_Create(AST.POOL_MEMBER)
        AST_SetData1(node, name)
        AST_SetData2(node, init_value)
        ReturnValue(node)
    }
}

// =============================================================================
// LITERALS / EXPRESSIONS
// =============================================================================

// Identifier: DATA1=name
Function.AST_MakeIdentifier {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_Create(AST.IDENTIFIER)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

// Number: DATA1=value (as string or integer)
Function.AST_MakeNumber {
    Input: value: Address
    Output: Address
    Body: {
        node = AST_Create(AST.NUMBER)
        AST_SetData1(node, value)
        ReturnValue(node)
    }
}

// String: DATA1=value
Function.AST_MakeString {
    Input: value: Address
    Output: Address
    Body: {
        node = AST_Create(AST.STRING)
        AST_SetData1(node, value)
        ReturnValue(node)
    }
}

// Boolean: DATA1=value (0 or 1)
Function.AST_MakeBoolean {
    Input: value: Integer
    Output: Address
    Body: {
        node = AST_Create(AST.BOOLEAN)
        AST_SetData1(node, value)
        ReturnValue(node)
    }
}

// Null literal
Function.AST_MakeNull {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.NULL))
    }
}

// Array literal: children=[elements...]
Function.AST_MakeArrayLiteral {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.ARRAY_LITERAL))
    }
}

// =============================================================================
// OPERATORS
// =============================================================================

// Binary operation: DATA1=op_type, children=[left, right]
Function.AST_MakeBinaryOp {
    Input: op_type: Integer
    Input: left: Address
    Input: right: Address
    Output: Address
    Body: {
        node = AST_Create(AST.BINARY_OP)
        AST_SetData1(node, op_type)
        AST_AddChild(node, left)
        AST_AddChild(node, right)
        ReturnValue(node)
    }
}

// Unary operation: DATA1=op_type, children=[operand]
Function.AST_MakeUnaryOp {
    Input: op_type: Integer
    Input: operand: Address
    Output: Address
    Body: {
        node = AST_Create(AST.UNARY_OP)
        AST_SetData1(node, op_type)
        AST_AddChild(node, operand)
        ReturnValue(node)
    }
}

// =============================================================================
// CALLS AND ACCESS
// =============================================================================

// Function call with args array: DATA1=func_name, children=[args...]
// This version accepts an XArray of arguments and adds them all
Function.AST_MakeCall {
    Input: func_name: Address
    Input: args: Address
    Output: Address
    Body: {
        node = AST_Create(AST.CALL)
        AST_SetData1(node, func_name)
        
        IfCondition NotEqual(args, 0) ThenBlock: {
            arg_count = XArray.XSize(args)
            i = 0
            WhileLoop LessThan(i, arg_count) {
                arg = XArray.XGet(args, i)
                AST_AddChild(node, arg)
                i = Add(i, 1)
            }
        }
        
        ReturnValue(node)
    }
}

// Simple call without args (for building incrementally)
Function.AST_MakeCallSimple {
    Input: func_name: Address
    Output: Address
    Body: {
        node = AST_Create(AST.CALL)
        AST_SetData1(node, func_name)
        ReturnValue(node)
    }
}

// Add argument to call node
Function.AST_AddCallArg {
    Input: call_node: Address
    Input: arg: Address
    Body: {
        AST_AddChild(call_node, arg)
    }
}

// Member access: DATA1=member_name, children=[base]
Function.AST_MakeMemberAccess {
    Input: base: Address
    Input: member: Address
    Output: Address
    Body: {
        node = AST_Create(AST.MEMBER_ACCESS)
        AST_SetData1(node, member)
        AST_AddChild(node, base)
        ReturnValue(node)
    }
}

// Index access: children=[base, index]
Function.AST_MakeIndexAccess {
    Input: base: Address
    Input: index: Address
    Output: Address
    Body: {
        node = AST_Create(AST.INDEX_ACCESS)
        AST_AddChild(node, base)
        AST_AddChild(node, index)
        ReturnValue(node)
    }
}

// =============================================================================
// STATEMENTS
// =============================================================================

// Assignment: DATA1=target (identifier string), children=[value]
Function.AST_MakeAssignment {
    Input: target: Address
    Input: value: Address
    Output: Address
    Body: {
        node = AST_Create(AST.ASSIGNMENT)
        AST_SetData1(node, target)
        AST_AddChild(node, value)
        ReturnValue(node)
    }
}

// Block: children=[statements...]
Function.AST_MakeBlock {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.BLOCK))
    }
}

// If: children=[condition, then_block, else_block?]
Function.AST_MakeIf {
    Input: condition: Address
    Input: then_block: Address
    Input: else_block: Address
    Output: Address
    Body: {
        node = AST_Create(AST.IF)
        AST_AddChild(node, condition)
        AST_AddChild(node, then_block)
        IfCondition NotEqual(else_block, 0) ThenBlock: {
            AST_AddChild(node, else_block)
        }
        ReturnValue(node)
    }
}

// While: children=[condition, body]
Function.AST_MakeWhile {
    Input: condition: Address
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.WHILE)
        AST_AddChild(node, condition)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// Return: children=[value?]
Function.AST_MakeReturn {
    Input: value: Address
    Output: Address
    Body: {
        node = AST_Create(AST.RETURN)
        IfCondition NotEqual(value, 0) ThenBlock: {
            AST_AddChild(node, value)
        }
        ReturnValue(node)
    }
}

// ExitLoop (break)
Function.AST_MakeExitLoop {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.EXIT_LOOP))
    }
}

// ContinueLoop
Function.AST_MakeContinueLoop {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.CONTINUE_LOOP))
    }
}

// =============================================================================
// CONTROL FLOW
// =============================================================================

// ForEvery loop: DATA1=var_name, children=[iterable, body]
Function.AST_MakeForEvery {
    Input: var_name: Address
    Input: iterable: Address
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.FOR_EVERY)
        AST_SetData1(node, var_name)
        AST_AddChild(node, iterable)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// Switch: DATA1=expr, children=[cases...]
Function.AST_MakeSwitch {
    Input: expr: Address
    Output: Address
    Body: {
        node = AST_Create(AST.SWITCH)
        AST_AddChild(node, expr)
        ReturnValue(node)
    }
}

// Case: DATA1=value, children=[body]
Function.AST_MakeCase {
    Input: value: Address
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.CASE)
        AST_SetData1(node, value)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// Default case: children=[body]
Function.AST_MakeDefault {
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.DEFAULT)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================

// Try: children=[body, catch?, finally?]
Function.AST_MakeTry {
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.TRY)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// Catch: DATA1=exception_var, children=[body]
Function.AST_MakeCatch {
    Input: exception_var: Address
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.CATCH)
        AST_SetData1(node, exception_var)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// Finally: children=[body]
Function.AST_MakeFinally {
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.FINALLY)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// =============================================================================
// I/O NODES
// =============================================================================

// Print: DATA1=print_type (1=msg, 2=num, 3=char), children=[value]
Function.AST_MakePrint {
    Input: print_type: Integer
    Input: value: Address
    Output: Address
    Body: {
        node = AST_Create(AST.PRINT)
        AST_SetData1(node, print_type)
        AST_AddChild(node, value)
        ReturnValue(node)
    }
}

// Halt: children=[message?]
Function.AST_MakeHalt {
    Output: Address
    Body: {
        ReturnValue(AST_Create(AST.HALT))
    }
}

// =============================================================================
// LOOP CONSTRUCTS
// =============================================================================

// LoopMain: children=[body]
Function.AST_MakeLoopMain {
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.LOOP_MAIN)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// LoopActor: DATA1=name, children=[body]
Function.AST_MakeLoopActor {
    Input: name: Address
    Input: body: Address
    Output: Address
    Body: {
        node = AST_Create(AST.LOOP_ACTOR)
        AST_SetData1(node, name)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

// =============================================================================
// TYPE NODES
// =============================================================================

// Create a type node
Function.AST_MakeType {
    Input: type_kind: Integer
    Output: Address
    Body: {
        ReturnValue(AST_Create(type_kind))
    }
}

// Custom type: DATA1=type_name
Function.AST_MakeCustomType {
    Input: type_name: Address
    Output: Address
    Body: {
        node = AST_Create(AST.TYPE_CUSTOM)
        AST_SetData1(node, type_name)
        ReturnValue(node)
    }
}