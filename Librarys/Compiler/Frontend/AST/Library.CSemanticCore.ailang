// Library.CSemanticCore.ailang
// Semantic analysis for the AILang self-hosting compiler
// Builds symbol tables, resolves names, validates types
// Location: Librarys/Compiler/Frontend/AST/Library.CSemanticCore.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes



// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Sem_Init {
    Body: {
        // Create symbol table
        Semantic.symbols = XArray.XCreate(1024)
        Semantic.symbol_count = 0
        
        // Create scope stack
        Semantic.scopes = XArray.XCreate(64)
        Semantic.scope_depth = 0
        
        // Clear state
        Semantic.current_function = 0
        Semantic.error = 0
        Semantic.error_count = 0
        Semantic.warning_count = 0
        Semantic.error_msg = 0
        Semantic.error_line = 0
        Semantic.error_col = 0
        
        // Push global scope
        Sem_PushScope()
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.Sem_Free {
    Body: {
        // Free symbol records
        IfCondition NotEqual(Semantic.symbols, 0) ThenBlock: {
            i = 0
            WhileLoop LessThan(i, Semantic.symbol_count) {
                sym = XArray.XGet(Semantic.symbols, i)
                IfCondition NotEqual(sym, 0) ThenBlock: {
                    ArrayDestroy(sym)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Semantic.symbols)
            Semantic.symbols = 0
        }
        
        // Free scope stack
        IfCondition NotEqual(Semantic.scopes, 0) ThenBlock: {
            XArray.XDestroy(Semantic.scopes)
            Semantic.scopes = 0
        }
        
        Semantic.symbol_count = 0
        Semantic.scope_depth = 0
    }
}

// =============================================================================
// SCOPE MANAGEMENT
// =============================================================================
Function.Sem_PushScope {
    Body: {
        // Record current symbol count as scope start
        XArray.XPush(Semantic.scopes, Semantic.symbol_count)
        Semantic.scope_depth = Add(Semantic.scope_depth, 1)
    }
}

Function.Sem_PopScope {
    Body: {
        IfCondition GreaterThan(Semantic.scope_depth, 0) ThenBlock: {
            Semantic.scope_depth = Subtract(Semantic.scope_depth, 1)
            
            // Get scope start
            scope_start = XArray.XGet(Semantic.scopes, Semantic.scope_depth)
            
            // Remove symbols added in this scope (mark as invalid)
            i = scope_start
            WhileLoop LessThan(i, Semantic.symbol_count) {
                sym = XArray.XGet(Semantic.symbols, i)
                IfCondition NotEqual(sym, 0) ThenBlock: {
                    // Mark scope level as -1 to invalidate
                    ArraySet(sym, SymField.SCOPE, -1)
                }
                i = Add(i, 1)
            }
            
            // Pop scope marker
            XArray.XPop(Semantic.scopes)
        }
    }
}

// =============================================================================
// SYMBOL TABLE OPERATIONS
// =============================================================================

// Add a symbol to the table
Function.Sem_AddSymbol {
    Input: name: Address
    Input: sym_type: Integer
    Input: data_type: Integer
    Input: node: Address
    Output: Address
    Body: {
        // Create symbol record
        sym = ArrayCreate(SymField.SYM_SIZE)
        ArraySet(sym, SymField.NAME, name)
        ArraySet(sym, SymField.TYPE, sym_type)
        ArraySet(sym, SymField.DATA_TYPE, data_type)
        ArraySet(sym, SymField.SCOPE, Semantic.scope_depth)
        ArraySet(sym, SymField.NODE, node)
        ArraySet(sym, SymField.FLAGS, SymFlag.DEFINED)
        
        // Add to table
        XArray.XPush(Semantic.symbols, sym)
        Semantic.symbol_count = Add(Semantic.symbol_count, 1)
        
        ReturnValue(sym)
    }
}

// Look up a symbol by name (searches from current scope up)
Function.Sem_Lookup {
    Input: name: Address
    Output: Address
    Body: {
        // Search backwards (most recent first)
        i = Subtract(Semantic.symbol_count, 1)
        WhileLoop GreaterEqual(i, 0) {
            sym = XArray.XGet(Semantic.symbols, i)
            IfCondition NotEqual(sym, 0) ThenBlock: {
                sym_scope = ArrayGet(sym, SymField.SCOPE)
                // Skip invalidated symbols
                IfCondition GreaterEqual(sym_scope, 0) ThenBlock: {
                    sym_name = ArrayGet(sym, SymField.NAME)
                    IfCondition EqualTo(StringCompare(name, sym_name), 0) ThenBlock: {
                        ReturnValue(sym)
                    }
                }
            }
            i = Subtract(i, 1)
        }
        ReturnValue(0)
    }
}

// Look up in current scope only
Function.Sem_LookupLocal {
    Input: name: Address
    Output: Address
    Body: {
        // Get current scope start
        IfCondition EqualTo(Semantic.scope_depth, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        scope_start = XArray.XGet(Semantic.scopes, Subtract(Semantic.scope_depth, 1))
        
        i = scope_start
        WhileLoop LessThan(i, Semantic.symbol_count) {
            sym = XArray.XGet(Semantic.symbols, i)
            IfCondition NotEqual(sym, 0) ThenBlock: {
                sym_name = ArrayGet(sym, SymField.NAME)
                IfCondition EqualTo(StringCompare(name, sym_name), 0) ThenBlock: {
                    ReturnValue(sym)
                }
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// ERROR REPORTING
// =============================================================================
Function.Sem_Error {
    Input: msg: Address
    Input: line: Integer
    Input: col: Integer
    Body: {
        Semantic.error = 1
        Semantic.error_count = Add(Semantic.error_count, 1)
        Semantic.error_msg = msg
        Semantic.error_line = line
        Semantic.error_col = col
        
        PrintMessage("SEMANTIC ERROR at line ")
        PrintNumber(line)
        PrintMessage(", col ")
        PrintNumber(col)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

Function.Sem_Warning {
    Input: msg: Address
    Input: line: Integer
    Input: col: Integer
    Body: {
        Semantic.warning_count = Add(Semantic.warning_count, 1)
        
        PrintMessage("WARNING at line ")
        PrintNumber(line)
        PrintMessage(", col ")
        PrintNumber(col)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

// =============================================================================
// MAIN ANALYSIS ENTRY POINT
// =============================================================================
Function.Sem_Analyze {
    Input: ast: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            Sem_Error("Null AST", 0, 0)
            ReturnValue(0)
        }
        
        PrintMessage("[SEMANTIC] Starting analysis...\n")
        
        // Pass 1: Collect declarations (functions, pools, etc.)
        Sem_CollectDeclarations(ast)
        
        // Pass 2: Validate bodies and expressions
        Sem_ValidateBodies(ast)
        
        // Report results
        PrintMessage("[SEMANTIC] Analysis complete: ")
        PrintNumber(Semantic.symbol_count)
        PrintMessage(" symbols, ")
        PrintNumber(Semantic.error_count)
        PrintMessage(" errors, ")
        PrintNumber(Semantic.warning_count)
        PrintMessage(" warnings\n")
        
        // Return success if no errors
        IfCondition EqualTo(Semantic.error_count, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// PASS 1: COLLECT DECLARATIONS
// =============================================================================
Function.Sem_CollectDeclarations {
    Input: ast: Address
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(ast)
        
        // Program - iterate children
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                child = AST_GetChild(ast, i)
                Sem_CollectDeclarations(child)
                i = Add(i, 1)
            }
            ReturnValue(1)
        }
        
        // Function declaration
        IfCondition EqualTo(node_type, AST.FUNCTION) ThenBlock: {
            name = AST_GetData1(ast)
            existing = Sem_Lookup(name)
            IfCondition NotEqual(existing, 0) ThenBlock: {
                Sem_Error("Duplicate function declaration", 0, 0)
            } ElseBlock: {
                Sem_AddSymbol(name, SymType.SYM_FUNCTION, 0, ast)
            }
            ReturnValue(1)
        }
        
        // SubRoutine declaration
        IfCondition EqualTo(node_type, AST.SUBROUTINE) ThenBlock: {
            name = AST_GetData1(ast)
            existing = Sem_Lookup(name)
            IfCondition NotEqual(existing, 0) ThenBlock: {
                Sem_Error("Duplicate subroutine declaration", 0, 0)
            } ElseBlock: {
                Sem_AddSymbol(name, SymType.SYM_SUBROUTINE, 0, ast)
            }
            ReturnValue(1)
        }
        
        // Pool declaration
        IfCondition EqualTo(node_type, AST.POOL) ThenBlock: {
            name = AST_GetData1(ast)
            Sem_AddSymbol(name, SymType.SYM_POOL, 0, ast)
            
            // Add pool members as SYM_POOL_VAR
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                child = AST_GetChild(ast, i)
                IfCondition NotEqual(child, 0) ThenBlock: {
                    member_name = AST_GetData1(child)
                    IfCondition NotEqual(member_name, 0) ThenBlock: {
                        full_name = StringConcat(name, ".")
                        full_name = StringConcat(full_name, member_name)
                        Sem_AddSymbol(full_name, SymType.SYM_POOL_VAR, 0, child)
                    }
                }
                i = Add(i, 1)
            }
            ReturnValue(1)
        }
        
        // Library import - just note it
        IfCondition EqualTo(node_type, AST.LIBRARY_IMPORT) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// PASS 2: VALIDATE BODIES
// =============================================================================
Function.Sem_ValidateBodies {
    Input: ast: Address
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(ast)
        
        // Program - iterate children
        IfCondition EqualTo(node_type, AST.PROGRAM) ThenBlock: {
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                child = AST_GetChild(ast, i)
                Sem_ValidateBodies(child)
                i = Add(i, 1)
            }
            ReturnValue(1)
        }
        
        // Function - validate body
        IfCondition EqualTo(node_type, AST.FUNCTION) ThenBlock: {
            name = AST_GetData1(ast)
            Semantic.current_function = name
            
            Sem_PushScope()
            
            // Add parameters to scope
            Sem_CollectParameters(ast)
            
            // Validate body statements
            count = AST_GetChildCount(ast)
            i = 0
            WhileLoop LessThan(i, count) {
                child = AST_GetChild(ast, i)
                child_type = AST_GetType(child)
                IfCondition EqualTo(child_type, AST.BLOCK) ThenBlock: {
                    Sem_ValidateBlock(child)
                }
                i = Add(i, 1)
            }
            
            Sem_PopScope()
            Semantic.current_function = 0
            ReturnValue(1)
        }
        
        // SubRoutine - validate body
        IfCondition EqualTo(node_type, AST.SUBROUTINE) ThenBlock: {
            name = AST_GetData1(ast)
            Semantic.current_function = name
            
            Sem_PushScope()
            Sem_ValidateBlock(ast)
            Sem_PopScope()
            
            Semantic.current_function = 0
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// PARAMETER COLLECTION
// =============================================================================
Function.Sem_CollectParameters {
    Input: func_node: Address
    Body: {
        count = AST_GetChildCount(func_node)
        i = 0
        WhileLoop LessThan(i, count) {
            child = AST_GetChild(func_node, i)
            child_type = AST_GetType(child)
            IfCondition EqualTo(child_type, AST.PARAMETER) ThenBlock: {
                param_name = AST_GetData1(child)
                Sem_AddSymbol(param_name, SymType.SYM_PARAMETER, 0, child)
            }
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// BLOCK VALIDATION
// =============================================================================
Function.Sem_ValidateBlock {
    Input: block: Address
    Body: {
        IfCondition EqualTo(block, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        count = AST_GetChildCount(block)
        i = 0
        WhileLoop LessThan(i, count) {
            stmt = AST_GetChild(block, i)
            Sem_ValidateStatement(stmt)
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

// =============================================================================
// STATEMENT VALIDATION
// =============================================================================
Function.Sem_ValidateStatement {
    Input: stmt: Address
    Body: {
        IfCondition EqualTo(stmt, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(stmt)
        
        // Assignment - check target and validate expression
        IfCondition EqualTo(node_type, AST.ASSIGNMENT) ThenBlock: {
            // Add variable to scope if new
            target = AST_GetData1(stmt)
            existing = Sem_Lookup(target)
            IfCondition EqualTo(existing, 0) ThenBlock: {
                Sem_AddSymbol(target, SymType.SYM_VARIABLE, 0, stmt)
            }
            
            // Validate RHS expression
            count = AST_GetChildCount(stmt)
            IfCondition GreaterThan(count, 0) ThenBlock: {
                expr = AST_GetChild(stmt, 0)
                Sem_ValidateExpression(expr)
            }
            ReturnValue(1)
        }
        
        // Function call - validate
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            Sem_ValidateCall(stmt)
            ReturnValue(1)
        }
        
        // Return - validate expression if present
        IfCondition EqualTo(node_type, AST.RETURN) ThenBlock: {
            count = AST_GetChildCount(stmt)
            IfCondition GreaterThan(count, 0) ThenBlock: {
                expr = AST_GetChild(stmt, 0)
                Sem_ValidateExpression(expr)
            }
            ReturnValue(1)
        }
        
        // If statement - validate condition and branches
        IfCondition EqualTo(node_type, AST.IF) ThenBlock: {
            count = AST_GetChildCount(stmt)
            IfCondition GreaterThan(count, 0) ThenBlock: {
                cond = AST_GetChild(stmt, 0)
                Sem_ValidateExpression(cond)
            }
            IfCondition GreaterThan(count, 1) ThenBlock: {
                then_block = AST_GetChild(stmt, 1)
                Sem_PushScope()
                Sem_ValidateBlock(then_block)
                Sem_PopScope()
            }
            IfCondition GreaterThan(count, 2) ThenBlock: {
                else_block = AST_GetChild(stmt, 2)
                Sem_PushScope()
                Sem_ValidateBlock(else_block)
                Sem_PopScope()
            }
            ReturnValue(1)
        }
        
        // While loop - validate condition and body
        IfCondition EqualTo(node_type, AST.WHILE) ThenBlock: {
            count = AST_GetChildCount(stmt)
            IfCondition GreaterThan(count, 0) ThenBlock: {
                cond = AST_GetChild(stmt, 0)
                Sem_ValidateExpression(cond)
            }
            IfCondition GreaterThan(count, 1) ThenBlock: {
                body = AST_GetChild(stmt, 1)
                Sem_PushScope()
                Sem_ValidateBlock(body)
                Sem_PopScope()
            }
            ReturnValue(1)
        }
        
        // Block - nested scope
        IfCondition EqualTo(node_type, AST.BLOCK) ThenBlock: {
            Sem_PushScope()
            Sem_ValidateBlock(stmt)
            Sem_PopScope()
            ReturnValue(1)
        }
        
        // Print statements - validate argument
        IfCondition EqualTo(node_type, AST.PRINT) ThenBlock: {
            count = AST_GetChildCount(stmt)
            IfCondition GreaterThan(count, 0) ThenBlock: {
                arg = AST_GetChild(stmt, 0)
                Sem_ValidateExpression(arg)
            }
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// EXPRESSION VALIDATION
// =============================================================================
Function.Sem_ValidateExpression {
    Input: expr: Address
    Body: {
        IfCondition EqualTo(expr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        node_type = AST_GetType(expr)
        
        // Identifier - check if defined
        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
            name = AST_GetData1(expr)
            sym = Sem_Lookup(name)
            IfCondition EqualTo(sym, 0) ThenBlock: {
                // Check if it's a pool.member reference
                // For now, allow dotted names
                // TODO: Proper validation of pool references
            }
            ReturnValue(1)
        }
        
        // Literals - always valid
        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
            ReturnValue(1)
        }
        
        // Function call
        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
            Sem_ValidateCall(expr)
            ReturnValue(1)
        }
        
        // Binary operation - validate both sides
        IfCondition EqualTo(node_type, AST.BINARY_OP) ThenBlock: {
            count = AST_GetChildCount(expr)
            IfCondition GreaterThan(count, 0) ThenBlock: {
                left = AST_GetChild(expr, 0)
                Sem_ValidateExpression(left)
            }
            IfCondition GreaterThan(count, 1) ThenBlock: {
                right = AST_GetChild(expr, 1)
                Sem_ValidateExpression(right)
            }
            ReturnValue(1)
        }
        
        // Unary operation
        IfCondition EqualTo(node_type, AST.UNARY_OP) ThenBlock: {
            count = AST_GetChildCount(expr)
            IfCondition GreaterThan(count, 0) ThenBlock: {
                operand = AST_GetChild(expr, 0)
                Sem_ValidateExpression(operand)
            }
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// FUNCTION CALL VALIDATION
// =============================================================================
Function.Sem_ValidateCall {
    Input: call: Address
    Body: {
        IfCondition EqualTo(call, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        func_name = AST_GetData1(call)
        
        // Look up function
        sym = Sem_Lookup(func_name)
        
        // Allow built-in functions (Add, Subtract, PrintMessage, etc.)
        // TODO: Add built-in function registry
        
        // Validate arguments
        count = AST_GetChildCount(call)
        i = 0
        WhileLoop LessThan(i, count) {
            arg = AST_GetChild(call, i)
            Sem_ValidateExpression(arg)
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// UTILITY: CHECK IF SYMBOL EXISTS
// =============================================================================
Function.Sem_IsDefined {
    Input: name: Address
    Output: Integer
    Body: {
        sym = Sem_Lookup(name)
        IfCondition NotEqual(sym, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// UTILITY: GET SYMBOL TYPE
// =============================================================================
Function.Sem_GetSymbolType {
    Input: name: Address
    Output: Integer
    Body: {
        sym = Sem_Lookup(name)
        IfCondition NotEqual(sym, 0) ThenBlock: {
            sym_type = ArrayGet(sym, SymField.TYPE)
            ReturnValue(sym_type)
        }
        ReturnValue(SymType.SYM_UNKNOWN)
    }
}