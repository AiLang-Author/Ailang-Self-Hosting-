// Library.CLexerCore.ailang
// Core lexer state and utility functions
// Mirrors lexer_class.py core functionality

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.Lexer.CLexerTypes
LibraryImport.Compiler.Frontend.Lexer.CLexerKeywords

// =============================================================================
// LEXER INITIALIZATION
// =============================================================================
Function.Lex_Init {
    Input: source: Address
    Input: source_len: Integer
    Body: {
        // Store source
        Lex.source = source
        Lex.source_len = source_len
        
        // Reset position
        Lex.pos = 0
        Lex.line = 1
        Lex.col = 1
        
        // Create token list
        Lex.tokens = XArray.XCreate(256)
        Lex.token_count = 0
        
        // Create token buffer
        Lex.tok_buf = Allocate(Lex.tok_buf_size)
        Lex.tok_buf_pos = 0
        
        // Clear errors
        Lex.error = 0
        Lex.error_line = 0
        Lex.error_col = 0
        Lex.error_msg = 0
        
        // Initialize keyword table
        Kw_Init()
        
        ReturnValue(1)
    }
}

// =============================================================================
// LEXER CLEANUP
// =============================================================================
Function.Lex_Free {
    Body: {
        // Free token buffer
        IfCondition NotEqual(Lex.tok_buf, 0) ThenBlock: {
            Deallocate(Lex.tok_buf, Lex.tok_buf_size)
            Lex.tok_buf = 0
        }
        
        // Free tokens (each token is an array)
        IfCondition NotEqual(Lex.tokens, 0) ThenBlock: {
            count = XArray.XSize(Lex.tokens)
            i = 0
            WhileLoop LessThan(i, count) {
                tok = XArray.XGet(Lex.tokens, i)
                IfCondition NotEqual(tok, 0) ThenBlock: {
                    ArrayDestroy(tok)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Lex.tokens)
            Lex.tokens = 0
        }
        
        Lex.token_count = 0
        
        // Free keyword table
        Kw_Free()
        
        ReturnValue(1)
    }
}

// =============================================================================
// CHARACTER ACCESS
// =============================================================================
Function.Lex_CurrentChar {
    Output: Integer
    Body: {
        IfCondition GreaterEqual(Lex.pos, Lex.source_len) ThenBlock: {
            ReturnValue(0)
        }
        c = GetByte(Lex.source, Lex.pos)
        ReturnValue(c)
    }
}

Function.Lex_PeekChar {
    Input: offset: Integer
    Output: Integer
    Body: {
        peek_pos = Add(Lex.pos, offset)
        IfCondition GreaterEqual(peek_pos, Lex.source_len) ThenBlock: {
            ReturnValue(0)
        }
        c = GetByte(Lex.source, peek_pos)
        ReturnValue(c)
    }
}

Function.Lex_Advance {
    Body: {
        IfCondition LessThan(Lex.pos, Lex.source_len) ThenBlock: {
            c = GetByte(Lex.source, Lex.pos)
            IfCondition EqualTo(c, ASCII.LF) ThenBlock: {
                Lex.line = Add(Lex.line, 1)
                Lex.col = 1
            } ElseBlock: {
                Lex.col = Add(Lex.col, 1)
            }
            Lex.pos = Add(Lex.pos, 1)
        }
    }
}

// =============================================================================
// CHARACTER CLASSIFICATION
// =============================================================================
Function.Lex_IsWhitespace {
    Input: c: Integer
    Output: Integer
    Body: {
        is_space = EqualTo(c, ASCII.SPACE)
        is_tab = EqualTo(c, ASCII.TAB)
        is_cr = EqualTo(c, ASCII.CR)
        
        result = Or(Or(is_space, is_tab), is_cr)
        ReturnValue(result)
    }
}

Function.Lex_IsDigit {
    Input: c: Integer
    Output: Integer
    Body: {
        result = And(GreaterEqual(c, ASCII.ZERO), LessEqual(c, ASCII.NINE))
        ReturnValue(result)
    }
}

Function.Lex_IsAlpha {
    Input: c: Integer
    Output: Integer
    Body: {
        is_upper = And(GreaterEqual(c, ASCII.A_UPPER), LessEqual(c, ASCII.Z_UPPER))
        is_lower = And(GreaterEqual(c, ASCII.A_LOWER), LessEqual(c, ASCII.Z_LOWER))
        is_underscore = EqualTo(c, ASCII.UNDERSCORE)
        
        result = Or(Or(is_upper, is_lower), is_underscore)
        ReturnValue(result)
    }
}

Function.Lex_IsAlphaNum {
    Input: c: Integer
    Output: Integer
    Body: {
        is_alpha = Lex_IsAlpha(c)
        is_digit = Lex_IsDigit(c)
        result = Or(is_alpha, is_digit)
        ReturnValue(result)
    }
}

Function.Lex_IsIdentifierStart {
    Input: c: Integer
    Output: Integer
    Body: {
        // Same as IsAlpha (letters and underscore can start identifiers)
        result = Lex_IsAlpha(c)
        ReturnValue(result)
    }
}

// =============================================================================
// WHITESPACE HANDLING
// =============================================================================
Function.Lex_SkipWhitespace {
    Body: {
        continue_skip = 1
        WhileLoop EqualTo(continue_skip, 1) {
            c = Lex_CurrentChar()
            IfCondition EqualTo(c, 0) ThenBlock: {
                continue_skip = 0
            } ElseBlock: {
                is_ws = Lex_IsWhitespace(c)
                IfCondition EqualTo(is_ws, 1) ThenBlock: {
                    Lex_Advance()
                } ElseBlock: {
                    continue_skip = 0
                }
            }
        }
    }
}

// =============================================================================
// TOKEN BUFFER OPERATIONS
// =============================================================================
Function.Lex_BufClear {
    Body: {
        Lex.tok_buf_pos = 0
        SetByte(Lex.tok_buf, 0, 0)
    }
}

Function.Lex_BufAppend {
    Input: c: Integer
    Body: {
        IfCondition LessThan(Lex.tok_buf_pos, Subtract(Lex.tok_buf_size, 1)) ThenBlock: {
            SetByte(Lex.tok_buf, Lex.tok_buf_pos, c)
            Lex.tok_buf_pos = Add(Lex.tok_buf_pos, 1)
            SetByte(Lex.tok_buf, Lex.tok_buf_pos, 0)
        }
    }
}

Function.Lex_BufGetString {
    Output: Address
    Body: {
        // Allocate and copy buffer contents
        len = Lex.tok_buf_pos
        result = Allocate(Add(len, 1))
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(Lex.tok_buf, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, len, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// TOKEN CREATION
// =============================================================================
Function.Lex_AddToken {
    Input: tok_type: Integer
    Input: tok_value: Address
    Input: tok_line: Integer
    Input: tok_col: Integer
    Input: tok_len: Integer
    Body: {
        // Create token record: [type, value, line, col, length]
        tok = ArrayCreate(5)
        ArraySet(tok, TokField.TYPE, tok_type)
        ArraySet(tok, TokField.VALUE, tok_value)
        ArraySet(tok, TokField.LINE, tok_line)
        ArraySet(tok, TokField.COL, tok_col)
        ArraySet(tok, TokField.LENGTH, tok_len)
        
        XArray.XPush(Lex.tokens, tok)
        Lex.token_count = Add(Lex.token_count, 1)
        
        ReturnValue(tok)
    }
}

Function.Lex_AddTokenSimple {
    Input: tok_type: Integer
    Input: tok_value: Address
    Body: {
        len = 1
        IfCondition NotEqual(tok_value, 0) ThenBlock: {
            len = StringLength(tok_value)
        }
        Lex_AddToken(tok_type, tok_value, Lex.line, Lex.col, len)
    }
}

// =============================================================================
// TOKEN ACCESS (for parser)
// =============================================================================
Function.Lex_GetToken {
    Input: index: Integer
    Output: Address
    Body: {
        IfCondition GreaterEqual(index, Lex.token_count) ThenBlock: {
            ReturnValue(0)
        }
        tok = XArray.XGet(Lex.tokens, index)
        ReturnValue(tok)
    }
}

Function.Lex_GetType {
    Input: index: Integer
    Output: Integer
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(Token.EOF)
        }
        t = ArrayGet(tok, TokField.TYPE)
        ReturnValue(t)
    }
}

Function.Lex_GetVal {
    Input: index: Integer
    Output: Address
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(0)
        }
        v = ArrayGet(tok, TokField.VALUE)
        ReturnValue(v)
    }
}

Function.Lex_GetLine {
    Input: index: Integer
    Output: Integer
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(0)
        }
        l = ArrayGet(tok, TokField.LINE)
        ReturnValue(l)
    }
}

Function.Lex_GetCol {
    Input: index: Integer
    Output: Integer
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(0)
        }
        c = ArrayGet(tok, TokField.COL)
        ReturnValue(c)
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================
Function.Lex_Error {
    Input: msg: Address
    Body: {
        Lex.error = 1
        Lex.error_line = Lex.line
        Lex.error_col = Lex.col
        Lex.error_msg = msg
        
        PrintMessage("Lexer error at line ")
        PrintNumber(Lex.line)
        PrintMessage(", column ")
        PrintNumber(Lex.col)
        PrintMessage(": ")
        PrintString(msg)
        PrintMessage("\n")
    }
}

Function.Lex_Warning {
    Input: msg: Address
    Body: {
        PrintMessage("Lexer warning at line ")
        PrintNumber(Lex.line)
        PrintMessage(", column ")
        PrintNumber(Lex.col)
        PrintMessage(": ")
        PrintString(msg)
        PrintMessage("\n")
    }
}