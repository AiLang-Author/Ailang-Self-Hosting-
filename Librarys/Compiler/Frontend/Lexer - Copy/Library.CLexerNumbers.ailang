// Library.CLexerNumbers.ailang
// Number lexing for the AILang self-hosting compiler
// Handles: integers, hex (0x), binary (0b), floats, scientific notation

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.Lexer.CLexerTypes
LibraryImport.Compiler.Frontend.Lexer.CLexerCore

// =============================================================================
// HEX DIGIT CHECK
// =============================================================================
Function.Lex_IsHexDigit {
    Input: c: Integer
    Output: Integer
    Body: {
        is_digit = Lex_IsDigit(c)
        is_upper_hex = And(GreaterEqual(c, 65), LessEqual(c, 70))   // A-F
        is_lower_hex = And(GreaterEqual(c, 97), LessEqual(c, 102))  // a-f
        
        result = Or(Or(is_digit, is_upper_hex), is_lower_hex)
        ReturnValue(result)
    }
}

// =============================================================================
// BINARY DIGIT CHECK
// =============================================================================
Function.Lex_IsBinaryDigit {
    Input: c: Integer
    Output: Integer
    Body: {
        result = Or(EqualTo(c, 48), EqualTo(c, 49))  // '0' or '1'
        ReturnValue(result)
    }
}

// =============================================================================
// READ NUMBER
// Handles: decimal, hex (0x), binary (0b), floats, scientific notation
// Returns string value (parser will convert to numeric)
// =============================================================================
Function.Lex_ReadNumber {
    Output: Address
    Body: {
        Lex_BufClear()
        
        c = Lex_CurrentChar()
        
        // Handle negative sign
        IfCondition EqualTo(c, ASCII.DASH) ThenBlock: {
            Lex_BufAppend(c)
            Lex_Advance()
            c = Lex_CurrentChar()
        }
        
        // Check for hex (0x) or binary (0b)
        IfCondition EqualTo(c, ASCII.ZERO) ThenBlock: {
            next = Lex_PeekChar(1)
            
            // Hex: 0x...
            IfCondition Or(EqualTo(next, 120), EqualTo(next, 88)) ThenBlock: {
                // 'x' or 'X'
                Lex_BufAppend(c)
                Lex_Advance()
                Lex_BufAppend(Lex_CurrentChar())
                Lex_Advance()
                
                // Read hex digits (allow underscores)
                has_digits = 0
                WhileLoop EqualTo(1, 1) {
                    c = Lex_CurrentChar()
                    is_hex = Lex_IsHexDigit(c)
                    is_underscore = EqualTo(c, ASCII.UNDERSCORE)
                    
                    IfCondition Or(is_hex, is_underscore) ThenBlock: {
                        // Skip underscores in output
                        IfCondition EqualTo(is_underscore, 0) ThenBlock: {
                            Lex_BufAppend(c)
                            has_digits = 1
                        }
                        Lex_Advance()
                    } ElseBlock: {
                        BreakLoop
                    }
                }
                
                IfCondition EqualTo(has_digits, 0) ThenBlock: {
                    Lex_Error("Invalid hex literal: no digits after 0x")
                    ReturnValue(0)
                }
                
                result = Lex_BufGetString()
                ReturnValue(result)
            }
            
            // Binary: 0b...
            IfCondition Or(EqualTo(next, 98), EqualTo(next, 66)) ThenBlock: {
                // 'b' or 'B'
                Lex_BufAppend(c)
                Lex_Advance()
                Lex_BufAppend(Lex_CurrentChar())
                Lex_Advance()
                
                // Read binary digits (allow underscores)
                has_digits = 0
                WhileLoop EqualTo(1, 1) {
                    c = Lex_CurrentChar()
                    is_bin = Lex_IsBinaryDigit(c)
                    is_underscore = EqualTo(c, ASCII.UNDERSCORE)
                    
                    IfCondition Or(is_bin, is_underscore) ThenBlock: {
                        IfCondition EqualTo(is_underscore, 0) ThenBlock: {
                            Lex_BufAppend(c)
                            has_digits = 1
                        }
                        Lex_Advance()
                    } ElseBlock: {
                        BreakLoop
                    }
                }
                
                IfCondition EqualTo(has_digits, 0) ThenBlock: {
                    Lex_Error("Invalid binary literal: no digits after 0b")
                    ReturnValue(0)
                }
                
                result = Lex_BufGetString()
                ReturnValue(result)
            }
        }
        
        // Regular decimal number (with optional decimal point and exponent)
        has_dot = 0
        has_exp = 0
        has_digits = 0
        
        WhileLoop EqualTo(1, 1) {
            c = Lex_CurrentChar()
            
            // Check for digit
            is_digit = Lex_IsDigit(c)
            IfCondition EqualTo(is_digit, 1) ThenBlock: {
                Lex_BufAppend(c)
                Lex_Advance()
                has_digits = 1
                ContinueLoop
            }
            
            // Check for underscore (skip in output)
            IfCondition EqualTo(c, ASCII.UNDERSCORE) ThenBlock: {
                Lex_Advance()
                ContinueLoop
            }
            
            // Check for decimal point
            IfCondition EqualTo(c, ASCII.DOT) ThenBlock: {
                // Only one decimal point allowed
                IfCondition EqualTo(has_dot, 1) ThenBlock: {
                    BreakLoop
                }
                // Make sure next char is digit (not another dot or identifier)
                next = Lex_PeekChar(1)
                next_is_digit = Lex_IsDigit(next)
                IfCondition EqualTo(next_is_digit, 0) ThenBlock: {
                    BreakLoop
                }
                has_dot = 1
                Lex_BufAppend(c)
                Lex_Advance()
                ContinueLoop
            }
            
            // Check for exponent (e or E)
            is_exp_char = Or(EqualTo(c, 101), EqualTo(c, 69))  // 'e' or 'E'
            IfCondition EqualTo(is_exp_char, 1) ThenBlock: {
                // Only one exponent allowed
                IfCondition EqualTo(has_exp, 1) ThenBlock: {
                    BreakLoop
                }
                has_exp = 1
                Lex_BufAppend(c)
                Lex_Advance()
                
                // Check for sign after exponent
                c = Lex_CurrentChar()
                is_sign = Or(EqualTo(c, ASCII.PLUS), EqualTo(c, ASCII.DASH))
                IfCondition EqualTo(is_sign, 1) ThenBlock: {
                    Lex_BufAppend(c)
                    Lex_Advance()
                }
                
                // Must have at least one digit after exponent
                c = Lex_CurrentChar()
                exp_digit = Lex_IsDigit(c)
                IfCondition EqualTo(exp_digit, 0) ThenBlock: {
                    Lex_Error("Invalid number: expected digit after exponent")
                    ReturnValue(0)
                }
                ContinueLoop
            }
            
            // Not part of number - break
            BreakLoop
        }
        
        // Validate we have at least one digit
        IfCondition EqualTo(has_digits, 0) ThenBlock: {
            Lex_Error("Invalid number: no digits")
            ReturnValue(0)
        }
        
        result = Lex_BufGetString()
        ReturnValue(result)
    }
}

// =============================================================================
// CHECK IF AT NUMBER START
// Returns 1 if current position could start a number
// =============================================================================
Function.Lex_AtNumberStart {
    Output: Integer
    Body: {
        c = Lex_CurrentChar()
        
        // Direct digit
        is_digit = Lex_IsDigit(c)
        IfCondition EqualTo(is_digit, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Negative number: - followed by digit
        IfCondition EqualTo(c, ASCII.DASH) ThenBlock: {
            next = Lex_PeekChar(1)
            next_digit = Lex_IsDigit(next)
            ReturnValue(next_digit)
        }
        
        ReturnValue(0)
    }
}