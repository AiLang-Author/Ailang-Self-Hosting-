// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CLexerCore.ailang
// Core lexer state and utility functions
// Mirrors lexer_class.py core functionality

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.Lexer.CLexerTypes
LibraryImport.Compiler.Frontend.Lexer.CLexerKeywords


// =============================================================================
// TOKEN RECORD STRUCTURE
// Each token is stored as an array: [type, value, line, col, length]
// =============================================================================
FixedPool.TokField {
    "TYPE": Initialize=0
    "VALUE": Initialize=1
    "LINE": Initialize=2
    "COL": Initialize=3
    "LENGTH": Initialize=4
    "TOKEN_SIZE": Initialize=5
}


// =============================================================================
// CHARACTER CLASS CONSTANTS
// =============================================================================
FixedPool.CharClass {
    "WHITESPACE": Initialize=1
    "NEWLINE": Initialize=2
    "DIGIT": Initialize=3
    "ALPHA": Initialize=4
    "ALPHA_NUM": Initialize=5
    "OPERATOR": Initialize=6
    "DELIMITER": Initialize=7
    "QUOTE": Initialize=8
}


// =============================================================================
// LEXER STATE
// =============================================================================
FixedPool.Lex {
    "source": Initialize=0, CanChange=True
    "source_len": Initialize=0, CanChange=True
    "pos": Initialize=0, CanChange=True
    "line": Initialize=1, CanChange=True
    "col": Initialize=1, CanChange=True
    "tokens": Initialize=0, CanChange=True
    "token_count": Initialize=0, CanChange=True
    "tok_buf": Initialize=0, CanChange=True
    "tok_buf_size": Initialize=256
    "tok_buf_pos": Initialize=0, CanChange=True
    "error": Initialize=0, CanChange=True
    "error_line": Initialize=0, CanChange=True
    "error_col": Initialize=0, CanChange=True
    "error_msg": Initialize=0, CanChange=True
    "strict_mode": Initialize=1, CanChange=True
}

// =============================================================================
// CHARACTER CLASS CONSTANTS
// =============================================================================
FixedPool.CharClass {
    "WHITESPACE": Initialize=1
    "NEWLINE": Initialize=2
    "DIGIT": Initialize=3
    "ALPHA": Initialize=4
    "ALPHA_NUM": Initialize=5
    "OPERATOR": Initialize=6
    "DELIMITER": Initialize=7
    "QUOTE": Initialize=8
}

// =============================================================================
// ASCII CONSTANTS
// =============================================================================
FixedPool.ASCII {
    "NUL": Initialize=0
    "TAB": Initialize=9
    "LF": Initialize=10
    "CR": Initialize=13
    "SPACE": Initialize=32
    "BANG": Initialize=33
    "DQUOTE": Initialize=34
    "HASH": Initialize=35
    "PERCENT": Initialize=37
    "AMPERSAND": Initialize=38
    "SQUOTE": Initialize=39
    "LPAREN": Initialize=40
    "RPAREN": Initialize=41
    "STAR": Initialize=42
    "PLUS": Initialize=43
    "COMMA": Initialize=44
    "DASH": Initialize=45
    "DOT": Initialize=46
    "SLASH": Initialize=47
    "ZERO": Initialize=48
    "NINE": Initialize=57
    "COLON": Initialize=58
    "SEMICOLON": Initialize=59
    "LESS": Initialize=60
    "EQUALS_SIGN": Initialize=61
    "GREATER": Initialize=62
    "QUESTION": Initialize=63
    "AT": Initialize=64
    "A_UPPER": Initialize=65
    "Z_UPPER": Initialize=90
    "LBRACKET": Initialize=91
    "BACKSLASH": Initialize=92
    "RBRACKET": Initialize=93
    "CARET": Initialize=94
    "UNDERSCORE": Initialize=95
    "BACKTICK": Initialize=96
    "A_LOWER": Initialize=97
    "Z_LOWER": Initialize=122
    "LBRACE": Initialize=123
    "PIPE": Initialize=124
    "RBRACE": Initialize=125
    "TILDE": Initialize=126
}

// =============================================================================
// LEXER INITIALIZATION
// =============================================================================
Function.Lex_Init {
    Input: source: Address
    Input: source_len: Integer
    Body: {
        // Store source
        Lex.source = source
        Lex.source_len = source_len
        
        // Reset position
        Lex.pos = 0
        Lex.line = 1
        Lex.col = 1
        
        // Create token list
        Lex.tokens = XArray.XCreate(256)
        Lex.token_count = 0
        
        // Create token buffer
        Lex.tok_buf = Allocate(Lex.tok_buf_size)
        Lex.tok_buf_pos = 0
        
        // Clear errors
        Lex.error = 0
        Lex.error_line = 0
        Lex.error_col = 0
        Lex.error_msg = 0
        
        // Initialize keyword table
        Kw_Init()
        
        ReturnValue(1)
    }
}

// =============================================================================
// LEXER CLEANUP
// =============================================================================
Function.Lex_Free {
    Body: {
        // Free token buffer
        IfCondition NotEqual(Lex.tok_buf, 0) ThenBlock: {
            Deallocate(Lex.tok_buf, Lex.tok_buf_size)
            Lex.tok_buf = 0
        }
        
        // Free tokens (each token is an array)
        IfCondition NotEqual(Lex.tokens, 0) ThenBlock: {
            count = XArray.XSize(Lex.tokens)
            i = 0
            WhileLoop LessThan(i, count) {
                tok = XArray.XGet(Lex.tokens, i)
                IfCondition NotEqual(tok, 0) ThenBlock: {
                    ArrayDestroy(tok)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Lex.tokens)
            Lex.tokens = 0
        }
        
        Lex.token_count = 0
        
        // Free keyword table
        Kw_Free()
        
        ReturnValue(1)
    }
}

// =============================================================================
// CHARACTER ACCESS
// =============================================================================
Function.Lex_CurrentChar {
    Output: Integer
    Body: {
        IfCondition GreaterEqual(Lex.pos, Lex.source_len) ThenBlock: {
            ReturnValue(0)
        }
        c = GetByte(Lex.source, Lex.pos)
        ReturnValue(c)
    }
}

Function.Lex_PeekChar {
    Input: offset: Integer
    Output: Integer
    Body: {
        peek_pos = Add(Lex.pos, offset)
        IfCondition GreaterEqual(peek_pos, Lex.source_len) ThenBlock: {
            ReturnValue(0)
        }
        c = GetByte(Lex.source, peek_pos)
        ReturnValue(c)
    }
}

Function.Lex_Advance {
    Body: {
        IfCondition LessThan(Lex.pos, Lex.source_len) ThenBlock: {
            c = GetByte(Lex.source, Lex.pos)
            IfCondition EqualTo(c, ASCII.LF) ThenBlock: {
                Lex.line = Add(Lex.line, 1)
                Lex.col = 1
            } ElseBlock: {
                Lex.col = Add(Lex.col, 1)
            }
            Lex.pos = Add(Lex.pos, 1)
        }
    }
}

// =============================================================================
// CHARACTER CLASSIFICATION
// =============================================================================
Function.Lex_IsWhitespace {
    Input: c: Integer
    Output: Integer
    Body: {
        is_space = EqualTo(c, ASCII.SPACE)
        is_tab = EqualTo(c, ASCII.TAB)
        is_cr = EqualTo(c, ASCII.CR)
        
        result = Or(Or(is_space, is_tab), is_cr)
        ReturnValue(result)
    }
}

Function.Lex_IsDigit {
    Input: c: Integer
    Output: Integer
    Body: {
        result = And(GreaterEqual(c, ASCII.ZERO), LessEqual(c, ASCII.NINE))
        ReturnValue(result)
    }
}

Function.Lex_IsAlpha {
    Input: c: Integer
    Output: Integer
    Body: {
        is_upper = And(GreaterEqual(c, ASCII.A_UPPER), LessEqual(c, ASCII.Z_UPPER))
        is_lower = And(GreaterEqual(c, ASCII.A_LOWER), LessEqual(c, ASCII.Z_LOWER))
        is_underscore = EqualTo(c, ASCII.UNDERSCORE)
        
        result = Or(Or(is_upper, is_lower), is_underscore)
        ReturnValue(result)
    }
}

Function.Lex_IsAlphaNum {
    Input: c: Integer
    Output: Integer
    Body: {
        is_alpha = Lex_IsAlpha(c)
        is_digit = Lex_IsDigit(c)
        result = Or(is_alpha, is_digit)
        ReturnValue(result)
    }
}

Function.Lex_IsIdentifierStart {
    Input: c: Integer
    Output: Integer
    Body: {
        // Same as IsAlpha (letters and underscore can start identifiers)
        result = Lex_IsAlpha(c)
        ReturnValue(result)
    }
}

// =============================================================================
// WHITESPACE HANDLING
// =============================================================================
Function.Lex_SkipWhitespace {
    Body: {
        continue_skip = 1
        WhileLoop EqualTo(continue_skip, 1) {
            c = Lex_CurrentChar()
            IfCondition EqualTo(c, 0) ThenBlock: {
                continue_skip = 0
            } ElseBlock: {
                is_ws = Lex_IsWhitespace(c)
                IfCondition EqualTo(is_ws, 1) ThenBlock: {
                    Lex_Advance()
                } ElseBlock: {
                    continue_skip = 0
                }
            }
        }
    }
}

// =============================================================================
// TOKEN BUFFER OPERATIONS
// =============================================================================
Function.Lex_BufClear {
    Body: {
        Lex.tok_buf_pos = 0
        SetByte(Lex.tok_buf, 0, 0)
    }
}

Function.Lex_BufAppend {
    Input: c: Integer
    Body: {
        IfCondition LessThan(Lex.tok_buf_pos, Subtract(Lex.tok_buf_size, 1)) ThenBlock: {
            SetByte(Lex.tok_buf, Lex.tok_buf_pos, c)
            Lex.tok_buf_pos = Add(Lex.tok_buf_pos, 1)
            SetByte(Lex.tok_buf, Lex.tok_buf_pos, 0)
        }
    }
}

Function.Lex_BufGetString {
    Output: Address
    Body: {
        // Allocate and copy buffer contents
        len = Lex.tok_buf_pos
        result = Allocate(Add(len, 1))
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(Lex.tok_buf, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, len, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// TOKEN CREATION
// =============================================================================
Function.Lex_AddToken {
    Input: tok_type: Integer
    Input: tok_value: Address
    Input: tok_line: Integer
    Input: tok_col: Integer
    Input: tok_len: Integer
    Body: {
        // Create token record: [type, value, line, col, length]
        tok = ArrayCreate(5)
        ArraySet(tok, TokField.TYPE, tok_type)
        ArraySet(tok, TokField.VALUE, tok_value)
        ArraySet(tok, TokField.LINE, tok_line)
        ArraySet(tok, TokField.COL, tok_col)
        ArraySet(tok, TokField.LENGTH, tok_len)
        
        XArray.XPush(Lex.tokens, tok)
        Lex.token_count = Add(Lex.token_count, 1)
        
        ReturnValue(tok)
    }
}

Function.Lex_AddTokenSimple {
    Input: tok_type: Integer
    Input: tok_value: Address
    Body: {
        len = 1
        IfCondition NotEqual(tok_value, 0) ThenBlock: {
            len = StringLength(tok_value)
        }
        Lex_AddToken(tok_type, tok_value, Lex.line, Lex.col, len)
    }
}

// =============================================================================
// TOKEN ACCESS (for parser)
// =============================================================================
Function.Lex_GetToken {
    Input: index: Integer
    Output: Address
    Body: {
        IfCondition GreaterEqual(index, Lex.token_count) ThenBlock: {
            ReturnValue(0)
        }
        tok = XArray.XGet(Lex.tokens, index)
        ReturnValue(tok)
    }
}

Function.Lex_GetType {
    Input: index: Integer
    Output: Integer
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(Token.EOF)
        }
        t = ArrayGet(tok, TokField.TYPE)
        ReturnValue(t)
    }
}

Function.Lex_GetVal {
    Input: index: Integer
    Output: Address
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(0)
        }
        v = ArrayGet(tok, TokField.VALUE)
        ReturnValue(v)
    }
}

Function.Lex_GetLine {
    Input: index: Integer
    Output: Integer
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(0)
        }
        l = ArrayGet(tok, TokField.LINE)
        ReturnValue(l)
    }
}

Function.Lex_GetCol {
    Input: index: Integer
    Output: Integer
    Body: {
        tok = Lex_GetToken(index)
        IfCondition EqualTo(tok, 0) ThenBlock: {
            ReturnValue(0)
        }
        c = ArrayGet(tok, TokField.COL)
        ReturnValue(c)
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================
Function.Lex_Error {
    Input: msg: Address
    Body: {
        Lex.error = 1
        Lex.error_line = Lex.line
        Lex.error_col = Lex.col
        Lex.error_msg = msg
        
        PrintMessage("Lexer error at line ")
        PrintNumber(Lex.line)
        PrintMessage(", column ")
        PrintNumber(Lex.col)
        PrintMessage(": ")
        PrintString(msg)
        PrintMessage("\n")
    }
}

Function.Lex_Warning {
    Input: msg: Address
    Body: {
        PrintMessage("Lexer warning at line ")
        PrintNumber(Lex.line)
        PrintMessage(", column ")
        PrintNumber(Lex.col)
        PrintMessage(": ")
        PrintString(msg)
        PrintMessage("\n")
    }
}