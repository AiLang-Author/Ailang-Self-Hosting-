// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CLexerIdentifiers.ailang
// Identifier and keyword lexing for the AILang self-hosting compiler
// Handles: identifiers, dotted names (Module.Name), ~ suffix, keyword lookup

LibraryImport.Compiler.Frontend.Lexer.CLexerTypes
LibraryImport.Compiler.Frontend.Lexer.CLexerCore
LibraryImport.Compiler.Frontend.Lexer.CLexerKeywords

// =============================================================================
// READ SIMPLE IDENTIFIER
// Reads alphanumeric sequence (no dots)
// =============================================================================
Function.Lex_ReadIdentifier {
    Output: Address
    Body: {
        Lex_BufClear()
        
        // First char must be alpha or underscore (already checked by caller)
        c = Lex_CurrentChar()
        Lex_BufAppend(c)
        Lex_Advance()
        
        // Continue with alphanumeric
        continue_read = 1
        WhileLoop EqualTo(continue_read, 1) {
            c = Lex_CurrentChar()
            IfCondition EqualTo(c, 0) ThenBlock: {
                continue_read = 0
            } ElseBlock: {
                is_alnum = Lex_IsAlphaNum(c)
                IfCondition EqualTo(is_alnum, 1) ThenBlock: {
                    Lex_BufAppend(c)
                    Lex_Advance()
                } ElseBlock: {
                    continue_read = 0
                }
            }
        }
        
        result = Lex_BufGetString()
        ReturnValue(result)
    }
}

// =============================================================================
// READ DOTTED IDENTIFIER
// Handles Module.Submodule.Name patterns
// Input: first_part - the already-read first identifier part
// =============================================================================
Function.Lex_ReadDottedIdentifier {
    Input: first_part: Address
    Output: Address
    Body: {
        // Start building full dotted name
        Lex_BufClear()
        
        // Copy first part to buffer
        i = 0
        c = GetByte(first_part, i)
        WhileLoop NotEqual(c, 0) {
            Lex_BufAppend(c)
            i = Add(i, 1)
            c = GetByte(first_part, i)
        }
        
        // Continue reading .identifier sequences
        continue_dotted = 1
        WhileLoop EqualTo(continue_dotted, 1) {
            c = Lex_CurrentChar()
            
            // Check for dot followed by identifier start
            IfCondition EqualTo(c, ASCII.DOT) ThenBlock: {
                next = Lex_PeekChar(1)
                is_ident_start = Lex_IsIdentifierStart(next)
                
                IfCondition EqualTo(is_ident_start, 1) ThenBlock: {
                    // Append the dot
                    Lex_BufAppend(ASCII.DOT)
                    Lex_Advance()
                    
                    // Read and append next part
                    part_done = 0
                    WhileLoop EqualTo(part_done, 0) {
                        c = Lex_CurrentChar()
                        IfCondition EqualTo(c, 0) ThenBlock: {
                            part_done = 1
                        } ElseBlock: {
                            is_alnum = Lex_IsAlphaNum(c)
                            IfCondition EqualTo(is_alnum, 1) ThenBlock: {
                                Lex_BufAppend(c)
                                Lex_Advance()
                            } ElseBlock: {
                                part_done = 1
                            }
                        }
                    }
                } ElseBlock: {
                    // Dot not followed by identifier - stop
                    continue_dotted = 0
                }
            } ElseBlock: {
                // No dot - stop
                continue_dotted = 0
            }
        }
        
        result = Lex_BufGetString()
        ReturnValue(result)
    }
}

// =============================================================================
// CHECK AND APPEND TILDE SUFFIX
// Handles special identifiers like Name~
// Returns 1 if tilde was appended
// =============================================================================
Function.Lex_CheckTildeSuffix {
    Output: Integer
    Body: {
        c = Lex_CurrentChar()
        IfCondition EqualTo(c, ASCII.TILDE) ThenBlock: {
            Lex_BufAppend(c)
            Lex_Advance()
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// TOKENIZE IDENTIFIER
// Main entry point for identifier/keyword tokenization
// =============================================================================
Function.Lex_TokenizeIdentifier {
    Input: line_start: Integer
    Input: col_start: Integer
    Body: {
        // Read the basic identifier
        value = Lex_ReadIdentifier()
        
        // Check for ~ suffix (Phase 4 feature)
        c = Lex_CurrentChar()
        IfCondition EqualTo(c, ASCII.TILDE) ThenBlock: {
            // Reallocate with tilde
            old_len = StringLength(value)
            new_value = Allocate(Add(old_len, 2))
            
            i = 0
            WhileLoop LessThan(i, old_len) {
                ch = GetByte(value, i)
                SetByte(new_value, i, ch)
                i = Add(i, 1)
            }
            SetByte(new_value, old_len, ASCII.TILDE)
            SetByte(new_value, Add(old_len, 1), 0)
            
            Deallocate(value, 0)
            value = new_value
            Lex_Advance()
        }
        
        // Check if it's a keyword
        tok_type = Kw_Lookup(value)
        
        // If it's a keyword, emit it and stop - don't consume dots
        IfCondition NotEqual(tok_type, Token.IDENTIFIER) ThenBlock: {
            len = StringLength(value)
            Lex_AddToken(tok_type, value, line_start, col_start, len)
            ReturnValue(0)
        }
        
        // Not a keyword - check for dotted name (Module.Submodule.Name)
        c = Lex_CurrentChar()
        IfCondition EqualTo(c, ASCII.DOT) ThenBlock: {
            next = Lex_PeekChar(1)
            is_ident_start = Lex_IsIdentifierStart(next)
            
            IfCondition EqualTo(is_ident_start, 1) ThenBlock: {
                // Read full dotted name
                dotted = Lex_ReadDottedIdentifier(value)
                Deallocate(value, 0)
                value = dotted
            }
        }
        
        // Emit as identifier
        len = StringLength(value)
        Lex_AddToken(Token.IDENTIFIER, value, line_start, col_start, len)
    }
}

// =============================================================================
// CHECK IF CURRENT POSITION STARTS AN IDENTIFIER
// =============================================================================
Function.Lex_AtIdentifierStart {
    Output: Integer
    Body: {
        c = Lex_CurrentChar()
        result = Lex_IsIdentifierStart(c)
        ReturnValue(result)
    }
}