// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CLexerOperators.ailang
// Operator and delimiter lexing for the AILang self-hosting compiler
// Handles: two-char operators, single-char operators, delimiters

LibraryImport.Compiler.Frontend.Lexer.CLexerTypes
LibraryImport.Compiler.Frontend.Lexer.CLexerCore

// =============================================================================
// TWO-CHARACTER OPERATOR CHECK
// Returns token type if two-char op found, 0 otherwise
// =============================================================================
Function.Lex_CheckTwoCharOp {
    Input: c1: Integer
    Input: c2: Integer
    Output: Integer
    Body: {
        // -> (arrow)
        IfCondition And(EqualTo(c1, ASCII.DASH), EqualTo(c2, ASCII.GREATER)) ThenBlock: {
            ReturnValue(Token.ARROW)
        }
        
        // == (equal to)
        IfCondition And(EqualTo(c1, ASCII.EQUALS_SIGN), EqualTo(c2, ASCII.EQUALS_SIGN)) ThenBlock: {
            ReturnValue(Token.EQUALTO)
        }
        
        // != (not equal)
        IfCondition And(EqualTo(c1, ASCII.BANG), EqualTo(c2, ASCII.EQUALS_SIGN)) ThenBlock: {
            ReturnValue(Token.NOTEQUAL)
        }
        
        // >= (greater equal)
        IfCondition And(EqualTo(c1, ASCII.GREATER), EqualTo(c2, ASCII.EQUALS_SIGN)) ThenBlock: {
            ReturnValue(Token.GREATEREQUAL)
        }
        
        // <= (less equal)
        IfCondition And(EqualTo(c1, ASCII.LESS), EqualTo(c2, ASCII.EQUALS_SIGN)) ThenBlock: {
            ReturnValue(Token.LESSEQUAL)
        }
        
        // && (logical and)
        IfCondition And(EqualTo(c1, ASCII.AMPERSAND), EqualTo(c2, ASCII.AMPERSAND)) ThenBlock: {
            ReturnValue(Token.AND_AND)
        }
        
        // || (logical or)
        IfCondition And(EqualTo(c1, ASCII.PIPE), EqualTo(c2, ASCII.PIPE)) ThenBlock: {
            ReturnValue(Token.PIPE_PIPE)
        }
        
        // << (left shift)
        IfCondition And(EqualTo(c1, ASCII.LESS), EqualTo(c2, ASCII.LESS)) ThenBlock: {
            ReturnValue(Token.LESS_LESS)
        }
        
        // >> (right shift)
        IfCondition And(EqualTo(c1, ASCII.GREATER), EqualTo(c2, ASCII.GREATER)) ThenBlock: {
            ReturnValue(Token.GREATER_GREATER)
        }
        
        // Not a two-char operator
        ReturnValue(0)
    }
}

// =============================================================================
// SINGLE-CHARACTER TOKEN CHECK
// Returns token type for single char, 0 if not recognized
// =============================================================================
Function.Lex_CheckSingleCharToken {
    Input: c: Integer
    Output: Integer
    Body: {
        // Delimiters
        IfCondition EqualTo(c, ASCII.LBRACE) ThenBlock: {
            ReturnValue(Token.LBRACE)
        }
        IfCondition EqualTo(c, ASCII.RBRACE) ThenBlock: {
            ReturnValue(Token.RBRACE)
        }
        IfCondition EqualTo(c, ASCII.LPAREN) ThenBlock: {
            ReturnValue(Token.LPAREN)
        }
        IfCondition EqualTo(c, ASCII.RPAREN) ThenBlock: {
            ReturnValue(Token.RPAREN)
        }
        IfCondition EqualTo(c, ASCII.LBRACKET) ThenBlock: {
            ReturnValue(Token.LBRACKET)
        }
        IfCondition EqualTo(c, ASCII.RBRACKET) ThenBlock: {
            ReturnValue(Token.RBRACKET)
        }
        IfCondition EqualTo(c, ASCII.COMMA) ThenBlock: {
            ReturnValue(Token.COMMA)
        }
        IfCondition EqualTo(c, ASCII.COLON) ThenBlock: {
            ReturnValue(Token.COLON)
        }
        IfCondition EqualTo(c, ASCII.SEMICOLON) ThenBlock: {
            ReturnValue(Token.SEMICOLON)
        }
        IfCondition EqualTo(c, ASCII.DOT) ThenBlock: {
            ReturnValue(Token.DOT)
        }
        IfCondition EqualTo(c, ASCII.DASH) ThenBlock: {
            ReturnValue(Token.DASH)
        }
        IfCondition EqualTo(c, ASCII.EQUALS_SIGN) ThenBlock: {
            ReturnValue(Token.EQUALS)
        }
        
        // Math symbols (with _SIGN suffix)
        IfCondition EqualTo(c, ASCII.PLUS) ThenBlock: {
            ReturnValue(Token.PLUS_SIGN)
        }
        IfCondition EqualTo(c, ASCII.STAR) ThenBlock: {
            ReturnValue(Token.STAR_SIGN)
        }
        IfCondition EqualTo(c, ASCII.SLASH) ThenBlock: {
            ReturnValue(Token.SLASH_SIGN)
        }
        IfCondition EqualTo(c, ASCII.PERCENT) ThenBlock: {
            ReturnValue(Token.PERCENT_SIGN)
        }
        IfCondition EqualTo(c, ASCII.CARET) ThenBlock: {
            ReturnValue(Token.CARET_SIGN)
        }
        
        // Comparison symbols
        IfCondition EqualTo(c, ASCII.GREATER) ThenBlock: {
            ReturnValue(Token.GREATER_SIGN)
        }
        IfCondition EqualTo(c, ASCII.LESS) ThenBlock: {
            ReturnValue(Token.LESS_SIGN)
        }
        
        // Logical/bitwise symbols
        IfCondition EqualTo(c, ASCII.BANG) ThenBlock: {
            ReturnValue(Token.BANG_SIGN)
        }
        IfCondition EqualTo(c, ASCII.AMPERSAND) ThenBlock: {
            ReturnValue(Token.AMPERSAND_SIGN)
        }
        IfCondition EqualTo(c, ASCII.PIPE) ThenBlock: {
            ReturnValue(Token.PIPE_SIGN)
        }
        IfCondition EqualTo(c, ASCII.TILDE) ThenBlock: {
            ReturnValue(Token.TILDE_SIGN)
        }
        
        // Not recognized
        ReturnValue(0)
    }
}

// =============================================================================
// TOKENIZE TWO-CHARACTER OPERATOR
// Checks for two-char op and creates token if found
// Returns 1 if handled, 0 if not
// =============================================================================
Function.Lex_TokenizeTwoCharOp {
    Input: line_start: Integer
    Input: col_start: Integer
    Output: Integer
    Body: {
        c1 = Lex_CurrentChar()
        c2 = Lex_PeekChar(1)
        
        tok_type = Lex_CheckTwoCharOp(c1, c2)
        
        IfCondition NotEqual(tok_type, 0) ThenBlock: {
            // Get appropriate value string for the operator
            value = Lex_GetTwoCharOpValue(tok_type)
            
            // Advance past both characters
            Lex_Advance()
            Lex_Advance()
            
            // Add token
            Lex_AddToken(tok_type, value, line_start, col_start, 2)
            
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// GET VALUE STRING FOR TWO-CHAR OPERATORS
// Returns the semantic value (e.g., "EqualTo" for ==)
// =============================================================================
Function.Lex_GetTwoCharOpValue {
    Input: tok_type: Integer
    Output: Address
    Body: {
        // Arrow -> just uses symbol
        IfCondition EqualTo(tok_type, Token.ARROW) ThenBlock: {
            result = Allocate(3)
            SetByte(result, 0, ASCII.DASH)
            SetByte(result, 1, ASCII.GREATER)
            SetByte(result, 2, 0)
            ReturnValue(result)
        }
        
        // == -> "EqualTo"
        IfCondition EqualTo(tok_type, Token.EQUALTO) ThenBlock: {
            result = Allocate(8)
            SetByte(result, 0, 69)   // E
            SetByte(result, 1, 113)  // q
            SetByte(result, 2, 117)  // u
            SetByte(result, 3, 97)   // a
            SetByte(result, 4, 108)  // l
            SetByte(result, 5, 84)   // T
            SetByte(result, 6, 111)  // o
            SetByte(result, 7, 0)
            ReturnValue(result)
        }
        
        // != -> "NotEqual"
        IfCondition EqualTo(tok_type, Token.NOTEQUAL) ThenBlock: {
            result = Allocate(9)
            SetByte(result, 0, 78)   // N
            SetByte(result, 1, 111)  // o
            SetByte(result, 2, 116)  // t
            SetByte(result, 3, 69)   // E
            SetByte(result, 4, 113)  // q
            SetByte(result, 5, 117)  // u
            SetByte(result, 6, 97)   // a
            SetByte(result, 7, 108)  // l
            SetByte(result, 8, 0)
            ReturnValue(result)
        }
        
        // >= -> "GreaterEqual"
        IfCondition EqualTo(tok_type, Token.GREATEREQUAL) ThenBlock: {
            result = Allocate(13)
            SetByte(result, 0, 71)   // G
            SetByte(result, 1, 114)  // r
            SetByte(result, 2, 101)  // e
            SetByte(result, 3, 97)   // a
            SetByte(result, 4, 116)  // t
            SetByte(result, 5, 101)  // e
            SetByte(result, 6, 114)  // r
            SetByte(result, 7, 69)   // E
            SetByte(result, 8, 113)  // q
            SetByte(result, 9, 117)  // u
            SetByte(result, 10, 97)  // a
            SetByte(result, 11, 108) // l
            SetByte(result, 12, 0)
            ReturnValue(result)
        }
        
        // <= -> "LessEqual"
        IfCondition EqualTo(tok_type, Token.LESSEQUAL) ThenBlock: {
            result = Allocate(10)
            SetByte(result, 0, 76)   // L
            SetByte(result, 1, 101)  // e
            SetByte(result, 2, 115)  // s
            SetByte(result, 3, 115)  // s
            SetByte(result, 4, 69)   // E
            SetByte(result, 5, 113)  // q
            SetByte(result, 6, 117)  // u
            SetByte(result, 7, 97)   // a
            SetByte(result, 8, 108)  // l
            SetByte(result, 9, 0)
            ReturnValue(result)
        }
        
        // && -> "And"
        IfCondition EqualTo(tok_type, Token.AND_AND) ThenBlock: {
            result = Allocate(4)
            SetByte(result, 0, 65)   // A
            SetByte(result, 1, 110)  // n
            SetByte(result, 2, 100)  // d
            SetByte(result, 3, 0)
            ReturnValue(result)
        }
        
        // || -> "Or"
        IfCondition EqualTo(tok_type, Token.PIPE_PIPE) ThenBlock: {
            result = Allocate(3)
            SetByte(result, 0, 79)   // O
            SetByte(result, 1, 114)  // r
            SetByte(result, 2, 0)
            ReturnValue(result)
        }
        
        // << -> "LeftShift"
        IfCondition EqualTo(tok_type, Token.LESS_LESS) ThenBlock: {
            result = Allocate(10)
            SetByte(result, 0, 76)   // L
            SetByte(result, 1, 101)  // e
            SetByte(result, 2, 102)  // f
            SetByte(result, 3, 116)  // t
            SetByte(result, 4, 83)   // S
            SetByte(result, 5, 104)  // h
            SetByte(result, 6, 105)  // i
            SetByte(result, 7, 102)  // f
            SetByte(result, 8, 116)  // t
            SetByte(result, 9, 0)
            ReturnValue(result)
        }
        
        // >> -> "RightShift"
        IfCondition EqualTo(tok_type, Token.GREATER_GREATER) ThenBlock: {
            result = Allocate(11)
            SetByte(result, 0, 82)   // R
            SetByte(result, 1, 105)  // i
            SetByte(result, 2, 103)  // g
            SetByte(result, 3, 104)  // h
            SetByte(result, 4, 116)  // t
            SetByte(result, 5, 83)   // S
            SetByte(result, 6, 104)  // h
            SetByte(result, 7, 105)  // i
            SetByte(result, 8, 102)  // f
            SetByte(result, 9, 116)  // t
            SetByte(result, 10, 0)
            ReturnValue(result)
        }
        
        // Default: return null
        ReturnValue(0)
    }
}

// =============================================================================
// TOKENIZE SINGLE-CHARACTER TOKEN
// Creates token for single char operators/delimiters
// Returns 1 if handled, 0 if not
// =============================================================================
Function.Lex_TokenizeSingleCharToken {
    Input: line_start: Integer
    Input: col_start: Integer
    Output: Integer
    Body: {
        c = Lex_CurrentChar()
        
        // REMOVED: Special case for dot - now always tokenize as DOT
        
        tok_type = Lex_CheckSingleCharToken(c)
        
        IfCondition NotEqual(tok_type, 0) ThenBlock: {
            // Create value string (single character)
            value = Allocate(2)
            SetByte(value, 0, c)
            SetByte(value, 1, 0)
            
            Lex_Advance()
            
            Lex_AddToken(tok_type, value, line_start, col_start, 1)
            
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// TOKENIZE OPERATOR (Main Entry Point)
// Tries two-char first, then single-char
// Returns 1 if handled, 0 if not
// =============================================================================
Function.Lex_TokenizeOperator {
    Input: line_start: Integer
    Input: col_start: Integer
    Output: Integer
    Body: {
        // Try two-character operators first
        handled = Lex_TokenizeTwoCharOp(line_start, col_start)
        IfCondition EqualTo(handled, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Try single-character tokens
        handled = Lex_TokenizeSingleCharToken(line_start, col_start)
        ReturnValue(handled)
    }
}