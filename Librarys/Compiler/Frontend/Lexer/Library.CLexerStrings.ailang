// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CLexerStrings.ailang
// String and comment lexing for the AILang self-hosting compiler
// Mirrors string reading from lexer_class.py

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.Lexer.CLexerTypes
LibraryImport.Compiler.Frontend.Lexer.CLexerCore

// =============================================================================
// STRING LEXING
// Handles: "string literals" with escape sequences
// =============================================================================
Function.Lex_ReadString {
    Output: Address
    Body: {
        Lex_BufClear()
        
        // Skip opening quote
        Lex_Advance()
        
        reading = 1
        WhileLoop EqualTo(reading, 1) {
            c = Lex_CurrentChar()
            
            // End of file
            IfCondition EqualTo(c, 0) ThenBlock: {
                Lex_Error("Unterminated string literal")
                reading = 0
                ContinueLoop
            }
            
            // Closing quote
            IfCondition EqualTo(c, ASCII.DQUOTE) ThenBlock: {
                Lex_Advance()
                reading = 0
                ContinueLoop
            }
            
            // Escape sequence
            IfCondition EqualTo(c, ASCII.BACKSLASH) ThenBlock: {
                Lex_Advance()
                escaped = Lex_CurrentChar()
                
                IfCondition EqualTo(escaped, 0) ThenBlock: {
                    Lex_Error("Unterminated escape sequence")
                    reading = 0
                    ContinueLoop
                }
                
                // Handle escape codes
                IfCondition EqualTo(escaped, 110) ThenBlock: {
                    // 'n' -> newline
                    Lex_BufAppend(ASCII.LF)
                } ElseBlock: {
                    IfCondition EqualTo(escaped, 116) ThenBlock: {
                        // 't' -> tab
                        Lex_BufAppend(ASCII.TAB)
                    } ElseBlock: {
                        IfCondition EqualTo(escaped, 114) ThenBlock: {
                            // 'r' -> carriage return
                            Lex_BufAppend(ASCII.CR)
                        } ElseBlock: {
                            IfCondition EqualTo(escaped, ASCII.BACKSLASH) ThenBlock: {
                                // '\\' -> backslash
                                Lex_BufAppend(ASCII.BACKSLASH)
                            } ElseBlock: {
                                IfCondition EqualTo(escaped, ASCII.DQUOTE) ThenBlock: {
                                    // '\"' -> quote
                                    Lex_BufAppend(ASCII.DQUOTE)
                                } ElseBlock: {
                                    IfCondition EqualTo(escaped, 48) ThenBlock: {
                                        // '\0' -> null
                                        Lex_BufAppend(0)
                                    } ElseBlock: {
                                        // Unknown escape, keep as-is
                                        Lex_BufAppend(ASCII.BACKSLASH)
                                        Lex_BufAppend(escaped)
                                    }
                                }
                            }
                        }
                    }
                }
                
                Lex_Advance()
                ContinueLoop
            }
            
            // Newline in string (without escape) is error
            IfCondition EqualTo(c, ASCII.LF) ThenBlock: {
                Lex_Error("Newline in string literal")
                reading = 0
                ContinueLoop
            }
            
            // Regular character
            Lex_BufAppend(c)
            Lex_Advance()
        }
        
        result = Lex_BufGetString()
        ReturnValue(result)
    }
}

// =============================================================================
// COMMENT LEXING
// Handles: // line comments, //DOC: doc comments, //COM: com comments
// =============================================================================
Function.Lex_ReadComment {
    Output: Integer
    Body: {
        // Skip the two slashes
        Lex_Advance()
        Lex_Advance()
        
        // Clear buffer for comment content
        Lex_BufClear()
        
        // Read until newline or EOF - accept ANY character
        done = 0
        WhileLoop EqualTo(done, 0) {
            c = Lex_CurrentChar()
            
            // EOF - done
            IfCondition EqualTo(c, 0) ThenBlock: {
                done = 1
                ContinueLoop
            }
            
            // Newline (LF=10) - done but don't consume
            IfCondition EqualTo(c, 10) ThenBlock: {
                done = 1
                ContinueLoop
            }
            
            // Carriage return (CR=13) - done but don't consume
            IfCondition EqualTo(c, 13) ThenBlock: {
                done = 1
                ContinueLoop
            }
            
            // Any other character - add to buffer and continue
            Lex_BufAppend(c)
            Lex_Advance()
        }
        
        // Always return regular COMMENT type for now
        // DOC/COM/TAG detection can be added later
        ReturnValue(Token.COMMENT)
    }
}

// =============================================================================
// TOKENIZE COMMENT
// Creates COMMENT token from current position
// =============================================================================
Function.Lex_TokenizeComment {
    Input: line_start: Integer
    Input: col_start: Integer
    Body: {
        comment_type = Lex_ReadComment()
        value = Lex_BufGetString()
        len = StringLength(value)
        
        Lex_AddToken(comment_type, value, line_start, col_start, Add(len, 2))
    }
}
// =============================================================================
// TOKENIZE STRING
// Creates STRING token from current position
// =============================================================================
Function.Lex_TokenizeString {
    Input: line_start: Integer
    Input: col_start: Integer
    Body: {
        value = Lex_ReadString()
        
        IfCondition EqualTo(Lex.error, 0) ThenBlock: {
            len = StringLength(value)
            // Length includes quotes
            Lex_AddToken(Token.STRING, value, line_start, col_start, Add(len, 2))
        }
    }
}

