// Library.CParserCore.ailang
// Core parser functions: initialization, token navigation, error handling
// Foundation for all other parser modules

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.CTypes
LibraryImport.Compiler.Frontend.Lexer.CLexerCore


// =============================================================================
// PARSER INITIALIZATION
// =============================================================================
Function.Parse_Init {
    Input: token_count: Integer
    Body: {
        Parser.pos = 0
        Parser.token_count = token_count
        Parser.error = 0
        Parser.error_msg = 0
        Parser.error_line = 0
        Parser.error_col = 0
        Parser.ast_root = 0
        Parser.node_count = 0
        Parser.context_depth = 0
        
        // Create context stack for error messages
        Parser.context_stack = XArray.XCreate(NodeConfig.MAX_CONTEXT_DEPTH)
        
        // Cache first token
        IfCondition GreaterThan(token_count, 0) ThenBlock: {
            Parse_UpdateCurrent()
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// PARSER CLEANUP
// =============================================================================
Function.Parse_Free {
    Body: {
        IfCondition NotEqual(Parser.context_stack, 0) ThenBlock: {
            XArray.XDestroy(Parser.context_stack)
            Parser.context_stack = 0
        }
        Parser.context_depth = 0
    }
}

// =============================================================================
// TOKEN CACHE UPDATE
// Refreshes current token info from lexer token stream
// =============================================================================
Function.Parse_UpdateCurrent {
    Body: {
        IfCondition GreaterEqual(Parser.pos, Parser.token_count) ThenBlock: {
            Parser.current_type = Token.EOF
            Parser.current_value = 0
            Parser.current_line = 0
            Parser.current_col = 0
            ReturnValue(0)
        }
        
        Parser.current_type = Lex_GetType(Parser.pos)
        Parser.current_value = Lex_GetVal(Parser.pos)
        Parser.current_line = Lex_GetLine(Parser.pos)
        Parser.current_col = Lex_GetCol(Parser.pos)
        
        ReturnValue(1)
    }
}

// =============================================================================
// TOKEN NAVIGATION
// =============================================================================

// Get current token type
Function.Parse_CurrentType {
    Output: Integer
    Body: {
        ReturnValue(Parser.current_type)
    }
}

// Get current token value
Function.Parse_CurrentValue {
    Output: Address
    Body: {
        ReturnValue(Parser.current_value)
    }
}

// Get current token line
Function.Parse_CurrentLine {
    Output: Integer
    Body: {
        ReturnValue(Parser.current_line)
    }
}

// Get current token column
Function.Parse_CurrentCol {
    Output: Integer
    Body: {
        ReturnValue(Parser.current_col)
    }
}

// Advance to next token
Function.Parse_Advance {
    Body: {
        IfCondition LessThan(Parser.pos, Parser.token_count) ThenBlock: {
            Parser.pos = Add(Parser.pos, 1)
            Parse_UpdateCurrent()
        }
    }
}

// Peek at token type at offset from current
Function.Parse_Peek {
    Input: offset: Integer
    Output: Integer
    Body: {
        peek_pos = Add(Parser.pos, offset)
        IfCondition GreaterEqual(peek_pos, Parser.token_count) ThenBlock: {
            ReturnValue(Token.EOF)
        }
        tok_type = Lex_GetType(peek_pos)
        ReturnValue(tok_type)
    }
}

// Peek at token value at offset from current
Function.Parse_PeekValue {
    Input: offset: Integer
    Output: Address
    Body: {
        peek_pos = Add(Parser.pos, offset)
        IfCondition GreaterEqual(peek_pos, Parser.token_count) ThenBlock: {
            ReturnValue(0)
        }
        tok_val = Lex_GetVal(peek_pos)
        ReturnValue(tok_val)
    }
}

// Peek at token line at offset
Function.Parse_PeekLine {
    Input: offset: Integer
    Output: Integer
    Body: {
        peek_pos = Add(Parser.pos, offset)
        IfCondition GreaterEqual(peek_pos, Parser.token_count) ThenBlock: {
            ReturnValue(0)
        }
        tok_line = Lex_GetLine(peek_pos)
        ReturnValue(tok_line)
    }
}

// =============================================================================
// TOKEN MATCHING
// =============================================================================

// Check if current token matches type (doesn't consume)
Function.Parse_Check {
    Input: token_type: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(Parser.current_type, token_type) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Check if current token matches type and advance if so
Function.Parse_Match {
    Input: token_type: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(Parser.current_type, token_type) ThenBlock: {
            Parse_Advance()
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Consume expected token or error
Function.Parse_Consume {
    Input: token_type: Integer
    Input: error_msg: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(Parser.current_type, token_type) ThenBlock: {
            Parse_Advance()
            ReturnValue(1)
        }
        
        // Build error message with expected vs got
        Parse_Error(error_msg)
        ReturnValue(0)
    }
}

// Consume and return the value (for identifiers, strings, numbers)
Function.Parse_ConsumeValue {
    Input: token_type: Integer
    Input: error_msg: Address
    Output: Address
    Body: {
        IfCondition EqualTo(Parser.current_type, token_type) ThenBlock: {
            value = Parser.current_value
            Parse_Advance()
            ReturnValue(value)
        }
        
        Parse_Error(error_msg)
        ReturnValue(0)
    }
}

// =============================================================================
// NEWLINE HANDLING
// =============================================================================

// Skip any newline tokens
Function.Parse_SkipNewlines {
    Body: {
        WhileLoop EqualTo(Parser.current_type, Token.NEWLINE) {
            Parse_Advance()
        }
    }
}

// Skip newlines and comments
Function.Parse_SkipWhitespace {
    Body: {
        done = 0
        WhileLoop EqualTo(done, 0) {
            IfCondition EqualTo(Parser.current_type, Token.NEWLINE) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(Parser.current_type, Token.COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(Parser.current_type, Token.DOC_COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(Parser.current_type, Token.COM_COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(Parser.current_type, Token.TAG_COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            done = 1
        }
    }
}

// =============================================================================
// CONTEXT STACK (for error messages)
// =============================================================================

// Push a context onto the stack (e.g., "Function.Main", "WhileLoop")
Function.Parse_PushContext {
    Input: context: Address
    Body: {
        IfCondition LessThan(Parser.context_depth, NodeConfig.MAX_CONTEXT_DEPTH) ThenBlock: {
            XArray.XSet(Parser.context_stack, Parser.context_depth, context)
            Parser.context_depth = Add(Parser.context_depth, 1)
        }
    }
}

// Pop context from stack
Function.Parse_PopContext {
    Body: {
        IfCondition GreaterThan(Parser.context_depth, 0) ThenBlock: {
            Parser.context_depth = Subtract(Parser.context_depth, 1)
        }
    }
}

// Get current context string for error messages
Function.Parse_GetContext {
    Output: Address
    Body: {
        IfCondition EqualTo(Parser.context_depth, 0) ThenBlock: {
            ReturnValue("top level")
        }
        
        // Return the most recent context
        idx = Subtract(Parser.context_depth, 1)
        ctx = XArray.XGet(Parser.context_stack, idx)
        ReturnValue(ctx)
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================

// Report error at current position
Function.Parse_Error {
    Input: msg: Address
    Body: {
        // Only record first error
        IfCondition EqualTo(Parser.error, 0) ThenBlock: {
            Parser.error = 1
            Parser.error_msg = msg
            Parser.error_line = Parser.current_line
            Parser.error_col = Parser.current_col
        }
        
        // Print error immediately for debugging
        PrintMessage("PARSE ERROR at line ")
        PrintNumber(Parser.current_line)
        PrintMessage(", col ")
        PrintNumber(Parser.current_col)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
        
        // Show context
        ctx = Parse_GetContext()
        PrintMessage("  In: ")
        PrintMessage(ctx)
        PrintMessage("\n")
        
        // Show current token
        PrintMessage("  Got token type: ")
        PrintNumber(Parser.current_type)
        IfCondition NotEqual(Parser.current_value, 0) ThenBlock: {
            PrintMessage(" value: \"")
            PrintMessage(Parser.current_value)
            PrintMessage("\"")
        }
        PrintMessage("\n")
    }
}

// Report error at specific position
Function.Parse_ErrorAt {
    Input: msg: Address
    Input: line: Integer
    Input: col: Integer
    Body: {
        IfCondition EqualTo(Parser.error, 0) ThenBlock: {
            Parser.error = 1
            Parser.error_msg = msg
            Parser.error_line = line
            Parser.error_col = col
        }
        
        PrintMessage("PARSE ERROR at line ")
        PrintNumber(line)
        PrintMessage(", col ")
        PrintNumber(col)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

// Check if parser is in error state
Function.Parse_HasError {
    Output: Integer
    Body: {
        ReturnValue(Parser.error)
    }
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Check if at end of tokens
Function.Parse_AtEnd {
    Output: Integer
    Body: {
        IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition GreaterEqual(Parser.pos, Parser.token_count) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Check if current token is a statement terminator
Function.Parse_AtStatementEnd {
    Output: Integer
    Body: {
        IfCondition EqualTo(Parser.current_type, Token.NEWLINE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(Parser.current_type, Token.RBRACE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Check if current token starts an expression
Function.Parse_AtExpressionStart {
    Output: Integer
    Body: {
        // Identifiers
        IfCondition EqualTo(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            ReturnValue(1)
        }
        // Literals
        IfCondition EqualTo(Parser.current_type, Token.NUMBER) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(Parser.current_type, Token.STRING) ThenBlock: {
            ReturnValue(1)
        }
        // Parenthesized expression
        IfCondition EqualTo(Parser.current_type, Token.LPAREN) ThenBlock: {
            ReturnValue(1)
        }
        // Keywords that are expressions (True, False, Null)
        IfCondition EqualTo(Parser.current_type, Token.TRUE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(Parser.current_type, Token.FALSE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(Parser.current_type, Token.NULL) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// Check if current token is a keyword that starts a statement
Function.Parse_AtStatementStart {
    Output: Integer
    Body: {
        t = Parser.current_type
        
        // Control flow
        IfCondition EqualTo(t, Token.IFCONDITION) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, Token.WHILELOOP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, Token.RETURNVALUE) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, Token.BREAKLOOP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, Token.CONTINUELOOP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, Token.TRYBLOCK) ThenBlock: { ReturnValue(1) }
        
        // I/O
        IfCondition EqualTo(t, Token.PRINTMESSAGE) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, Token.PRINTNUMBER) ThenBlock: { ReturnValue(1) }
        
        // Task/concurrency
        IfCondition EqualTo(t, Token.RUNTASK) ThenBlock: { ReturnValue(1) }
        
        // Debug
        IfCondition EqualTo(t, Token.DEBUGASSERT) ThenBlock: { ReturnValue(1) }
        
        // Identifiers (assignments, function calls)
        IfCondition EqualTo(t, Token.IDENTIFIER) ThenBlock: { ReturnValue(1) }
        
        ReturnValue(0)
    }
}

// =============================================================================
// TOKEN TYPE NAME (for debugging)
// =============================================================================
Function.Parse_TokenTypeName {
    Input: tok_type: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(tok_type, Token.EOF) ThenBlock: { ReturnValue("EOF") }
        IfCondition EqualTo(tok_type, Token.NEWLINE) ThenBlock: { ReturnValue("NEWLINE") }
        IfCondition EqualTo(tok_type, Token.IDENTIFIER) ThenBlock: { ReturnValue("IDENTIFIER") }
        IfCondition EqualTo(tok_type, Token.NUMBER) ThenBlock: { ReturnValue("NUMBER") }
        IfCondition EqualTo(tok_type, Token.STRING) ThenBlock: { ReturnValue("STRING") }
        IfCondition EqualTo(tok_type, Token.LBRACE) ThenBlock: { ReturnValue("LBRACE") }
        IfCondition EqualTo(tok_type, Token.RBRACE) ThenBlock: { ReturnValue("RBRACE") }
        IfCondition EqualTo(tok_type, Token.LPAREN) ThenBlock: { ReturnValue("LPAREN") }
        IfCondition EqualTo(tok_type, Token.RPAREN) ThenBlock: { ReturnValue("RPAREN") }
        IfCondition EqualTo(tok_type, Token.COMMA) ThenBlock: { ReturnValue("COMMA") }
        IfCondition EqualTo(tok_type, Token.COLON) ThenBlock: { ReturnValue("COLON") }
        IfCondition EqualTo(tok_type, Token.EQUALS) ThenBlock: { ReturnValue("EQUALS") }
        IfCondition EqualTo(tok_type, Token.DOT) ThenBlock: { ReturnValue("DOT") }
        
        // Return generic for unknown
        ReturnValue("TOKEN")
    }
}