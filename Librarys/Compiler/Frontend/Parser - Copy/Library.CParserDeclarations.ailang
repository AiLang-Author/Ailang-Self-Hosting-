// Library.CParserDeclarations.ailang
// Top-level declaration parsing for the AILang self-hosting compiler
// Handles: Function, SubRoutine, Pools, LibraryImport, Loop types

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.CTypes

LibraryImport.Compiler.Frontend.Parser.CParserCore
LibraryImport.Compiler.Frontend.Parser.CParserUtils
LibraryImport.Compiler.Frontend.Parser.CParserExpressions
LibraryImport.Compiler.Frontend.Parser.CParserStatements

// =============================================================================
// MAIN DECLARATION DISPATCHER
// =============================================================================

// Parse a top-level declaration
Function.Parse_Declaration {
    Output: Address
    Body: {
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        t = Parser.current_type
        
        // End of file
        IfCondition EqualTo(t, Token.EOF) ThenBlock: {
            ReturnValue(0)
        }
        
        // Skip comments at top level
        IfCondition Or(EqualTo(t, Token.COMMENT), EqualTo(t, Token.DOC_COMMENT)) ThenBlock: {
            Parse_Advance()
            ReturnValue(0)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Library Import
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.LIBRARYIMPORT) ThenBlock: {
            ReturnValue(Parse_LibraryImport())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Function Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.FUNCTION) ThenBlock: {
            ReturnValue(Parse_Function())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // SubRoutine Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.SUBROUTINE) ThenBlock: {
            ReturnValue(Parse_SubRoutine())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Pool Declarations (all types)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.FIXEDPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_FIXED))
        }
        IfCondition EqualTo(t, Token.DYNAMICPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_DYNAMIC))
        }
        IfCondition EqualTo(t, Token.TEMPORALPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_TEMPORAL))
        }
        IfCondition EqualTo(t, Token.NEURALPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_NEURAL))
        }
        IfCondition EqualTo(t, Token.KERNELPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_KERNEL))
        }
        IfCondition EqualTo(t, Token.ACTORPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_ACTOR))
        }
        IfCondition EqualTo(t, Token.SECURITYPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_SECURITY))
        }
        IfCondition EqualTo(t, Token.CONSTRAINEDPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_CONSTRAINED))
        }
        IfCondition EqualTo(t, Token.FILEPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_FILE))
        }
        IfCondition EqualTo(t, Token.LINKAGEPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(ASTNode.POOL_LINKAGE))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Loop Declarations (Actor system)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.LOOPMAIN) ThenBlock: {
            ReturnValue(Parse_Loop(ASTNode.LOOP_MAIN))
        }
        IfCondition EqualTo(t, Token.LOOPACTOR) ThenBlock: {
            ReturnValue(Parse_Loop(ASTNode.LOOP_ACTOR))
        }
        IfCondition EqualTo(t, Token.LOOPSTART) ThenBlock: {
            ReturnValue(Parse_Loop(ASTNode.LOOP_START))
        }
        IfCondition EqualTo(t, Token.LOOPSHADOW) ThenBlock: {
            ReturnValue(Parse_Loop(ASTNode.LOOP_SHADOW))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Macro Definitions
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.MACROBLOCK) ThenBlock: {
            ReturnValue(Parse_MacroBlock())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Identifier - could be dotted declaration or top-level assignment
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.IDENTIFIER) ThenBlock: {
            // Check if it's a dotted declaration like "Function.Name"
            // The lexer may have combined these
            ReturnValue(Parse_IdentifierDeclaration())
        }
        
        // Unknown top-level construct
        Parse_Error("Expected declaration (Function, SubRoutine, Pool, or LibraryImport)")
        Parse_Advance()
        ReturnValue(0)
    }
}

// =============================================================================
// LIBRARY IMPORT
// =============================================================================

// Parse: LibraryImport.Path.To.Module
Function.Parse_LibraryImport {
    Output: Address
    Body: {
        Parse_Consume(Token.LIBRARYIMPORT, "Expected 'LibraryImport'")
        Parse_Consume(Token.DOT, "Expected '.' after LibraryImport")
        
        // Read the import path (may be dotted)
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            Parse_Error("Expected module path after LibraryImport.")
            ReturnValue(0)
        }
        
        // The lexer may have combined the entire path already
        path = Parser.current_value
        Parse_Advance()
        
        node = AST_CreateNode(ASTNode.LIBRARY_IMPORT)
        AST_SetData1(node, path)
        
        ReturnValue(node)
    }
}

// =============================================================================
// FUNCTION DECLARATION
// =============================================================================

// Parse: Function.Name { Input: ..., Output: ..., Body: { ... } }
Function.Parse_Function {
    Output: Address
    Body: {
        Parse_Consume(Token.FUNCTION, "Expected 'Function'")
        Parse_Consume(Token.DOT, "Expected '.' after Function")
        
        // Get function name (may be dotted like Module.FuncName)
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            Parse_Error("Expected function name")
            ReturnValue(0)
        }
        func_name = Parser.current_value
        Parse_Advance()
        
        Parse_PushContext(func_name)
        Parse_SkipNewlines()
        Parse_Consume(Token.LBRACE, "Expected '{' after function name")
        Parse_SkipNewlines()
        
        // Create function node
        node = AST_CreateNode(ASTNode.FUNCTION)
        AST_SetData1(node, func_name)
        
        // Parse function sections: Input, Output, Body
        WhileLoop NotEqual(Parser.current_type, Token.RBRACE) {
            IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in function")
                ExitLoop
            }
            
            Parse_SkipNewlines()
            t = Parser.current_type
            
            // Input: parameters
            IfCondition EqualTo(t, Token.INPUT) ThenBlock: {
                Parse_FunctionInput(node)
                ContinueLoop
            }
            
            // Output: type
            IfCondition EqualTo(t, Token.OUTPUT) ThenBlock: {
                Parse_FunctionOutput(node)
                ContinueLoop
            }
            
            // Body: { statements }
            IfCondition EqualTo(t, Token.BODY) ThenBlock: {
                Parse_FunctionBody(node)
                ContinueLoop
            }
            
            // Skip unknown/whitespace
            Parse_Advance()
            Parse_SkipNewlines()
        }
        
        Parse_Consume(Token.RBRACE, "Expected '}' after function")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// Parse function input parameters
Function.Parse_FunctionInput {
    Input: node: Address
    Body: {
        Parse_Consume(Token.INPUT, "Expected 'Input'")
        Parse_Consume(Token.COLON, "Expected ':'")
        
        // Single parameter or parenthesized list
        IfCondition EqualTo(Parser.current_type, Token.LPAREN) ThenBlock: {
            // Multiple parameters: Input: (name: Type, name2: Type)
            Parse_Advance()
            Parse_SkipNewlines()
            
            WhileLoop NotEqual(Parser.current_type, Token.RPAREN) {
                param = Parse_Parameter()
                IfCondition NotEqual(param, 0) ThenBlock: {
                    AST_AddChild(node, param)
                }
                
                IfCondition EqualTo(Parser.current_type, Token.COMMA) ThenBlock: {
                    Parse_Advance()
                    Parse_SkipNewlines()
                }
            }
            Parse_Consume(Token.RPAREN, "Expected ')'")
        } ElseBlock: {
            // Single parameter: Input: name: Type
            param = Parse_Parameter()
            IfCondition NotEqual(param, 0) ThenBlock: {
                AST_AddChild(node, param)
            }
        }
        
        Parse_SkipNewlines()
    }
}

// Parse function output type
Function.Parse_FunctionOutput {
    Input: node: Address
    Body: {
        Parse_Consume(Token.OUTPUT, "Expected 'Output'")
        Parse_Consume(Token.COLON, "Expected ':'")
        
        // Parse type
        type_node = Parse_Type()
        AST_SetData2(node, type_node)
        
        Parse_SkipNewlines()
    }
}

// Parse function body
Function.Parse_FunctionBody {
    Input: node: Address
    Body: {
        Parse_Consume(Token.BODY, "Expected 'Body'")
        Parse_Consume(Token.COLON, "Expected ':'")
        Parse_SkipNewlines()
        
        // Parse body block
        body = Parse_Block()
        AST_AddChild(node, body)
        
        Parse_SkipNewlines()
    }
}

// =============================================================================
// PARAMETER PARSING
// =============================================================================

// Parse: name: Type
Function.Parse_Parameter {
    Output: Address
    Body: {
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            Parse_Error("Expected parameter name")
            ReturnValue(0)
        }
        
        param_name = Parser.current_value
        Parse_Advance()
        
        // Optional type annotation
        param_type = 0
        IfCondition EqualTo(Parser.current_type, Token.COLON) ThenBlock: {
            Parse_Advance()
            param_type = Parse_Type()
        }
        
        node = AST_MakeParameter(param_name, param_type)
        ReturnValue(node)
    }
}

// =============================================================================
// TYPE PARSING
// =============================================================================

// Parse a type expression
Function.Parse_Type {
    Output: Address
    Body: {
        t = Parser.current_type
        
        // Built-in types
        IfCondition EqualTo(t, Token.INTEGER) ThenBlock: {
            Parse_Advance()
            ReturnValue(ASTNode.TYPE_INTEGER)
        }
        IfCondition EqualTo(t, Token.ADDRESS) ThenBlock: {
            Parse_Advance()
            ReturnValue(ASTNode.TYPE_ADDRESS)
        }
        IfCondition EqualTo(t, Token.TEXT) ThenBlock: {
            Parse_Advance()
            ReturnValue(ASTNode.TYPE_TEXT)
        }
        IfCondition EqualTo(t, Token.BOOLEAN) ThenBlock: {
            Parse_Advance()
            ReturnValue(ASTNode.TYPE_BOOLEAN)
        }
        IfCondition EqualTo(t, Token.VOID) ThenBlock: {
            Parse_Advance()
            ReturnValue(ASTNode.TYPE_VOID)
        }
        IfCondition EqualTo(t, Token.ANY) ThenBlock: {
            Parse_Advance()
            ReturnValue(ASTNode.TYPE_ANY)
        }
        
        // Custom type (identifier)
        IfCondition EqualTo(t, Token.IDENTIFIER) ThenBlock: {
            type_name = Parser.current_value
            Parse_Advance()
            
            // Create custom type node
            node = AST_CreateNode(ASTNode.TYPE_CUSTOM)
            AST_SetData1(node, type_name)
            ReturnValue(node)
        }
        
        // Default to Any
        ReturnValue(ASTNode.TYPE_ANY)
    }
}

// =============================================================================
// SUBROUTINE DECLARATION
// =============================================================================

// Parse: SubRoutine.Name { Body: { ... } } or SubRoutine.Name { ... }
Function.Parse_SubRoutine {
    Output: Address
    Body: {
        Parse_Consume(Token.SUBROUTINE, "Expected 'SubRoutine'")
        Parse_Consume(Token.DOT, "Expected '.' after SubRoutine")
        
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            Parse_Error("Expected subroutine name")
            ReturnValue(0)
        }
        sub_name = Parser.current_value
        Parse_Advance()
        
        Parse_PushContext(sub_name)
        Parse_SkipNewlines()
        Parse_Consume(Token.LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_MakeSubRoutine(sub_name)
        
        // SubRoutines can have:
        // 1. Direct body statements
        // 2. Body: { ... } wrapper
        IfCondition EqualTo(Parser.current_type, Token.BODY) ThenBlock: {
            Parse_Advance()
            Parse_Consume(Token.COLON, "Expected ':'")
            body = Parse_Block()
            AST_AddChild(node, body)
        } ElseBlock: {
            // Direct statements
            WhileLoop NotEqual(Parser.current_type, Token.RBRACE) {
                IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
                    Parse_Error("Unexpected end of file in subroutine")
                    ExitLoop
                }
                
                stmt = Parse_Statement()
                IfCondition NotEqual(stmt, 0) ThenBlock: {
                    AST_AddChild(node, stmt)
                }
                Parse_SkipNewlines()
            }
        }
        
        Parse_Consume(Token.RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// =============================================================================
// POOL DECLARATIONS
// =============================================================================

// Parse: PoolType.Name { members... }
Function.Parse_Pool {
    Input: pool_type: Integer
    Output: Address
    Body: {
        Parse_Advance()  // consume pool keyword
        Parse_Consume(Token.DOT, "Expected '.' after pool type")
        
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            Parse_Error("Expected pool name")
            ReturnValue(0)
        }
        pool_name = Parser.current_value
        Parse_Advance()
        
        Parse_PushContext(pool_name)
        Parse_SkipNewlines()
        Parse_Consume(Token.LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_CreateNode(pool_type)
        AST_SetData1(node, pool_name)
        
        // Parse pool members
        WhileLoop NotEqual(Parser.current_type, Token.RBRACE) {
            IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in pool")
                ExitLoop
            }
            
            Parse_SkipNewlines()
            
            // Members are string keys: "name": Initialize=value, CanChange=True
            IfCondition EqualTo(Parser.current_type, Token.STRING) ThenBlock: {
                member = Parse_PoolMember()
                IfCondition NotEqual(member, 0) ThenBlock: {
                    AST_AddChild(node, member)
                }
            } ElseBlock: {
                Parse_Advance()  // skip unknown
            }
            
            Parse_SkipNewlines()
        }
        
        Parse_Consume(Token.RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// Parse pool member: "key": Initialize=value, CanChange=True/False
Function.Parse_PoolMember {
    Output: Address
    Body: {
        // Get key (string)
        IfCondition NotEqual(Parser.current_type, Token.STRING) ThenBlock: {
            Parse_Error("Expected string key for pool member")
            ReturnValue(0)
        }
        key = Parser.current_value
        Parse_Advance()
        
        Parse_Consume(Token.COLON, "Expected ':' after member key")
        
        node = AST_CreateNode(ASTNode.POOL_MEMBER)
        AST_SetData1(node, key)
        
        // Parse attributes: Initialize=value, CanChange=True, etc.
        has_attrs = 1
        WhileLoop EqualTo(has_attrs, 1) {
            Parse_SkipNewlines()
            
            IfCondition EqualTo(Parser.current_type, Token.INITIALIZE) ThenBlock: {
                Parse_Advance()
                Parse_Consume(Token.EQUALS, "Expected '='")
                
                // Parse value (number, string, or identifier)
                init_value = Parse_Expression()
                AST_SetData2(node, init_value)
                
            } ElseBlock: {
                IfCondition EqualTo(Parser.current_type, Token.CANCHANGE) ThenBlock: {
                    Parse_Advance()
                    Parse_Consume(Token.EQUALS, "Expected '='")
                    
                    // True or False
                    IfCondition EqualTo(Parser.current_type, Token.TRUE) ThenBlock: {
                        AST_SetData3(node, 1)
                        Parse_Advance()
                    } ElseBlock: {
                        IfCondition EqualTo(Parser.current_type, Token.FALSE) ThenBlock: {
                            AST_SetData3(node, 0)
                            Parse_Advance()
                        }
                    }
                } ElseBlock: {
                    has_attrs = 0
                }
            }
            
            // Check for comma (more attributes)
            IfCondition EqualTo(Parser.current_type, Token.COMMA) ThenBlock: {
                Parse_Advance()
            } ElseBlock: {
                has_attrs = 0
            }
        }
        
        ReturnValue(node)
    }
}

// =============================================================================
// LOOP DECLARATIONS (Actor System)
// =============================================================================

// Parse: LoopType.Name { ... }
Function.Parse_Loop {
    Input: loop_type: Integer
    Output: Address
    Body: {
        Parse_Advance()  // consume loop keyword
        Parse_Consume(Token.DOT, "Expected '.' after loop type")
        
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            Parse_Error("Expected loop name")
            ReturnValue(0)
        }
        loop_name = Parser.current_value
        Parse_Advance()
        
        Parse_PushContext(loop_name)
        Parse_SkipNewlines()
        Parse_Consume(Token.LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_CreateNode(loop_type)
        AST_SetData1(node, loop_name)
        
        // Parse loop body
        WhileLoop NotEqual(Parser.current_type, Token.RBRACE) {
            IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in loop")
                ExitLoop
            }
            
            stmt = Parse_Statement()
            IfCondition NotEqual(stmt, 0) ThenBlock: {
                AST_AddChild(node, stmt)
            }
            Parse_SkipNewlines()
        }
        
        Parse_Consume(Token.RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// =============================================================================
// MACRO BLOCK
// =============================================================================

// Parse: MacroBlock.Name { ... }
Function.Parse_MacroBlock {
    Output: Address
    Body: {
        Parse_Consume(Token.MACROBLOCK, "Expected 'MacroBlock'")
        Parse_Consume(Token.DOT, "Expected '.'")
        
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            Parse_Error("Expected macro name")
            ReturnValue(0)
        }
        macro_name = Parser.current_value
        Parse_Advance()
        
        Parse_PushContext(macro_name)
        Parse_SkipNewlines()
        Parse_Consume(Token.LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_CreateNode(ASTNode.MACRO_BLOCK)
        AST_SetData1(node, macro_name)
        
        // Parse macro body (statements)
        WhileLoop NotEqual(Parser.current_type, Token.RBRACE) {
            IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in macro")
                ExitLoop
            }
            
            stmt = Parse_Statement()
            IfCondition NotEqual(stmt, 0) ThenBlock: {
                AST_AddChild(node, stmt)
            }
            Parse_SkipNewlines()
        }
        
        Parse_Consume(Token.RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// =============================================================================
// IDENTIFIER DECLARATION (dotted names at top level)
// =============================================================================

// Handle identifiers that might be dotted declarations
Function.Parse_IdentifierDeclaration {
    Output: Address
    Body: {
        // The lexer may have combined "Function.Name" into one identifier
        name = Parser.current_value
        
        // Check if it starts with a known declaration prefix
        // This is a simplification - proper parsing would split the identifier
        
        // For now, treat as expression/assignment at top level
        ReturnValue(Parse_ExprOrAssignment())
    }
}

Debug("library.load", level=1) {
    PrintMessage("CParserDeclarations Library loaded successfully!\n")
}