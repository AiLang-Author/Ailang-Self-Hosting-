// Library.CParserExpressions.ailang
// Expression parsing for the AILang self-hosting compiler
// Handles: literals, identifiers, calls, member access, operators

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.CTypes

LibraryImport.Compiler.Frontend.Parser.CParserCore
LibraryImport.Compiler.Frontend.Parser.CParserUtils

// =============================================================================
// MAIN EXPRESSION ENTRY POINT
// =============================================================================

// Parse any expression
// AILang uses explicit parentheses for binary ops, so no precedence climbing needed
Function.Parse_Expression {
    Output: Address
    Body: {
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        
        // Parse primary expression first
        expr = Parse_Primary()
        
        IfCondition EqualTo(expr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Handle postfix operations: member access and calls
        expr = Parse_Postfix(expr)
        
        ReturnValue(expr)
    }
}

// =============================================================================
// POSTFIX OPERATIONS (member access, function calls)
// =============================================================================

// Parse postfix operators: .member, (args)
Function.Parse_Postfix {
    Input: expr: Address
    Output: Address
    Body: {
        done = 0
        WhileLoop EqualTo(done, 0) {
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(expr)
            }
            
            // Member access: expr.member
            IfCondition EqualTo(Parser.current_type, Token.DOT) ThenBlock: {
                Parse_Advance()
                Parse_SkipNewlines()
                
                // Expect identifier after dot
                IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
                    Parse_Error("Expected identifier after '.'")
                    ReturnValue(expr)
                }
                
                member_name = Parser.current_value
                Parse_Advance()
                
                expr = AST_MakeMemberAccess(expr, member_name)
                ContinueLoop
            }
            
            // Function call: expr(args)
            IfCondition EqualTo(Parser.current_type, Token.LPAREN) ThenBlock: {
                // Only allow calls on identifiers or member access
                node_type = AST_GetType(expr)
                IfCondition Or(EqualTo(node_type, ASTNode.IDENTIFIER), EqualTo(node_type, ASTNode.MEMBER_ACCESS)) ThenBlock: {
                    // Get function name from expression
                    func_name = AST_GetData1(expr)
                    
                    // Parse arguments
                    args = Parse_Arguments()
                    
                    // Create call node (reusing the name)
                    call = AST_MakeCall(func_name, args)
                    
                    // Free the identifier node since we're replacing it
                    AST_FreeNode(expr)
                    XArray.XDestroy(args)
                    
                    expr = call
                    ContinueLoop
                }
            }
            
            // No more postfix operations
            done = 1
        }
        
        ReturnValue(expr)
    }
}

// =============================================================================
// PRIMARY EXPRESSIONS
// =============================================================================

// Parse a primary expression (literals, identifiers, parenthesized)
Function.Parse_Primary {
    Output: Address
    Body: {
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        t = Parser.current_type
        
        // ─────────────────────────────────────────────────────────────────────
        // Unary minus: -expr
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.DASH) ThenBlock: {
            Parse_Advance()
            operand = Parse_Primary()
            IfCondition EqualTo(operand, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            // Syntactic sugar: -x becomes Subtract(0, x)
            zero = AST_MakeNumber("0")
            args = XArray.XCreate(4)
            XArray.XPush(args, zero)
            XArray.XPush(args, operand)
            result = AST_MakeCall("Subtract", args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Unary NOT: !expr
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.BANG_SIGN) ThenBlock: {
            Parse_Advance()
            operand = Parse_Primary()
            IfCondition EqualTo(operand, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            args = XArray.XCreate(4)
            XArray.XPush(args, operand)
            result = AST_MakeCall("Not", args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Bitwise NOT: ~expr
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.TILDE_SIGN) ThenBlock: {
            Parse_Advance()
            operand = Parse_Primary()
            IfCondition EqualTo(operand, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            args = XArray.XCreate(4)
            XArray.XPush(args, operand)
            result = AST_MakeCall("BitwiseNot", args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Number literal
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.NUMBER) ThenBlock: {
            value = Parser.current_value
            Parse_Advance()
            ReturnValue(AST_MakeNumber(value))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // String literal
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.STRING) ThenBlock: {
            value = Parser.current_value
            Parse_Advance()
            ReturnValue(AST_MakeString(value))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Boolean True
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.TRUE) ThenBlock: {
            Parse_Advance()
            node = AST_CreateNode(ASTNode.BOOLEAN)
            AST_SetData1(node, 1)
            ReturnValue(node)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Boolean False
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.FALSE) ThenBlock: {
            Parse_Advance()
            node = AST_CreateNode(ASTNode.BOOLEAN)
            AST_SetData1(node, 0)
            ReturnValue(node)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Null
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.NULL) ThenBlock: {
            Parse_Advance()
            node = AST_CreateNode(ASTNode.NULL)
            ReturnValue(node)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Identifier (may be dotted: Pool.Field or simple)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.IDENTIFIER) ThenBlock: {
            ReturnValue(Parse_Identifier())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Parenthesized expression or infix operator
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.LPAREN) ThenBlock: {
            ReturnValue(Parse_ParenExpr())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Array literal [...]
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, Token.LBRACKET) ThenBlock: {
            ReturnValue(Parse_ArrayLiteral())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Error: unexpected token
        // ─────────────────────────────────────────────────────────────────────
        Parse_Error("Expected expression")
        ReturnValue(0)
    }
}

// =============================================================================
// IDENTIFIER PARSING
// =============================================================================

// Parse identifier (handles dotted names from lexer)
Function.Parse_Identifier {
    Output: Address
    Body: {
        // The lexer may have already combined dotted names like "Pool.Field"
        // into a single IDENTIFIER token
        name = Parser.current_value
        Parse_Advance()
        
        ReturnValue(AST_MakeIdentifier(name))
    }
}

// =============================================================================
// PARENTHESIZED EXPRESSION / INFIX OPERATORS
// =============================================================================

// Parse (expr) or (expr op expr)
Function.Parse_ParenExpr {
    Output: Address
    Body: {
        Parse_Consume(Token.LPAREN, "Expected '('")
        Parse_SkipNewlines()
        
        // Parse first expression
        expr = Parse_Expression()
        IfCondition EqualTo(expr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        
        // Check if there's an infix operator
        op_name = Parse_GetInfixOp()
        
        IfCondition NotEqual(op_name, 0) ThenBlock: {
            // It's a binary operation: (a op b)
            Parse_Advance()  // consume operator
            Parse_SkipNewlines()
            
            // Parse second operand
            right = Parse_Expression()
            IfCondition EqualTo(right, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            Parse_SkipNewlines()
            Parse_Consume(Token.RPAREN, "Expected ')' after binary expression")
            
            // Build function call: op_name(expr, right)
            args = XArray.XCreate(4)
            XArray.XPush(args, expr)
            XArray.XPush(args, right)
            result = AST_MakeCall(op_name, args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // Just a grouped expression: (expr)
        Parse_Consume(Token.RPAREN, "Expected ')'")
        ReturnValue(expr)
    }
}

// =============================================================================
// INFIX OPERATOR DETECTION
// =============================================================================

// Check if current token is an infix operator
// Returns the function name (e.g., "Add") or 0 if not an operator
Function.Parse_GetInfixOp {
    Output: Address
    Body: {
        t = Parser.current_type
        
        // Arithmetic
        IfCondition EqualTo(t, Token.PLUS_SIGN) ThenBlock: { ReturnValue("Add") }
        IfCondition EqualTo(t, Token.DASH) ThenBlock: { ReturnValue("Subtract") }
        IfCondition EqualTo(t, Token.STAR_SIGN) ThenBlock: { ReturnValue("Multiply") }
        IfCondition EqualTo(t, Token.SLASH_SIGN) ThenBlock: { ReturnValue("Divide") }
        IfCondition EqualTo(t, Token.PERCENT_SIGN) ThenBlock: { ReturnValue("Modulo") }
        IfCondition EqualTo(t, Token.CARET_SIGN) ThenBlock: { ReturnValue("Power") }
        
        // Comparison (single char)
        IfCondition EqualTo(t, Token.GREATER_SIGN) ThenBlock: { ReturnValue("GreaterThan") }
        IfCondition EqualTo(t, Token.LESS_SIGN) ThenBlock: { ReturnValue("LessThan") }
        
        // Comparison (two char)
        IfCondition EqualTo(t, Token.EQUALTO) ThenBlock: { ReturnValue("EqualTo") }
        IfCondition EqualTo(t, Token.NOTEQUAL) ThenBlock: { ReturnValue("NotEqual") }
        IfCondition EqualTo(t, Token.GREATEREQUAL) ThenBlock: { ReturnValue("GreaterEqual") }
        IfCondition EqualTo(t, Token.LESSEQUAL) ThenBlock: { ReturnValue("LessEqual") }
        
        // Logical
        IfCondition EqualTo(t, Token.AND_AND) ThenBlock: { ReturnValue("And") }
        IfCondition EqualTo(t, Token.PIPE_PIPE) ThenBlock: { ReturnValue("Or") }
        
        // Bitwise
        IfCondition EqualTo(t, Token.AMPERSAND_SIGN) ThenBlock: { ReturnValue("BitwiseAnd") }
        IfCondition EqualTo(t, Token.PIPE_SIGN) ThenBlock: { ReturnValue("BitwiseOr") }
        IfCondition EqualTo(t, Token.LESS_LESS) ThenBlock: { ReturnValue("LeftShift") }
        IfCondition EqualTo(t, Token.GREATER_GREATER) ThenBlock: { ReturnValue("RightShift") }
        
        // Not an operator
        ReturnValue(0)
    }
}

// =============================================================================
// ARGUMENT LIST PARSING
// =============================================================================

// Parse argument list: (expr, expr, ...)
// Returns XArray of argument nodes
Function.Parse_Arguments {
    Output: Address
    Body: {
        args = XArray.XCreate(16)
        
        Parse_Consume(Token.LPAREN, "Expected '(' for arguments")
        Parse_SkipNewlines()
        
        // Handle empty argument list
        IfCondition EqualTo(Parser.current_type, Token.RPAREN) ThenBlock: {
            Parse_Advance()
            ReturnValue(args)
        }
        
        // Parse first argument
        arg = Parse_Expression()
        IfCondition NotEqual(arg, 0) ThenBlock: {
            XArray.XPush(args, arg)
        }
        
        // Parse remaining arguments
        WhileLoop EqualTo(Parser.current_type, Token.COMMA) {
            Parse_Advance()  // consume comma
            Parse_SkipNewlines()
            
            arg = Parse_Expression()
            IfCondition NotEqual(arg, 0) ThenBlock: {
                XArray.XPush(args, arg)
            }
            
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(args)
            }
        }
        
        Parse_SkipNewlines()
        Parse_Consume(Token.RPAREN, "Expected ')' after arguments")
        
        ReturnValue(args)
    }
}

// =============================================================================
// ARRAY LITERAL
// =============================================================================

// Parse array literal: [expr, expr, ...]
Function.Parse_ArrayLiteral {
    Output: Address
    Body: {
        Parse_Consume(Token.LBRACKET, "Expected '['")
        Parse_SkipNewlines()
        
        node = AST_CreateNode(ASTNode.ARRAY_LITERAL)
        
        // Handle empty array
        IfCondition EqualTo(Parser.current_type, Token.RBRACKET) ThenBlock: {
            Parse_Advance()
            ReturnValue(node)
        }
        
        // Parse first element
        elem = Parse_Expression()
        IfCondition NotEqual(elem, 0) ThenBlock: {
            AST_AddChild(node, elem)
        }
        
        // Parse remaining elements
        Parse_SkipNewlines()
        WhileLoop EqualTo(Parser.current_type, Token.COMMA) {
            Parse_Advance()  // consume comma
            Parse_SkipNewlines()
            
            elem = Parse_Expression()
            IfCondition NotEqual(elem, 0) ThenBlock: {
                AST_AddChild(node, elem)
            }
            
            Parse_SkipNewlines()
            
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(node)
            }
        }
        
        Parse_Consume(Token.RBRACKET, "Expected ']' after array elements")
        
        ReturnValue(node)
    }
}

// =============================================================================
// NAMED ARGUMENT PARSING (for function calls with keyword args)
// =============================================================================

// Parse named argument: name: value or name=value
Function.Parse_NamedArgument {
    Output: Address
    Body: {
        // Check if it's identifier followed by : or =
        IfCondition NotEqual(Parser.current_type, Token.IDENTIFIER) ThenBlock: {
            // Just a regular expression
            ReturnValue(Parse_Expression())
        }
        
        // Peek ahead for : or =
        next = Parse_Peek(1)
        IfCondition Or(EqualTo(next, Token.COLON), EqualTo(next, Token.EQUALS)) ThenBlock: {
            // Named argument: name: value
            name = Parser.current_value
            Parse_Advance()  // consume name
            Parse_Advance()  // consume : or =
            Parse_SkipNewlines()
            
            value = Parse_Expression()
            
            // Create parameter-like node for named arg
            node = AST_CreateNode(ASTNode.PARAMETER)
            AST_SetData1(node, name)
            AST_AddChild(node, value)
            ReturnValue(node)
        }
        
        // Just a regular expression
        ReturnValue(Parse_Expression())
    }
}

// =============================================================================
// BUILT-IN FUNCTION CALL PARSING
// =============================================================================

// Check if identifier is a built-in math/comparison function
Function.Parse_IsBuiltinFunc {
    Input: name: Address
    Output: Integer
    Body: {
        // Arithmetic
        IfCondition EqualTo(StringCompare(name, "Add"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Subtract"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Multiply"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Divide"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Modulo"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Power"), 0) ThenBlock: { ReturnValue(1) }
        
        // Comparison
        IfCondition EqualTo(StringCompare(name, "EqualTo"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "NotEqual"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "GreaterThan"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "LessThan"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "GreaterEqual"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "LessEqual"), 0) ThenBlock: { ReturnValue(1) }
        
        // Logical
        IfCondition EqualTo(StringCompare(name, "And"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Or"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Not"), 0) ThenBlock: { ReturnValue(1) }
        
        // Bitwise
        IfCondition EqualTo(StringCompare(name, "BitwiseAnd"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "BitwiseOr"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "BitwiseXor"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "BitwiseNot"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "LeftShift"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "RightShift"), 0) ThenBlock: { ReturnValue(1) }
        
        ReturnValue(0)
    }
}

