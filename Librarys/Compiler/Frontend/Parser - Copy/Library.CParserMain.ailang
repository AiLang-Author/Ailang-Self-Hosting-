// Library.CParserMain.ailang
// Main parser entry point for the AILang self-hosting compiler

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.Lexer.CLexerCore
LibraryImport.Compiler.Frontend.CTypes
LibraryImport.Compiler.Frontend.Parser.CParserCore
LibraryImport.Compiler.Frontend.Parser.CParserUtils
LibraryImport.Compiler.Frontend.Parser.CParserExpressions
LibraryImport.Compiler.Frontend.Parser.CParserStatements
LibraryImport.Compiler.Frontend.Parser.CParserDeclarations

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================

Function.Parse_Program {
    Output: Address
    Body: {
        program = AST_MakeProgram()
        Parser.ast_root = program
        
        PrintMessage("[PARSER] Starting parse...\n")
        
        WhileLoop NotEqual(Parser.current_type, Token.EOF) {
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                PrintMessage("[PARSER] Stopping due to error\n")
                ExitLoop
            }
            
            Parse_SkipNewlines()
            
            IfCondition EqualTo(Parser.current_type, Token.EOF) ThenBlock: {
                ExitLoop
            }
            
            decl = Parse_Declaration()
            
            IfCondition NotEqual(decl, 0) ThenBlock: {
                AST_AddChild(program, decl)
            }
            
            Parse_SkipNewlines()
        }
        
        decl_count = AST_GetChildCount(program)
        PrintMessage("[PARSER] Parsed ")
        PrintNumber(decl_count)
        PrintMessage(" declarations, ")
        PrintNumber(Parser.node_count)
        PrintMessage(" total nodes\n")
        
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            PrintMessage("[PARSER] FAILED with errors\n")
        } ElseBlock: {
            PrintMessage("[PARSER] SUCCESS\n")
        }
        
        ReturnValue(program)
    }
}

// =============================================================================
// PARSE PIPELINE
// =============================================================================

Function.Parse {
    Input: token_count: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("[PARSER] Failed to initialize\n")
            ReturnValue(0)
        }
        
        ast = Parse_Program()
        ReturnValue(ast)
    }
}

Function.Parse_WithOptions {
    Input: token_count: Integer
    Input: show_progress: Integer
    Input: show_ast: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(show_progress, 1) ThenBlock: {
            PrintMessage("[PARSER] Token count: ")
            PrintNumber(token_count)
            PrintMessage("\n")
        }
        
        ast = Parse_Program()
        
        IfCondition And(EqualTo(show_ast, 1), NotEqual(ast, 0)) ThenBlock: {
            AST_Dump(ast)
        }
        
        ReturnValue(ast)
    }
}

// =============================================================================
// SINGLE ITEM PARSING (REPL)
// =============================================================================

Function.Parse_SingleExpression {
    Input: token_count: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        expr = Parse_Expression()
        ReturnValue(expr)
    }
}

Function.Parse_SingleStatement {
    Input: token_count: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        stmt = Parse_Statement()
        ReturnValue(stmt)
    }
}

// =============================================================================
// ERROR RECOVERY
// =============================================================================

Function.Parse_Synchronize {
    Body: {
        WhileLoop NotEqual(Parser.current_type, Token.EOF) {
            prev = Parse_Peek(-1)
            IfCondition EqualTo(prev, Token.NEWLINE) ThenBlock: {
                IfCondition EqualTo(Parse_AtStatementStart(), 1) ThenBlock: {
                    ReturnValue(0)
                }
            }
            
            t = Parser.current_type
            IfCondition EqualTo(t, Token.FUNCTION) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, Token.SUBROUTINE) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, Token.FIXEDPOOL) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, Token.DYNAMICPOOL) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, Token.LIBRARYIMPORT) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, Token.LOOPMAIN) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, Token.LOOPACTOR) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, Token.RBRACE) ThenBlock: { ReturnValue(0) }
            
            Parse_Advance()
        }
        ReturnValue(0)
    }
}

// =============================================================================
// VALIDATION
// =============================================================================

Function.Parse_Validate {
    Input: ast: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            PrintMessage("[VALIDATE] ERROR: Null AST\n")
            ReturnValue(0)
        }
        
        root_type = AST_GetType(ast)
        IfCondition NotEqual(root_type, ASTNode.PROGRAM) ThenBlock: {
            PrintMessage("[VALIDATE] ERROR: Root is not PROGRAM node\n")
            ReturnValue(0)
        }
        
        decl_count = AST_GetChildCount(ast)
        func_count = 0
        sub_count = 0
        pool_count = 0
        import_count = 0
        
        i = 0
        WhileLoop LessThan(i, decl_count) {
            child = AST_GetChild(ast, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, ASTNode.FUNCTION) ThenBlock: {
                func_count = Add(func_count, 1)
            }
            IfCondition EqualTo(child_type, ASTNode.SUBROUTINE) ThenBlock: {
                sub_count = Add(sub_count, 1)
            }
            IfCondition EqualTo(child_type, ASTNode.LIBRARY_IMPORT) ThenBlock: {
                import_count = Add(import_count, 1)
            }
            IfCondition And(GreaterEqual(child_type, ASTNode.POOL_FIXED), LessEqual(child_type, ASTNode.POOL_LINKAGE)) ThenBlock: {
                pool_count = Add(pool_count, 1)
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[VALIDATE] Imports: ")
        PrintNumber(import_count)
        PrintMessage(", Functions: ")
        PrintNumber(func_count)
        PrintMessage(", SubRoutines: ")
        PrintNumber(sub_count)
        PrintMessage(", Pools: ")
        PrintNumber(pool_count)
        PrintMessage("\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================

Function.Parse_Cleanup {
    Input: free_ast: Integer
    Body: {
        Parse_Free()
        
        IfCondition And(EqualTo(free_ast, 1), NotEqual(Parser.ast_root, 0)) ThenBlock: {
            AST_FreeNode(Parser.ast_root)
            Parser.ast_root = 0
        }
    }
}


Function.Parse_PrintStats {
    Body: {
        PrintMessage("\n=== Parser Statistics ===\n")
        PrintMessage("Position: ")
        PrintNumber(Parser.pos)
        PrintMessage(" / ")
        PrintNumber(Parser.token_count)
        PrintMessage("\n")
        
        PrintMessage("Nodes created: ")
        PrintNumber(Parser.node_count)
        PrintMessage("\n")
        
        PrintMessage("Context depth: ")
        PrintNumber(Parser.context_depth)
        PrintMessage("\n")
        
        PrintMessage("Error state: ")
        IfCondition EqualTo(Parser.error, 1) ThenBlock: {
            PrintMessage("ERROR at line ")
            PrintNumber(Parser.error_line)
            PrintMessage(": ")
            PrintMessage(Parser.error_msg)
        } ElseBlock: {
            PrintMessage("OK")
        }
        PrintMessage("\n")
        PrintMessage("=========================\n")
    }
}
