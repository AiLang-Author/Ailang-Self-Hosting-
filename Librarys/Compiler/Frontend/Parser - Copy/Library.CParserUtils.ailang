// Library.CParserUtils.ailang
// AST Node Creation and Manipulation Utilities
// Provides helper functions for building the AST during parsing

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.CTypes

// =============================================================================
// AST NODE CREATION
// All nodes: [TYPE, LINE, COL, DATA1, DATA2, DATA3, DATA4, CHILDREN]
// =============================================================================

Function.AST_CreateNode {
    Input: node_type: Integer
    Output: Address
    Body: {
        node = Allocate(64)
        
        StoreValue(node, node_type)
        StoreValue(Add(node, 8), Parser.current_line)
        StoreValue(Add(node, 16), Parser.current_col)
        StoreValue(Add(node, 24), 0)
        StoreValue(Add(node, 32), 0)
        StoreValue(Add(node, 40), 0)
        StoreValue(Add(node, 48), 0)
        
        children = XArray.XCreate(NodeConfig.MAX_CHILDREN)
        StoreValue(Add(node, 56), children)
        
        Parser.node_count = Add(Parser.node_count, 1)
        
        ReturnValue(node)
    }
}

Function.AST_CreateNodeAt {
    Input: node_type: Integer
    Input: line: Integer
    Input: col: Integer
    Output: Address
    Body: {
        node = Allocate(64)
        
        StoreValue(node, node_type)
        StoreValue(Add(node, 8), line)
        StoreValue(Add(node, 16), col)
        StoreValue(Add(node, 24), 0)
        StoreValue(Add(node, 32), 0)
        StoreValue(Add(node, 40), 0)
        StoreValue(Add(node, 48), 0)
        
        children = XArray.XCreate(NodeConfig.MAX_CHILDREN)
        StoreValue(Add(node, 56), children)
        
        Parser.node_count = Add(Parser.node_count, 1)
        
        ReturnValue(node)
    }
}

// =============================================================================
// FIELD ACCESS - SETTERS (no return value)
// =============================================================================

Function.AST_SetField {
    Input: node: Address
    Input: field: Integer
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            offset = Multiply(field, 8)
            StoreValue(Add(node, offset), value)
        }
    }
}

Function.AST_SetData1 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 24), value)
        }
    }
}

Function.AST_SetData2 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 32), value)
        }
    }
}

Function.AST_SetData3 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 40), value)
        }
    }
}

Function.AST_SetData4 {
    Input: node: Address
    Input: value: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            StoreValue(Add(node, 48), value)
        }
    }
}

// =============================================================================
// FIELD ACCESS - GETTERS
// =============================================================================

Function.AST_GetField {
    Input: node: Address
    Input: field: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        offset = Multiply(field, 8)
        ReturnValue(Dereference(Add(node, offset)))
    }
}

Function.AST_GetData1 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 24)))
    }
}

Function.AST_GetData2 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 32)))
    }
}

Function.AST_GetData3 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 40)))
    }
}

Function.AST_GetData4 {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 48)))
    }
}

Function.AST_GetType {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(node))
    }
}

Function.AST_GetLine {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 8)))
    }
}

Function.AST_GetCol {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 16)))
    }
}

Function.AST_GetChildren {
    Input: node: Address
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 56)))
    }
}

// =============================================================================
// CHILD NODE MANAGEMENT
// =============================================================================

Function.AST_AddChild {
    Input: parent: Address
    Input: child: Address
    Body: {
        IfCondition And(NotEqual(parent, 0), NotEqual(child, 0)) ThenBlock: {
            children = Dereference(Add(parent, 56))
            XArray.XPush(children, child)
        }
    }
}

Function.AST_GetChild {
    Input: node: Address
    Input: index: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        children = Dereference(Add(node, 56))
        ReturnValue(XArray.XGet(children, index))
    }
}

Function.AST_GetChildCount {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        children = Dereference(Add(node, 56))
        ReturnValue(XArray.XSize(children))
    }
}

Function.AST_IsType {
    Input: node: Address
    Input: expected_type: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        actual = Dereference(node)
        IfCondition EqualTo(actual, expected_type) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// SPECIALIZED NODE CREATORS
// =============================================================================

Function.AST_MakeIdentifier {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.IDENTIFIER)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

Function.AST_MakeNumber {
    Input: value: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.NUMBER)
        AST_SetData1(node, value)
        ReturnValue(node)
    }
}

Function.AST_MakeString {
    Input: value: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.STRING)
        AST_SetData1(node, value)
        ReturnValue(node)
    }
}

Function.AST_MakeBinaryOp {
    Input: op_type: Integer
    Input: left: Address
    Input: right: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.BINARY_OP)
        AST_SetData1(node, op_type)
        AST_AddChild(node, left)
        AST_AddChild(node, right)
        ReturnValue(node)
    }
}

Function.AST_MakeUnaryOp {
    Input: op_type: Integer
    Input: operand: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.UNARY_OP)
        AST_SetData1(node, op_type)
        AST_AddChild(node, operand)
        ReturnValue(node)
    }
}

Function.AST_MakeCall {
    Input: func_name: Address
    Input: args: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.CALL)
        AST_SetData1(node, func_name)
        
        IfCondition NotEqual(args, 0) ThenBlock: {
            arg_count = XArray.XSize(args)
            i = 0
            WhileLoop LessThan(i, arg_count) {
                arg = XArray.XGet(args, i)
                AST_AddChild(node, arg)
                i = Add(i, 1)
            }
        }
        
        ReturnValue(node)
    }
}

Function.AST_MakeMemberAccess {
    Input: base: Address
    Input: member: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.MEMBER_ACCESS)
        AST_SetData1(node, member)
        AST_AddChild(node, base)
        ReturnValue(node)
    }
}

Function.AST_MakeAssignment {
    Input: target: Address
    Input: value: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.ASSIGNMENT)
        AST_SetData1(node, target)
        AST_AddChild(node, value)
        ReturnValue(node)
    }
}

Function.AST_MakeIf {
    Input: condition: Address
    Input: then_block: Address
    Input: else_block: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.IF)
        AST_AddChild(node, condition)
        AST_AddChild(node, then_block)
        IfCondition NotEqual(else_block, 0) ThenBlock: {
            AST_AddChild(node, else_block)
        }
        ReturnValue(node)
    }
}

Function.AST_MakeWhile {
    Input: condition: Address
    Input: body: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.WHILE)
        AST_AddChild(node, condition)
        AST_AddChild(node, body)
        ReturnValue(node)
    }
}

Function.AST_MakeReturn {
    Input: value: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.RETURN)
        IfCondition NotEqual(value, 0) ThenBlock: {
            AST_AddChild(node, value)
        }
        ReturnValue(node)
    }
}

Function.AST_MakeBlock {
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.BLOCK)
        ReturnValue(node)
    }
}

Function.AST_MakeParameter {
    Input: name: Address
    Input: type_node: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.PARAMETER)
        AST_SetData1(node, name)
        AST_SetData2(node, type_node)
        ReturnValue(node)
    }
}

Function.AST_MakeFunction {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.FUNCTION)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

Function.AST_MakeSubRoutine {
    Input: name: Address
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.SUBROUTINE)
        AST_SetData1(node, name)
        ReturnValue(node)
    }
}

Function.AST_MakeProgram {
    Output: Address
    Body: {
        node = AST_CreateNode(ASTNode.PROGRAM)
        ReturnValue(node)
    }
}

// =============================================================================
// AST CLEANUP
// =============================================================================

Function.AST_FreeNode {
    Input: node: Address
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            children = Dereference(Add(node, 56))
            IfCondition NotEqual(children, 0) ThenBlock: {
                child_count = XArray.XSize(children)
                i = 0
                WhileLoop LessThan(i, child_count) {
                    child = XArray.XGet(children, i)
                    AST_FreeNode(child)
                    i = Add(i, 1)
                }
                XArray.XDestroy(children)
            }
            
            Deallocate(node, 64)
            Parser.node_count = Subtract(Parser.node_count, 1)
        }
    }
}

// =============================================================================
// DEBUG UTILITIES
// =============================================================================

Function.AST_NodeTypeName {
    Input: node_type: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(node_type, ASTNode.PROGRAM) ThenBlock: { ReturnValue("PROGRAM") }
        IfCondition EqualTo(node_type, ASTNode.LIBRARY_IMPORT) ThenBlock: { ReturnValue("LIBRARY_IMPORT") }
        IfCondition EqualTo(node_type, ASTNode.FUNCTION) ThenBlock: { ReturnValue("FUNCTION") }
        IfCondition EqualTo(node_type, ASTNode.SUBROUTINE) ThenBlock: { ReturnValue("SUBROUTINE") }
        IfCondition EqualTo(node_type, ASTNode.PARAMETER) ThenBlock: { ReturnValue("PARAMETER") }
        IfCondition EqualTo(node_type, ASTNode.POOL_FIXED) ThenBlock: { ReturnValue("POOL_FIXED") }
        IfCondition EqualTo(node_type, ASTNode.POOL_DYNAMIC) ThenBlock: { ReturnValue("POOL_DYNAMIC") }
        IfCondition EqualTo(node_type, ASTNode.ASSIGNMENT) ThenBlock: { ReturnValue("ASSIGNMENT") }
        IfCondition EqualTo(node_type, ASTNode.IF) ThenBlock: { ReturnValue("IF") }
        IfCondition EqualTo(node_type, ASTNode.WHILE) ThenBlock: { ReturnValue("WHILE") }
        IfCondition EqualTo(node_type, ASTNode.RETURN) ThenBlock: { ReturnValue("RETURN") }
        IfCondition EqualTo(node_type, ASTNode.BLOCK) ThenBlock: { ReturnValue("BLOCK") }
        IfCondition EqualTo(node_type, ASTNode.PRINT) ThenBlock: { ReturnValue("PRINT") }
        IfCondition EqualTo(node_type, ASTNode.CALL) ThenBlock: { ReturnValue("CALL") }
        IfCondition EqualTo(node_type, ASTNode.IDENTIFIER) ThenBlock: { ReturnValue("IDENTIFIER") }
        IfCondition EqualTo(node_type, ASTNode.NUMBER) ThenBlock: { ReturnValue("NUMBER") }
        IfCondition EqualTo(node_type, ASTNode.STRING) ThenBlock: { ReturnValue("STRING") }
        IfCondition EqualTo(node_type, ASTNode.BINARY_OP) ThenBlock: { ReturnValue("BINARY_OP") }
        IfCondition EqualTo(node_type, ASTNode.UNARY_OP) ThenBlock: { ReturnValue("UNARY_OP") }
        IfCondition EqualTo(node_type, ASTNode.MEMBER_ACCESS) ThenBlock: { ReturnValue("MEMBER_ACCESS") }
        ReturnValue("UNKNOWN")
    }
}

Function.AST_PrintIndent {
    Input: indent: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, indent) {
            PrintMessage("  ")
            i = Add(i, 1)
        }
    }
}

Function.AST_DumpNode {
    Input: node: Address
    Input: indent: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            AST_PrintIndent(indent)
            PrintMessage("<null>\n")
        } ElseBlock: {
            AST_PrintIndent(indent)
            
            node_type = AST_GetType(node)
            type_name = AST_NodeTypeName(node_type)
            PrintMessage(type_name)
            
            PrintMessage(" [")
            PrintNumber(AST_GetLine(node))
            PrintMessage(":")
            PrintNumber(AST_GetCol(node))
            PrintMessage("]")
            
            data1 = AST_GetData1(node)
            IfCondition GreaterThan(data1, 1000) ThenBlock: {
                PrintMessage(" \"")
                PrintMessage(data1)
                PrintMessage("\"")
            }
            
            PrintMessage("\n")
        }
    }
}

Function.AST_DumpTree {
    Input: node: Address
    Input: indent: Integer
    Body: {
        IfCondition NotEqual(node, 0) ThenBlock: {
            AST_DumpNode(node, indent)
            
            children = AST_GetChildren(node)
            IfCondition NotEqual(children, 0) ThenBlock: {
                child_count = XArray.XSize(children)
                i = 0
                next_indent = Add(indent, 1)
                WhileLoop LessThan(i, child_count) {
                    child = XArray.XGet(children, i)
                    AST_DumpTree(child, next_indent)
                    i = Add(i, 1)
                }
            }
        }
    }
}

Function.AST_Dump {
    Input: root: Address
    Body: {
        PrintMessage("=== AST DUMP ===\n")
        AST_DumpTree(root, 0)
        PrintMessage("================\n")
        PrintMessage("Total nodes: ")
        PrintNumber(Parser.node_count)
        PrintMessage("\n")
    }
}