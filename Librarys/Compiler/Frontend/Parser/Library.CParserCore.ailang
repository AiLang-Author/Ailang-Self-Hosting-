// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CParserCore.ailang
// Core parser functions: initialization, token navigation, error handling
// Foundation for all other parser modules

LibraryImport.XArrays

LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes
LibraryImport.Compiler.Frontend.Lexer.CLexerCore

// =============================================================================
// PARSER'S TOKEN TYPES (must match CLexerTypes.ailang Token values EXACTLY)
// =============================================================================
FixedPool.PToken {
    "P_RUNTASK": Initialize=1
    "P_PRINTMESSAGE": Initialize=2
    "P_RETURNVALUE": Initialize=3
    "P_IFCONDITION": Initialize=4
    "P_THENBLOCK": Initialize=5
    "P_ELSEBLOCK": Initialize=6
    "P_TRUEBLOCK": Initialize=7
    "P_FALSEBLOCK": Initialize=8
    "P_WHILELOOP": Initialize=9
    "P_UNTILCONDITION": Initialize=10
    "P_FOREVERY": Initialize=11
    "P_IN": Initialize=12
    "P_TRYBLOCK": Initialize=13
    "P_CATCHERROR": Initialize=14
    "P_FINALLYBLOCK": Initialize=15
    "P_SENDMESSAGE": Initialize=16
    "P_RECEIVEMESSAGE": Initialize=17
    "P_EVERYINTERVAL": Initialize=18
    "P_BREAKLOOP": Initialize=19
    "P_HALTPROGRAM": Initialize=20
    "P_DEBUG": Initialize=21
    "P_DEBUGASSERT": Initialize=22
    "P_DEBUGTRACE": Initialize=23
    "P_DEBUGBREAK": Initialize=24
    "P_DEBUGMEMORY": Initialize=25
    "P_DEBUGPERF": Initialize=26
    "P_DEBUGINSPECT": Initialize=27
    "P_DEBUGCONTROL": Initialize=28
    "P_CONTINUELOOP": Initialize=29
    "P_FORK": Initialize=30
    "P_BRANCH": Initialize=31
    "P_CASE": Initialize=32
    "P_DEFAULT": Initialize=33
    "P_TRUEPATH": Initialize=34
    "P_FALSEPATH": Initialize=35
    "P_FIXEDPOOL": Initialize=36
    "P_DYNAMICPOOL": Initialize=37
    "P_TEMPORALPOOL": Initialize=38
    "P_NEURALPOOL": Initialize=39
    "P_KERNELPOOL": Initialize=40
    "P_ACTORPOOL": Initialize=41
    "P_SECURITYPOOL": Initialize=42
    "P_CONSTRAINEDPOOL": Initialize=43
    "P_FILEPOOL": Initialize=44
    "P_LINKAGEPOOL": Initialize=45
    "P_DIRECTION": Initialize=46
    "P_INOUT": Initialize=47
    "P_SUBPOOL": Initialize=48
    "P_INITIALIZE": Initialize=49
    "P_CANCHANGE": Initialize=50
    "P_CANBENULL": Initialize=51
    "P_RANGE": Initialize=52
    "P_MAXIMUMLENGTH": Initialize=53
    "P_MINIMUMLENGTH": Initialize=54
    "P_ELEMENTTYPE": Initialize=55
    "P_WHERE": Initialize=56
    "P_POOLRESIZE": Initialize=57
    "P_POOLMOVE": Initialize=58
    "P_POOLCOMPACT": Initialize=59
    "P_POOLALLOCATE": Initialize=60
    "P_HASHCREATE": Initialize=61
    "P_HASHFUNCTION": Initialize=62
    "P_HASHSET": Initialize=63
    "P_HASHGET": Initialize=64
    "P_SOCKETCREATE": Initialize=65
    "P_SOCKETBIND": Initialize=66
    "P_SOCKETLISTEN": Initialize=67
    "P_SOCKETACCEPT": Initialize=68
    "P_SOCKETREAD": Initialize=69
    "P_SOCKETWRITE": Initialize=70
    "P_SOCKETCLOSE": Initialize=71
    "P_SOCKETCONNECT": Initialize=72
    "P_SOCKETSETOPTION": Initialize=73
    "P_POOLFREE": Initialize=74
    "P_ADD": Initialize=75
    "P_SUBTRACT": Initialize=76
    "P_MULTIPLY": Initialize=77
    "P_DIVIDE": Initialize=78
    "P_POWER": Initialize=79
    "P_MODULO": Initialize=80
    "P_SQUAREROOT": Initialize=81
    "P_ABSOLUTEVALUE": Initialize=82
    "P_ISQRT": Initialize=83
    "P_ABS": Initialize=84
    "P_MIN": Initialize=85
    "P_MAX": Initialize=86
    "P_POW": Initialize=87
    "P_PLUS_SIGN": Initialize=88
    "P_STAR_SIGN": Initialize=89
    "P_SLASH_SIGN": Initialize=90
    "P_PERCENT_SIGN": Initialize=91
    "P_CARET_SIGN": Initialize=92
    "P_GREATER_SIGN": Initialize=93
    "P_LESS_SIGN": Initialize=94
    "P_BANG_SIGN": Initialize=95
    "P_AMPERSAND_SIGN": Initialize=96
    "P_PIPE_SIGN": Initialize=97
    "P_TILDE_SIGN": Initialize=98
    "P_EQUAL_EQUAL": Initialize=99
    "P_BANG_EQUAL": Initialize=100
    "P_GREATER_EQUAL_SIGN": Initialize=101
    "P_LESS_EQUAL_SIGN": Initialize=102
    "P_AND_AND": Initialize=103
    "P_PIPE_PIPE": Initialize=104
    "P_LESS_LESS": Initialize=105
    "P_GREATER_GREATER": Initialize=106
    "P_GREATERTHAN": Initialize=107
    "P_LESSTHAN": Initialize=108
    "P_GREATEREQUAL": Initialize=109
    "P_LESSEQUAL": Initialize=110
    "P_EQUALTO": Initialize=111
    "P_NOTEQUAL": Initialize=112
    "P_AND": Initialize=113
    "P_OR": Initialize=114
    "P_NOT": Initialize=115
    "P_XOR": Initialize=116
    "P_IMPLIES": Initialize=117
    "P_BITWISEAND": Initialize=118
    "P_BITWISEOR": Initialize=119
    "P_BITWISEXOR": Initialize=120
    "P_BITWISENOT": Initialize=121
    "P_LEFTSHIFT": Initialize=122
    "P_RIGHTSHIFT": Initialize=123
    "P_READINPUT": Initialize=124
    "P_READINPUTNUMBER": Initialize=125
    "P_GETUSERCHOICE": Initialize=126
    "P_READKEY": Initialize=127
    "P_STRINGEQUALS": Initialize=128
    "P_STRINGCONTAINS": Initialize=129
    "P_STRINGSTARTSWITH": Initialize=130
    "P_STRINGENDSWITH": Initialize=131
    "P_STRINGCONCAT": Initialize=132
    "P_STRINGLENGTH": Initialize=133
    "P_STRINGSUBSTRING": Initialize=134
    "P_STRINGTOUPPER": Initialize=135
    "P_STRINGTOLOWER": Initialize=136
    "P_STRINGTRIM": Initialize=137
    "P_STRINGREPLACE": Initialize=138
    "P_STRINGTOSTRING": Initialize=139
    "P_NUMBERTOSTRING": Initialize=140
    "P_STRINGTONUMBER": Initialize=141
    "P_STRINGEXTRACT": Initialize=142
    "P_STRINGCHARAT": Initialize=143
    "P_STRINGEXTRACTUNTIL": Initialize=144
    "P_STRINGINDEXOF": Initialize=145
    "P_STRINGSPLIT": Initialize=146
    "P_CHARTOSTRING": Initialize=147
    "P_OPENFILE": Initialize=148
    "P_CLOSEFILE": Initialize=149
    "P_READFILE": Initialize=150
    "P_WRITEFILE": Initialize=151
    "P_CREATEFILE": Initialize=152
    "P_DELETEFILE": Initialize=153
    "P_READLINE": Initialize=154
    "P_WRITELINE": Initialize=155
    "P_READTEXTFILE": Initialize=156
    "P_WRITETEXTFILE": Initialize=157
    "P_APPENDTEXTFILE": Initialize=158
    "P_READBINARYFILE": Initialize=159
    "P_WRITEBINARYFILE": Initialize=160
    "P_APPENDBINARYFILE": Initialize=161
    "P_FILEEXISTS": Initialize=162
    "P_GETFILESIZE": Initialize=163
    "P_GETFILEDATE": Initialize=164
    "P_SETFILEDATE": Initialize=165
    "P_GETFILEPERMISSIONS": Initialize=166
    "P_SETFILEPERMISSIONS": Initialize=167
    "P_SEEKPOSITION": Initialize=168
    "P_GETPOSITION": Initialize=169
    "P_REWIND": Initialize=170
    "P_COPYFILE": Initialize=171
    "P_MOVEFILE": Initialize=172
    "P_RENAMEFILE": Initialize=173
    "P_FLUSHFILE": Initialize=174
    "P_LOCKFILE": Initialize=175
    "P_UNLOCKFILE": Initialize=176
    "P_CREATEDIRECTORY": Initialize=177
    "P_DELETEDIRECTORY": Initialize=178
    "P_LISTDIRECTORY": Initialize=179
    "P_DIRECTORYEXISTS": Initialize=180
    "P_GETWORKINGDIRECTORY": Initialize=181
    "P_SETWORKINGDIRECTORY": Initialize=182
    "P_BUFFEREDREAD": Initialize=183
    "P_BUFFEREDWRITE": Initialize=184
    "P_SETBUFFERSIZE": Initialize=185
    "P_FLUSHBUFFERS": Initialize=186
    "P_POINTER": Initialize=187
    "P_DEREFERENCE": Initialize=188
    "P_ADDRESSOF": Initialize=189
    "P_SIZEOF": Initialize=190
    "P_ALLOCATE": Initialize=191
    "P_DEALLOCATE": Initialize=192
    "P_MEMORYCOPY": Initialize=193
    "P_MEMORYSET": Initialize=194
    "P_MEMORYCOMPARE": Initialize=195
    "P_MEMCHR": Initialize=196
    "P_MEMFIND": Initialize=197
    "P_STOREVALUE": Initialize=198
    "P_HARDWAREREGISTER": Initialize=199
    "P_CONTROLREGISTER": Initialize=200
    "P_SEGMENTREGISTER": Initialize=201
    "P_FLAGSREGISTER": Initialize=202
    "P_MODELSPECIFICREGISTER": Initialize=203
    "P_PORTREAD": Initialize=204
    "P_PORTWRITE": Initialize=205
    "P_PORTREADBYTE": Initialize=206
    "P_PORTWRITEBYTE": Initialize=207
    "P_PORTREADWORD": Initialize=208
    "P_PORTWRITEWORD": Initialize=209
    "P_PORTREADDWORD": Initialize=210
    "P_PORTWRITEDWORD": Initialize=211
    "P_INTERRUPTHANDLER": Initialize=212
    "P_EXCEPTIONHANDLER": Initialize=213
    "P_ENABLEINTERRUPTS": Initialize=214
    "P_DISABLEINTERRUPTS": Initialize=215
    "P_HALT": Initialize=216
    "P_WAIT": Initialize=217
    "P_TRIGGERSOFTWAREINTERRUPT": Initialize=218
    "P_INTERRUPTVECTOR": Initialize=219
    "P_ATOMICREAD": Initialize=220
    "P_ATOMICWRITE": Initialize=221
    "P_ATOMICADD": Initialize=222
    "P_ATOMICSUBTRACT": Initialize=223
    "P_ATOMICCOMPARESWAP": Initialize=224
    "P_ATOMICEXCHANGE": Initialize=225
    "P_COMPILERFENCE": Initialize=226
    "P_CACHEINVALIDATE": Initialize=227
    "P_CACHEFLUSH": Initialize=228
    "P_TLBINVALIDATE": Initialize=229
    "P_TLBFLUSH": Initialize=230
    "P_PHYSICALMEMORY": Initialize=231
    "P_INLINEASSEMBLY": Initialize=232
    "P_ASSEMBLY": Initialize=233
    "P_VOLATILE": Initialize=234
    "P_BARRIER": Initialize=235
    "P_PRIVILEGELEVEL": Initialize=236
    "P_TASKSWITCH": Initialize=237
    "P_PROCESSCONTEXT": Initialize=238
    "P_DEVICEDRIVER": Initialize=239
    "P_DEVICEREGISTER": Initialize=240
    "P_DMAOPERATION": Initialize=241
    "P_MMIOREAD": Initialize=242
    "P_MMIOWRITE": Initialize=243
    "P_DEVICEINTERRUPT": Initialize=244
    "P_BOOTLOADER": Initialize=245
    "P_KERNELENTRY": Initialize=246
    "P_INITIALIZATION": Initialize=247
    "P_GLOBALCONSTRUCTORS": Initialize=248
    "P_GLOBALDESTRUCTORS": Initialize=249
    "P_PAGETABLE": Initialize=250
    "P_VIRTUALMEMORY": Initialize=251
    "P_MMIO": Initialize=252
    "P_CACHE": Initialize=253
    "P_TLB": Initialize=254
    "P_MEMORYBARRIER": Initialize=255
    "P_READONLY": Initialize=256
    "P_READWRITE": Initialize=257
    "P_READEXECUTE": Initialize=258
    "P_READWRITEEXECUTE": Initialize=259
    "P_USERMODE": Initialize=260
    "P_KERNELMODE": Initialize=261
    "P_GLOBAL": Initialize=262
    "P_DIRTY": Initialize=263
    "P_ACCESSED": Initialize=264
    "P_CACHED": Initialize=265
    "P_UNCACHED": Initialize=266
    "P_WRITECOMBINING": Initialize=267
    "P_WRITETHROUGH": Initialize=268
    "P_WRITEBACK": Initialize=269
    "P_L1CACHE": Initialize=270
    "P_L2CACHE": Initialize=271
    "P_L3CACHE": Initialize=272
    "P_PAGESIZE4KB": Initialize=273
    "P_PAGESIZE2MB": Initialize=274
    "P_PAGESIZE1GB": Initialize=275
    "P_INVALIDATE": Initialize=276
    "P_FLUSH": Initialize=277
    "P_FLUSHALL": Initialize=278
    "P_FLUSHGLOBAL": Initialize=279
    "P_FUNCTION": Initialize=280
    "P_LAMBDA": Initialize=281
    "P_APPLY": Initialize=282
    "P_COMBINATOR": Initialize=283
    "P_INPUT": Initialize=284
    "P_OUTPUT": Initialize=285
    "P_BODY": Initialize=286
    "P_CURRY": Initialize=287
    "P_UNCURRY": Initialize=288
    "P_COMPOSE": Initialize=289
    "P_INTEGER": Initialize=290
    "P_FLOATINGPOINT": Initialize=291
    "P_TEXT": Initialize=292
    "P_BOOLEAN": Initialize=293
    "P_ADDRESS": Initialize=294
    "P_ARRAY": Initialize=295
    "P_MAP": Initialize=296
    "P_TUPLE": Initialize=297
    "P_RECORD": Initialize=298
    "P_OPTIONALTYPE": Initialize=299
    "P_CONSTRAINEDTYPE": Initialize=300
    "P_ANY": Initialize=301
    "P_VOID": Initialize=302
    "P_BYTE": Initialize=303
    "P_WORD": Initialize=304
    "P_DWORD": Initialize=305
    "P_QWORD": Initialize=306
    "P_UINT8": Initialize=307
    "P_UINT16": Initialize=308
    "P_UINT32": Initialize=309
    "P_UINT64": Initialize=310
    "P_INT8": Initialize=311
    "P_INT16": Initialize=312
    "P_INT32": Initialize=313
    "P_INT64": Initialize=314
    "P_MACROBLOCK": Initialize=315
    "P_MACRO": Initialize=316
    "P_RUNMACRO": Initialize=317
    "P_EXPANDMACRO": Initialize=318
    "P_SECURITYCONTEXT": Initialize=319
    "P_WITHSECURITY": Initialize=320
    "P_ALLOWEDOPERATIONS": Initialize=321
    "P_DENIEDOPERATIONS": Initialize=322
    "P_MEMORYLIMIT": Initialize=323
    "P_CPUQUOTA": Initialize=324
    "P_LEVEL": Initialize=325
    "P_HARDWARE": Initialize=326
    "P_SYSCALL": Initialize=327
    "P_INTERRUPT": Initialize=328
    "P_REGISTER": Initialize=329
    "P_MEMORY": Initialize=330
    "P_PHYSICALADDRESS": Initialize=331
    "P_VIRTUALADDRESS": Initialize=332
    "P_FLAGS": Initialize=333
    "P_SUBROUTINE": Initialize=334
    "P_LIBRARYIMPORT": Initialize=335
    "P_LOOPMAIN": Initialize=336
    "P_LOOPACTOR": Initialize=337
    "P_LOOPSTART": Initialize=338
    "P_LOOPEND": Initialize=339
    "P_LOOPSHADOW": Initialize=340
    "P_TRUE": Initialize=341
    "P_FALSE": Initialize=342
    "P_NULL": Initialize=343
    "P_AUTOMATIC": Initialize=344
    "P_UNLIMITED": Initialize=345
    "P_CONSTANT": Initialize=346
    "P_PI": Initialize=347
    "P_E": Initialize=348
    "P_PHI": Initialize=349
    "P_BYTES": Initialize=350
    "P_KILOBYTES": Initialize=351
    "P_MEGABYTES": Initialize=352
    "P_GIGABYTES": Initialize=353
    "P_SECONDS": Initialize=354
    "P_MILLISECONDS": Initialize=355
    "P_MICROSECONDS": Initialize=356
    "P_PERCENT": Initialize=357
    "P_DOT": Initialize=358
    "P_LBRACE": Initialize=359
    "P_RBRACE": Initialize=360
    "P_LPAREN": Initialize=361
    "P_RPAREN": Initialize=362
    "P_LBRACKET": Initialize=363
    "P_RBRACKET": Initialize=364
    "P_COMMA": Initialize=365
    "P_COLON": Initialize=366
    "P_SEMICOLON": Initialize=367
    "P_DASH": Initialize=368
    "P_EQUALS": Initialize=369
    "P_ARROW": Initialize=370
    "P_IDENTIFIER": Initialize=371
    "P_NUMBER": Initialize=372
    "P_STRING": Initialize=373
    "P_COMMENT": Initialize=374
    "P_DOC_COMMENT": Initialize=375
    "P_COM_COMMENT": Initialize=376
    "P_TAG_COMMENT": Initialize=377
    "P_EOF": Initialize=378
    "P_NEWLINE": Initialize=379
    "P_ERROR": Initialize=380
    "P_PRINTNUMBER": Initialize=381
    "P_LOOPSPAWN": Initialize=387
    "P_LOOPYIELD": Initialize=388
    "P_LOOPSEND": Initialize=389
    "P_LOOPRECEIVE": Initialize=390
    "P_LOOPREPLY": Initialize=391
    "P_INLINEASM": Initialize=392
}


// =============================================================================
// PARSER STATE
// =============================================================================
FixedPool.PParser {
    "p_pos": Initialize=0, CanChange=True
    "p_token_count": Initialize=0, CanChange=True
    "p_current_type": Initialize=0, CanChange=True
    "p_current_value": Initialize=0, CanChange=True
    "p_current_line": Initialize=0, CanChange=True
    "p_current_col": Initialize=0, CanChange=True
    "p_error": Initialize=0, CanChange=True
    "p_error_msg": Initialize=0, CanChange=True
    "p_error_line": Initialize=0, CanChange=True
    "p_error_col": Initialize=0, CanChange=True
    "p_context_stack": Initialize=0, CanChange=True
    "p_context_depth": Initialize=0, CanChange=True
    "p_ast_root": Initialize=0, CanChange=True
    "p_node_count": Initialize=0, CanChange=True
    "p_strict_mode": Initialize=1, CanChange=True
}

// =============================================================================
// OPERATOR PRECEDENCE
// =============================================================================
FixedPool.PPrecedence {
    "P_NONE": Initialize=0
    "P_ASSIGNMENT": Initialize=1
    "P_OR": Initialize=2
    "P_AND": Initialize=3
    "P_EQUALITY": Initialize=4
    "P_COMPARISON": Initialize=5
    "P_TERM": Initialize=6
    "P_FACTOR": Initialize=7
    "P_UNARY": Initialize=8
    "P_CALL": Initialize=9
    "P_PRIMARY": Initialize=10
}

// =============================================================================
// PARSER INITIALIZATION
// =============================================================================
Function.Parse_Init {
    Input: token_count: Integer
    Body: {
        PParser.p_pos = 0
        PParser.p_token_count = token_count
        PParser.p_error = 0
        PParser.p_error_msg = 0
        PParser.p_error_line = 0
        PParser.p_error_col = 0
        PParser.p_ast_root = 0
        PParser.p_node_count = 0
        PParser.p_context_depth = 0
        
        // Create context stack for error messages
        PParser.p_context_stack = XArray.XCreate(ASTState.max_depth)
        
        // Cache first token
        IfCondition GreaterThan(token_count, 0) ThenBlock: {
            Parse_UpdateCurrent()
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// PARSER CLEANUP
// =============================================================================
Function.Parse_Free {
    Body: {
        IfCondition NotEqual(PParser.p_context_stack, 0) ThenBlock: {
            XArray.XDestroy(PParser.p_context_stack)
            PParser.p_context_stack = 0
        }
        PParser.p_context_depth = 0
    }
}

// =============================================================================
// TOKEN CACHE UPDATE
// Refreshes current token info from lexer token stream
// =============================================================================
Function.Parse_UpdateCurrent {
    Body: {
        IfCondition GreaterEqual(PParser.p_pos, PParser.p_token_count) ThenBlock: {
            PParser.p_current_type = PToken.P_EOF
            PParser.p_current_value = 0
            PParser.p_current_line = 0
            PParser.p_current_col = 0
            ReturnValue(0)
        }
        
        PParser.p_current_type = Lex_GetType(PParser.p_pos)
        PParser.p_current_value = Lex_GetVal(PParser.p_pos)
        PParser.p_current_line = Lex_GetLine(PParser.p_pos)
        PParser.p_current_col = Lex_GetCol(PParser.p_pos)
        
        ReturnValue(1)
    }
}

// =============================================================================
// TOKEN NAVIGATION
// =============================================================================

// Get current token type
Function.Parse_CurrentType {
    Output: Integer
    Body: {
        ReturnValue(PParser.p_current_type)
    }
}

// Get current token value
Function.Parse_CurrentValue {
    Output: Address
    Body: {
        ReturnValue(PParser.p_current_value)
    }
}

// Get current token line
Function.Parse_CurrentLine {
    Output: Integer
    Body: {
        ReturnValue(PParser.p_current_line)
    }
}

// Get current token column
Function.Parse_CurrentCol {
    Output: Integer
    Body: {
        ReturnValue(PParser.p_current_col)
    }
}

// Advance to next token
Function.Parse_Advance {
    Body: {
        IfCondition LessThan(PParser.p_pos, PParser.p_token_count) ThenBlock: {
            PParser.p_pos = Add(PParser.p_pos, 1)
            Parse_UpdateCurrent()
        }
    }
}

// Peek at token type at offset from current
Function.Parse_Peek {
    Input: offset: Integer
    Output: Integer
    Body: {
        peek_pos = Add(PParser.p_pos, offset)
        IfCondition GreaterEqual(peek_pos, PParser.p_token_count) ThenBlock: {
            ReturnValue(PToken.P_EOF)
        }
        tok_type = Lex_GetType(peek_pos)
        ReturnValue(tok_type)
    }
}

// Peek at token value at offset from current
Function.Parse_PeekValue {
    Input: offset: Integer
    Output: Address
    Body: {
        peek_pos = Add(PParser.p_pos, offset)
        IfCondition GreaterEqual(peek_pos, PParser.p_token_count) ThenBlock: {
            ReturnValue(0)
        }
        tok_val = Lex_GetVal(peek_pos)
        ReturnValue(tok_val)
    }
}

// Peek at token line at offset
Function.Parse_PeekLine {
    Input: offset: Integer
    Output: Integer
    Body: {
        peek_pos = Add(PParser.p_pos, offset)
        IfCondition GreaterEqual(peek_pos, PParser.p_token_count) ThenBlock: {
            ReturnValue(0)
        }
        tok_line = Lex_GetLine(peek_pos)
        ReturnValue(tok_line)
    }
}

// =============================================================================
// TOKEN MATCHING
// =============================================================================

// Check if current token matches type (doesn't consume)
Function.Parse_Check {
    Input: token_type: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(PParser.p_current_type, token_type) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Check if current token matches type and advance if so
Function.Parse_Match {
    Input: token_type: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(PParser.p_current_type, token_type) ThenBlock: {
            Parse_Advance()
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Consume expected token or error
Function.Parse_Consume {
    Input: token_type: Integer
    Input: error_msg: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(PParser.p_current_type, token_type) ThenBlock: {
            Parse_Advance()
            ReturnValue(1)
        }
        
        // Build error message with expected vs got
        Parse_Error(error_msg)
        ReturnValue(0)
    }
}

// Consume and return the value (for identifiers, strings, numbers)
Function.Parse_ConsumeValue {
    Input: token_type: Integer
    Input: error_msg: Address
    Output: Address
    Body: {
        IfCondition EqualTo(PParser.p_current_type, token_type) ThenBlock: {
            value = PParser.p_current_value
            Parse_Advance()
            ReturnValue(value)
        }
        
        Parse_Error(error_msg)
        ReturnValue(0)
    }
}

// =============================================================================
// NEWLINE HANDLING
// =============================================================================

// Skip any newline tokens
Function.Parse_SkipNewlines {
    Body: {
        WhileLoop EqualTo(PParser.p_current_type, PToken.P_NEWLINE) {
            Parse_Advance()
        }
    }
}

// Skip newlines and comments
Function.Parse_SkipWhitespace {
    Body: {
        done = 0
        WhileLoop EqualTo(done, 0) {
            IfCondition EqualTo(PParser.p_current_type, PToken.P_NEWLINE) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(PParser.p_current_type, PToken.P_COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(PParser.p_current_type, PToken.P_DOC_COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(PParser.p_current_type, PToken.P_COM_COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            IfCondition EqualTo(PParser.p_current_type, PToken.P_TAG_COMMENT) ThenBlock: {
                Parse_Advance()
                ContinueLoop
            }
            done = 1
        }
    }
}

// =============================================================================
// CONTEXT STACK (for error messages)
// =============================================================================

// Push a context onto the stack (e.g., "Function.Main", "WhileLoop")
Function.Parse_PushContext {
    Input: context: Address
    Body: {
        IfCondition LessThan(PParser.p_context_depth, ASTState.max_depth) ThenBlock: {
            XArray.XSet(PParser.p_context_stack, PParser.p_context_depth, context)
            PParser.p_context_depth = Add(PParser.p_context_depth, 1)
        }
    }
}

// Pop context from stack
Function.Parse_PopContext {
    Body: {
        IfCondition GreaterThan(PParser.p_context_depth, 0) ThenBlock: {
            PParser.p_context_depth = Subtract(PParser.p_context_depth, 1)
        }
    }
}

// Get current context string for error messages
Function.Parse_GetContext {
    Output: Address
    Body: {
        IfCondition EqualTo(PParser.p_context_depth, 0) ThenBlock: {
            ReturnValue("top level")
        }
        
        // Return the most recent context
        idx = Subtract(PParser.p_context_depth, 1)
        ctx = XArray.XGet(PParser.p_context_stack, idx)
        ReturnValue(ctx)
    }
}

// =============================================================================
// ERROR HANDLING
// =============================================================================

// Report error at current position
Function.Parse_Error {
    Input: msg: Address
    Body: {
        // Only record first error
        IfCondition EqualTo(PParser.p_error, 0) ThenBlock: {
            PParser.p_error = 1
            PParser.p_error_msg = msg
            PParser.p_error_line = PParser.p_current_line
            PParser.p_error_col = PParser.p_current_col
        }
        
        // Print error immediately for debugging
        PrintMessage("PARSE ERROR at line ")
        PrintNumber(PParser.p_current_line)
        PrintMessage(", col ")
        PrintNumber(PParser.p_current_col)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
        
        // Show context
        ctx = Parse_GetContext()
        PrintMessage("  In: ")
        PrintMessage(ctx)
        PrintMessage("\n")
        
        // Show current token
        PrintMessage("  Got token type: ")
        PrintNumber(PParser.p_current_type)
        IfCondition NotEqual(PParser.p_current_value, 0) ThenBlock: {
            PrintMessage(" value: \"")
            PrintMessage(PParser.p_current_value)
            PrintMessage("\"")
        }
        PrintMessage("\n")
    }
}

// Report error at specific position
Function.Parse_ErrorAt {
    Input: msg: Address
    Input: line: Integer
    Input: col: Integer
    Body: {
        IfCondition EqualTo(PParser.p_error, 0) ThenBlock: {
            PParser.p_error = 1
            PParser.p_error_msg = msg
            PParser.p_error_line = line
            PParser.p_error_col = col
        }
        
        PrintMessage("PARSE ERROR at line ")
        PrintNumber(line)
        PrintMessage(", col ")
        PrintNumber(col)
        PrintMessage(": ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

// Check if parser is in error state
Function.Parse_HasError {
    Output: Integer
    Body: {
        ReturnValue(PParser.p_error)
    }
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

// Check if at end of tokens
Function.Parse_AtEnd {
    Output: Integer
    Body: {
        IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition GreaterEqual(PParser.p_pos, PParser.p_token_count) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Check if current token is a statement terminator
Function.Parse_AtStatementEnd {
    Output: Integer
    Body: {
        IfCondition EqualTo(PParser.p_current_type, PToken.P_NEWLINE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(PParser.p_current_type, PToken.P_RBRACE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// Check if current token starts an expression
Function.Parse_AtExpressionStart {
    Output: Integer
    Body: {
        // Identifiers
        IfCondition EqualTo(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            ReturnValue(1)
        }
        // Literals
        IfCondition EqualTo(PParser.p_current_type, PToken.P_NUMBER) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(PParser.p_current_type, PToken.P_STRING) ThenBlock: {
            ReturnValue(1)
        }
        // Parenthesized expression
        IfCondition EqualTo(PParser.p_current_type, PToken.P_LPAREN) ThenBlock: {
            ReturnValue(1)
        }
        // Keywords that are expressions (True, False, Null)
        IfCondition EqualTo(PParser.p_current_type, PToken.P_TRUE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(PParser.p_current_type, PToken.P_FALSE) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(PParser.p_current_type, PToken.P_NULL) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// Check if current token is a keyword that starts a statement
Function.Parse_AtStatementStart {
    Output: Integer
    Body: {
        t = PParser.p_current_type
        
        // Control flow
        IfCondition EqualTo(t, PToken.P_IFCONDITION) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, PToken.P_WHILELOOP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, PToken.P_RETURNVALUE) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, PToken.P_BREAKLOOP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, PToken.P_CONTINUELOOP) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, PToken.P_TRYBLOCK) ThenBlock: { ReturnValue(1) }
        
        // I/O
        IfCondition EqualTo(t, PToken.P_PRINTMESSAGE) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(t, PToken.P_PRINTNUMBER) ThenBlock: { ReturnValue(1) }
        
        // Task/concurrency
        IfCondition EqualTo(t, PToken.P_RUNTASK) ThenBlock: { ReturnValue(1) }
        
        // Debug
        IfCondition EqualTo(t, PToken.P_DEBUGASSERT) ThenBlock: { ReturnValue(1) }
        
        // Identifiers (assignments, function calls)
        IfCondition EqualTo(t, PToken.P_IDENTIFIER) ThenBlock: { ReturnValue(1) }
        
        ReturnValue(0)
    }
}

// =============================================================================
// TOKEN TYPE NAME (for debugging)
// =============================================================================
Function.Parse_TokenTypeName {
    Input: tok_type: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(tok_type, PToken.P_EOF) ThenBlock: { ReturnValue("EOF") }
        IfCondition EqualTo(tok_type, PToken.P_NEWLINE) ThenBlock: { ReturnValue("NEWLINE") }
        IfCondition EqualTo(tok_type, PToken.P_IDENTIFIER) ThenBlock: { ReturnValue("IDENTIFIER") }
        IfCondition EqualTo(tok_type, PToken.P_NUMBER) ThenBlock: { ReturnValue("NUMBER") }
        IfCondition EqualTo(tok_type, PToken.P_STRING) ThenBlock: { ReturnValue("STRING") }
        IfCondition EqualTo(tok_type, PToken.P_LBRACE) ThenBlock: { ReturnValue("LBRACE") }
        IfCondition EqualTo(tok_type, PToken.P_RBRACE) ThenBlock: { ReturnValue("RBRACE") }
        IfCondition EqualTo(tok_type, PToken.P_LPAREN) ThenBlock: { ReturnValue("LPAREN") }
        IfCondition EqualTo(tok_type, PToken.P_RPAREN) ThenBlock: { ReturnValue("RPAREN") }
        IfCondition EqualTo(tok_type, PToken.P_COMMA) ThenBlock: { ReturnValue("COMMA") }
        IfCondition EqualTo(tok_type, PToken.P_COLON) ThenBlock: { ReturnValue("COLON") }
        IfCondition EqualTo(tok_type, PToken.P_EQUALS) ThenBlock: { ReturnValue("EQUALS") }
        IfCondition EqualTo(tok_type, PToken.P_DOT) ThenBlock: { ReturnValue("DOT") }
        
        // Return generic for unknown
        ReturnValue("TOKEN")
    }
}