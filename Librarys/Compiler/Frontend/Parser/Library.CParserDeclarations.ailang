// Library.CParserDeclarations.ailang
// Top-level declaration parsing for the AILang self-hosting compiler
// Handles: Function, SubRoutine, Pools, LibraryImport, Loop types

LibraryImport.XArrays

LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes

LibraryImport.Compiler.Frontend.Parser.CParserCore
LibraryImport.Compiler.Frontend.Parser.CParserExpressions
LibraryImport.Compiler.Frontend.Parser.CParserStatements

// =============================================================================
// MAIN DECLARATION DISPATCHER
// =============================================================================

// Parse a top-level declaration
Function.Parse_Declaration {
    Output: Address
    Body: {
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        t = PParser.p_current_type
        
        // End of file
        IfCondition EqualTo(t, PToken.P_EOF) ThenBlock: {
            ReturnValue(0)
        }
        
        // Skip comments at top level
        IfCondition EqualTo(t, PToken.P_COMMENT) ThenBlock: {
            Parse_Advance()
            ReturnValue(0)
        }
        IfCondition EqualTo(t, PToken.P_DOC_COMMENT) ThenBlock: {
            Parse_Advance()
            ReturnValue(0)
        }
        IfCondition EqualTo(t, PToken.P_COM_COMMENT) ThenBlock: {
            Parse_Advance()
            ReturnValue(0)
        }
        IfCondition EqualTo(t, PToken.P_TAG_COMMENT) ThenBlock: {
            Parse_Advance()
            ReturnValue(0)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Library Import
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_LIBRARYIMPORT) ThenBlock: {
            ReturnValue(Parse_LibraryImport())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // LinkagePool (special case - before other pools)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_LINKAGEPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_LINKAGE))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Pool Declarations (all types)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_FIXEDPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_FIXED))
        }
        IfCondition EqualTo(t, PToken.P_DYNAMICPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_DYNAMIC))
        }
        IfCondition EqualTo(t, PToken.P_TEMPORALPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_TEMPORAL))
        }
        IfCondition EqualTo(t, PToken.P_NEURALPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_NEURAL))
        }
        IfCondition EqualTo(t, PToken.P_KERNELPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_KERNEL))
        }
        IfCondition EqualTo(t, PToken.P_ACTORPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_ACTOR))
        }
        IfCondition EqualTo(t, PToken.P_SECURITYPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_SECURITY))
        }
        IfCondition EqualTo(t, PToken.P_CONSTRAINEDPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_CONSTRAINED))
        }
        IfCondition EqualTo(t, PToken.P_FILEPOOL) ThenBlock: {
            ReturnValue(Parse_Pool(AST.POOL_FILE))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Loop Declarations (Actor system)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_LOOPMAIN) ThenBlock: {
            ReturnValue(Parse_Loop(AST.LOOP_MAIN))
        }
        IfCondition EqualTo(t, PToken.P_LOOPACTOR) ThenBlock: {
            ReturnValue(Parse_Loop(AST.LOOP_ACTOR))
        }
        IfCondition EqualTo(t, PToken.P_LOOPSTART) ThenBlock: {
            ReturnValue(Parse_Loop(AST.LOOP_START))
        }
        IfCondition EqualTo(t, PToken.P_LOOPSHADOW) ThenBlock: {
            ReturnValue(Parse_Loop(AST.LOOP_SHADOW))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // SubRoutine Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_SUBROUTINE) ThenBlock: {
            ReturnValue(Parse_SubRoutine())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Function Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_FUNCTION) ThenBlock: {
            ReturnValue(Parse_Function())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Combinator Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_COMBINATOR) ThenBlock: {
            ReturnValue(Parse_Combinator())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // MacroBlock Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_MACROBLOCK) ThenBlock: {
            ReturnValue(Parse_MacroBlock())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // SecurityContext Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_SECURITYCONTEXT) ThenBlock: {
            ReturnValue(Parse_SecurityContext())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // ConstrainedType Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_CONSTRAINEDTYPE) ThenBlock: {
            ReturnValue(Parse_ConstrainedType())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Constant Declaration
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_CONSTANT) ThenBlock: {
            ReturnValue(Parse_Constant())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // AcronymDefinitions (identifier check)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_IDENTIFIER) ThenBlock: {
            IfCondition EqualTo(StringCompare(PParser.p_current_value, "AcronymDefinitions"), 0) ThenBlock: {
                ReturnValue(Parse_AcronymDefinitions())
            }
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Low-Level Declarations
        // ─────────────────────────────────────────────────────────────────────
        // TODO: Add these when P_* tokens are defined
        // InterruptHandler, DeviceDriver, Bootloader, KernelEntry
        
        // ─────────────────────────────────────────────────────────────────────
        // FALLBACK: Any other token - try parsing as a statement
        // This matches Python parser's: else: stmt = self.parse_statement()
        // Allows RunTask(), Debug(), assignments, etc. at top level
        // ─────────────────────────────────────────────────────────────────────
        stmt = Parse_Statement()
        IfCondition NotEqual(stmt, 0) ThenBlock: {
            ReturnValue(stmt)
        }
        
        // If statement parsing also failed, report error and advance
        IfCondition EqualTo(Parse_HasError(), 0) ThenBlock: {
            Parse_Error("Unexpected token at top level")
        }
        Parse_Advance()
        ReturnValue(0)
    }
}

// =============================================================================
// LIBRARY IMPORT
// =============================================================================

// Parse: LibraryImport.Path.To.Module
Function.Parse_LibraryImport {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_LIBRARYIMPORT, "Expected 'LibraryImport'")
        Parse_Consume(PToken.P_DOT, "Expected '.' after LibraryImport")
        
        // Read the import path (may be dotted)
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected module path after LibraryImport.")
            ReturnValue(0)
        }
        
        // The lexer may have combined the entire path already
        path = PParser.p_current_value
        Parse_Advance()
        
        node = AST_Create(AST.LIBRARY_IMPORT)
        AST_SetData1(node, path)
        
        ReturnValue(node)
    }
}

// =============================================================================
// FUNCTION DECLARATION
// =============================================================================

// Parse: Function.Name { Input: ..., Output: ..., Body: { ... } }
Function.Parse_Function {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_FUNCTION, "Expected 'Function'")
        Parse_Consume(PToken.P_DOT, "Expected '.' after Function")
        
        // Get function name (may be dotted like Module.FuncName)
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected function name")
            ReturnValue(0)
        }
        func_name = PParser.p_current_value
        Parse_Advance()
        
        Parse_PushContext(func_name)
        Parse_SkipNewlines()
        Parse_Consume(PToken.P_LBRACE, "Expected '{' after function name")
        Parse_SkipNewlines()
        
        // Create function node
        node = AST_Create(AST.FUNCTION)
        AST_SetData1(node, func_name)
        
        // Parse function sections: Input, Output, Body
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
            IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in function")
                ExitLoop
            }
            
            Parse_SkipNewlines()
            t = PParser.p_current_type
            
            // Input: parameters
            IfCondition EqualTo(t, PToken.P_INPUT) ThenBlock: {
                Parse_FunctionInput(node)
                ContinueLoop
            }
            
            // Output: type
            IfCondition EqualTo(t, PToken.P_OUTPUT) ThenBlock: {
                Parse_FunctionOutput(node)
                ContinueLoop
            }
            
            // Body: { statements }
            IfCondition EqualTo(t, PToken.P_BODY) ThenBlock: {
                Parse_FunctionBody(node)
                ContinueLoop
            }
            
            // Skip unknown/whitespace
            Parse_Advance()
            Parse_SkipNewlines()
        }
        
        Parse_Consume(PToken.P_RBRACE, "Expected '}' after function")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// Parse function input parameters
Function.Parse_FunctionInput {
    Input: node: Address
    Body: {
        Parse_Consume(PToken.P_INPUT, "Expected 'Input'")
        Parse_Consume(PToken.P_COLON, "Expected ':'")
        
        // Single parameter or parenthesized list
        IfCondition EqualTo(PParser.p_current_type, PToken.P_LPAREN) ThenBlock: {
            // Multiple parameters: Input: (name: Type, name2: Type)
            Parse_Advance()
            Parse_SkipNewlines()
            
            WhileLoop NotEqual(PParser.p_current_type, PToken.P_RPAREN) {
                param = Parse_Parameter()
                IfCondition NotEqual(param, 0) ThenBlock: {
                    AST_AddChild(node, param)
                }
                
                IfCondition EqualTo(PParser.p_current_type, PToken.P_COMMA) ThenBlock: {
                    Parse_Advance()
                    Parse_SkipNewlines()
                }
            }
            Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        } ElseBlock: {
            // Single parameter: Input: name: Type
            param = Parse_Parameter()
            IfCondition NotEqual(param, 0) ThenBlock: {
                AST_AddChild(node, param)
            }
        }
        
        Parse_SkipNewlines()
    }
}

// Parse function output type
Function.Parse_FunctionOutput {
    Input: node: Address
    Body: {
        Parse_Consume(PToken.P_OUTPUT, "Expected 'Output'")
        Parse_Consume(PToken.P_COLON, "Expected ':'")
        
        // Parse type
        type_node = Parse_Type()
        AST_SetData2(node, type_node)
        
        Parse_SkipNewlines()
    }
}

// Parse function body
Function.Parse_FunctionBody {
    Input: node: Address
    Body: {
        Parse_Consume(PToken.P_BODY, "Expected 'Body'")
        Parse_Consume(PToken.P_COLON, "Expected ':'")
        Parse_SkipNewlines()
        
        // Parse body block
        body = Parse_Block()
        AST_AddChild(node, body)
        
        Parse_SkipNewlines()
    }
}

// =============================================================================
// PARAMETER PARSING
// =============================================================================

// Parse: name: Type
Function.Parse_Parameter {
    Output: Address
    Body: {
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected parameter name")
            ReturnValue(0)
        }
        
        param_name = PParser.p_current_value
        Parse_Advance()
        
        // Optional type annotation
        param_type = 0
        IfCondition EqualTo(PParser.p_current_type, PToken.P_COLON) ThenBlock: {
            Parse_Advance()
            param_type = Parse_Type()
        }
        
        node = AST_MakeParameter(param_name, param_type)
        ReturnValue(node)
    }
}

// =============================================================================
// TYPE PARSING
// =============================================================================

// Parse a type expression
Function.Parse_Type {
    Output: Address
    Body: {
        t = PParser.p_current_type
        
        // Built-in types
        IfCondition EqualTo(t, PToken.P_INTEGER) ThenBlock: {
            Parse_Advance()
            ReturnValue(AST.TYPE_INTEGER)
        }
        IfCondition EqualTo(t, PToken.P_ADDRESS) ThenBlock: {
            Parse_Advance()
            ReturnValue(AST.TYPE_ADDRESS)
        }
        IfCondition EqualTo(t, PToken.P_TEXT) ThenBlock: {
            Parse_Advance()
            ReturnValue(AST.TYPE_TEXT)
        }
        IfCondition EqualTo(t, PToken.P_BOOLEAN) ThenBlock: {
            Parse_Advance()
            ReturnValue(AST.TYPE_BOOLEAN)
        }
        IfCondition EqualTo(t, PToken.P_VOID) ThenBlock: {
            Parse_Advance()
            ReturnValue(AST.TYPE_VOID)
        }
        IfCondition EqualTo(t, PToken.P_ANY) ThenBlock: {
            Parse_Advance()
            ReturnValue(AST.TYPE_ANY)
        }
        
        // Custom type (identifier)
        IfCondition EqualTo(t, PToken.P_IDENTIFIER) ThenBlock: {
            type_name = PParser.p_current_value
            Parse_Advance()
            
            // Create custom type node
            node = AST_Create(AST.TYPE_CUSTOM)
            AST_SetData1(node, type_name)
            ReturnValue(node)
        }
        
        // Default to Any
        ReturnValue(AST.TYPE_ANY)
    }
}

// =============================================================================
// SUBROUTINE DECLARATION
// =============================================================================

// Parse: SubRoutine.Name { Body: { ... } } or SubRoutine.Name { ... }
Function.Parse_SubRoutine {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_SUBROUTINE, "Expected 'SubRoutine'")
        Parse_Consume(PToken.P_DOT, "Expected '.' after SubRoutine")
        
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected subroutine name")
            ReturnValue(0)
        }
        sub_name = PParser.p_current_value
        Parse_Advance()
        
        Parse_PushContext(sub_name)
        Parse_SkipNewlines()
        Parse_Consume(PToken.P_LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_MakeSubRoutine(sub_name)
        
        // SubRoutines can have:
        // 1. Direct body statements
        // 2. Body: { ... } wrapper
        IfCondition EqualTo(PParser.p_current_type, PToken.P_BODY) ThenBlock: {
            Parse_Advance()
            Parse_Consume(PToken.P_COLON, "Expected ':'")
            body = Parse_Block()
            AST_AddChild(node, body)
        } ElseBlock: {
            // Direct statements
            WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
                IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                    Parse_Error("Unexpected end of file in subroutine")
                    ExitLoop
                }
                
                stmt = Parse_Statement()
                IfCondition NotEqual(stmt, 0) ThenBlock: {
                    AST_AddChild(node, stmt)
                }
                Parse_SkipNewlines()
            }
        }
        
        Parse_Consume(PToken.P_RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// =============================================================================
// COMBINATOR DECLARATION
// =============================================================================
Function.Parse_Combinator {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_COMBINATOR, "Expected 'Combinator'")
        Parse_Error("Combinator not yet implemented")
        ReturnValue(0)
    }
}

// =============================================================================
// POOL DECLARATIONS
// =============================================================================

// Parse: PoolType.Name { members... }
Function.Parse_Pool {
    Input: pool_type: Integer
    Output: Address
    Body: {
        Parse_Advance()  // consume pool keyword
        Parse_Consume(PToken.P_DOT, "Expected '.' after pool type")
        
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected pool name")
            ReturnValue(0)
        }
        pool_name = PParser.p_current_value
        Parse_Advance()
        
        Parse_PushContext(pool_name)
        Parse_SkipNewlines()
        Parse_Consume(PToken.P_LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_Create(pool_type)
        AST_SetData1(node, pool_name)
        
        // Parse pool members
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
            IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in pool")
                ExitLoop
            }
            
            Parse_SkipNewlines()
            
            // Members are string keys: "name": Initialize=value, CanChange=True
            IfCondition EqualTo(PParser.p_current_type, PToken.P_STRING) ThenBlock: {
                member = Parse_PoolMember()
                IfCondition NotEqual(member, 0) ThenBlock: {
                    AST_AddChild(node, member)
                }
            } ElseBlock: {
                Parse_Advance()  // skip unknown
            }
            
            Parse_SkipNewlines()
        }
        
        Parse_Consume(PToken.P_RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// Parse pool member: "key": Initialize=value, CanChange=True/False
Function.Parse_PoolMember {
    Output: Address
    Body: {
        // Get key (string)
        IfCondition NotEqual(PParser.p_current_type, PToken.P_STRING) ThenBlock: {
            Parse_Error("Expected string key for pool member")
            ReturnValue(0)
        }
        key = PParser.p_current_value
        Parse_Advance()
        
        Parse_Consume(PToken.P_COLON, "Expected ':' after member key")
        
        node = AST_Create(AST.POOL_MEMBER)
        AST_SetData1(node, key)
        
        // Parse attributes: Initialize=value, CanChange=True, etc.
        has_attrs = 1
        WhileLoop EqualTo(has_attrs, 1) {
            Parse_SkipNewlines()
            
            IfCondition EqualTo(PParser.p_current_type, PToken.P_INITIALIZE) ThenBlock: {
                Parse_Advance()
                Parse_Consume(PToken.P_EQUALS, "Expected '='")
                
                // Parse value (number, string, or identifier)
                init_value = Parse_Expression()
                AST_SetData2(node, init_value)
                
            } ElseBlock: {
                IfCondition EqualTo(PParser.p_current_type, PToken.P_CANCHANGE) ThenBlock: {
                    Parse_Advance()
                    Parse_Consume(PToken.P_EQUALS, "Expected '='")
                    
                    // True or False
                    IfCondition EqualTo(PParser.p_current_type, PToken.P_TRUE) ThenBlock: {
                        AST_SetData3(node, 1)
                        Parse_Advance()
                    } ElseBlock: {
                        IfCondition EqualTo(PParser.p_current_type, PToken.P_FALSE) ThenBlock: {
                            AST_SetData3(node, 0)
                            Parse_Advance()
                        }
                    }
                } ElseBlock: {
                    has_attrs = 0
                }
            }
            
            // Check for comma (more attributes)
            IfCondition EqualTo(PParser.p_current_type, PToken.P_COMMA) ThenBlock: {
                Parse_Advance()
            } ElseBlock: {
                has_attrs = 0
            }
        }
        
        ReturnValue(node)
    }
}

// =============================================================================
// LOOP DECLARATIONS (Actor System)
// =============================================================================

// Parse: LoopType.Name { ... }
Function.Parse_Loop {
    Input: loop_type: Integer
    Output: Address
    Body: {
        Parse_Advance()  // consume loop keyword
        Parse_Consume(PToken.P_DOT, "Expected '.' after loop type")
        
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected loop name")
            ReturnValue(0)
        }
        loop_name = PParser.p_current_value
        Parse_Advance()
        
        Parse_PushContext(loop_name)
        Parse_SkipNewlines()
        Parse_Consume(PToken.P_LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_Create(loop_type)
        AST_SetData1(node, loop_name)
        
        // Parse loop body
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
            IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in loop")
                ExitLoop
            }
            
            stmt = Parse_Statement()
            IfCondition NotEqual(stmt, 0) ThenBlock: {
                AST_AddChild(node, stmt)
            }
            Parse_SkipNewlines()
        }
        
        Parse_Consume(PToken.P_RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// =============================================================================
// MACRO BLOCK
// =============================================================================

// Parse: MacroBlock.Name { ... }
Function.Parse_MacroBlock {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_MACROBLOCK, "Expected 'MacroBlock'")
        Parse_Consume(PToken.P_DOT, "Expected '.'")
        
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected macro name")
            ReturnValue(0)
        }
        macro_name = PParser.p_current_value
        Parse_Advance()
        
        Parse_PushContext(macro_name)
        Parse_SkipNewlines()
        Parse_Consume(PToken.P_LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        node = AST_Create(AST.MACRO_BLOCK)
        AST_SetData1(node, macro_name)
        
        // Parse macro body (statements)
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
            IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in macro")
                ExitLoop
            }
            
            stmt = Parse_Statement()
            IfCondition NotEqual(stmt, 0) ThenBlock: {
                AST_AddChild(node, stmt)
            }
            Parse_SkipNewlines()
        }
        
        Parse_Consume(PToken.P_RBRACE, "Expected '}'")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// =============================================================================
// SECURITY CONTEXT
// =============================================================================
Function.Parse_SecurityContext {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_SECURITYCONTEXT, "Expected 'SecurityContext'")
        Parse_Error("SecurityContext not yet implemented")
        ReturnValue(0)
    }
}

// =============================================================================
// CONSTRAINED TYPE
// =============================================================================
Function.Parse_ConstrainedType {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_CONSTRAINEDTYPE, "Expected 'ConstrainedType'")
        Parse_Error("ConstrainedType not yet implemented")
        ReturnValue(0)
    }
}

// =============================================================================
// CONSTANT DECLARATION
// =============================================================================
Function.Parse_Constant {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_CONSTANT, "Expected 'Constant'")
        Parse_Error("Constant not yet implemented")
        ReturnValue(0)
    }
}

// =============================================================================
// ACRONYM DEFINITIONS
// =============================================================================
Function.Parse_AcronymDefinitions {
    Output: Address
    Body: {
        Parse_Error("AcronymDefinitions not yet implemented")
        ReturnValue(0)
    }
}

// =============================================================================
// IDENTIFIER DECLARATION (dotted names at top level)
// =============================================================================

// Handle identifiers that might be dotted declarations
Function.Parse_IdentifierDeclaration {
    Output: Address
    Body: {
        // The lexer may have combined "Function.Name" into one identifier
        name = PParser.p_current_value
        
        // Check if it starts with a known declaration prefix
        // This is a simplification - proper parsing would split the identifier
        
        // For now, treat as expression/assignment at top level
        ReturnValue(Parse_ExprOrAssignment())
    }
}

Debug("library.load", level=1) {
    PrintMessage("CParserDeclarations Library loaded successfully!\n")
}