// Library.CParserExpressions.ailang
// Expression parsing for the AILang self-hosting compiler
// Handles: literals, identifiers, calls, member access, operators

LibraryImport.XArrays

LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes

LibraryImport.Compiler.Frontend.Parser.CParserCore

// =============================================================================
// MAIN EXPRESSION ENTRY POINT
// =============================================================================

// Parse any expression
// AILang uses explicit parentheses for binary ops, so no precedence climbing needed
Function.Parse_Expression {
    Output: Address
    Body: {
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        
        // Parse primary expression first
        expr = Parse_Primary()
        
        IfCondition EqualTo(expr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Handle postfix operations: member access and calls
        expr = Parse_Postfix(expr)
        
        ReturnValue(expr)
    }
}

// =============================================================================
// POSTFIX OPERATIONS (member access, function calls)
// =============================================================================

// Parse postfix operators: .member, (args)
Function.Parse_Postfix {
    Input: expr: Address
    Output: Address
    Body: {
        done = 0
        WhileLoop EqualTo(done, 0) {
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(expr)
            }
            
            // Member access: expr.member
            IfCondition EqualTo(PParser.p_current_type, PToken.P_DOT) ThenBlock: {
                Parse_Advance()
                Parse_SkipNewlines()
                
                // Expect identifier after dot
                IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
                    Parse_Error("Expected identifier after '.'")
                    ReturnValue(expr)
                }
                
                member_name = PParser.p_current_value
                Parse_Advance()
                
                expr = AST_MakeMemberAccess(expr, member_name)
                ContinueLoop
            }
            
            // Function call: expr(args)
            IfCondition EqualTo(PParser.p_current_type, PToken.P_LPAREN) ThenBlock: {
                // Only allow calls on identifiers or member access
                node_type = AST_GetType(expr)
                IfCondition Or(EqualTo(node_type, AST.IDENTIFIER), EqualTo(node_type, AST.MEMBER_ACCESS)) ThenBlock: {
                    // Get function name from expression
                    func_name = AST_GetData1(expr)
                    
                    // Parse arguments
                    args = Parse_Arguments()
                    
                    // Create call node (reusing the name)
                    call = AST_MakeCall(func_name, args)
                    
                    // Free the identifier node since we're replacing it
                    AST_Free(expr)
                    XArray.XDestroy(args)
                    
                    expr = call
                    ContinueLoop
                }
            }
            
            // No more postfix operations
            done = 1
        }
        
        ReturnValue(expr)
    }
}

// =============================================================================
// PRIMARY EXPRESSIONS
// =============================================================================

// Parse a primary expression (literals, identifiers, parenthesized)
Function.Parse_Primary {
    Output: Address
    Body: {
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        t = PParser.p_current_type
        
        // ─────────────────────────────────────────────────────────────────────
        // Unary minus: -expr
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_DASH) ThenBlock: {
            Parse_Advance()
            operand = Parse_Primary()
            IfCondition EqualTo(operand, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            // Syntactic sugar: -x becomes Subtract(0, x)
            zero = AST_MakeNumber("0")
            args = XArray.XCreate(4)
            XArray.XPush(args, zero)
            XArray.XPush(args, operand)
            result = AST_MakeCall("Subtract", args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Unary NOT: !expr
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_BANG_SIGN) ThenBlock: {
            Parse_Advance()
            operand = Parse_Primary()
            IfCondition EqualTo(operand, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            args = XArray.XCreate(4)
            XArray.XPush(args, operand)
            result = AST_MakeCall("Not", args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Bitwise NOT: ~expr
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_TILDE_SIGN) ThenBlock: {
            Parse_Advance()
            operand = Parse_Primary()
            IfCondition EqualTo(operand, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            args = XArray.XCreate(4)
            XArray.XPush(args, operand)
            result = AST_MakeCall("BitwiseNot", args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Number literal
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_NUMBER) ThenBlock: {
            value = PParser.p_current_value
            Parse_Advance()
            ReturnValue(AST_MakeNumber(value))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // String literal
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_STRING) ThenBlock: {
            value = PParser.p_current_value
            Parse_Advance()
            ReturnValue(AST_MakeString(value))
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Boolean True
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_TRUE) ThenBlock: {
            Parse_Advance()
            node = AST_Create(AST.BOOLEAN)
            AST_SetData1(node, 1)
            ReturnValue(node)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Boolean False
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_FALSE) ThenBlock: {
            Parse_Advance()
            node = AST_Create(AST.BOOLEAN)
            AST_SetData1(node, 0)
            ReturnValue(node)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Null
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_NULL) ThenBlock: {
            Parse_Advance()
            node = AST_Create(AST.NULL)
            ReturnValue(node)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Identifier (may be dotted: Pool.Field or simple)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_IDENTIFIER) ThenBlock: {
            ReturnValue(Parse_Identifier())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Parenthesized expression or infix operator
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_LPAREN) ThenBlock: {
            ReturnValue(Parse_ParenExpr())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Array literal [...]
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_LBRACKET) ThenBlock: {
            ReturnValue(Parse_ArrayLiteral())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Any keyword with a value followed by ( is a function call
        // Handles ALL builtins: Add, StringLength, Allocate, etc.
        // ─────────────────────────────────────────────────────────────────────
        IfCondition NotEqual(PParser.p_current_value, 0) ThenBlock: {
            next_type = Parse_Peek(1)
            IfCondition EqualTo(next_type, PToken.P_LPAREN) ThenBlock: {
                func_name = PParser.p_current_value
                ReturnValue(Parse_BuiltinCall(func_name))
            }
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Error: unexpected token
        // ─────────────────────────────────────────────────────────────────────
        Parse_Error("Expected expression")
        ReturnValue(0)
    }
}

// =============================================================================
// BUILT-IN FUNCTION CALL
// =============================================================================

// Parse a built-in function call: Keyword(args)
// Works for ANY keyword token that has a value and is followed by (
Function.Parse_BuiltinCall {
    Input: func_name: Address
    Output: Address
    Body: {
        Parse_Advance()  // consume the keyword token
        
        // Parse arguments (this consumes the parens)
        args = Parse_Arguments()
        
        // Create call node
        call = AST_MakeCall(func_name, args)
        XArray.XDestroy(args)
        
        ReturnValue(call)
    }
}


// =============================================================================
// IDENTIFIER PARSING
// =============================================================================

// Parse identifier (handles dotted names from lexer)
Function.Parse_Identifier {
    Output: Address
    Body: {
        // The lexer may have already combined dotted names like "Pool.Field"
        // into a single IDENTIFIER token
        name = PParser.p_current_value
        Parse_Advance()
        
        ReturnValue(AST_MakeIdentifier(name))
    }
}

// =============================================================================
// PARENTHESIZED EXPRESSION / INFIX OPERATORS
// =============================================================================

// Parse (expr) or (expr op expr)
Function.Parse_ParenExpr {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_LPAREN, "Expected '('")
        Parse_SkipNewlines()
        
        // Parse first expression
        expr = Parse_Expression()
        IfCondition EqualTo(expr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        
        // Check if there's an infix operator
        op_name = Parse_GetInfixOp()
        
        IfCondition NotEqual(op_name, 0) ThenBlock: {
            // It's a binary operation: (a op b)
            Parse_Advance()  // consume operator
            Parse_SkipNewlines()
            
            // Parse second operand
            right = Parse_Expression()
            IfCondition EqualTo(right, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            Parse_SkipNewlines()
            Parse_Consume(PToken.P_RPAREN, "Expected ')' after binary expression")
            
            // Build function call: op_name(expr, right)
            args = XArray.XCreate(4)
            XArray.XPush(args, expr)
            XArray.XPush(args, right)
            result = AST_MakeCall(op_name, args)
            XArray.XDestroy(args)
            ReturnValue(result)
        }
        
        // Just a grouped expression: (expr)
        Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        ReturnValue(expr)
    }
}

// =============================================================================
// INFIX OPERATOR DETECTION
// =============================================================================

// Check if current token is an infix operator
// Returns the function name (e.g., "Add") or 0 if not an operator
Function.Parse_GetInfixOp {
    Output: Address
    Body: {
        t = PParser.p_current_type
        
        // Arithmetic
        IfCondition EqualTo(t, PToken.P_PLUS_SIGN) ThenBlock: { ReturnValue("Add") }
        IfCondition EqualTo(t, PToken.P_DASH) ThenBlock: { ReturnValue("Subtract") }
        IfCondition EqualTo(t, PToken.P_STAR_SIGN) ThenBlock: { ReturnValue("Multiply") }
        IfCondition EqualTo(t, PToken.P_SLASH_SIGN) ThenBlock: { ReturnValue("Divide") }
        IfCondition EqualTo(t, PToken.P_PERCENT_SIGN) ThenBlock: { ReturnValue("Modulo") }
        IfCondition EqualTo(t, PToken.P_CARET_SIGN) ThenBlock: { ReturnValue("Power") }
        
        // Comparison (single char)
        IfCondition EqualTo(t, PToken.P_GREATER_SIGN) ThenBlock: { ReturnValue("GreaterThan") }
        IfCondition EqualTo(t, PToken.P_LESS_SIGN) ThenBlock: { ReturnValue("LessThan") }
        
        // Comparison (two char)
        IfCondition EqualTo(t, PToken.P_EQUALTO) ThenBlock: { ReturnValue("EqualTo") }
        IfCondition EqualTo(t, PToken.P_NOTEQUAL) ThenBlock: { ReturnValue("NotEqual") }
        IfCondition EqualTo(t, PToken.P_GREATEREQUAL) ThenBlock: { ReturnValue("GreaterEqual") }
        IfCondition EqualTo(t, PToken.P_LESSEQUAL) ThenBlock: { ReturnValue("LessEqual") }
        
        // Logical
        IfCondition EqualTo(t, PToken.P_AND_AND) ThenBlock: { ReturnValue("And") }
        IfCondition EqualTo(t, PToken.P_PIPE_PIPE) ThenBlock: { ReturnValue("Or") }
        
        // Bitwise
        IfCondition EqualTo(t, PToken.P_AMPERSAND_SIGN) ThenBlock: { ReturnValue("BitwiseAnd") }
        IfCondition EqualTo(t, PToken.P_PIPE_SIGN) ThenBlock: { ReturnValue("BitwiseOr") }
        IfCondition EqualTo(t, PToken.P_LESS_LESS) ThenBlock: { ReturnValue("LeftShift") }
        IfCondition EqualTo(t, PToken.P_GREATER_GREATER) ThenBlock: { ReturnValue("RightShift") }
        
        // Not an operator
        ReturnValue(0)
    }
}

// =============================================================================
// ARGUMENT LIST PARSING
// =============================================================================

// Parse argument list: (expr, expr, ...)
// Returns XArray of argument nodes
Function.Parse_Arguments {
    Output: Address
    Body: {
        args = XArray.XCreate(16)
        
        Parse_Consume(PToken.P_LPAREN, "Expected '(' for arguments")
        Parse_SkipNewlines()
        
        // Handle empty argument list
        IfCondition EqualTo(PParser.p_current_type, PToken.P_RPAREN) ThenBlock: {
            Parse_Advance()
            ReturnValue(args)
        }
        
        // Parse first argument
        arg = Parse_Expression()
        IfCondition NotEqual(arg, 0) ThenBlock: {
            XArray.XPush(args, arg)
        }
        
        // Parse remaining arguments
        WhileLoop EqualTo(PParser.p_current_type, PToken.P_COMMA) {
            Parse_Advance()  // consume comma
            Parse_SkipNewlines()
            
            arg = Parse_Expression()
            IfCondition NotEqual(arg, 0) ThenBlock: {
                XArray.XPush(args, arg)
            }
            
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(args)
            }
        }
        
        Parse_SkipNewlines()
        Parse_Consume(PToken.P_RPAREN, "Expected ')' after arguments")
        
        ReturnValue(args)
    }
}

// =============================================================================
// ARRAY LITERAL
// =============================================================================

// Parse array literal: [expr, expr, ...]
Function.Parse_ArrayLiteral {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_LBRACKET, "Expected '['")
        Parse_SkipNewlines()
        
        node = AST_Create(AST.ARRAY_LITERAL)
        
        // Handle empty array
        IfCondition EqualTo(PParser.p_current_type, PToken.P_RBRACKET) ThenBlock: {
            Parse_Advance()
            ReturnValue(node)
        }
        
        // Parse first element
        elem = Parse_Expression()
        IfCondition NotEqual(elem, 0) ThenBlock: {
            AST_AddChild(node, elem)
        }
        
        // Parse remaining elements
        Parse_SkipNewlines()
        WhileLoop EqualTo(PParser.p_current_type, PToken.P_COMMA) {
            Parse_Advance()  // consume comma
            Parse_SkipNewlines()
            
            elem = Parse_Expression()
            IfCondition NotEqual(elem, 0) ThenBlock: {
                AST_AddChild(node, elem)
            }
            
            Parse_SkipNewlines()
            
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(node)
            }
        }
        
        Parse_Consume(PToken.P_RBRACKET, "Expected ']' after array elements")
        
        ReturnValue(node)
    }
}

// =============================================================================
// NAMED ARGUMENT PARSING (for function calls with keyword args)
// =============================================================================

// Parse named argument: name: value or name=value
Function.Parse_NamedArgument {
    Output: Address
    Body: {
        // Check if it's identifier followed by : or =
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            // Just a regular expression
            ReturnValue(Parse_Expression())
        }
        
        // Peek ahead for : or =
        next = Parse_Peek(1)
        IfCondition Or(EqualTo(next, PToken.P_COLON), EqualTo(next, PToken.P_EQUALS)) ThenBlock: {
            // Named argument: name: value
            name = PParser.p_current_value
            Parse_Advance()  // consume name
            Parse_Advance()  // consume : or =
            Parse_SkipNewlines()
            
            value = Parse_Expression()
            
            // Create parameter-like node for named arg
            node = AST_Create(AST.PARAMETER)
            AST_SetData1(node, name)
            AST_AddChild(node, value)
            ReturnValue(node)
        }
        
        // Just a regular expression
        ReturnValue(Parse_Expression())
    }
}

// =============================================================================
// BUILT-IN FUNCTION CALL PARSING
// =============================================================================

// Check if identifier is a built-in math/comparison function
Function.Parse_IsBuiltinFunc {
    Input: name: Address
    Output: Integer
    Body: {
        // Arithmetic
        IfCondition EqualTo(StringCompare(name, "Add"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Subtract"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Multiply"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Divide"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Modulo"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Power"), 0) ThenBlock: { ReturnValue(1) }
        
        // Comparison
        IfCondition EqualTo(StringCompare(name, "EqualTo"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "NotEqual"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "GreaterThan"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "LessThan"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "GreaterEqual"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "LessEqual"), 0) ThenBlock: { ReturnValue(1) }
        
        // Logical
        IfCondition EqualTo(StringCompare(name, "And"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Or"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "Not"), 0) ThenBlock: { ReturnValue(1) }
        
        // Bitwise
        IfCondition EqualTo(StringCompare(name, "BitwiseAnd"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "BitwiseOr"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "BitwiseXor"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "BitwiseNot"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "LeftShift"), 0) ThenBlock: { ReturnValue(1) }
        IfCondition EqualTo(StringCompare(name, "RightShift"), 0) ThenBlock: { ReturnValue(1) }
        
        ReturnValue(0)
    }
}

