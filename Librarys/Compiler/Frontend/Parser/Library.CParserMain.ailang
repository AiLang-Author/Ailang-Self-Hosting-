// Library.CParserMain.ailang
// Main parser entry point for the AILang self-hosting compiler

LibraryImport.XArrays
LibraryImport.Compiler.Frontend.Lexer.CLexerCore

LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes
LibraryImport.Compiler.Frontend.AST.CASTDebug
LibraryImport.Compiler.Frontend.Parser.CParserCore
LibraryImport.Compiler.Frontend.Parser.CParserExpressions
LibraryImport.Compiler.Frontend.Parser.CParserStatements
LibraryImport.Compiler.Frontend.Parser.CParserDeclarations

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================

Function.Parse_Program {
    Output: Address
    Body: {
        program = AST_MakeProgram()
        PParser.p_ast_root = program
        
        PrintMessage("[PARSER] Starting parse...\n")
        
        last_pos = -1
        stuck_count = 0
        
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_EOF) {
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                PrintMessage("[PARSER] Stopping due to error\n")
                ExitLoop
            }
            
            // Detect infinite loop - if position hasn't changed
            IfCondition EqualTo(PParser.p_pos, last_pos) ThenBlock: {
                stuck_count = Add(stuck_count, 1)
                IfCondition GreaterThan(stuck_count, 3) ThenBlock: {
                    PrintMessage("[PARSER] ERROR: Parser stuck at position ")
                    PrintNumber(PParser.p_pos)
                    PrintMessage(", forcing advance\n")
                    Parse_Advance()
                    stuck_count = 0
                }
            } ElseBlock: {
                stuck_count = 0
            }
            last_pos = PParser.p_pos
            
            Parse_SkipNewlines()
            
            IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                ExitLoop
            }
            
            decl = Parse_Declaration()
            
            IfCondition NotEqual(decl, 0) ThenBlock: {
                AST_AddChild(program, decl)
            }
            
            Parse_SkipNewlines()
        }
        
        decl_count = AST_GetChildCount(program)
        PrintMessage("[PARSER] Parsed ")
        PrintNumber(decl_count)
        PrintMessage(" declarations, ")
        PrintNumber(ASTState.node_count)
        PrintMessage(" total nodes\n")
        
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            PrintMessage("[PARSER] FAILED with errors\n")
        } ElseBlock: {
            PrintMessage("[PARSER] SUCCESS\n")
        }
        
        ReturnValue(program)
    }
}
// =============================================================================
// PARSE PIPELINE
// =============================================================================

Function.Parse {
    Input: token_count: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("[PARSER] Failed to initialize\n")
            ReturnValue(0)
        }
        
        ast = Parse_Program()
        ReturnValue(ast)
    }
}

Function.Parse_WithOptions {
    Input: token_count: Integer
    Input: show_progress: Integer
    Input: show_ast: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(show_progress, 1) ThenBlock: {
            PrintMessage("[PARSER] Token count: ")
            PrintNumber(token_count)
            PrintMessage("\n")
        }
        
        ast = Parse_Program()
        
        IfCondition And(EqualTo(show_ast, 1), NotEqual(ast, 0)) ThenBlock: {
            AST_Dump(ast)
        }
        
        ReturnValue(ast)
    }
}

// =============================================================================
// SINGLE ITEM PARSING (REPL)
// =============================================================================

Function.Parse_SingleExpression {
    Input: token_count: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        expr = Parse_Expression()
        ReturnValue(expr)
    }
}

Function.Parse_SingleStatement {
    Input: token_count: Integer
    Output: Address
    Body: {
        result = Parse_Init(token_count)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        stmt = Parse_Statement()
        ReturnValue(stmt)
    }
}

// =============================================================================
// ERROR RECOVERY
// =============================================================================

Function.Parse_Synchronize {
    Body: {
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_EOF) {
            prev = Parse_Peek(-1)
            IfCondition EqualTo(prev, PToken.P_NEWLINE) ThenBlock: {
                IfCondition EqualTo(Parse_AtStatementStart(), 1) ThenBlock: {
                    ReturnValue(0)
                }
            }
            
            t = PParser.p_current_type
            IfCondition EqualTo(t, PToken.P_FUNCTION) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, PToken.P_SUBROUTINE) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, PToken.P_FIXEDPOOL) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, PToken.P_DYNAMICPOOL) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, PToken.P_LIBRARYIMPORT) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, PToken.P_LOOPMAIN) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, PToken.P_LOOPACTOR) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(t, PToken.P_RBRACE) ThenBlock: { ReturnValue(0) }
            
            Parse_Advance()
        }
        ReturnValue(0)
    }
}

// =============================================================================
// VALIDATION
// =============================================================================

Function.Parse_Validate {
    Input: ast: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(ast, 0) ThenBlock: {
            PrintMessage("[VALIDATE] ERROR: Null AST\n")
            ReturnValue(0)
        }
        
        root_type = AST_GetType(ast)
        IfCondition NotEqual(root_type, AST.PROGRAM) ThenBlock: {
            PrintMessage("[VALIDATE] ERROR: Root is not PROGRAM node\n")
            ReturnValue(0)
        }
        
        decl_count = AST_GetChildCount(ast)
        func_count = 0
        sub_count = 0
        pool_count = 0
        import_count = 0
        
        i = 0
        WhileLoop LessThan(i, decl_count) {
            child = AST_GetChild(ast, i)
            child_type = AST_GetType(child)
            
            IfCondition EqualTo(child_type, AST.FUNCTION) ThenBlock: {
                func_count = Add(func_count, 1)
            }
            IfCondition EqualTo(child_type, AST.SUBROUTINE) ThenBlock: {
                sub_count = Add(sub_count, 1)
            }
            IfCondition EqualTo(child_type, AST.LIBRARY_IMPORT) ThenBlock: {
                import_count = Add(import_count, 1)
            }
            IfCondition And(GreaterEqual(child_type, AST.POOL_FIXED), LessEqual(child_type, AST.POOL_LINKAGE)) ThenBlock: {
                pool_count = Add(pool_count, 1)
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[VALIDATE] Imports: ")
        PrintNumber(import_count)
        PrintMessage(", Functions: ")
        PrintNumber(func_count)
        PrintMessage(", SubRoutines: ")
        PrintNumber(sub_count)
        PrintMessage(", Pools: ")
        PrintNumber(pool_count)
        PrintMessage("\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================

Function.Parse_Cleanup {
    Input: free_ast: Integer
    Body: {
        Parse_Free()
        
        IfCondition And(EqualTo(free_ast, 1), NotEqual(PParser.p_ast_root, 0)) ThenBlock: {
            AST_Free(PParser.p_ast_root)
            PParser.p_ast_root = 0
        }
    }
}


Function.Parse_PrintStats {
    Body: {
        PrintMessage("\n=== Parser Statistics ===\n")
        PrintMessage("Position: ")
        PrintNumber(PParser.p_pos)
        PrintMessage(" / ")
        PrintNumber(PParser.p_token_count)
        PrintMessage("\n")
        
        PrintMessage("Nodes created: ")
        PrintNumber(ASTState.node_count)
        PrintMessage("\n")
        
        PrintMessage("Context depth: ")
        PrintNumber(PParser.p_context_depth)
        PrintMessage("\n")
        
        PrintMessage("Error state: ")
        IfCondition EqualTo(PParser.p_error, 1) ThenBlock: {
            PrintMessage("ERROR at line ")
            PrintNumber(PParser.p_error_line)
            PrintMessage(": ")
            PrintMessage(PParser.p_error_msg)
        } ElseBlock: {
            PrintMessage("OK")
        }
        PrintMessage("\n")
        PrintMessage("=========================\n")
    }
}
