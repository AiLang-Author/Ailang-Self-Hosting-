// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CParserStatements.ailang
// Statement parsing for the AILang self-hosting compiler
// Handles: assignments, control flow, I/O, blocks

LibraryImport.XArrays

LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes
LibraryImport.Compiler.Frontend.Parser.CParserCore
LibraryImport.Compiler.Frontend.Parser.CParserExpressions

// =============================================================================
// MAIN STATEMENT DISPATCHER
// =============================================================================

// Parse a single statement
Function.Parse_Statement {
    Output: Address
    Body: {
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        t = PParser.p_current_type
        
        // Skip comments
        IfCondition Or(EqualTo(t, PToken.P_COMMENT), EqualTo(t, PToken.P_DOC_COMMENT)) ThenBlock: {
            Parse_Advance()
            ReturnValue(0)
        }
        IfCondition Or(EqualTo(t, PToken.P_COM_COMMENT), EqualTo(t, PToken.P_TAG_COMMENT)) ThenBlock: {
            Parse_Advance()
            ReturnValue(0)
        }
        
        // End of block or file
        IfCondition Or(EqualTo(t, PToken.P_RBRACE), EqualTo(t, PToken.P_EOF)) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition EqualTo(t, PToken.P_ELSEBLOCK) ThenBlock: {
            ReturnValue(0)
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Control Flow Keywords
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_IFCONDITION) ThenBlock: {
            ReturnValue(Parse_IfCondition())
        }
        IfCondition EqualTo(t, PToken.P_WHILELOOP) ThenBlock: {
            ReturnValue(Parse_WhileLoop())
        }
        IfCondition EqualTo(t, PToken.P_FOREVERY) ThenBlock: {
            ReturnValue(Parse_ForEvery())
        }
        IfCondition EqualTo(t, PToken.P_FORK) ThenBlock: {
            ReturnValue(Parse_Fork())
        }
        IfCondition EqualTo(t, PToken.P_BRANCH) ThenBlock: {
            ReturnValue(Parse_Branch())
        }
        IfCondition EqualTo(t, PToken.P_TRYBLOCK) ThenBlock: {
            ReturnValue(Parse_TryBlock())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Return / Exit / Continue
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_RETURNVALUE) ThenBlock: {
            ReturnValue(Parse_ReturnValue())
        }
        IfCondition EqualTo(t, PToken.P_BREAKLOOP) ThenBlock: {
            ReturnValue(Parse_ExitLoop())
        }
        IfCondition EqualTo(t, PToken.P_CONTINUELOOP) ThenBlock: {
            ReturnValue(Parse_ContinueLoop())
        }
        IfCondition EqualTo(t, PToken.P_HALTPROGRAM) ThenBlock: {
            ReturnValue(Parse_HaltProgram())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // I/O Statements
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_PRINTMESSAGE) ThenBlock: {
            ReturnValue(Parse_PrintMessage())
        }
        IfCondition EqualTo(t, PToken.P_PRINTNUMBER) ThenBlock: {
            ReturnValue(Parse_PrintNumber())
        }
        IfCondition EqualTo(t, PToken.P_RUNTASK) ThenBlock: {
            ReturnValue(Parse_RunTask())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Debug Statements
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_DEBUG) ThenBlock: {
            ReturnValue(Parse_DebugBlock())
        }
        IfCondition EqualTo(t, PToken.P_DEBUGASSERT) ThenBlock: {
            ReturnValue(Parse_DebugAssert())
        }
        
        // ─────────────────────────────────────────────────────────────────────
        // Expression or Assignment (identifier starts both)
        // ─────────────────────────────────────────────────────────────────────
        IfCondition EqualTo(t, PToken.P_IDENTIFIER) ThenBlock: {
            ReturnValue(Parse_ExprOrAssignment())
        }
        
        // Fallback: try to parse as expression statement
        is_expr_start = Parse_AtExpressionStart()
        IfCondition EqualTo(is_expr_start, 1) ThenBlock: {
            expr = Parse_Expression()
            ReturnValue(expr)
        }
        
        // Unknown token - skip to avoid infinite loop
        Parse_Error("Unexpected token in statement")
        Parse_Advance()
        ReturnValue(0)
    }
}

// =============================================================================
// EXPRESSION OR ASSIGNMENT
// =============================================================================

// Parse identifier-starting statement (assignment or expression)
Function.Parse_ExprOrAssignment {
    Output: Address
    Body: {
        // Parse the left-hand side as an expression
        expr = Parse_Expression()
        IfCondition EqualTo(expr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if followed by =
        IfCondition EqualTo(PParser.p_current_type, PToken.P_EQUALS) ThenBlock: {
            // It's an assignment
            Parse_Advance()  // consume =
            Parse_SkipNewlines()
            
            // Get target name from expression
            target = AST_GetData1(expr)
            
            // Parse value
            value = Parse_Expression()
            
            // Create assignment node
            result = AST_MakeAssignment(target, value)
            
            // Free the target expression node
            AST_Free(expr)
            
            ReturnValue(result)
        }
        
        // Just an expression statement (function call, etc.)
        ReturnValue(expr)
    }
}

// =============================================================================
// CONTROL FLOW: IF CONDITION
// =============================================================================

// Parse: IfCondition expr ThenBlock: { ... } ElseBlock: { ... }
Function.Parse_IfCondition {
    Output: Address
    Body: {
        Parse_PushContext("IfCondition")
        
        Parse_Consume(PToken.P_IFCONDITION, "Expected 'IfCondition'")
        
        // Parse condition expression
        condition = Parse_Expression()
        IfCondition EqualTo(condition, 0) ThenBlock: {
            Parse_PopContext()
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        
        // ThenBlock: { ... }
        Parse_Consume(PToken.P_THENBLOCK, "Expected 'ThenBlock'")
        Parse_Consume(PToken.P_COLON, "Expected ':' after ThenBlock")
        then_block = Parse_Block()
        
        Parse_SkipNewlines()
        
        // Optional ElseBlock: { ... }
        else_block = 0
        IfCondition EqualTo(PParser.p_current_type, PToken.P_ELSEBLOCK) ThenBlock: {
            Parse_Advance()
            Parse_Consume(PToken.P_COLON, "Expected ':' after ElseBlock")
            else_block = Parse_Block()
        }
        
        Parse_PopContext()
        
        result = AST_MakeIf(condition, then_block, else_block)
        ReturnValue(result)
    }
}

// =============================================================================
// CONTROL FLOW: WHILE LOOP
// =============================================================================

// Parse: WhileLoop condition { ... }
Function.Parse_WhileLoop {
    Output: Address
    Body: {
        Parse_PushContext("WhileLoop")
        
        Parse_Consume(PToken.P_WHILELOOP, "Expected 'WhileLoop'")
        
        // Parse condition
        condition = Parse_Expression()
        IfCondition EqualTo(condition, 0) ThenBlock: {
            Parse_PopContext()
            ReturnValue(0)
        }
        
        Parse_SkipNewlines()
        
        // Parse body block
        body = Parse_Block()
        
        Parse_PopContext()
        
        result = AST_MakeWhile(condition, body)
        ReturnValue(result)
    }
}

// =============================================================================
// CONTROL FLOW: FOR EVERY
// =============================================================================

// Parse: ForEvery variable in collection { ... }
Function.Parse_ForEvery {
    Output: Address
    Body: {
        Parse_PushContext("ForEvery")
        
        Parse_Consume(PToken.P_FOREVERY, "Expected 'ForEvery'")
        
        // Parse variable name
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected variable name after ForEvery")
            Parse_PopContext()
            ReturnValue(0)
        }
        var_name = PParser.p_current_value
        Parse_Advance()
        
        // Expect 'in'
        Parse_Consume(PToken.P_IN, "Expected 'in' after variable")
        
        // Parse collection expression
        collection = Parse_Expression()
        
        Parse_SkipNewlines()
        
        // Parse body
        body = Parse_Block()
        
        Parse_PopContext()
        
        // Create FOR_EVERY node
        node = AST_Create(AST.FOR_EVERY)
        AST_SetData1(node, var_name)
        AST_AddChild(node, collection)
        AST_AddChild(node, body)
        
        ReturnValue(node)
    }
}

// =============================================================================
// CONTROL FLOW: FORK (boolean branch)
// =============================================================================

// Parse: Fork condition TrueBlock: { ... } FalseBlock: { ... }
Function.Parse_Fork {
    Output: Address
    Body: {
        Parse_PushContext("Fork")
        
        Parse_Consume(PToken.P_FORK, "Expected 'Fork'")
        
        condition = Parse_Expression()
        Parse_SkipNewlines()
        
        // TrueBlock
        Parse_Consume(PToken.P_TRUEBLOCK, "Expected 'TrueBlock'")
        Parse_Consume(PToken.P_COLON, "Expected ':'")
        true_block = Parse_Block()
        
        Parse_SkipNewlines()
        
        // FalseBlock
        Parse_Consume(PToken.P_FALSEBLOCK, "Expected 'FalseBlock'")
        Parse_Consume(PToken.P_COLON, "Expected ':'")
        false_block = Parse_Block()
        
        Parse_PopContext()
        
        // Create FORK node (similar to IF but different semantics)
        node = AST_Create(AST.FORK)
        AST_AddChild(node, condition)
        AST_AddChild(node, true_block)
        AST_AddChild(node, false_block)
        
        ReturnValue(node)
    }
}

// =============================================================================
// CONTROL FLOW: BRANCH (multi-way)
// =============================================================================

// Parse: Branch expr { Case val: { ... } Default: { ... } }
Function.Parse_Branch {
    Output: Address
    Body: {
        Parse_PushContext("Branch")
        
        Parse_Consume(PToken.P_BRANCH, "Expected 'Branch'")
        
        expression = Parse_Expression()
        Parse_SkipNewlines()
        Parse_Consume(PToken.P_LBRACE, "Expected '{' after Branch expression")
        Parse_SkipNewlines()
        
        // Create BRANCH node
        node = AST_Create(AST.SWITCH)
        AST_AddChild(node, expression)
        
        // Parse cases
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
            Parse_SkipNewlines()
            
            IfCondition EqualTo(PParser.p_current_type, PToken.P_CASE) ThenBlock: {
                Parse_Advance()
                
                // Parse case value
                case_value = Parse_Expression()
                Parse_Consume(PToken.P_COLON, "Expected ':' after Case value")
                case_body = Parse_Block()
                
                // Create CASE node
                case_node = AST_Create(AST.CASE)
                AST_AddChild(case_node, case_value)
                AST_AddChild(case_node, case_body)
                AST_AddChild(node, case_node)
                
                Parse_SkipNewlines()
                ContinueLoop
            }
            
            IfCondition EqualTo(PParser.p_current_type, PToken.P_DEFAULT) ThenBlock: {
                Parse_Advance()
                Parse_Consume(PToken.P_COLON, "Expected ':' after Default")
                default_body = Parse_Block()
                
                // Create DEFAULT_CASE node
                default_node = AST_Create(AST.DEFAULT)
                AST_AddChild(default_node, default_body)
                AST_AddChild(node, default_node)
                
                Parse_SkipNewlines()
                ContinueLoop
            }
            
            // Unknown in Branch
            Parse_Error("Expected 'Case' or 'Default' in Branch")
            ExitLoop
        }
        
        Parse_Consume(PToken.P_RBRACE, "Expected '}' after Branch")
        Parse_PopContext()
        
        ReturnValue(node)
    }
}

// =============================================================================
// CONTROL FLOW: TRY / CATCH / FINALLY
// =============================================================================

// Parse: TryBlock: { ... } CatchError: Type { ... } FinallyBlock: { ... }
Function.Parse_TryBlock {
    Output: Address
    Body: {
        Parse_PushContext("TryBlock")
        
        Parse_Consume(PToken.P_TRYBLOCK, "Expected 'TryBlock'")
        Parse_Consume(PToken.P_COLON, "Expected ':'")
        try_body = Parse_Block()
        
        Parse_SkipNewlines()
        
        // Create TRY node
        node = AST_Create(AST.TRY)
        AST_AddChild(node, try_body)
        
        // Parse catch clauses
        WhileLoop EqualTo(PParser.p_current_type, PToken.P_CATCHERROR) {
            Parse_Advance()
            Parse_Consume(PToken.P_COLON, "Expected ':'")
            
            // Optional error type
            error_type = 0
            IfCondition NotEqual(PParser.p_current_type, PToken.P_LBRACE) ThenBlock: {
                error_type = PParser.p_current_value
                Parse_Advance()
            }
            
            catch_body = Parse_Block()
            
            // Create CATCH node
            catch_node = AST_Create(AST.CATCH)
            AST_SetData1(catch_node, error_type)
            AST_AddChild(catch_node, catch_body)
            AST_AddChild(node, catch_node)
            
            Parse_SkipNewlines()
        }
        
        // Optional finally
        IfCondition EqualTo(PParser.p_current_type, PToken.P_FINALLYBLOCK) ThenBlock: {
            Parse_Advance()
            Parse_Consume(PToken.P_COLON, "Expected ':'")
            finally_body = Parse_Block()
            
            finally_node = AST_Create(AST.FINALLY)
            AST_AddChild(finally_node, finally_body)
            AST_AddChild(node, finally_node)
        }
        
        Parse_PopContext()
        ReturnValue(node)
    }
}

// =============================================================================
// RETURN / EXIT / CONTINUE
// =============================================================================

// Parse: ReturnValue(expr)
Function.Parse_ReturnValue {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_RETURNVALUE, "Expected 'ReturnValue'")
        Parse_Consume(PToken.P_LPAREN, "Expected '('")
        
        value = Parse_Expression()
        
        Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        
        result = AST_MakeReturn(value)
        ReturnValue(result)
    }
}

// Parse: ExitLoop or BreakLoop
Function.Parse_ExitLoop {
    Output: Address
    Body: {
        Parse_Advance()  // consume keyword
        
        node = AST_Create(AST.EXIT_LOOP)
        ReturnValue(node)
    }
}

// Parse: ContinueLoop
Function.Parse_ContinueLoop {
    Output: Address
    Body: {
        Parse_Advance()  // consume keyword
        
        node = AST_Create(AST.CONTINUE_LOOP)
        ReturnValue(node)
    }
}

// Parse: HaltProgram() or HaltProgram("message")
Function.Parse_HaltProgram {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_HALTPROGRAM, "Expected 'HaltProgram'")
        
        node = AST_Create(AST.HALT)
        
        // Optional message
        IfCondition EqualTo(PParser.p_current_type, PToken.P_LPAREN) ThenBlock: {
            Parse_Advance()
            IfCondition NotEqual(PParser.p_current_type, PToken.P_RPAREN) ThenBlock: {
                msg = Parse_Expression()
                AST_AddChild(node, msg)
            }
            Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        }
        
        ReturnValue(node)
    }
}

// =============================================================================
// I/O STATEMENTS
// =============================================================================

// Parse: PrintMessage(expr)
Function.Parse_PrintMessage {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_PRINTMESSAGE, "Expected 'PrintMessage'")
        Parse_Consume(PToken.P_LPAREN, "Expected '('")
        
        message = Parse_Expression()
        
        Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        
        node = AST_Create(AST.PRINT)
        AST_SetData1(node, 1)  // 1 = message type
        AST_AddChild(node, message)
        
        ReturnValue(node)
    }
}

// Parse: PrintNumber(expr)
Function.Parse_PrintNumber {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_PRINTNUMBER, "Expected 'PrintNumber'")
        Parse_Consume(PToken.P_LPAREN, "Expected '('")
        
        value = Parse_Expression()
        
        Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        
        node = AST_Create(AST.PRINT)
        AST_SetData1(node, 2)  // 2 = number type
        AST_AddChild(node, value)
        
        ReturnValue(node)
    }
}

// Parse: RunTask(task_name)
Function.Parse_RunTask {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_RUNTASK, "Expected 'RunTask'")
        Parse_Consume(PToken.P_LPAREN, "Expected '('")
        
        // Get task name
        IfCondition NotEqual(PParser.p_current_type, PToken.P_IDENTIFIER) ThenBlock: {
            Parse_Error("Expected task name identifier")
            ReturnValue(0)
        }
        task_name = PParser.p_current_value
        Parse_Advance()
        
        Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        
        node = AST_Create(AST.RUN_TASK)
        AST_SetData1(node, task_name)
        
        ReturnValue(node)
    }
}

// =============================================================================
// DEBUG STATEMENTS
// =============================================================================

// Parse: Debug("label", level=N) { ... }
Function.Parse_DebugBlock {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_DEBUG, "Expected 'Debug'")
        Parse_Consume(PToken.P_LPAREN, "Expected '('")
        
        // Parse label
        IfCondition NotEqual(PParser.p_current_type, PToken.P_STRING) ThenBlock: {
            Parse_Error("Expected string label for Debug")
            ReturnValue(0)
        }
        label = PParser.p_current_value
        Parse_Advance()
        
        // Optional: , level=N
        level = 1
        IfCondition EqualTo(PParser.p_current_type, PToken.P_COMMA) ThenBlock: {
            Parse_Advance()
            // Expect level=N
            Parse_Consume(PToken.P_IDENTIFIER, "Expected 'level'")
            Parse_Consume(PToken.P_EQUALS, "Expected '='")
            IfCondition EqualTo(PParser.p_current_type, PToken.P_NUMBER) ThenBlock: {
                // TODO: Convert string to int
                level = 1
                Parse_Advance()
            }
        }
        
        Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        
        // Parse debug body
        body = Parse_Block()
        
        node = AST_Create(AST.DEBUG_BLOCK)
        AST_SetData1(node, label)
        AST_SetData2(node, level)
        AST_AddChild(node, body)
        
        ReturnValue(node)
    }
}

// Parse: DebugAssert(condition, "message")
Function.Parse_DebugAssert {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_DEBUGASSERT, "Expected 'DebugAssert'")
        Parse_Consume(PToken.P_LPAREN, "Expected '('")
        
        condition = Parse_Expression()
        
        message = 0
        IfCondition EqualTo(PParser.p_current_type, PToken.P_COMMA) ThenBlock: {
            Parse_Advance()
            message = Parse_Expression()
        }
        
        Parse_Consume(PToken.P_RPAREN, "Expected ')'")
        
        node = AST_Create(AST.DEBUG_ASSERT)
        AST_AddChild(node, condition)
        IfCondition NotEqual(message, 0) ThenBlock: {
            AST_AddChild(node, message)
        }
        
        ReturnValue(node)
    }
}

// =============================================================================
// BLOCK PARSING
// =============================================================================

// Parse a block: { statement* }
Function.Parse_Block {
    Output: Address
    Body: {
        Parse_Consume(PToken.P_LBRACE, "Expected '{'")
        Parse_SkipNewlines()
        
        block = AST_MakeBlock()
        
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
            IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                Parse_Error("Unexpected end of file in block")
                ReturnValue(block)
            }
            
            stmt = Parse_Statement()
            IfCondition NotEqual(stmt, 0) ThenBlock: {
                AST_AddChild(block, stmt)
            }
            
            Parse_SkipNewlines()
            
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(block)
            }
        }
        
        Parse_Consume(PToken.P_RBRACE, "Expected '}'")
        
        ReturnValue(block)
    }
}

// =============================================================================
// STATEMENT LIST (for function bodies, etc.)
// =============================================================================

// Parse multiple statements until closing brace
Function.Parse_StatementList {
    Output: Address
    Body: {
        statements = XArray.XCreate(32)
        
        Parse_SkipNewlines()
        
        WhileLoop NotEqual(PParser.p_current_type, PToken.P_RBRACE) {
            IfCondition EqualTo(PParser.p_current_type, PToken.P_EOF) ThenBlock: {
                ExitLoop
            }
            
            stmt = Parse_Statement()
            IfCondition NotEqual(stmt, 0) ThenBlock: {
                XArray.XPush(statements, stmt)
            }
            
            Parse_SkipNewlines()
            
            IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
                ReturnValue(statements)
            }
        }
        
        ReturnValue(statements)
    }
}


