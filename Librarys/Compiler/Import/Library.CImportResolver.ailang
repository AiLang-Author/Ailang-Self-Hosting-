// Library.CImportResolver.ailang
// Import resolution with deduplication, conflict detection, and namespace aliasing
// Mirrors import_resolver.py logic for the self-hosting compiler
// Location: Librarys/Compiler/Import/Library.CImportResolver.ailang
// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
// SPDX-License-Identifier: SCSL-1.0

LibraryImport.XArrays

// =============================================================================
// IMPORT STATE - stored as allocated structure
// Initialized by Import_Init, accessed via functions
// =============================================================================

// State structure offsets (allocated as single block)
// [0]:  loaded_paths      - XArray of file path hashes
// [8]:  loaded_content    - XArray of file content pointers
// [16]: loaded_names      - XArray of module name pointers
// [24]: symbol_table      - XArray of (symbol_hash, module_index) pairs
// [32]: conflicts         - XArray of conflicting symbol hashes
// [40]: prefixes          - XArray of (module_index, prefix_ptr) pairs
// [48]: prefix_counter    - Integer for generating unique prefixes
// [56]: library_base      - Pointer to "Librarys" string
// [64]: output_buffer     - XArray of output source lines
// [72]: error_count       - Count of import errors

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Import_Init {
    Output: Address
    Body: {
        // Allocate state structure: 80 bytes (10 fields * 8 bytes)
        state = Allocate(80)
        
        // Initialize XArrays - assign to variables first to avoid nested call bug
        arr_paths = XArray.XCreate(64)
        StoreValue(state, arr_paths)
        
        arr_content = XArray.XCreate(64)
        StoreValue(Add(state, 8), arr_content)
        
        arr_names = XArray.XCreate(64)
        StoreValue(Add(state, 16), arr_names)
        
        arr_symbols = XArray.XCreate(256)
        StoreValue(Add(state, 24), arr_symbols)
        
        arr_conflicts = XArray.XCreate(32)
        StoreValue(Add(state, 32), arr_conflicts)
        
        arr_prefixes = XArray.XCreate(32)
        StoreValue(Add(state, 40), arr_prefixes)
        
        StoreValue(Add(state, 48), 0)  // prefix_counter
        
        // Set library base path
        lib_base = Import_AllocString("Librarys")
        StoreValue(Add(state, 56), lib_base)
        
        // Output buffer for combined source
        arr_output = XArray.XCreate(1024)
        StoreValue(Add(state, 64), arr_output)
        
        StoreValue(Add(state, 72), 0)  // error_count
        
        ReturnValue(state)
    }
}

// =============================================================================
// STRING UTILITIES
// =============================================================================

// Allocate and copy a string
Function.Import_AllocString {
    Input: str: Address
    Output: Address
    Body: {
        len = StringLength(str)
        new_str = Allocate(Add(len, 1))
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            SetByte(new_str, i, c)
            i = Add(i, 1)
        }
        SetByte(new_str, len, 0)
        ReturnValue(new_str)
    }
}

// Simple string hash (DJB2 variant)
Function.Import_HashString {
    Input: str: Address
    Output: Integer
    Body: {
        hash = 5381
        len = StringLength(str)
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            // hash = hash * 33 + c
            hash = Add(Multiply(hash, 33), c)
            // Keep positive by masking to 31 bits
            hash = BitwiseAnd(hash, 2147483647)
            i = Add(i, 1)
        }
        ReturnValue(hash)
    }
}

// =============================================================================
// PATH BUILDING
// Convert "Compiler.Frontend.Lexer.CLexerTypes" to
// "Librarys/Compiler/Frontend/Lexer/Library.CLexerTypes.ailang"
// =============================================================================
Function.Import_BuildPath {
    Input: state: Address
    Input: module_name: Address
    Output: Address
    Body: {
        name_len = StringLength(module_name)
        
        // Find last dot (separates path from filename)
        last_dot = -1
        i = 0
        WhileLoop LessThan(i, name_len) {
            c = GetByte(module_name, i)
            IfCondition EqualTo(c, 46) ThenBlock: {  // '.'
                last_dot = i
            }
            i = Add(i, 1)
        }
        
        // Allocate path buffer: "Librarys/" + path + "/Library." + name + ".ailang" + null
        // Generous allocation: name_len * 2 + 30
        path_size = Add(Multiply(name_len, 2), 30)
        path = Allocate(path_size)
        pos = 0
        
        // Copy "Librarys/"
        lib_base = Dereference(Add(state, 56))
        lib_len = StringLength(lib_base)
        i = 0
        WhileLoop LessThan(i, lib_len) {
            SetByte(path, pos, GetByte(lib_base, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        SetByte(path, pos, 47)  // '/'
        pos = Add(pos, 1)
        
        // Convert directory path (dots to slashes)
        IfCondition GreaterThan(last_dot, 0) ThenBlock: {
            i = 0
            WhileLoop LessThan(i, last_dot) {
                c = GetByte(module_name, i)
                IfCondition EqualTo(c, 46) ThenBlock: {  // '.' -> '/'
                    SetByte(path, pos, 47)
                } ElseBlock: {
                    SetByte(path, pos, c)
                }
                pos = Add(pos, 1)
                i = Add(i, 1)
            }
            SetByte(path, pos, 47)  // trailing '/'
            pos = Add(pos, 1)
        }
        
        // Add "Library."
        prefix = "Library."
        prefix_len = 8
        i = 0
        WhileLoop LessThan(i, prefix_len) {
            SetByte(path, pos, GetByte(prefix, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Copy filename part (after last dot, or entire name)
        file_start = 0
        IfCondition GreaterThan(last_dot, 0) ThenBlock: {
            file_start = Add(last_dot, 1)
        }
        i = file_start
        WhileLoop LessThan(i, name_len) {
            SetByte(path, pos, GetByte(module_name, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Add ".ailang"
        suffix = ".ailang"
        suffix_len = 7
        i = 0
        WhileLoop LessThan(i, suffix_len) {
            SetByte(path, pos, GetByte(suffix, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        SetByte(path, pos, 0)  // null terminate
        ReturnValue(path)
    }
}

// =============================================================================
// DEDUPLICATION
// =============================================================================
Function.Import_IsLoaded {
    Input: state: Address
    Input: path: Address
    Output: Integer
    Body: {
        hash = Import_HashString(path)
        loaded_paths = Dereference(state)
        count = XArray.XSize(loaded_paths)
        
        i = 0
        WhileLoop LessThan(i, count) {
            stored_hash = XArray.XGet(loaded_paths, i)
            IfCondition EqualTo(hash, stored_hash) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

Function.Import_MarkLoaded {
    Input: state: Address
    Input: path: Address
    Input: content: Address
    Input: name: Address
    Body: {
        hash = Import_HashString(path)
        loaded_paths = Dereference(state)
        loaded_content = Dereference(Add(state, 8))
        loaded_names = Dereference(Add(state, 16))
        
        XArray.XPush(loaded_paths, hash)
        XArray.XPush(loaded_content, content)
        XArray.XPush(loaded_names, name)
    }
}

// =============================================================================
// IMPORT EXTRACTION
// Find all "LibraryImport.X" and "Import.X" lines in source
// Returns XArray of module name strings
// =============================================================================
Function.Import_ExtractImports {
    Input: source: Address
    Output: Address
    Body: {
        imports = XArray.XCreate(32)
        len = StringLength(source)
        
        pos = 0
        line_start = 0
        
        WhileLoop LessThan(pos, len) {
            c = GetByte(source, pos)
            
            IfCondition EqualTo(c, 10) ThenBlock: {  // newline
                line_len = Subtract(pos, line_start)
                
                // Check for "LibraryImport." (14 chars)
                IfCondition GreaterEqual(line_len, 14) ThenBlock: {
                    // Check 'L' at start
                    c0 = GetByte(source, line_start)
                    IfCondition EqualTo(c0, 76) ThenBlock: {  // 'L'
                        // Check 'I' at position 7
                        c1 = GetByte(source, Add(line_start, 7))
                        IfCondition EqualTo(c1, 73) ThenBlock: {  // 'I'
                            // Check '.' at position 13
                            c2 = GetByte(source, Add(line_start, 13))
                            IfCondition EqualTo(c2, 46) ThenBlock: {  // '.'
                                // Extract module name
                                mod_start = Add(line_start, 14)
                                mod_len = Subtract(pos, mod_start)
                                
                                // Trim trailing whitespace
                                WhileLoop GreaterThan(mod_len, 0) {
                                    mc = GetByte(source, Add(mod_start, Subtract(mod_len, 1)))
                                    IfCondition Or(EqualTo(mc, 32), Or(EqualTo(mc, 13), EqualTo(mc, 9))) ThenBlock: {
                                        mod_len = Subtract(mod_len, 1)
                                    } ElseBlock: {
                                        BreakLoop
                                    }
                                }
                                
                                IfCondition GreaterThan(mod_len, 0) ThenBlock: {
                                    mod_name = Allocate(Add(mod_len, 1))
                                    i = 0
                                    WhileLoop LessThan(i, mod_len) {
                                        SetByte(mod_name, i, GetByte(source, Add(mod_start, i)))
                                        i = Add(i, 1)
                                    }
                                    SetByte(mod_name, mod_len, 0)
                                    XArray.XPush(imports, mod_name)
                                }
                            }
                        }
                    }
                }
                
                // Also check for "Import." (7 chars) - file imports
                IfCondition GreaterEqual(line_len, 7) ThenBlock: {
                    c0 = GetByte(source, line_start)
                    IfCondition EqualTo(c0, 73) ThenBlock: {  // 'I'
                        c1 = GetByte(source, Add(line_start, 6))
                        IfCondition EqualTo(c1, 46) ThenBlock: {  // '.' after "Import"
                            // Verify it's "Import." not "LibraryImport."
                            c2 = GetByte(source, Add(line_start, 1))
                            IfCondition EqualTo(c2, 109) ThenBlock: {  // 'm'
                                mod_start = Add(line_start, 7)
                                mod_len = Subtract(pos, mod_start)
                                
                                // Trim
                                WhileLoop GreaterThan(mod_len, 0) {
                                    mc = GetByte(source, Add(mod_start, Subtract(mod_len, 1)))
                                    IfCondition Or(EqualTo(mc, 32), Or(EqualTo(mc, 13), EqualTo(mc, 9))) ThenBlock: {
                                        mod_len = Subtract(mod_len, 1)
                                    } ElseBlock: {
                                        BreakLoop
                                    }
                                }
                                
                                IfCondition GreaterThan(mod_len, 0) ThenBlock: {
                                    // Mark as file import with "FILE:" prefix
                                    mod_name = Allocate(Add(mod_len, 6))
                                    SetByte(mod_name, 0, 70)   // 'F'
                                    SetByte(mod_name, 1, 73)   // 'I'
                                    SetByte(mod_name, 2, 76)   // 'L'
                                    SetByte(mod_name, 3, 69)   // 'E'
                                    SetByte(mod_name, 4, 58)   // ':'
                                    i = 0
                                    WhileLoop LessThan(i, mod_len) {
                                        SetByte(mod_name, Add(i, 5), GetByte(source, Add(mod_start, i)))
                                        i = Add(i, 1)
                                    }
                                    SetByte(mod_name, Add(mod_len, 5), 0)
                                    XArray.XPush(imports, mod_name)
                                }
                            }
                        }
                    }
                }
                
                line_start = Add(pos, 1)
            }
            
            pos = Add(pos, 1)
        }
        
        ReturnValue(imports)
    }
}

// =============================================================================
// SYMBOL EXTRACTION
// Find Function.X, SubRoutine.X definitions
// =============================================================================
Function.Import_ExtractSymbols {
    Input: source: Address
    Output: Address
    Body: {
        symbols = XArray.XCreate(64)
        len = StringLength(source)
        
        pos = 0
        WhileLoop LessThan(pos, len) {
            // Look for "Function." or "SubRoutine."
            IfCondition LessThan(Add(pos, 9), len) ThenBlock: {
                c0 = GetByte(source, pos)
                
                // Check for "Function."
                IfCondition EqualTo(c0, 70) ThenBlock: {  // 'F'
                    c8 = GetByte(source, Add(pos, 8))
                    IfCondition EqualTo(c8, 46) ThenBlock: {  // '.'
                        // Extract function name
                        name_start = Add(pos, 9)
                        name_end = name_start
                        
                        // Find end of name (space, newline, or '{')
                        WhileLoop LessThan(name_end, len) {
                            nc = GetByte(source, name_end)
                            IfCondition Or(EqualTo(nc, 32), Or(EqualTo(nc, 10), Or(EqualTo(nc, 13), EqualTo(nc, 123)))) ThenBlock: {
                                BreakLoop
                            }
                            name_end = Add(name_end, 1)
                        }
                        
                        name_len = Subtract(name_end, name_start)
                        IfCondition GreaterThan(name_len, 0) ThenBlock: {
                            sym_name = Allocate(Add(name_len, 1))
                            i = 0
                            WhileLoop LessThan(i, name_len) {
                                SetByte(sym_name, i, GetByte(source, Add(name_start, i)))
                                i = Add(i, 1)
                            }
                            SetByte(sym_name, name_len, 0)
                            
                            sym_hash = Import_HashString(sym_name)
                            XArray.XPush(symbols, sym_hash)
                            Deallocate(sym_name, Add(name_len, 1))
                        }
                        
                        pos = name_end
                    }
                }
                
                // Check for "SubRoutine."
                IfCondition EqualTo(c0, 83) ThenBlock: {  // 'S'
                    IfCondition LessThan(Add(pos, 11), len) ThenBlock: {
                        c10 = GetByte(source, Add(pos, 10))
                        IfCondition EqualTo(c10, 46) ThenBlock: {  // '.'
                            name_start = Add(pos, 11)
                            name_end = name_start
                            
                            WhileLoop LessThan(name_end, len) {
                                nc = GetByte(source, name_end)
                                IfCondition Or(EqualTo(nc, 32), Or(EqualTo(nc, 10), Or(EqualTo(nc, 13), EqualTo(nc, 123)))) ThenBlock: {
                                    BreakLoop
                                }
                                name_end = Add(name_end, 1)
                            }
                            
                            name_len = Subtract(name_end, name_start)
                            IfCondition GreaterThan(name_len, 0) ThenBlock: {
                                sym_name = Allocate(Add(name_len, 1))
                                i = 0
                                WhileLoop LessThan(i, name_len) {
                                    SetByte(sym_name, i, GetByte(source, Add(name_start, i)))
                                    i = Add(i, 1)
                                }
                                SetByte(sym_name, name_len, 0)
                                
                                sym_hash = Import_HashString(sym_name)
                                XArray.XPush(symbols, sym_hash)
                                Deallocate(sym_name, Add(name_len, 1))
                            }
                            
                            pos = name_end
                        }
                    }
                }
            }
            
            pos = Add(pos, 1)
        }
        
        ReturnValue(symbols)
    }
}

// =============================================================================
// CONFLICT DETECTION
// =============================================================================
Function.Import_DetectConflicts {
    Input: state: Address
    Body: {
        symbol_table = Dereference(Add(state, 24))
        conflicts = Dereference(Add(state, 32))
        
        sym_count = XArray.XSize(symbol_table)
        
        // For each symbol, check if it appears in multiple modules
        i = 0
        WhileLoop LessThan(i, sym_count) {
            sym_hash = XArray.XGet(symbol_table, i)
            mod_idx = XArray.XGet(symbol_table, Add(i, 1))
            
            // Count occurrences of this symbol hash
            occurrences = 0
            j = 0
            WhileLoop LessThan(j, sym_count) {
                other_hash = XArray.XGet(symbol_table, j)
                IfCondition EqualTo(sym_hash, other_hash) ThenBlock: {
                    occurrences = Add(occurrences, 1)
                }
                j = Add(j, 2)  // Skip module index
            }
            
            // If multiple occurrences, mark as conflict
            IfCondition GreaterThan(occurrences, 1) ThenBlock: {
                // Check if already in conflicts
                already = 0
                conf_count = XArray.XSize(conflicts)
                k = 0
                WhileLoop LessThan(k, conf_count) {
                    existing_hash = XArray.XGet(conflicts, k)
                    IfCondition EqualTo(existing_hash, sym_hash) ThenBlock: {
                        already = 1
                        BreakLoop
                    }
                    k = Add(k, 1)
                }
                
                IfCondition EqualTo(already, 0) ThenBlock: {
                    XArray.XPush(conflicts, sym_hash)
                }
            }
            
            i = Add(i, 2)  // symbol_table stores (hash, module_idx) pairs
        }
    }
}

// =============================================================================
// PREFIX GENERATION
// Generate "NSXXXXXX" prefixes for conflicting modules
// =============================================================================
Function.Import_GeneratePrefix {
    Input: state: Address
    Output: Address
    Body: {
        counter = Dereference(Add(state, 48))
        
        // Generate prefix: "NS" + 6 alphanumeric chars from counter
        prefix = Allocate(9)  // "NSXXXXXX" + null
        SetByte(prefix, 0, 78)  // 'N'
        SetByte(prefix, 1, 83)  // 'S'
        
        // Convert counter to base-36 characters
        val = counter
        i = 7
        WhileLoop GreaterEqual(i, 2) {
            digit = Modulo(val, 36)
            IfCondition LessThan(digit, 10) ThenBlock: {
                SetByte(prefix, i, Add(48, digit))  // '0'-'9'
            } ElseBlock: {
                SetByte(prefix, i, Add(55, digit))  // 'A'-'Z'
            }
            val = Divide(val, 36)
            i = Subtract(i, 1)
        }
        SetByte(prefix, 8, 0)
        
        // Increment counter
        StoreValue(Add(state, 48), Add(counter, 1))
        
        ReturnValue(prefix)
    }
}

// =============================================================================
// MODULE LOADING
// Uses ReadTextFile (from Python compiler) to read file contents
// =============================================================================
Function.Import_LoadModule {
    Input: state: Address
    Input: module_name: Address
    Output: Integer
    Body: {
        // Check if this is a file import (starts with "FILE:")
        c0 = GetByte(module_name, 0)
        IfCondition EqualTo(c0, 70) ThenBlock: {  // 'F'
            c4 = GetByte(module_name, 4)
            IfCondition EqualTo(c4, 58) ThenBlock: {  // ':'
                // File import: look in current directory
                file_name = Add(module_name, 5)  // Skip "FILE:"
                path = Import_BuildFilePath(file_name)
                ReturnValue(Import_LoadFromPath(state, path, module_name))
            }
        }
        
        // Library import: build Librarys/... path
        path = Import_BuildPath(state, module_name)
        ReturnValue(Import_LoadFromPath(state, path, module_name))
    }
}

Function.Import_BuildFilePath {
    Input: file_name: Address
    Output: Address
    Body: {
        name_len = StringLength(file_name)
        // filename + ".ailang" + null
        path = Allocate(Add(name_len, 8))
        
        i = 0
        WhileLoop LessThan(i, name_len) {
            SetByte(path, i, GetByte(file_name, i))
            i = Add(i, 1)
        }
        
        // Add ".ailang"
        SetByte(path, name_len, 46)        // '.'
        SetByte(path, Add(name_len, 1), 97)  // 'a'
        SetByte(path, Add(name_len, 2), 105) // 'i'
        SetByte(path, Add(name_len, 3), 108) // 'l'
        SetByte(path, Add(name_len, 4), 97)  // 'a'
        SetByte(path, Add(name_len, 5), 110) // 'n'
        SetByte(path, Add(name_len, 6), 103) // 'g'
        SetByte(path, Add(name_len, 7), 0)
        
        ReturnValue(path)
    }
}

// Helper: Read file into allocated buffer (workaround for ReadTextFile bug)
Function.Import_ReadFile {
    Input: path: Address
    Output: Address
    Body: {
        // Allocate buffer (64KB max file size for imports)
        max_size = 65536
        buffer = Allocate(Add(max_size, 1))
        
        // Read file using ReadBinaryFile (works with variable paths)
        bytes_read = ReadBinaryFile(path, buffer, max_size)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            Deallocate(buffer, Add(max_size, 1))
            ReturnValue(0)
        }
        
        // Null-terminate
        SetByte(buffer, bytes_read, 0)
        
        ReturnValue(buffer)
    }
}

Function.Import_LoadFromPath {
    Input: state: Address
    Input: path: Address
    Input: module_name: Address
    Output: Integer
    Body: {
        // Check if already loaded
        is_loaded = Import_IsLoaded(state, path)
        IfCondition EqualTo(is_loaded, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        // Check if file exists first
        exists = FileExists(path)
        IfCondition EqualTo(exists, 0) ThenBlock: {
            PrintMessage("[IMPORT ERROR] File not found: ")
            PrintMessage(path)
            PrintMessage("\n")
            
            error_count = Dereference(Add(state, 72))
            StoreValue(Add(state, 72), Add(error_count, 1))
            
            ReturnValue(0)
        }
        
        // Read file using helper (avoids ReadTextFile bug with variables)
        content = Import_ReadFile(path)
        IfCondition EqualTo(content, 0) ThenBlock: {
            PrintMessage("[IMPORT ERROR] Cannot read: ")
            PrintMessage(path)
            PrintMessage("\n")
            
            error_count = Dereference(Add(state, 72))
            StoreValue(Add(state, 72), Add(error_count, 1))
            
            ReturnValue(0)
        }
        
        // Mark as loaded
        mod_name_str = Import_AllocString(module_name)
        Import_MarkLoaded(state, path, content, mod_name_str)
        
        // Get module index
        loaded_paths = Dereference(state)
        module_idx = Subtract(XArray.XSize(loaded_paths), 1)
        
        // Extract symbols and add to symbol table
        symbols = Import_ExtractSymbols(content)
        symbol_table = Dereference(Add(state, 24))
        sym_count = XArray.XSize(symbols)
        
        i = 0
        WhileLoop LessThan(i, sym_count) {
            sym_hash = XArray.XGet(symbols, i)
            XArray.XPush(symbol_table, sym_hash)
            XArray.XPush(symbol_table, module_idx)
            i = Add(i, 1)
        }
        XArray.XDestroy(symbols)
        
        // Recursively load sub-imports
        sub_imports = Import_ExtractImports(content)
        sub_count = XArray.XSize(sub_imports)
        
        i = 0
        WhileLoop LessThan(i, sub_count) {
            sub_name = XArray.XGet(sub_imports, i)
            Import_LoadModule(state, sub_name)
            i = Add(i, 1)
        }
        XArray.XDestroy(sub_imports)
        
        ReturnValue(1)
    }
}

// =============================================================================
// SOURCE COMBINATION
// Inline file imports, deduplicate library imports
// =============================================================================
Function.Import_CombineSources {
    Input: state: Address
    Input: main_source: Address
    Output: Address
    Body: {
        output = XArray.XCreate(2048)
        
        loaded_content = Dereference(Add(state, 8))
        loaded_names = Dereference(Add(state, 16))
        module_count = XArray.XSize(loaded_content)
        
        // === REMOVED: No longer collect/emit LibraryImport statements ===
        // The self-hosting compiler inlines everything, no deferred resolution
        
        // Inline ALL loaded modules (both file imports AND library imports)
        i = 0
        WhileLoop LessThan(i, module_count) {
            mod_name = XArray.XGet(loaded_names, i)
            content = XArray.XGet(loaded_content, i)
            
            // Build header
            header = Import_BuildHeader(mod_name)
            XArray.XPush(output, header)
            
            // Inline content (strip import lines to avoid re-processing)
            Import_InlineContent(content, output)
            
            blank = Import_AllocString("")
            XArray.XPush(output, blank)
            
            i = Add(i, 1)
        }
        
        // Add main source comment
        main_header = Import_AllocString("// === Main module ===")
        XArray.XPush(output, main_header)
        
        // Inline main source (strip import lines)
        Import_InlineContent(main_source, output)
        
        // Combine all lines into single buffer
        ReturnValue(Import_JoinLines(output))
    }
}


// NEW FUNCTION: Build header as single concatenated string
Function.Import_BuildHeader {
    Input: mod_name: Address
    Output: Address
    Body: {
        // "// === Inlined from " + mod_name + " ==="
        prefix = "// === Inlined from "
        suffix = " ==="
        
        prefix_len = StringLength(prefix)
        name_len = StringLength(mod_name)
        suffix_len = StringLength(suffix)
        
        total_len = Add(Add(prefix_len, name_len), suffix_len)
        result = Allocate(Add(total_len, 1))
        
        pos = 0
        
        // Copy prefix
        i = 0
        WhileLoop LessThan(i, prefix_len) {
            SetByte(result, pos, GetByte(prefix, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Copy mod_name
        i = 0
        WhileLoop LessThan(i, name_len) {
            SetByte(result, pos, GetByte(mod_name, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Copy suffix
        i = 0
        WhileLoop LessThan(i, suffix_len) {
            SetByte(result, pos, GetByte(suffix, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        SetByte(result, total_len, 0)
        ReturnValue(result)
    }
}

// Collect unique LibraryImport lines
Function.Import_CollectLibraryImports {
    Input: source: Address
    Input: imports: Address
    Body: {
        len = StringLength(source)
        pos = 0
        line_start = 0
        
        WhileLoop LessThan(pos, len) {
            c = GetByte(source, pos)
            
            IfCondition EqualTo(c, 10) ThenBlock: {
                line_len = Subtract(pos, line_start)
                
                // Check for "LibraryImport."
                IfCondition GreaterEqual(line_len, 14) ThenBlock: {
                    c0 = GetByte(source, line_start)
                    IfCondition EqualTo(c0, 76) ThenBlock: {  // 'L'
                        // Copy line
                        line = Allocate(Add(line_len, 1))
                        i = 0
                        WhileLoop LessThan(i, line_len) {
                            SetByte(line, i, GetByte(source, Add(line_start, i)))
                            i = Add(i, 1)
                        }
                        SetByte(line, line_len, 0)
                        
                        // Check if duplicate
                        is_dup = 0
                        imp_count = XArray.XSize(imports)
                        j = 0
                        WhileLoop LessThan(j, imp_count) {
                            existing = XArray.XGet(imports, j)
                            cmp_res = StringCompare(line, existing)
                            IfCondition EqualTo(cmp_res, 0) ThenBlock: {
                                is_dup = 1
                                BreakLoop
                            }
                            j = Add(j, 1)
                        }
                        
                        IfCondition EqualTo(is_dup, 0) ThenBlock: {
                            XArray.XPush(imports, line)
                        } ElseBlock: {
                            Deallocate(line, Add(line_len, 1))
                        }
                    }
                }
                
                line_start = Add(pos, 1)
            }
            
            pos = Add(pos, 1)
        }
    }
}

// Inline content, skipping import lines
Function.Import_InlineContent {
    Input: source: Address
    Input: output: Address
    Body: {
        len = StringLength(source)
        pos = 0
        line_start = 0
        
        WhileLoop LessEqual(pos, len) {
            c = GetByte(source, pos)
            
            // Check for newline or end of string
            IfCondition Or(EqualTo(c, 10), EqualTo(pos, len)) ThenBlock: {
                line_len = Subtract(pos, line_start)
                
                // Default: include line
                skip_line = 0
                
                // Check for "LibraryImport." (14 chars) - skip these
                IfCondition GreaterEqual(line_len, 14) ThenBlock: {
                    c0 = GetByte(source, line_start)
                    IfCondition EqualTo(c0, 76) ThenBlock: {  // 'L'
                        c7 = GetByte(source, Add(line_start, 7))
                        IfCondition EqualTo(c7, 73) ThenBlock: {  // 'I' at pos 7
                            c13 = GetByte(source, Add(line_start, 13))
                            IfCondition EqualTo(c13, 46) ThenBlock: {  // '.' at pos 13
                                skip_line = 1
                            }
                        }
                    }
                }
                
                // Check for "Import." (7 chars) - skip these
                IfCondition And(EqualTo(skip_line, 0), GreaterEqual(line_len, 7)) ThenBlock: {
                    c0 = GetByte(source, line_start)
                    IfCondition EqualTo(c0, 73) ThenBlock: {  // 'I'
                        c1 = GetByte(source, Add(line_start, 1))
                        IfCondition EqualTo(c1, 109) ThenBlock: {  // 'm'
                            c6 = GetByte(source, Add(line_start, 6))
                            IfCondition EqualTo(c6, 46) ThenBlock: {  // '.'
                                skip_line = 1
                            }
                        }
                    }
                }
                
                // Copy line if not skipped
                IfCondition EqualTo(skip_line, 0) ThenBlock: {
                    IfCondition GreaterThan(line_len, 0) ThenBlock: {
                        line = Allocate(Add(line_len, 1))
                        j = 0
                        WhileLoop LessThan(j, line_len) {
                            SetByte(line, j, GetByte(source, Add(line_start, j)))
                            j = Add(j, 1)
                        }
                        SetByte(line, line_len, 0)
                        XArray.XPush(output, line)
                    } ElseBlock: {
                        // Empty line
                        empty = Import_AllocString("")
                        XArray.XPush(output, empty)
                    }
                }
                
                line_start = Add(pos, 1)
            }
            
            pos = Add(pos, 1)
        }
    }
}


// Join lines into single buffer
Function.Import_JoinLines {
    Input: lines: Address
    Output: Address
    Body: {
        // Calculate total size
        total_size = 0
        line_count = XArray.XSize(lines)
        
        i = 0
        WhileLoop LessThan(i, line_count) {
            line = XArray.XGet(lines, i)
            len = StringLength(line)
            total_size = Add(total_size, len)
            total_size = Add(total_size, 1)  // newline
            i = Add(i, 1)
        }
        
        // Allocate and copy
        result = Allocate(Add(total_size, 1))
        pos = 0
        
        i = 0
        WhileLoop LessThan(i, line_count) {
            line = XArray.XGet(lines, i)
            line_len = StringLength(line)
            
            j = 0
            WhileLoop LessThan(j, line_len) {
                SetByte(result, pos, GetByte(line, j))
                pos = Add(pos, 1)
                j = Add(j, 1)
            }
            SetByte(result, pos, 10)  // newline
            pos = Add(pos, 1)
            
            i = Add(i, 1)
        }
        
        SetByte(result, pos, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================
Function.Import_ResolveAll {
    Input: main_source: Address
    Output: Address
    Body: {
        state = Import_Init()
        
        // Extract imports from main source
        imports = Import_ExtractImports(main_source)
        count = XArray.XSize(imports)
        
        PrintMessage("[IMPORT] Found ")
        PrintNumber(count)
        PrintMessage(" imports\n")
        
        // Load each import recursively
        i = 0
        WhileLoop LessThan(i, count) {
            mod_name = XArray.XGet(imports, i)
            PrintMessage("[IMPORT] Loading: ")
            PrintMessage(mod_name)
            PrintMessage("\n")
            
            Import_LoadModule(state, mod_name)
            i = Add(i, 1)
        }
        
        // Detect conflicts
        Import_DetectConflicts(state)
        
        conflicts = Dereference(Add(state, 32))
        conf_count = XArray.XSize(conflicts)
        IfCondition GreaterThan(conf_count, 0) ThenBlock: {
            PrintMessage("[IMPORT] Found ")
            PrintNumber(conf_count)
            PrintMessage(" symbol conflicts\n")
        }
        
        // Report stats
        loaded_paths = Dereference(state)
        loaded_count = XArray.XSize(loaded_paths)
        PrintMessage("[IMPORT] Total modules loaded: ")
        PrintNumber(loaded_count)
        PrintMessage("\n")
        
        error_count = Dereference(Add(state, 72))
        IfCondition GreaterThan(error_count, 0) ThenBlock: {
            PrintMessage("[IMPORT] ERRORS: ")
            PrintNumber(error_count)
            PrintMessage("\n")
            ReturnValue(0)
        }
        
        // Combine sources
        combined = Import_CombineSources(state, main_source)
        
        XArray.XDestroy(imports)
        
        ReturnValue(combined)
    }
}