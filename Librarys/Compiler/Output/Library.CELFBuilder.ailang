// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.CELFBuilder.ailang
// ELF64 executable builder for Linux x86-64
// Location: Librarys/Compiler/Output/Library.CELFBuilder.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Output.CELFTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.ELF_Init {
    Body: {
        // Allocate output buffer (start with 64KB)
        ELF.buffer_capacity = 65536
        ELF.buffer = Allocate(ELF.buffer_capacity)
        ELF.buffer_size = 0
        
        // Initialize addresses
        ELF.base_addr = ELFDefault.BASE_ADDR
        ELF.entry_addr = 0
        ELF.text_addr = 0
        ELF.data_addr = 0
        
        // Section tracking
        ELF.text_offset = 0
        ELF.text_size = 0
        ELF.data_offset = 0
        ELF.data_size = 0
        ELF.bss_size = 0
        
        // Headers
        ELF.phdr_count = 0
        ELF.shdr_count = 0
        
        // String table
        ELF.shstrtab = Allocate(256)
        ELF.shstrtab_size = 0
        
        // Clear errors
        ELF.error = 0
        ELF.error_msg = 0
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.ELF_Free {
    Body: {
        IfCondition NotEqual(ELF.buffer, 0) ThenBlock: {
            Deallocate(ELF.buffer, ELF.buffer_capacity)
            ELF.buffer = 0
        }
        IfCondition NotEqual(ELF.shstrtab, 0) ThenBlock: {
            Deallocate(ELF.shstrtab, 256)
            ELF.shstrtab = 0
        }
        ELF.buffer_size = 0
    }
}

// =============================================================================
// LOW-LEVEL BUFFER OPERATIONS
// =============================================================================

Function.ELF_WriteByte {
    Input: b: Integer
    Body: {
        IfCondition GreaterEqual(ELF.buffer_size, ELF.buffer_capacity) ThenBlock: {
            ELF_GrowBuffer()
        }
        SetByte(ELF.buffer, ELF.buffer_size, b)
        ELF.buffer_size = Add(ELF.buffer_size, 1)
    }
}

Function.ELF_WriteWord {
    Input: w: Integer
    Body: {
        ELF_WriteByte(BitwiseAnd(w, 255))
        ELF_WriteByte(BitwiseAnd(RightShift(w, 8), 255))
    }
}

Function.ELF_WriteDWord {
    Input: d: Integer
    Body: {
        ELF_WriteByte(BitwiseAnd(d, 255))
        ELF_WriteByte(BitwiseAnd(RightShift(d, 8), 255))
        ELF_WriteByte(BitwiseAnd(RightShift(d, 16), 255))
        ELF_WriteByte(BitwiseAnd(RightShift(d, 24), 255))
    }
}

Function.ELF_WriteQWord {
    Input: q: Integer
    Body: {
        ELF_WriteDWord(BitwiseAnd(q, 4294967295))
        ELF_WriteDWord(RightShift(q, 32))
    }
}

Function.ELF_WriteBytes {
    Input: ptr: Address
    Input: count: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, count) {
            b = GetByte(ptr, i)
            ELF_WriteByte(b)
            i = Add(i, 1)
        }
    }
}

Function.ELF_WriteZeros {
    Input: count: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, count) {
            ELF_WriteByte(0)
            i = Add(i, 1)
        }
    }
}

Function.ELF_GrowBuffer {
    Body: {
        new_capacity = Multiply(ELF.buffer_capacity, 2)
        new_buffer = Allocate(new_capacity)
        
        // Copy existing data
        i = 0
        WhileLoop LessThan(i, ELF.buffer_size) {
            b = GetByte(ELF.buffer, i)
            SetByte(new_buffer, i, b)
            i = Add(i, 1)
        }
        
        Deallocate(ELF.buffer, ELF.buffer_capacity)
        ELF.buffer = new_buffer
        ELF.buffer_capacity = new_capacity
    }
}

Function.ELF_Align {
    Input: alignment: Integer
    Body: {
        remainder = Modulo(ELF.buffer_size, alignment)
        IfCondition NotEqual(remainder, 0) ThenBlock: {
            padding = Subtract(alignment, remainder)
            ELF_WriteZeros(padding)
        }
    }
}

// =============================================================================
// STRING TABLE MANAGEMENT
// =============================================================================

Function.ELF_AddString {
    Input: str: Address
    Output: Integer
    Body: {
        offset = ELF.shstrtab_size
        
        // Copy string including null terminator
        i = 0
        done = 0
        WhileLoop EqualTo(done, 0) {
            c = GetByte(str, i)
            SetByte(ELF.shstrtab, ELF.shstrtab_size, c)
            ELF.shstrtab_size = Add(ELF.shstrtab_size, 1)
            IfCondition EqualTo(c, 0) ThenBlock: {
                done = 1
            }
            i = Add(i, 1)
        }
        
        ReturnValue(offset)
    }
}

// =============================================================================
// ELF HEADER
// =============================================================================

Function.ELF_WriteHeader {
    Input: entry: Integer
    Input: phoff: Integer
    Input: shoff: Integer
    Input: phnum: Integer
    Input: shnum: Integer
    Input: shstrndx: Integer
    Body: {
        // e_ident[0..3]: Magic number
        ELF_WriteByte(ELFMagic.MAG0)
        ELF_WriteByte(ELFMagic.MAG1)
        ELF_WriteByte(ELFMagic.MAG2)
        ELF_WriteByte(ELFMagic.MAG3)
        
        // e_ident[4]: Class (64-bit)
        ELF_WriteByte(ELFClass.CLASS64)
        
        // e_ident[5]: Data encoding (little endian)
        ELF_WriteByte(ELFData.LSB)
        
        // e_ident[6]: Version
        ELF_WriteByte(ELFVersion.CURRENT)
        
        // e_ident[7]: OS/ABI
        ELF_WriteByte(ELFOSABI.NONE)
        
        // e_ident[8..15]: Padding
        ELF_WriteZeros(8)
        
        // e_type: Executable
        ELF_WriteWord(ELFType.EXEC)
        
        // e_machine: x86-64
        ELF_WriteWord(ELFMachine.X86_64)
        
        // e_version
        ELF_WriteDWord(ELFVersion.CURRENT)
        
        // e_entry: Entry point
        ELF_WriteQWord(entry)
        
        // e_phoff: Program header offset
        ELF_WriteQWord(phoff)
        
        // e_shoff: Section header offset
        ELF_WriteQWord(shoff)
        
        // e_flags: Processor flags (none for x86-64)
        ELF_WriteDWord(0)
        
        // e_ehsize: ELF header size
        ELF_WriteWord(ELFHdr.SIZE)
        
        // e_phentsize: Program header entry size
        ELF_WriteWord(PHdr.SIZE)
        
        // e_phnum: Number of program headers
        ELF_WriteWord(phnum)
        
        // e_shentsize: Section header entry size
        ELF_WriteWord(SHdr.SIZE)
        
        // e_shnum: Number of section headers
        ELF_WriteWord(shnum)
        
        // e_shstrndx: Section header string table index
        ELF_WriteWord(shstrndx)
    }
}

// =============================================================================
// PROGRAM HEADER
// =============================================================================

// =============================================================================
// PROGRAM HEADER - Split to stay under 6 param limit
// =============================================================================

Function.ELF_WriteProgramHeader {
    Input: p_type: Integer
    Input: p_flags: Integer
    Input: p_offset: Integer
    Input: p_vaddr: Integer
    Input: p_filesz: Integer
    Input: p_align: Integer
    Body: {
        ELF_WriteDWord(p_type)
        ELF_WriteDWord(p_flags)
        ELF_WriteQWord(p_offset)
        ELF_WriteQWord(p_vaddr)
        ELF_WriteQWord(p_vaddr)      // p_paddr = p_vaddr
        ELF_WriteQWord(p_filesz)
        ELF_WriteQWord(p_filesz)     // p_memsz = p_filesz
        ELF_WriteQWord(p_align)
    }
}

// =============================================================================
// SECTION HEADER
// =============================================================================

Function.ELF_WriteSectionHeader {
    Input: sh_name: Integer
    Input: sh_type: Integer
    Input: sh_flags: Integer
    Input: sh_addr: Integer
    Input: sh_offset: Integer
    Input: sh_size: Integer
    Input: sh_link: Integer
    Input: sh_info: Integer
    Input: sh_addralign: Integer
    Input: sh_entsize: Integer
    Body: {
        ELF_WriteDWord(sh_name)
        ELF_WriteDWord(sh_type)
        ELF_WriteQWord(sh_flags)
        ELF_WriteQWord(sh_addr)
        ELF_WriteQWord(sh_offset)
        ELF_WriteQWord(sh_size)
        ELF_WriteDWord(sh_link)
        ELF_WriteDWord(sh_info)
        ELF_WriteQWord(sh_addralign)
        ELF_WriteQWord(sh_entsize)
    }
}

// =============================================================================
// MAIN BUILD FUNCTION
// Creates a minimal executable from code and data buffers
// =============================================================================

// =============================================================================
// ELF BUILD - Main entry point
// =============================================================================
Function.ELF_Build {
    Input: code: Address
    Input: code_size: Integer
    Input: data: Address
    Input: data_size: Integer
    Output: Integer
    Body: {
        PrintMessage("[ELF] Building executable...\n")
        
        // Layout calculation:
        // [ELF Header: 64 bytes]
        // [Program Headers: 2 * 56 = 112 bytes]
        // [.text section: code_size bytes, aligned]
        // [.data section: data_size bytes, aligned]
        
        // Calculate offsets
        elf_hdr_size = ELFHdr.SIZE                    // 64
        phdr_offset = elf_hdr_size                    // 64
        phdr_count = 2                                // .text and .data segments
        phdr_total = Multiply(phdr_count, PHdr.SIZE)  // 112
        
        // Code starts after headers
        text_offset = Add(phdr_offset, phdr_total)    // 176
        
        // Align text to 16 bytes
        text_offset_aligned = BitwiseAnd(Add(text_offset, 15), -16)
        
        // Data follows code (page aligned for separate segment)
        data_offset = Add(text_offset_aligned, code_size)
        data_offset_aligned = BitwiseAnd(Add(data_offset, 4095), -4096)
        
        // Calculate virtual addresses
        base = ELF.base_addr
        text_vaddr = Add(base, text_offset_aligned)
        data_vaddr = Add(base, data_offset_aligned)
        
        // Entry point is start of code
        entry_vaddr = text_vaddr
        
        PrintMessage("[ELF] Layout:\n")
        PrintMessage("  Code offset: ")
        PrintNumber(text_offset_aligned)
        PrintMessage(", size: ")
        PrintNumber(code_size)
        PrintMessage("\n")
        PrintMessage("  Data offset: ")
        PrintNumber(data_offset_aligned)
        PrintMessage(", size: ")
        PrintNumber(data_size)
        PrintMessage("\n")
        PrintMessage("  Code vaddr: 0x")
        PrintNumber(text_vaddr)
        PrintMessage("\n")
        PrintMessage("  Data vaddr: 0x")
        PrintNumber(data_vaddr)
        PrintMessage("\n")
        PrintMessage("  Entry: 0x")
        PrintNumber(entry_vaddr)
        PrintMessage("\n")
        
        // Apply data relocations before writing
        Emit_SetBaseAddresses(text_vaddr, data_vaddr)
        Emit_ApplyDataRelocations()
        
        // Write ELF header (no section headers)
        ELF_WriteHeader(entry_vaddr, phdr_offset, 0, phdr_count, 0, 0)
        
        // Write program headers
        // PT_LOAD for .text (read + execute)
        ELF_WriteProgramHeader(PHType.LOAD, PHFlags.RX, text_offset_aligned, text_vaddr, code_size, ELFDefault.PAGE_SIZE)
        
        // PT_LOAD for .data (read + write)
        ELF_WriteProgramHeader(PHType.LOAD, PHFlags.RW, data_offset_aligned, data_vaddr, data_size, ELFDefault.PAGE_SIZE)
        
        // Pad to text offset
        WhileLoop LessThan(ELF.buffer_size, text_offset_aligned) {
            ELF_WriteByte(0)
        }
        
        // Write code
        ELF_WriteBytes(code, code_size)
        
        // Pad to data offset
        WhileLoop LessThan(ELF.buffer_size, data_offset_aligned) {
            ELF_WriteByte(0)
        }
        
        // Write data
        ELF_WriteBytes(data, data_size)
        
        PrintMessage("[ELF] Build complete: ")
        PrintNumber(ELF.buffer_size)
        PrintMessage(" bytes\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// SIMPLE BUILD (from Emit buffers)
// =============================================================================

Function.ELF_BuildFromEmit {
    Output: Integer
    Body: {
        ReturnValue(ELF_Build(Emit.code, Emit.code_size, Emit.data, Emit.data_size))
    }
}

// =============================================================================
// OUTPUT
// =============================================================================

Function.ELF_GetBuffer {
    Output: Address
    Body: {
        ReturnValue(ELF.buffer)
    }
}

Function.ELF_GetSize {
    Output: Integer
    Body: {
        ReturnValue(ELF.buffer_size)
    }
}

// =============================================================================
// FILE OUTPUT
// =============================================================================

Function.ELF_WriteFile {
    Input: filename: Address
    Output: Integer
    Body: {
        PrintMessage("[ELF] Writing to: ")
        PrintMessage(filename)
        PrintMessage("\n")
        
        // Open file for writing (O_WRONLY | O_CREAT | O_TRUNC = 577)
        // Mode 0755 = 493
        fd = FileOpen(filename, 577, 493)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            PrintMessage("[ELF] ERROR: Could not open file\n")
            ReturnValue(0)
        }
        
        // Write buffer
        written = FileWrite(fd, ELF.buffer, ELF.buffer_size)
        
        // Close file
        FileClose(fd)
        
        IfCondition NotEqual(written, ELF.buffer_size) ThenBlock: {
            PrintMessage("[ELF] WARNING: Incomplete write\n")
            ReturnValue(0)
        }
        
        PrintMessage("[ELF] Wrote ")
        PrintNumber(written)
        PrintMessage(" bytes\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE I/O STUBS (implement via syscalls or runtime)
// =============================================================================
Function.FileOpen { Input: path: Address Input: flags: Integer Input: mode: Integer Output: Integer Body: { ReturnValue(-1) } }
Function.FileWrite { Input: fd: Integer Input: buf: Address Input: count: Integer Output: Integer Body: { ReturnValue(0) } }
Function.FileClose { Input: fd: Integer Body: { } }