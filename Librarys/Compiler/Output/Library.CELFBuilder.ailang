// Library.CELFBuilder.ailang
// ELF64 executable builder for Linux x86-64
// Location: Librarys/Compiler/Output/Library.CELFBuilder.ailang

LibraryImport.XArrays
LibraryImport.Compiler.Output.CELFTypes
LibraryImport.Compiler.CodeEmit.CEmitCore

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.ELF_Init {
    Body: {
        // Allocate output buffer (start with 64KB)
        ELF.buffer_capacity = 65536
        ELF.buffer = Allocate(ELF.buffer_capacity)
        ELF.buffer_size = 0
        
        // Initialize addresses
        ELF.base_addr = ELFDefault.BASE_ADDR
        ELF.entry_addr = 0
        ELF.text_addr = 0
        ELF.data_addr = 0
        
        // Section tracking
        ELF.text_offset = 0
        ELF.text_size = 0
        ELF.data_offset = 0
        ELF.data_size = 0
        ELF.bss_size = 0
        
        // Headers
        ELF.phdr_count = 0
        ELF.shdr_count = 0
        
        // String table
        ELF.shstrtab = Allocate(256)
        ELF.shstrtab_size = 0
        
        // Clear errors
        ELF.error = 0
        ELF.error_msg = 0
        
        ReturnValue(1)
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.ELF_Free {
    Body: {
        IfCondition NotEqual(ELF.buffer, 0) ThenBlock: {
            Deallocate(ELF.buffer, ELF.buffer_capacity)
            ELF.buffer = 0
        }
        IfCondition NotEqual(ELF.shstrtab, 0) ThenBlock: {
            Deallocate(ELF.shstrtab, 256)
            ELF.shstrtab = 0
        }
        ELF.buffer_size = 0
    }
}

// =============================================================================
// LOW-LEVEL BUFFER OPERATIONS
// =============================================================================

Function.ELF_WriteByte {
    Input: b: Integer
    Body: {
        IfCondition GreaterOrEqual(ELF.buffer_size, ELF.buffer_capacity) ThenBlock: {
            ELF_GrowBuffer()
        }
        SetByte(Add(ELF.buffer, ELF.buffer_size), b)
        ELF.buffer_size = Add(ELF.buffer_size, 1)
    }
}

Function.ELF_WriteWord {
    Input: w: Integer
    Body: {
        ELF_WriteByte(BitAnd(w, 255))
        ELF_WriteByte(BitAnd(ShiftRight(w, 8), 255))
    }
}

Function.ELF_WriteDWord {
    Input: d: Integer
    Body: {
        ELF_WriteByte(BitAnd(d, 255))
        ELF_WriteByte(BitAnd(ShiftRight(d, 8), 255))
        ELF_WriteByte(BitAnd(ShiftRight(d, 16), 255))
        ELF_WriteByte(BitAnd(ShiftRight(d, 24), 255))
    }
}

Function.ELF_WriteQWord {
    Input: q: Integer
    Body: {
        ELF_WriteDWord(BitAnd(q, 4294967295))
        ELF_WriteDWord(ShiftRight(q, 32))
    }
}

Function.ELF_WriteBytes {
    Input: ptr: Address
    Input: count: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, count) {
            b = GetByte(Add(ptr, i))
            ELF_WriteByte(b)
            i = Add(i, 1)
        }
    }
}

Function.ELF_WriteZeros {
    Input: count: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, count) {
            ELF_WriteByte(0)
            i = Add(i, 1)
        }
    }
}

Function.ELF_GrowBuffer {
    Body: {
        new_capacity = Multiply(ELF.buffer_capacity, 2)
        new_buffer = Allocate(new_capacity)
        
        // Copy existing data
        i = 0
        WhileLoop LessThan(i, ELF.buffer_size) {
            b = GetByte(Add(ELF.buffer, i))
            SetByte(Add(new_buffer, i), b)
            i = Add(i, 1)
        }
        
        Deallocate(ELF.buffer, ELF.buffer_capacity)
        ELF.buffer = new_buffer
        ELF.buffer_capacity = new_capacity
    }
}

Function.ELF_Align {
    Input: alignment: Integer
    Body: {
        remainder = Modulo(ELF.buffer_size, alignment)
        IfCondition NotEqual(remainder, 0) ThenBlock: {
            padding = Subtract(alignment, remainder)
            ELF_WriteZeros(padding)
        }
    }
}

// =============================================================================
// STRING TABLE MANAGEMENT
// =============================================================================

Function.ELF_AddString {
    Input: str: Address
    Output: Integer
    Body: {
        offset = ELF.shstrtab_size
        
        // Copy string including null terminator
        i = 0
        done = 0
        WhileLoop EqualTo(done, 0) {
            c = GetByte(Add(str, i))
            SetByte(Add(ELF.shstrtab, ELF.shstrtab_size), c)
            ELF.shstrtab_size = Add(ELF.shstrtab_size, 1)
            IfCondition EqualTo(c, 0) ThenBlock: {
                done = 1
            }
            i = Add(i, 1)
        }
        
        ReturnValue(offset)
    }
}

// =============================================================================
// ELF HEADER
// =============================================================================

Function.ELF_WriteHeader {
    Input: entry: Integer
    Input: phoff: Integer
    Input: shoff: Integer
    Input: phnum: Integer
    Input: shnum: Integer
    Input: shstrndx: Integer
    Body: {
        // e_ident[0..3]: Magic number
        ELF_WriteByte(ELFMagic.MAG0)
        ELF_WriteByte(ELFMagic.MAG1)
        ELF_WriteByte(ELFMagic.MAG2)
        ELF_WriteByte(ELFMagic.MAG3)
        
        // e_ident[4]: Class (64-bit)
        ELF_WriteByte(ELFClass.CLASS64)
        
        // e_ident[5]: Data encoding (little endian)
        ELF_WriteByte(ELFData.LSB)
        
        // e_ident[6]: Version
        ELF_WriteByte(ELFVersion.CURRENT)
        
        // e_ident[7]: OS/ABI
        ELF_WriteByte(ELFOSABI.NONE)
        
        // e_ident[8..15]: Padding
        ELF_WriteZeros(8)
        
        // e_type: Executable
        ELF_WriteWord(ELFType.EXEC)
        
        // e_machine: x86-64
        ELF_WriteWord(ELFMachine.X86_64)
        
        // e_version
        ELF_WriteDWord(ELFVersion.CURRENT)
        
        // e_entry: Entry point
        ELF_WriteQWord(entry)
        
        // e_phoff: Program header offset
        ELF_WriteQWord(phoff)
        
        // e_shoff: Section header offset
        ELF_WriteQWord(shoff)
        
        // e_flags: Processor flags (none for x86-64)
        ELF_WriteDWord(0)
        
        // e_ehsize: ELF header size
        ELF_WriteWord(ELFHdr.SIZE)
        
        // e_phentsize: Program header entry size
        ELF_WriteWord(PHdr.SIZE)
        
        // e_phnum: Number of program headers
        ELF_WriteWord(phnum)
        
        // e_shentsize: Section header entry size
        ELF_WriteWord(SHdr.SIZE)
        
        // e_shnum: Number of section headers
        ELF_WriteWord(shnum)
        
        // e_shstrndx: Section header string table index
        ELF_WriteWord(shstrndx)
    }
}

// =============================================================================
// PROGRAM HEADER
// =============================================================================

Function.ELF_WriteProgramHeader {
    Input: p_type: Integer
    Input: p_flags: Integer
    Input: p_offset: Integer
    Input: p_vaddr: Integer
    Input: p_filesz: Integer
    Input: p_memsz: Integer
    Input: p_align: Integer
    Body: {
        // p_type
        ELF_WriteDWord(p_type)
        
        // p_flags
        ELF_WriteDWord(p_flags)
        
        // p_offset
        ELF_WriteQWord(p_offset)
        
        // p_vaddr
        ELF_WriteQWord(p_vaddr)
        
        // p_paddr (same as vaddr for executables)
        ELF_WriteQWord(p_vaddr)
        
        // p_filesz
        ELF_WriteQWord(p_filesz)
        
        // p_memsz
        ELF_WriteQWord(p_memsz)
        
        // p_align
        ELF_WriteQWord(p_align)
    }
}

// =============================================================================
// SECTION HEADER
// =============================================================================

Function.ELF_WriteSectionHeader {
    Input: sh_name: Integer
    Input: sh_type: Integer
    Input: sh_flags: Integer
    Input: sh_addr: Integer
    Input: sh_offset: Integer
    Input: sh_size: Integer
    Input: sh_link: Integer
    Input: sh_info: Integer
    Input: sh_addralign: Integer
    Input: sh_entsize: Integer
    Body: {
        ELF_WriteDWord(sh_name)
        ELF_WriteDWord(sh_type)
        ELF_WriteQWord(sh_flags)
        ELF_WriteQWord(sh_addr)
        ELF_WriteQWord(sh_offset)
        ELF_WriteQWord(sh_size)
        ELF_WriteDWord(sh_link)
        ELF_WriteDWord(sh_info)
        ELF_WriteQWord(sh_addralign)
        ELF_WriteQWord(sh_entsize)
    }
}

// =============================================================================
// MAIN BUILD FUNCTION
// Creates a minimal executable from code and data buffers
// =============================================================================

Function.ELF_Build {
    Input: code: Address
    Input: code_size: Integer
    Input: data: Address
    Input: data_size: Integer
    Output: Integer
    Body: {
        PrintMessage("[ELF] Building executable...\n")
        
        // Layout calculation:
        // [ELF Header: 64 bytes]
        // [Program Headers: 2 * 56 = 112 bytes]
        // [.text section: code_size bytes, aligned]
        // [.data section: data_size bytes, aligned]
        // [.shstrtab section: string table]
        // [Section Headers: 5 * 64 = 320 bytes]
        
        // Calculate offsets
        elf_hdr_size = ELFHdr.SIZE                    // 64
        phdr_offset = elf_hdr_size                    // 64
        phdr_count = 2                                // .text and .data segments
        phdr_total = Multiply(phdr_count, PHdr.SIZE) // 112
        
        // Code starts after headers
        text_offset = Add(phdr_offset, phdr_total)   // 176
        
        // Align text
        text_offset_aligned = BitAnd(Add(text_offset, 15), -16)
        
        // Data follows code (page aligned for separate segment)
        data_offset = Add(text_offset_aligned, code_size)
        data_offset_aligned = BitAnd(Add(data_offset, 4095), -4096)
        
        // String table follows data
        shstrtab_offset = Add(data_offset_aligned, data_size)
        
        // Build section name string table
        ELF.shstrtab_size = 0
        SetByte(ELF.shstrtab, 0)  // First byte is null
        ELF.shstrtab_size = 1
        
        name_text = ELF_AddString(".text")
        name_data = ELF_AddString(".data")
        name_shstrtab = ELF_AddString(".shstrtab")
        
        shstrtab_size = ELF.shstrtab_size
        
        // Section headers follow string table
        shdr_offset = Add(shstrtab_offset, shstrtab_size)
        shdr_offset_aligned = BitAnd(Add(shdr_offset, 7), -8)
        shdr_count = 4  // NULL, .text, .data, .shstrtab
        
        // Calculate virtual addresses
        base = ELF.base_addr
        text_vaddr = Add(base, text_offset_aligned)
        data_vaddr = Add(base, data_offset_aligned)
        
        // Entry point is start of code
        entry_vaddr = text_vaddr
        
        PrintMessage("[ELF] Layout:\n")
        PrintMessage("  Code offset: ")
        PrintNumber(text_offset_aligned)
        PrintMessage(", size: ")
        PrintNumber(code_size)
        PrintMessage("\n")
        PrintMessage("  Data offset: ")
        PrintNumber(data_offset_aligned)
        PrintMessage(", size: ")
        PrintNumber(data_size)
        PrintMessage("\n")
        PrintMessage("  Entry: 0x")
        PrintNumber(entry_vaddr)
        PrintMessage("\n")
        
        // Write ELF header
        ELF_WriteHeader(entry_vaddr, phdr_offset, shdr_offset_aligned, phdr_count, shdr_count, 3)
        
        // Write program headers
        // PT_LOAD for .text (read + execute)
        ELF_WriteProgramHeader(PHType.LOAD, PHFlags.RX, text_offset_aligned, text_vaddr, code_size, code_size, ELFDefault.PAGE_SIZE)
        
        // PT_LOAD for .data (read + write)
        ELF_WriteProgramHeader(PHType.LOAD, PHFlags.RW, data_offset_aligned, data_vaddr, data_size, data_size, ELFDefault.PAGE_SIZE)
        
        // Pad to text offset
        WhileLoop LessThan(ELF.buffer_size, text_offset_aligned) {
            ELF_WriteByte(0)
        }
        
        // Write code
        ELF_WriteBytes(code, code_size)
        
        // Pad to data offset
        WhileLoop LessThan(ELF.buffer_size, data_offset_aligned) {
            ELF_WriteByte(0)
        }
        
        // Write data
        ELF_WriteBytes(data, data_size)
        
        // Write section name string table
        ELF_WriteBytes(ELF.shstrtab, shstrtab_size)
        
        // Pad to section header offset
        WhileLoop LessThan(ELF.buffer_size, shdr_offset_aligned) {
            ELF_WriteByte(0)
        }
        
        // Write section headers
        // [0] NULL section
        ELF_WriteSectionHeader(0, SHType.NULL, 0, 0, 0, 0, 0, 0, 0, 0)
        
        // [1] .text section
        text_flags = BitOr(SHFlags.ALLOC, SHFlags.EXECINSTR)
        ELF_WriteSectionHeader(name_text, SHType.PROGBITS, text_flags, text_vaddr, text_offset_aligned, code_size, 0, 0, 16, 0)
        
        // [2] .data section
        data_flags = BitOr(SHFlags.ALLOC, SHFlags.WRITE)
        ELF_WriteSectionHeader(name_data, SHType.PROGBITS, data_flags, data_vaddr, data_offset_aligned, data_size, 0, 0, 8, 0)
        
        // [3] .shstrtab section
        ELF_WriteSectionHeader(name_shstrtab, SHType.STRTAB, 0, 0, shstrtab_offset, shstrtab_size, 0, 0, 1, 0)
        
        PrintMessage("[ELF] Build complete: ")
        PrintNumber(ELF.buffer_size)
        PrintMessage(" bytes\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// SIMPLE BUILD (from Emit buffers)
// =============================================================================

Function.ELF_BuildFromEmit {
    Output: Integer
    Body: {
        ReturnValue(ELF_Build(Emit.code, Emit.code_size, Emit.data, Emit.data_size))
    }
}

// =============================================================================
// OUTPUT
// =============================================================================

Function.ELF_GetBuffer {
    Output: Address
    Body: {
        ReturnValue(ELF.buffer)
    }
}

Function.ELF_GetSize {
    Output: Integer
    Body: {
        ReturnValue(ELF.buffer_size)
    }
}

// =============================================================================
// FILE OUTPUT
// =============================================================================

Function.ELF_WriteFile {
    Input: filename: Address
    Output: Integer
    Body: {
        PrintMessage("[ELF] Writing to: ")
        PrintMessage(filename)
        PrintMessage("\n")
        
        // Open file for writing (O_WRONLY | O_CREAT | O_TRUNC = 577)
        // Mode 0755 = 493
        fd = FileOpen(filename, 577, 493)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            PrintMessage("[ELF] ERROR: Could not open file\n")
            ReturnValue(0)
        }
        
        // Write buffer
        written = FileWrite(fd, ELF.buffer, ELF.buffer_size)
        
        // Close file
        FileClose(fd)
        
        IfCondition NotEqual(written, ELF.buffer_size) ThenBlock: {
            PrintMessage("[ELF] WARNING: Incomplete write\n")
            ReturnValue(0)
        }
        
        PrintMessage("[ELF] Wrote ")
        PrintNumber(written)
        PrintMessage(" bytes\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// FILE I/O STUBS (implement via syscalls or runtime)
// =============================================================================
Function.FileOpen { Input: path: Address Input: flags: Integer Input: mode: Integer Output: Integer Body: { ReturnValue(-1) } }
Function.FileWrite { Input: fd: Integer Input: buf: Address Input: count: Integer Output: Integer Body: { ReturnValue(0) } }
Function.FileClose { Input: fd: Integer Body: { } }