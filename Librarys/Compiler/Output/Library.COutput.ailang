// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.COutput.ailang
// File output operations using Linux syscalls
// Location: Librarys/Compiler/Output/Library.COutput.ailang

LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.Output.CELFTypes
LibraryImport.Compiler.Output.CELFBuilder
LibraryImport.Compiler.CodeEmit.CSyscallTable

// =============================================================================
// FILE FLAGS (for open syscall)
// =============================================================================
FixedPool.FileFlags {
    "O_RDONLY": Initialize=0
    "O_WRONLY": Initialize=1
    "O_RDWR": Initialize=2
    "O_CREAT": Initialize=64
    "O_TRUNC": Initialize=512
    "O_APPEND": Initialize=1024
    "O_EXCL": Initialize=128
    
   
    "WRITE_NEW": Initialize=577   
    "WRITE_APPEND": Initialize=1025 
    "READ_WRITE": Initialize=2
}

// =============================================================================
// FILE PERMISSIONS
// =============================================================================
FixedPool.FileMode {
    "EXEC": Initialize=493           
    "RW": Initialize=420           
    "PRIVATE": Initialize=384        
}

// =============================================================================
// FILE OPERATIONS (using syscalls)
// =============================================================================

// Open file, returns file descriptor or -1 on error
Function.File_Open {
    Input: path: Address
    Input: flags: Integer
    Input: mode: Integer
    Output: Integer
    Body: {
        // syscall: open(path, flags, mode) = syscall 2
        // RDI = path, RSI = flags, RDX = mode
        // Returns fd in RAX, or negative error
        fd = SystemCall(SysNum.OPEN, path, flags, mode, 0, 0, 0)
        ReturnValue(fd)
    }
}

// Write to file, returns bytes written or -1 on error
Function.File_Write {
    Input: fd: Integer
    Input: buf: Address
    Input: count: Integer
    Output: Integer
    Body: {
        // syscall: write(fd, buf, count) = syscall 1
        written = SystemCall(SysNum.WRITE, fd, buf, count, 0, 0, 0)
        ReturnValue(written)
    }
}

// Read from file, returns bytes read or -1 on error
Function.File_Read {
    Input: fd: Integer
    Input: buf: Address
    Input: count: Integer
    Output: Integer
    Body: {
        // syscall: read(fd, buf, count) = syscall 0
        bytes_read = SystemCall(SysNum.READ, fd, buf, count, 0, 0, 0)
        ReturnValue(bytes_read)
    }
}

// Close file
Function.File_Close {
    Input: fd: Integer
    Output: Integer
    Body: {
        // syscall: close(fd) = syscall 3
        result = SystemCall(SysNum.CLOSE, fd, 0, 0, 0, 0, 0)
        ReturnValue(result)
    }
}

// Seek in file
Function.File_Seek {
    Input: fd: Integer
    Input: offset: Integer
    Input: whence: Integer
    Output: Integer
    Body: {
        // syscall: lseek(fd, offset, whence) = syscall 8
        result = SystemCall(SysNum.LSEEK, fd, offset, whence, 0, 0, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// HIGH-LEVEL OUTPUT FUNCTIONS
// =============================================================================

// Write ELF executable to file
Function.Output_WriteExecutable {
    Input: filename: Address
    Output: Integer
    Body: {
        PrintMessage("[OUTPUT] Creating executable: ")
        PrintMessage(filename)
        PrintMessage("\n")
        
        // Open file for writing
        fd = File_Open(filename, FileFlags.WRITE_NEW, FileMode.EXEC)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            PrintMessage("[OUTPUT] ERROR: Could not create file (error ")
            PrintNumber(fd)
            PrintMessage(")\n")
            ReturnValue(0)
        }
        
        // Get ELF buffer
        buf = ELF_GetBuffer()
        size = ELF_GetSize()
        
        // Write buffer
        written = File_Write(fd, buf, size)
        
        // Close file
        File_Close(fd)
        
        IfCondition NotEqual(written, size) ThenBlock: {
            PrintMessage("[OUTPUT] WARNING: Incomplete write (")
            PrintNumber(written)
            PrintMessage(" of ")
            PrintNumber(size)
            PrintMessage(" bytes)\n")
            ReturnValue(0)
        }
        
        PrintMessage("[OUTPUT] Successfully wrote ")
        PrintNumber(written)
        PrintMessage(" bytes\n")
        
        ReturnValue(1)
    }
}

// Write raw binary (code only, no ELF headers)
Function.Output_WriteBinary {
    Input: filename: Address
    Input: code: Address
    Input: code_size: Integer
    Output: Integer
    Body: {
        fd = File_Open(filename, FileFlags.WRITE_NEW, FileMode.EXEC)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            PrintMessage("[OUTPUT] ERROR: Could not create binary file\n")
            ReturnValue(0)
        }
        
        written = File_Write(fd, code, code_size)
        File_Close(fd)
        
        ReturnValue(EqualTo(written, code_size))
    }
}

// Write data file
Function.Output_WriteData {
    Input: filename: Address
    Input: data: Address
    Input: data_size: Integer
    Output: Integer
    Body: {
        fd = File_Open(filename, FileFlags.WRITE_NEW, FileMode.RW)
        
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        written = File_Write(fd, data, data_size)
        File_Close(fd)
        
        ReturnValue(EqualTo(written, data_size))
    }
}

// =============================================================================
// COMPLETE BUILD AND OUTPUT
// =============================================================================

// Build and write executable from emit buffers
Function.Output_BuildAndWrite {
    Input: filename: Address
    Output: Integer
    Body: {
        PrintMessage("\n[OUTPUT] === Building Executable ===\n")
        
        // Initialize ELF builder
        ELF_Init()
        
        // Build ELF from emit buffers
        result = ELF_BuildFromEmit()
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("[OUTPUT] ERROR: ELF build failed\n")
            ELF_Free()
            ReturnValue(0)
        }
        
        // Write to file
        result = Output_WriteExecutable(filename)
        
        // Cleanup
        ELF_Free()
        
        IfCondition EqualTo(result, 1) ThenBlock: {
            PrintMessage("[OUTPUT] === Build Complete ===\n\n")
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// DIAGNOSTIC OUTPUT
// =============================================================================

// Dump code buffer as hex
Function.Output_DumpCode {
    Input: max_bytes: Integer
    Body: {
        PrintMessage("\n[CODE DUMP] First ")
        PrintNumber(max_bytes)
        PrintMessage(" bytes:\n")
        
        count = max_bytes
        IfCondition GreaterThan(count, Emit.code_size) ThenBlock: {
            count = Emit.code_size
        }
        
        i = 0
        WhileLoop LessThan(i, count) {
            // Print offset every 16 bytes
            IfCondition EqualTo(Modulo(i, 16), 0) ThenBlock: {
                IfCondition GreaterThan(i, 0) ThenBlock: {
                    PrintMessage("\n")
                }
                PrintNumber(i)
                PrintMessage(": ")
            }
            
            b = GetByte(Emit.code, i)
            PrintNumber(b)
            PrintMessage(" ")
            
            i = Add(i, 1)
        }
        PrintMessage("\n\n")
    }
}

// Print compilation statistics
Function.Output_PrintStats {
    Body: {
        PrintMessage("\n=== Compilation Statistics ===\n")
        PrintMessage("Code size:    ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("Data size:    ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        PrintMessage("Labels:       ")
        PrintNumber(Emit.label_count)
        PrintMessage("\n")
        PrintMessage("Fixups:       ")
        PrintNumber(Emit.fixup_count)
        PrintMessage("\n")
        PrintMessage("Symbols:      ")
        PrintNumber(Emit.symbol_count)
        PrintMessage("\n")
        PrintMessage("Instructions: ")
        PrintNumber(Emit.instructions_emitted)
        PrintMessage("\n")
        PrintMessage("==============================\n\n")
    }
}

