// Library.AILangChecker.ailang
// Comprehensive Static Analysis Checker for AILang
// Version 2.0 - Production Ready
//
// Features:
//   - Cycle detection (unbounded recursion)
//   - Expression nesting depth
//   - Memory leak detection (Allocate/Deallocate pairing)
//   - Magic number detection
//   - Parameter count warnings
//   - Block nesting depth
//   - Undefined function detection
//
// Dependencies: XArrays
// Usage: LibraryImport.AILangChecker
//        result = Checker.CheckSource(source_string)

LibraryImport.XArrays

// =============================================================================
// TOKEN TYPES
// =============================================================================
FixedPool.TokenType {
    "IDENTIFIER": Initialize=1
    "NUMBER": Initialize=2
    "STRING": Initialize=3
    "KEYWORD": Initialize=4
    "OPERATOR": Initialize=5
    "NEWLINE": Initialize=6
    "EOF": Initialize=7
    "ERROR": Initialize=99
}

// =============================================================================
// CHECKER STATE
// =============================================================================
FixedPool.Checker {
    "source": Initialize=0, CanChange=True
    "source_len": Initialize=0, CanChange=True
    "pos": Initialize=0, CanChange=True
    "line": Initialize=1, CanChange=True
    "col": Initialize=1, CanChange=True
    "tokens": Initialize=0, CanChange=True
    "token_count": Initialize=0, CanChange=True
    "warnings": Initialize=0, CanChange=True
    "errors": Initialize=0, CanChange=True
    "warning_count": Initialize=0, CanChange=True
    "error_count": Initialize=0, CanChange=True
    "depth": Initialize=0, CanChange=True
    "max_depth": Initialize=0, CanChange=True
    "expr_depth": Initialize=0, CanChange=True
    "max_expr_depth": Initialize=0, CanChange=True
    "max_expr_line": Initialize=0, CanChange=True
    "func_names": Initialize=0, CanChange=True
    "func_count": Initialize=0, CanChange=True
    "call_graph": Initialize=0, CanChange=True
    "defined_funcs": Initialize=0, CanChange=True
    "called_funcs": Initialize=0, CanChange=True
    "current_func": Initialize=0, CanChange=True
    "current_func_idx": Initialize=-1, CanChange=True
    "in_function": Initialize=0, CanChange=True
    "alloc_count": Initialize=0, CanChange=True
    "dealloc_count": Initialize=0, CanChange=True
    "alloc_vars": Initialize=0, CanChange=True
    "alloc_lines": Initialize=0, CanChange=True
    "magic_numbers": Initialize=0, CanChange=True
    "magic_lines": Initialize=0, CanChange=True
    "magic_count": Initialize=0, CanChange=True
    "loop_depth": Initialize=0, CanChange=True
    "max_loop_depth": Initialize=0, CanChange=True
    "in_loop": Initialize=0, CanChange=True
    "buffer": Initialize=0, CanChange=True
    "buffer_size": Initialize=512
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Checker.Init {
    Input: source_code: Address
    Body: {
        Checker.source = source_code
        Checker.source_len = StringLength(source_code)
        Checker.pos = 0
        Checker.line = 1
        Checker.col = 1
        
        Checker.tokens = XArray.XCreate(1024)
        Checker.token_count = 0
        
        Checker.warnings = XArray.XCreate(64)
        Checker.errors = XArray.XCreate(64)
        Checker.warning_count = 0
        Checker.error_count = 0
        
        Checker.depth = 0
        Checker.max_depth = 0
        Checker.expr_depth = 0
        Checker.max_expr_depth = 0
        Checker.max_expr_line = 0
        
        Checker.func_names = XArray.XCreate(64)
        Checker.func_count = 0
        Checker.call_graph = XArray.XCreate(64)
        Checker.defined_funcs = XArray.XCreate(64)
        Checker.called_funcs = XArray.XCreate(64)
        Checker.current_func = 0
        Checker.current_func_idx = -1
        Checker.in_function = 0
        
        Checker.alloc_count = 0
        Checker.dealloc_count = 0
        Checker.alloc_vars = XArray.XCreate(32)
        Checker.alloc_lines = XArray.XCreate(32)
        
        Checker.magic_numbers = XArray.XCreate(32)
        Checker.magic_lines = XArray.XCreate(32)
        Checker.magic_count = 0
        
        Checker.loop_depth = 0
        Checker.max_loop_depth = 0
        Checker.in_loop = 0
        
        Checker.buffer = Allocate(Checker.buffer_size)
    }
}

// =============================================================================
// DIAGNOSTIC HELPERS
// =============================================================================
Function.Checker.AddWarning {
    Input: message: Address
    Body: {
        XArray.XPush(Checker.warnings, message)
        Checker.warning_count = Add(Checker.warning_count, 1)
    }
}

Function.Checker.AddError {
    Input: message: Address
    Body: {
        XArray.XPush(Checker.errors, message)
        Checker.error_count = Add(Checker.error_count, 1)
    }
}

// =============================================================================
// LEXER - CHARACTER HELPERS
// =============================================================================
Function.Checker.CurrentChar {
    Output: Integer
    Body: {
        IfCondition GreaterEqual(Checker.pos, Checker.source_len) ThenBlock: {
            ReturnValue(0)
        }
        ch = GetByte(Checker.source, Checker.pos)
        ReturnValue(ch)
    }
}

Function.Checker.PeekChar {
    Input: offset: Integer
    Output: Integer
    Body: {
        peek_pos = Add(Checker.pos, offset)
        IfCondition GreaterEqual(peek_pos, Checker.source_len) ThenBlock: {
            ReturnValue(0)
        }
        ch = GetByte(Checker.source, peek_pos)
        ReturnValue(ch)
    }
}

Function.Checker.Advance {
    Body: {
        ch = Checker.CurrentChar()
        IfCondition NotEqual(ch, 0) ThenBlock: {
            IfCondition EqualTo(ch, 10) ThenBlock: {
                Checker.line = Add(Checker.line, 1)
                Checker.col = 1
            } ElseBlock: {
                Checker.col = Add(Checker.col, 1)
            }
            Checker.pos = Add(Checker.pos, 1)
        }
    }
}

Function.Checker.IsDigit {
    Input: ch: Integer
    Output: Integer
    Body: {
        IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

Function.Checker.IsAlpha {
    Input: ch: Integer
    Output: Integer
    Body: {
        IfCondition And(GreaterEqual(ch, 65), LessEqual(ch, 90)) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition And(GreaterEqual(ch, 97), LessEqual(ch, 122)) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(ch, 95) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

Function.Checker.IsAlnum {
    Input: ch: Integer
    Output: Integer
    Body: {
        is_alpha = Checker.IsAlpha(ch)
        IfCondition EqualTo(is_alpha, 1) ThenBlock: {
            ReturnValue(1)
        }
        is_digit = Checker.IsDigit(ch)
        ReturnValue(is_digit)
    }
}

// =============================================================================
// LEXER - TOKEN CREATION
// =============================================================================
Function.Checker.AddToken {
    Input: tok_type: Integer
    Input: tok_value: Address
    Input: tok_line: Integer
    Body: {
        token = ArrayCreate(4)
        ArraySet(token, 0, tok_type)
        ArraySet(token, 1, tok_value)
        ArraySet(token, 2, tok_line)
        ArraySet(token, 3, Checker.col)
        XArray.XPush(Checker.tokens, token)
        Checker.token_count = Add(Checker.token_count, 1)
    }
}

// =============================================================================
// LEXER - READ IDENTIFIER (stops at dots for proper keyword detection)
// =============================================================================
Function.Checker.ReadIdentifier {
    Output: Address
    Body: {
        buf_pos = 0
        
        WhileLoop EqualTo(1, 1) {
            ch = Checker.CurrentChar()
            is_alnum = Checker.IsAlnum(ch)
            
            IfCondition EqualTo(is_alnum, 1) ThenBlock: {
                SetByte(Checker.buffer, buf_pos, ch)
                buf_pos = Add(buf_pos, 1)
                Checker.Advance()
            } ElseBlock: {
                BreakLoop
            }
        }
        
        result = Allocate(Add(buf_pos, 1))
        i = 0
        WhileLoop LessThan(i, buf_pos) {
            c = GetByte(Checker.buffer, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, buf_pos, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// LEXER - READ NUMBER
// =============================================================================
Function.Checker.ReadNumber {
    Output: Integer
    Body: {
        value = 0
        
        WhileLoop EqualTo(1, 1) {
            ch = Checker.CurrentChar()
            is_digit = Checker.IsDigit(ch)
            IfCondition EqualTo(is_digit, 0) ThenBlock: {
                BreakLoop
            }
            digit = Subtract(ch, 48)
            value = Add(Multiply(value, 10), digit)
            Checker.Advance()
        }
        
        ReturnValue(value)
    }
}

// =============================================================================
// LEXER - READ STRING
// =============================================================================
Function.Checker.ReadString {
    Output: Address
    Body: {
        quote = Checker.CurrentChar()
        Checker.Advance()
        
        buf_pos = 0
        
        WhileLoop EqualTo(1, 1) {
            ch = Checker.CurrentChar()
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            IfCondition EqualTo(ch, quote) ThenBlock: {
                Checker.Advance()
                BreakLoop
            }
            
            IfCondition EqualTo(ch, 92) ThenBlock: {
                Checker.Advance()
                esc = Checker.CurrentChar()
                IfCondition EqualTo(esc, 110) ThenBlock: {
                    SetByte(Checker.buffer, buf_pos, 10)
                } ElseBlock: {
                    IfCondition EqualTo(esc, 116) ThenBlock: {
                        SetByte(Checker.buffer, buf_pos, 9)
                    } ElseBlock: {
                        SetByte(Checker.buffer, buf_pos, esc)
                    }
                }
                buf_pos = Add(buf_pos, 1)
                Checker.Advance()
            } ElseBlock: {
                SetByte(Checker.buffer, buf_pos, ch)
                buf_pos = Add(buf_pos, 1)
                Checker.Advance()
            }
        }
        
        result = Allocate(Add(buf_pos, 1))
        i = 0
        WhileLoop LessThan(i, buf_pos) {
            c = GetByte(Checker.buffer, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, buf_pos, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// LEXER - KEYWORD DETECTION
// =============================================================================
Function.Checker.IsKeyword {
    Input: word: Address
    Output: Integer
    Body: {
        cmp = StringCompare(word, "Function")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "SubRoutine")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "FixedPool")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "IfCondition")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "WhileLoop")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "ThenBlock")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "ElseBlock")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "ReturnValue")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "Input")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "Output")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "Body")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "Allocate")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        cmp = StringCompare(word, "Deallocate")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        
        ReturnValue(0)
    }
}

// =============================================================================
// LEXER - MAIN TOKENIZE
// =============================================================================
Function.Checker.Lex {
    Body: {
        WhileLoop EqualTo(1, 1) {
            ch = Checker.CurrentChar()
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            IfCondition Or(EqualTo(ch, 32), EqualTo(ch, 9)) ThenBlock: {
                Checker.Advance()
                ContinueLoop
            }
            
            IfCondition EqualTo(ch, 10) ThenBlock: {
                Checker.AddToken(TokenType.NEWLINE, 0, Checker.line)
                Checker.Advance()
                ContinueLoop
            }
            
            IfCondition EqualTo(ch, 13) ThenBlock: {
                Checker.Advance()
                ContinueLoop
            }
            
            IfCondition EqualTo(ch, 47) ThenBlock: {
                next = Checker.PeekChar(1)
                IfCondition EqualTo(next, 47) ThenBlock: {
                    WhileLoop EqualTo(1, 1) {
                        c = Checker.CurrentChar()
                        IfCondition Or(EqualTo(c, 0), EqualTo(c, 10)) ThenBlock: {
                            BreakLoop
                        }
                        Checker.Advance()
                    }
                    ContinueLoop
                }
            }
            
            IfCondition Or(EqualTo(ch, 34), EqualTo(ch, 39)) ThenBlock: {
                current_line = Checker.line
                str = Checker.ReadString()
                Checker.AddToken(TokenType.STRING, str, current_line)
                ContinueLoop
            }
            
            is_digit = Checker.IsDigit(ch)
            IfCondition EqualTo(is_digit, 1) ThenBlock: {
                current_line = Checker.line
                num = Checker.ReadNumber()
                Checker.AddToken(TokenType.NUMBER, num, current_line)
                ContinueLoop
            }
            
            is_alpha = Checker.IsAlpha(ch)
            IfCondition EqualTo(is_alpha, 1) ThenBlock: {
                current_line = Checker.line
                ident = Checker.ReadIdentifier()
                is_kw = Checker.IsKeyword(ident)
                IfCondition EqualTo(is_kw, 1) ThenBlock: {
                    Checker.AddToken(TokenType.KEYWORD, ident, current_line)
                } ElseBlock: {
                    Checker.AddToken(TokenType.IDENTIFIER, ident, current_line)
                }
                ContinueLoop
            }
            
            Checker.AddToken(TokenType.OPERATOR, ch, Checker.line)
            Checker.Advance()
        }
        
        Checker.AddToken(TokenType.EOF, 0, Checker.line)
    }
}

// =============================================================================
// FUNCTION INDEX MANAGEMENT
// =============================================================================
Function.Checker.GetFuncIndex {
    Input: func_name: Address
    Input: is_definition: Integer
    Output: Integer
    Body: {
        i = 0
        
        WhileLoop LessThan(i, Checker.func_count) {
            existing = XArray.XGet(Checker.func_names, i)
            cmp = StringCompare(existing, func_name)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                IfCondition EqualTo(is_definition, 1) ThenBlock: {
                    XArray.XSet(Checker.defined_funcs, i, 1)
                }
                ReturnValue(i)
            }
            i = Add(i, 1)
        }
        
        name_len = StringLength(func_name)
        name_copy = Allocate(Add(name_len, 1))
        j = 0
        WhileLoop LessThan(j, name_len) {
            SetByte(name_copy, j, GetByte(func_name, j))
            j = Add(j, 1)
        }
        SetByte(name_copy, name_len, 0)
        
        XArray.XPush(Checker.func_names, name_copy)
        
        calls = XArray.XCreate(16)
        XArray.XPush(Checker.call_graph, calls)
        XArray.XPush(Checker.defined_funcs, is_definition)
        
        idx = Checker.func_count
        Checker.func_count = Add(Checker.func_count, 1)
        
        ReturnValue(idx)
    }
}

// =============================================================================
// HELPER: Get short name (after last dot)
// =============================================================================
Function.Checker.GetShortName {
    Input: full_name: Address
    Output: Address
    Body: {
        len = StringLength(full_name)
        last_dot = -1
        i = 0
        WhileLoop LessThan(i, len) {
            ch = GetByte(full_name, i)
            IfCondition EqualTo(ch, 46) ThenBlock: {
                last_dot = i
            }
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(last_dot, -1) ThenBlock: {
            ReturnValue(full_name)
        }
        
        start = Add(last_dot, 1)
        new_len = Subtract(len, start)
        result = Allocate(Add(new_len, 1))
        
        j = 0
        WhileLoop LessThan(j, new_len) {
            ch = GetByte(full_name, Add(start, j))
            SetByte(result, j, ch)
            j = Add(j, 1)
        }
        SetByte(result, new_len, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// BUILT-IN FUNCTION CHECK
// =============================================================================
Function.Checker.IsBuiltIn {
    Input: name: Address
    Output: Integer
    Body: {
        cmp = StringCompare(name, "Add")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "Subtract")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "Multiply")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "Divide")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "Modulo")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "EqualTo")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "NotEqual")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "LessThan")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "GreaterThan")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "LessEqual")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "GreaterEqual")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "And")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "Or")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "Not")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "PrintMessage")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "PrintNumber")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "StringLength")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "StringCompare")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "StringConcat")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "NumberToString")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "GetByte")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "SetByte")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "ArrayCreate")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "ArrayGet")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "ArraySet")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "ArrayDestroy")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        cmp = StringCompare(name, "ReturnValue")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
        ReturnValue(0)
    }
}

// =============================================================================
// MAGIC NUMBER CHECK
// =============================================================================
Function.Checker.IsMagicNumber {
    Input: num: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(num, 0) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 1) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, -1) ThenBlock: { ReturnValue(0) }
        IfCondition And(GreaterEqual(num, -10), LessEqual(num, 10)) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(num, 16) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 32) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 64) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 128) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 256) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 512) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 1024) ThenBlock: { ReturnValue(0) }
        
        IfCondition EqualTo(num, 10) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 13) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 48) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 57) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 65) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 90) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 97) ThenBlock: { ReturnValue(0) }
        IfCondition EqualTo(num, 122) ThenBlock: { ReturnValue(0) }
        
        ReturnValue(1)
    }
}

// =============================================================================
// CYCLE DETECTION - DFS
// =============================================================================
Function.Checker.DetectCycles {
    Body: {
        PrintMessage("DEBUG: DetectCycles: Start\n")
        IfCondition EqualTo(Checker.func_count, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            calls = XArray.XGet(Checker.call_graph, i)
            num_calls = XArray.XSize(calls)
            
            j = 0
            WhileLoop LessThan(j, num_calls) {
                callee_idx = XArray.XGet(calls, j)
                IfCondition EqualTo(callee_idx, i) ThenBlock: {
                    fname = XArray.XGet(Checker.func_names, i)
                    msg = StringConcat("Unbounded recursion: '", fname)
                    msg = StringConcat(msg, "' calls itself without base case detection")
                    Checker.AddError(msg)
                }
                j = Add(j, 1)
            }
            i = Add(i, 1)
        }
        
        PrintMessage("DEBUG: DetectCycles: Building visited array\n")
        visited = XArray.XCreate(Checker.func_count)
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            XArray.XPush(visited, 0)
            i = Add(i, 1)
        }
        
        PrintMessage("DEBUG: DetectCycles: Starting DFS loop\n")
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            state = XArray.XGet(visited, i)
            IfCondition EqualTo(state, 0) ThenBlock: {
                PrintMessage("DEBUG: DFS Root: ")
                PrintNumber(i)
                PrintMessage("\n")
                has_cycle = Checker.DFSCycle(i, visited)
            }
            i = Add(i, 1)
        }
        
        XArray.XDestroy(visited)
    }
}

Function.Checker.DFSCycle {
    Input: func_idx: Integer
    Input: visited: Address
    Output: Integer
    Body: {
        PrintMessage("DEBUG: DFSCycle visiting: ")
        PrintNumber(func_idx)
        PrintMessage("\n")
        
        XArray.XSet(visited, func_idx, 1)
        
        calls = XArray.XGet(Checker.call_graph, func_idx)
        size = XArray.XSize(calls)
        
        i = 0
        WhileLoop LessThan(i, size) {
            callee = XArray.XGet(calls, i)
            PrintMessage("  -> checking callee: ")
            PrintNumber(callee)
            PrintMessage("\n")
            
            state = XArray.XGet(visited, callee)
            
            IfCondition EqualTo(state, 1) ThenBlock: {
                ReturnValue(1)
            }
            
            IfCondition EqualTo(state, 0) ThenBlock: {
                has_cycle = Checker.DFSCycle(callee, visited)
                IfCondition EqualTo(has_cycle, 1) ThenBlock: {
                    ReturnValue(1)
                }
            }
            
            i = Add(i, 1)
        }
        
        XArray.XSet(visited, func_idx, 2)
        ReturnValue(0)
    }
}

// =============================================================================
// MAIN ANALYZER
// =============================================================================
Function.Checker.Analyze {
    Body: {
        PrintMessage("DEBUG: Checker.Analyze: Start\n")
        PrintMessage("DEBUG: About to access Checker.token_count\n")
        PrintMessage("DEBUG: token_count = ")
        PrintNumber(Checker.token_count)
        PrintMessage("\n")
        tok_idx = 0
        
        WhileLoop LessThan(tok_idx, Checker.token_count) {
            token = XArray.XGet(Checker.tokens, tok_idx)
            tok_type = ArrayGet(token, 0)
            value = ArrayGet(token, 1)
            line = ArrayGet(token, 2)
            
            IfCondition EqualTo(tok_type, TokenType.OPERATOR) ThenBlock: {
                IfCondition EqualTo(value, 123) ThenBlock: {
                    Checker.depth = Add(Checker.depth, 1)
                    IfCondition GreaterThan(Checker.depth, Checker.max_depth) ThenBlock: {
                        Checker.max_depth = Checker.depth
                    }
                }
                
                IfCondition EqualTo(value, 125) ThenBlock: {
                    IfCondition EqualTo(Checker.depth, 1) ThenBlock: {
                        IfCondition EqualTo(Checker.in_function, 1) ThenBlock: {
                            Checker.in_function = 0
                            Checker.current_func = 0
                            Checker.current_func_idx = -1
                        }
                    }
                    Checker.depth = Subtract(Checker.depth, 1)
                }
                
                IfCondition EqualTo(value, 40) ThenBlock: {
                    Checker.expr_depth = Add(Checker.expr_depth, 1)
                    IfCondition GreaterThan(Checker.expr_depth, Checker.max_expr_depth) ThenBlock: {
                        Checker.max_expr_depth = Checker.expr_depth
                        Checker.max_expr_line = line
                    }
                }
                
                IfCondition EqualTo(value, 41) ThenBlock: {
                    Checker.expr_depth = Subtract(Checker.expr_depth, 1)
                }
            }
            
            IfCondition EqualTo(tok_type, TokenType.KEYWORD) ThenBlock: {
                is_func = EqualTo(StringCompare(value, "Function"), 0)
                IfCondition EqualTo(is_func, 1) ThenBlock: {
                    dot_idx = Add(tok_idx, 1)
                    IfCondition LessThan(dot_idx, Checker.token_count) ThenBlock: {
                        dot_tok = XArray.XGet(Checker.tokens, dot_idx)
                        dot_type = ArrayGet(dot_tok, 0)
                        dot_val = ArrayGet(dot_tok, 1)
                        IfCondition And(EqualTo(dot_type, TokenType.OPERATOR), EqualTo(dot_val, 46)) ThenBlock: {
                            name_idx = Add(tok_idx, 2)
                            IfCondition LessThan(name_idx, Checker.token_count) ThenBlock: {
                                name_tok = XArray.XGet(Checker.tokens, name_idx)
                                name_type = ArrayGet(name_tok, 0)
                                IfCondition EqualTo(name_type, TokenType.IDENTIFIER) ThenBlock: {
                                    func_name = ArrayGet(name_tok, 1)
                                    
                                    short_name = Checker.GetShortName(func_name)
                                    Checker.current_func_idx = Checker.GetFuncIndex(short_name, 1)
                                    Checker.current_func = short_name
                                    Checker.in_function = 1
                                }
                            }
                        }
                    }
                }
                
                is_while = EqualTo(StringCompare(value, "WhileLoop"), 0)
                IfCondition EqualTo(is_while, 1) ThenBlock: {
                    Checker.loop_depth = Add(Checker.loop_depth, 1)
                    Checker.in_loop = 1
                    IfCondition GreaterThan(Checker.loop_depth, Checker.max_loop_depth) ThenBlock: {
                        Checker.max_loop_depth = Checker.loop_depth
                    }
                }
                
                is_alloc_kw = EqualTo(StringCompare(value, "Allocate"), 0)
                IfCondition EqualTo(is_alloc_kw, 1) ThenBlock: {
                    Checker.alloc_count = Add(Checker.alloc_count, 1)
                    XArray.XPush(Checker.alloc_lines, line)
                }
                
                is_dealloc_kw = EqualTo(StringCompare(value, "Deallocate"), 0)
                IfCondition EqualTo(is_dealloc_kw, 1) ThenBlock: {
                    Checker.dealloc_count = Add(Checker.dealloc_count, 1)
                }
            }
            
            IfCondition EqualTo(tok_type, TokenType.IDENTIFIER) ThenBlock: {
                next_idx = Add(tok_idx, 1)
                IfCondition LessThan(next_idx, Checker.token_count) ThenBlock: {
                    next_tok = XArray.XGet(Checker.tokens, next_idx)
                    next_type = ArrayGet(next_tok, 0)
                    next_val = ArrayGet(next_tok, 1)
                    
                    IfCondition And(EqualTo(next_type, TokenType.OPERATOR), EqualTo(next_val, 40)) ThenBlock: {
                        called_idx = Checker.GetFuncIndex(value, 0)
                        XArray.XPush(Checker.called_funcs, called_idx)
                        
                        IfCondition EqualTo(Checker.in_function, 1) ThenBlock: {
                            IfCondition GreaterEqual(Checker.current_func_idx, 0) ThenBlock: {
                                calls = XArray.XGet(Checker.call_graph, Checker.current_func_idx)
                                XArray.XPush(calls, called_idx)
                            }
                        }
                    }
                }
            }
            
            IfCondition EqualTo(tok_type, TokenType.NUMBER) ThenBlock: {
                is_magic = Checker.IsMagicNumber(value)
                IfCondition EqualTo(is_magic, 1) ThenBlock: {
                    XArray.XPush(Checker.magic_numbers, value)
                    XArray.XPush(Checker.magic_lines, line)
                    Checker.magic_count = Add(Checker.magic_count, 1)
                }
            }
            
            tok_idx = Add(tok_idx, 1)
        }
        
        PrintMessage("DEBUG: Checker.Analyze: Token loop complete\n")
        
        Checker.DetectCycles()
        
        PrintMessage("DEBUG: Checker.Analyze: Cycle detection complete\n")
        
        IfCondition GreaterThan(Checker.max_expr_depth, 3) ThenBlock: {
            msg = StringConcat("Expression nesting depth ", NumberToString(Checker.max_expr_depth))
            msg = StringConcat(msg, " exceeds recommended 3 (line ")
            msg = StringConcat(msg, NumberToString(Checker.max_expr_line))
            msg = StringConcat(msg, ") - consider using temporary variables")
            Checker.AddWarning(msg)
        }
        
        IfCondition GreaterThan(Checker.max_depth, 4) ThenBlock: {
            msg = StringConcat("Maximum block nesting depth ", NumberToString(Checker.max_depth))
            msg = StringConcat(msg, " exceeds recommended limit of 4")
            Checker.AddWarning(msg)
        }
        
        IfCondition GreaterThan(Checker.alloc_count, Checker.dealloc_count) ThenBlock: {
            diff = Subtract(Checker.alloc_count, Checker.dealloc_count)
            msg = StringConcat("Potential memory leak: ", NumberToString(diff))
            msg = StringConcat(msg, " Allocate(s) without matching Deallocate")
            Checker.AddWarning(msg)
        }
        
        IfCondition GreaterThan(Checker.magic_count, 0) ThenBlock: {
            msg = StringConcat("Found ", NumberToString(Checker.magic_count))
            msg = StringConcat(msg, " magic number(s) - consider named constants:")
            Checker.AddWarning(msg)
            
            max_show = 5
            IfCondition LessThan(Checker.magic_count, max_show) ThenBlock: {
                max_show = Checker.magic_count
            }
            
            i = 0
            WhileLoop LessThan(i, max_show) {
                num = XArray.XGet(Checker.magic_numbers, i)
                ln = XArray.XGet(Checker.magic_lines, i)
                
                detail = StringConcat("    - ", NumberToString(num))
                detail = StringConcat(detail, " at line ")
                detail = StringConcat(detail, NumberToString(ln))
                Checker.AddWarning(detail)
                
                i = Add(i, 1)
            }
        }
        
        PrintMessage("DEBUG: Checker.Analyze: Checking undefined functions\n")
        
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            is_defined = XArray.XGet(Checker.defined_funcs, i)
            IfCondition EqualTo(is_defined, 0) ThenBlock: {
                fname = XArray.XGet(Checker.func_names, i)
                is_builtin = Checker.IsBuiltIn(fname)
                IfCondition EqualTo(is_builtin, 0) ThenBlock: {
                    was_called = Checker.WasFuncCalled(i)
                    IfCondition EqualTo(was_called, 1) ThenBlock: {
                        msg = StringConcat("Call to undefined function '", fname)
                        msg = StringConcat(msg, "'")
                        Checker.AddWarning(msg)
                    }
                }
            }
            i = Add(i, 1)
        }
        
        PrintMessage("DEBUG: Checker.Analyze: Finished\n")
    }
}

// =============================================================================
// HELPER: Check if function was called
// =============================================================================
Function.Checker.WasFuncCalled {
    Input: func_idx: Integer
    Output: Integer
    Body: {
        num_called = XArray.XSize(Checker.called_funcs)
        i = 0
        WhileLoop LessThan(i, num_called) {
            called = XArray.XGet(Checker.called_funcs, i)
            IfCondition EqualTo(called, func_idx) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// REPORT OUTPUT
// =============================================================================
Function.Checker.Report {
    Body: {
        PrintMessage("\n========================================\n")
        PrintMessage("AILang Static Analysis Report\n")
        PrintMessage("========================================\n\n")
        
        IfCondition GreaterThan(Checker.error_count, 0) ThenBlock: {
            err_str = NumberToString(Checker.error_count)
            msg_line = StringConcat("ERRORS (", err_str)
            msg_line = StringConcat(msg_line, "):\n")
            PrintMessage(msg_line)
            
            i = 0
            WhileLoop LessThan(i, Checker.error_count) {
                msg = XArray.XGet(Checker.errors, i)
                PrintMessage("  [ERROR] ")
                PrintMessage(msg)
                PrintMessage("\n")
                i = Add(i, 1)
            }
            PrintMessage("\n")
        }
        
        IfCondition GreaterThan(Checker.warning_count, 0) ThenBlock: {
            warn_str = NumberToString(Checker.warning_count)
            msg_line = StringConcat("WARNINGS (", warn_str)
            msg_line = StringConcat(msg_line, "):\n")
            PrintMessage(msg_line)
            
            i = 0
            WhileLoop LessThan(i, Checker.warning_count) {
                msg = XArray.XGet(Checker.warnings, i)
                PrintMessage("  [WARN] ")
                PrintMessage(msg)
                PrintMessage("\n")
                i = Add(i, 1)
            }
            PrintMessage("\n")
        }
        
        IfCondition And(EqualTo(Checker.error_count, 0), EqualTo(Checker.warning_count, 0)) ThenBlock: {
            PrintMessage("No issues found!\n")
        } ElseBlock: {
            err_str = NumberToString(Checker.error_count)
            warn_str = NumberToString(Checker.warning_count)
            summary = StringConcat("Summary: ", err_str)
            summary = StringConcat(summary, " error(s), ")
            summary = StringConcat(summary, warn_str)
            summary = StringConcat(summary, " warning(s)\n")
            PrintMessage(summary)
        }
        
        PrintMessage("\n========================================\n")
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.Checker.Cleanup {
    Body: {
        i = 0
        WhileLoop LessThan(i, Checker.token_count) {
            token = XArray.XGet(Checker.tokens, i)
            tok_type = ArrayGet(token, 0)
            value = ArrayGet(token, 1)
            
            IfCondition Or(EqualTo(tok_type, TokenType.STRING), EqualTo(tok_type, TokenType.IDENTIFIER)) ThenBlock: {
                IfCondition NotEqual(value, 0) ThenBlock: {
                    Deallocate(value, 0)
                }
            }
            IfCondition EqualTo(tok_type, TokenType.KEYWORD) ThenBlock: {
                IfCondition NotEqual(value, 0) ThenBlock: {
                    Deallocate(value, 0)
                }
            }
            
            ArrayDestroy(token)
            i = Add(i, 1)
        }
        XArray.XDestroy(Checker.tokens)
        
        XArray.XDestroy(Checker.warnings)
        XArray.XDestroy(Checker.errors)
        
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            name = XArray.XGet(Checker.func_names, i)
            IfCondition NotEqual(name, 0) ThenBlock: {
                Deallocate(name, 0)
            }
            
            calls = XArray.XGet(Checker.call_graph, i)
            XArray.XDestroy(calls)
            
            i = Add(i, 1)
        }
        XArray.XDestroy(Checker.func_names)
        XArray.XDestroy(Checker.call_graph)
        XArray.XDestroy(Checker.defined_funcs)
        XArray.XDestroy(Checker.called_funcs)
        
        XArray.XDestroy(Checker.alloc_vars)
        XArray.XDestroy(Checker.alloc_lines)
        XArray.XDestroy(Checker.magic_numbers)
        XArray.XDestroy(Checker.magic_lines)
        
        IfCondition NotEqual(Checker.buffer, 0) ThenBlock: {
            Deallocate(Checker.buffer, Checker.buffer_size)
        }
    }
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================
Function.Checker.CheckSource {
    Input: source_code: Address
    Output: Integer
    Body: {
        Checker.Init(source_code)
        Checker.Lex()
        Checker.Analyze()
        Checker.Report()
        
        result = Checker.error_count
        
        Checker.Cleanup()
        
        ReturnValue(result)
    }
}