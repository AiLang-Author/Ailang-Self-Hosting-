// Library.AILangChecker2.ailang
// Extended Static Analysis for AILang
// Version 1.0
//
// Requires: Library.AILangChecker (core)
//
// Additional checks:
//   - Line number tracking for functions/calls
//   - Parameter count warnings (too many params)
//   - Dead code detection (unused functions)
//   - Duplicate string literals
//   - Long function detection
//
// Usage:
//   LibraryImport.AILangChecker
//   LibraryImport.AILangChecker2
//   Checker.Init(source)
//   Checker.Lex()
//   Checker.Analyze()
//   Checker2.Analyze()
//   Checker.Report()
//   Checker2.Report()
//   Checker2.Cleanup()
//   Checker.Cleanup()

LibraryImport.XArrays

// =============================================================================
// EXTENDED CHECKER STATE
// =============================================================================
FixedPool.Checker2 {
    "warnings": Initialize=0, CanChange=True
    "errors": Initialize=0, CanChange=True
    "warning_count": Initialize=0, CanChange=True
    "error_count": Initialize=0, CanChange=True
    "max_params": Initialize=6, CanChange=True
    "max_func_lines": Initialize=50, CanChange=True
    "func_def_lines": Initialize=0, CanChange=True
    "func_end_lines": Initialize=0, CanChange=True
    "call_lines": Initialize=0, CanChange=True
    "call_targets": Initialize=0, CanChange=True
    "call_count": Initialize=0, CanChange=True
    "string_literals": Initialize=0, CanChange=True
    "string_lines": Initialize=0, CanChange=True
    "string_count": Initialize=0, CanChange=True
    "param_counts": Initialize=0, CanChange=True
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Checker2.Init {
    Body: {
        Checker2.warnings = XArray.XCreate(32)
        Checker2.errors = XArray.XCreate(32)
        Checker2.warning_count = 0
        Checker2.error_count = 0
        
        Checker2.func_def_lines = XArray.XCreate(64)
        Checker2.func_end_lines = XArray.XCreate(64)
        Checker2.call_lines = XArray.XCreate(128)
        Checker2.call_targets = XArray.XCreate(128)
        Checker2.call_count = 0
        
        Checker2.string_literals = XArray.XCreate(64)
        Checker2.string_lines = XArray.XCreate(64)
        Checker2.string_count = 0
        
        Checker2.param_counts = XArray.XCreate(64)
    }
}

// =============================================================================
// DIAGNOSTIC HELPERS
// =============================================================================
Function.Checker2.AddWarning {
    Input: message: Address
    Body: {
        XArray.XPush(Checker2.warnings, message)
        Checker2.warning_count = Add(Checker2.warning_count, 1)
    }
}

Function.Checker2.AddError {
    Input: message: Address
    Body: {
        XArray.XPush(Checker2.errors, message)
        Checker2.error_count = Add(Checker2.error_count, 1)
    }
}

// =============================================================================
// MAIN ANALYSIS - Runs after Checker.Analyze()
// =============================================================================
Function.Checker2.Analyze {
    Body: {
        Checker2.Init()
        Checker2.ScanTokens()
        Checker2.CheckParamCounts()
        Checker2.CheckDeadCode()
        Checker2.CheckDuplicateStrings()
        Checker2.CheckLongFunctions()
    }
}

// =============================================================================
// TOKEN SCAN - Extract line info and strings
// =============================================================================
Function.Checker2.ScanTokens {
    Body: {
        // First, pre-populate arrays to match Checker.func_count
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            XArray.XPush(Checker2.func_def_lines, 0)
            XArray.XPush(Checker2.func_end_lines, 0)
            XArray.XPush(Checker2.param_counts, 0)
            i = Add(i, 1)
        }
        
        tok_idx = 0
        in_func_header = 0
        current_func_idx = -1
        current_func_line = 0
        param_count = 0
        
        WhileLoop LessThan(tok_idx, Checker.token_count) {
            token = XArray.XGet(Checker.tokens, tok_idx)
            tok_type = ArrayGet(token, 0)
            value = ArrayGet(token, 1)
            line = ArrayGet(token, 2)
            
            // Track function definitions and their lines
            IfCondition EqualTo(tok_type, TokenType.KEYWORD) ThenBlock: {
                is_func = EqualTo(StringCompare(value, "Function"), 0)
                IfCondition EqualTo(is_func, 1) ThenBlock: {
                    in_func_header = 1
                    current_func_line = line
                    param_count = 0
                    
                    // Get function index from core checker
                    name_idx = Add(tok_idx, 2)
                    IfCondition LessThan(name_idx, Checker.token_count) ThenBlock: {
                        name_tok = XArray.XGet(Checker.tokens, name_idx)
                        name_type = ArrayGet(name_tok, 0)
                        IfCondition EqualTo(name_type, TokenType.IDENTIFIER) ThenBlock: {
                            // Store definition line for this function index
                            func_name = ArrayGet(name_tok, 1)
                            short_name = Checker.GetShortName(func_name)
                            current_func_idx = Checker2.GetFuncIdxByName(short_name)
                            
                            IfCondition GreaterEqual(current_func_idx, 0) ThenBlock: {
                                XArray.XSet(Checker2.func_def_lines, current_func_idx, line)
                            }
                        }
                    }
                }
                
                // Count parameters
                is_input = EqualTo(StringCompare(value, "Input"), 0)
                IfCondition And(EqualTo(is_input, 1), EqualTo(in_func_header, 1)) ThenBlock: {
                    param_count = Add(param_count, 1)
                }
                
                // End of function header
                is_body = EqualTo(StringCompare(value, "Body"), 0)
                IfCondition And(EqualTo(is_body, 1), EqualTo(in_func_header, 1)) ThenBlock: {
                    in_func_header = 0
                    IfCondition GreaterEqual(current_func_idx, 0) ThenBlock: {
                        XArray.XSet(Checker2.param_counts, current_func_idx, param_count)
                    }
                }
            }
            
            // Track function call locations
            IfCondition EqualTo(tok_type, TokenType.IDENTIFIER) ThenBlock: {
                next_idx = Add(tok_idx, 1)
                IfCondition LessThan(next_idx, Checker.token_count) ThenBlock: {
                    next_tok = XArray.XGet(Checker.tokens, next_idx)
                    next_type = ArrayGet(next_tok, 0)
                    next_val = ArrayGet(next_tok, 1)
                    
                    IfCondition And(EqualTo(next_type, TokenType.OPERATOR), EqualTo(next_val, 40)) ThenBlock: {
                        // It's a function call - record line and target
                        target_idx = Checker2.GetFuncIdxByName(value)
                        XArray.XPush(Checker2.call_lines, line)
                        XArray.XPush(Checker2.call_targets, target_idx)
                        Checker2.call_count = Add(Checker2.call_count, 1)
                    }
                }
            }
            
            // Track closing braces to find function end lines
            IfCondition EqualTo(tok_type, TokenType.OPERATOR) ThenBlock: {
                IfCondition EqualTo(value, 125) ThenBlock: {
                    // Update end line for current function
                    IfCondition GreaterEqual(current_func_idx, 0) ThenBlock: {
                        XArray.XSet(Checker2.func_end_lines, current_func_idx, line)
                    }
                }
            }
            
            // Collect string literals
            IfCondition EqualTo(tok_type, TokenType.STRING) ThenBlock: {
                XArray.XPush(Checker2.string_literals, value)
                XArray.XPush(Checker2.string_lines, line)
                Checker2.string_count = Add(Checker2.string_count, 1)
            }
            
            tok_idx = Add(tok_idx, 1)
        }
    }
}

// =============================================================================
// HELPER: Find function index by name
// =============================================================================
Function.Checker2.GetFuncIdxByName {
    Input: name: Address
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            existing = XArray.XGet(Checker.func_names, i)
            cmp = StringCompare(existing, name)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(i)
            }
            i = Add(i, 1)
        }
        ReturnValue(-1)
    }
}

// =============================================================================
// CHECK: Too many parameters
// =============================================================================
Function.Checker2.CheckParamCounts {
    Body: {
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            IfCondition LessThan(i, XArray.XSize(Checker2.param_counts)) ThenBlock: {
                count = XArray.XGet(Checker2.param_counts, i)
                IfCondition GreaterThan(count, Checker2.max_params) ThenBlock: {
                    fname = XArray.XGet(Checker.func_names, i)
                    def_line = XArray.XGet(Checker2.func_def_lines, i)
                    
                    msg = StringConcat("Line ", NumberToString(def_line))
                    msg = StringConcat(msg, ": Function '")
                    msg = StringConcat(msg, fname)
                    msg = StringConcat(msg, "' has ")
                    msg = StringConcat(msg, NumberToString(count))
                    msg = StringConcat(msg, " params (max: ")
                    msg = StringConcat(msg, NumberToString(Checker2.max_params))
                    msg = StringConcat(msg, ") - consider using FixedPool")
                    Checker2.AddWarning(msg)
                }
            }
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// CHECK: Dead code (defined but never called)
// =============================================================================
Function.Checker2.CheckDeadCode {
    Body: {
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            is_defined = XArray.XGet(Checker.defined_funcs, i)
            IfCondition EqualTo(is_defined, 1) ThenBlock: {
                was_called = Checker.WasFuncCalled(i)
                IfCondition EqualTo(was_called, 0) ThenBlock: {
                    fname = XArray.XGet(Checker.func_names, i)
                    is_entry = Checker2.IsEntryPoint(fname)
                    IfCondition EqualTo(is_entry, 0) ThenBlock: {
                        def_line = 0
                        IfCondition LessThan(i, XArray.XSize(Checker2.func_def_lines)) ThenBlock: {
                            def_line = XArray.XGet(Checker2.func_def_lines, i)
                        }
                        
                        msg = StringConcat("Line ", NumberToString(def_line))
                        msg = StringConcat(msg, ": Function '")
                        msg = StringConcat(msg, fname)
                        msg = StringConcat(msg, "' is defined but never called")
                        Checker2.AddWarning(msg)
                    }
                }
            }
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// HELPER: Check if function is an entry point
// =============================================================================
Function.Checker2.IsEntryPoint {
    Input: fname: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(fname, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        len = StringLength(fname)
        IfCondition LessThan(len, 3) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check for "Run", "Main", "Init", "Test" prefixes
        c0 = GetByte(fname, 0)
        c1 = GetByte(fname, 1)
        c2 = GetByte(fname, 2)
        
        // "Run" = 82, 117, 110
        IfCondition And(EqualTo(c0, 82), And(EqualTo(c1, 117), EqualTo(c2, 110))) ThenBlock: {
            ReturnValue(1)
        }
        
        IfCondition GreaterEqual(len, 4) ThenBlock: {
            c3 = GetByte(fname, 3)
            // "Main" = 77, 97, 105, 110
            IfCondition And(EqualTo(c0, 77), And(EqualTo(c1, 97), And(EqualTo(c2, 105), EqualTo(c3, 110)))) ThenBlock: {
                ReturnValue(1)
            }
            // "Init" = 73, 110, 105, 116
            IfCondition And(EqualTo(c0, 73), And(EqualTo(c1, 110), And(EqualTo(c2, 105), EqualTo(c3, 116)))) ThenBlock: {
                ReturnValue(1)
            }
            // "Test" = 84, 101, 115, 116
            IfCondition And(EqualTo(c0, 84), And(EqualTo(c1, 101), And(EqualTo(c2, 115), EqualTo(c3, 116)))) ThenBlock: {
                ReturnValue(1)
            }
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// CHECK: Duplicate string literals
// =============================================================================
Function.Checker2.CheckDuplicateStrings {
    Body: {
        IfCondition LessThan(Checker2.string_count, 2) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, Checker2.string_count) {
            str1 = XArray.XGet(Checker2.string_literals, i)
            line1 = XArray.XGet(Checker2.string_lines, i)
            
            IfCondition NotEqual(str1, 0) ThenBlock: {
                len1 = StringLength(str1)
                // Only check strings longer than 10 chars
                IfCondition GreaterThan(len1, 10) ThenBlock: {
                    dup_count = 0
                    j = Add(i, 1)
                    WhileLoop LessThan(j, Checker2.string_count) {
                        str2 = XArray.XGet(Checker2.string_literals, j)
                        IfCondition NotEqual(str2, 0) ThenBlock: {
                            cmp = StringCompare(str1, str2)
                            IfCondition EqualTo(cmp, 0) ThenBlock: {
                                dup_count = Add(dup_count, 1)
                                // Mark as processed
                                XArray.XSet(Checker2.string_literals, j, 0)
                            }
                        }
                        j = Add(j, 1)
                    }
                    
                    IfCondition GreaterThan(dup_count, 0) ThenBlock: {
                        total = Add(dup_count, 1)
                        msg = StringConcat("Line ", NumberToString(line1))
                        msg = StringConcat(msg, ": String appears ")
                        msg = StringConcat(msg, NumberToString(total))
                        msg = StringConcat(msg, " times - consider a constant")
                        Checker2.AddWarning(msg)
                    }
                }
            }
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// CHECK: Long functions
// =============================================================================
Function.Checker2.CheckLongFunctions {
    Body: {
        i = 0
        WhileLoop LessThan(i, Checker.func_count) {
            is_defined = XArray.XGet(Checker.defined_funcs, i)
            IfCondition EqualTo(is_defined, 1) ThenBlock: {
                IfCondition LessThan(i, XArray.XSize(Checker2.func_def_lines)) ThenBlock: {
                    start_line = XArray.XGet(Checker2.func_def_lines, i)
                    end_line = XArray.XGet(Checker2.func_end_lines, i)
                    
                    IfCondition And(GreaterThan(start_line, 0), GreaterThan(end_line, start_line)) ThenBlock: {
                        func_len = Subtract(end_line, start_line)
                        IfCondition GreaterThan(func_len, Checker2.max_func_lines) ThenBlock: {
                            fname = XArray.XGet(Checker.func_names, i)
                            msg = StringConcat("Line ", NumberToString(start_line))
                            msg = StringConcat(msg, ": Function '")
                            msg = StringConcat(msg, fname)
                            msg = StringConcat(msg, "' is ")
                            msg = StringConcat(msg, NumberToString(func_len))
                            msg = StringConcat(msg, " lines (max: ")
                            msg = StringConcat(msg, NumberToString(Checker2.max_func_lines))
                            msg = StringConcat(msg, ") - consider splitting")
                            Checker2.AddWarning(msg)
                        }
                    }
                }
            }
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// HELPER: Get line of first call to a function
// =============================================================================
Function.Checker2.GetFirstCallLine {
    Input: func_idx: Integer
    Output: Integer
    Body: {
        i = 0
        WhileLoop LessThan(i, Checker2.call_count) {
            target = XArray.XGet(Checker2.call_targets, i)
            IfCondition EqualTo(target, func_idx) ThenBlock: {
                line = XArray.XGet(Checker2.call_lines, i)
                ReturnValue(line)
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// REPORT OUTPUT
// =============================================================================
Function.Checker2.Report {
    Body: {
        IfCondition GreaterThan(Checker2.error_count, 0) ThenBlock: {
            err_str = NumberToString(Checker2.error_count)
            msg_line = StringConcat("EXTENDED ERRORS (", err_str)
            msg_line = StringConcat(msg_line, "):\n")
            PrintMessage(msg_line)
            
            i = 0
            WhileLoop LessThan(i, Checker2.error_count) {
                msg = XArray.XGet(Checker2.errors, i)
                PrintMessage("  [ERROR] ")
                PrintMessage(msg)
                PrintMessage("\n")
                i = Add(i, 1)
            }
            PrintMessage("\n")
        }
        
        IfCondition GreaterThan(Checker2.warning_count, 0) ThenBlock: {
            warn_str = NumberToString(Checker2.warning_count)
            msg_line = StringConcat("EXTENDED WARNINGS (", warn_str)
            msg_line = StringConcat(msg_line, "):\n")
            PrintMessage(msg_line)
            
            i = 0
            WhileLoop LessThan(i, Checker2.warning_count) {
                msg = XArray.XGet(Checker2.warnings, i)
                PrintMessage("  [WARN] ")
                PrintMessage(msg)
                PrintMessage("\n")
                i = Add(i, 1)
            }
            PrintMessage("\n")
        }
        
        IfCondition And(EqualTo(Checker2.error_count, 0), EqualTo(Checker2.warning_count, 0)) ThenBlock: {
            PrintMessage("Extended checks: No additional issues.\n")
        }
    }
}

// =============================================================================
// CLEANUP
// =============================================================================
Function.Checker2.Cleanup {
    Body: {
        XArray.XDestroy(Checker2.warnings)
        XArray.XDestroy(Checker2.errors)
        XArray.XDestroy(Checker2.func_def_lines)
        XArray.XDestroy(Checker2.func_end_lines)
        XArray.XDestroy(Checker2.call_lines)
        XArray.XDestroy(Checker2.call_targets)
        XArray.XDestroy(Checker2.string_literals)
        XArray.XDestroy(Checker2.string_lines)
        XArray.XDestroy(Checker2.param_counts)
    }
}

// =============================================================================
// CONFIGURATION
// =============================================================================
Function.Checker2.SetMaxParams {
    Input: max_val: Integer
    Body: {
        Checker2.max_params = max_val
    }
}

Function.Checker2.SetMaxFuncLines {
    Input: max_val: Integer
    Body: {
        Checker2.max_func_lines = max_val
    }
}