// ============================================
// csv.ailang
// RFC 4180 compliant CSV parser/writer
// ============================================

LibraryImport.XArrays

// ============================================
// CONSTANTS
// ============================================

FixedPool.CSV_Config {
    "delimiter": Initialize=44
    "quote": Initialize=34
    "newline": Initialize=10
    "carriage": Initialize=13
    "max_field_size": Initialize=65536
    "max_fields": Initialize=1024
}

// File open flags
FixedPool.CSV_FileFlags {
    "O_RDONLY": Initialize=0
    "O_WRONLY": Initialize=1
    "O_RDWR": Initialize=2
    "O_CREAT": Initialize=64
    "O_TRUNC": Initialize=512
    "O_APPEND": Initialize=1024
    "O_CREAT_TRUNC_WRONLY": Initialize=577
}

// Seek whence values
FixedPool.CSV_Seek {
    "SEEK_SET": Initialize=0
    "SEEK_CUR": Initialize=1
    "SEEK_END": Initialize=2
}

// ============================================
// CSV ROW STRUCTURE
// ============================================

LinkagePool.CSV_Row {
    "fields": Initialize=0
    "field_count": Initialize=0
}

LinkagePool.CSV_Document {
    "rows": Initialize=0
    "row_count": Initialize=0
    "has_header": Initialize=0
    "headers": Initialize=0
}

// ============================================
// PARSER STATE
// ============================================

LinkagePool.CSV_Parser {
    "data": Initialize=0
    "len": Initialize=0
    "pos": Initialize=0
    "line": Initialize=1
    "col": Initialize=1
}

// ============================================
// LOW-LEVEL PARSING
// ============================================

Function.CSV_Parser_Create {
    Input: data: Address
    Input: len: Integer
    Output: Address
    Body: {
        parser = AllocateLinkage(LinkagePool.CSV_Parser)
        parser.data = data
        parser.len = len
        parser.pos = 0
        parser.line = 1
        parser.col = 1
        ReturnValue(parser)
    }
}

Function.CSV_Parser_Peek {
    Input: parser: Address
    Output: Integer
    Body: {
        IfCondition GreaterEqual(parser.pos, parser.len) ThenBlock: {
            ReturnValue(-1)
        }
        offset = Add(parser.data, parser.pos)
        ch = Dereference(offset, "byte")
        ReturnValue(ch)
    }
}

Function.CSV_Parser_Advance {
    Input: parser: Address
    Output: Integer
    Body: {
        IfCondition GreaterEqual(parser.pos, parser.len) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Add(parser.data, parser.pos)
        ch = Dereference(offset, "byte")
        parser.pos = Add(parser.pos, 1)
        
        IfCondition EqualTo(ch, CSV_Config.newline) ThenBlock: {
            parser.line = Add(parser.line, 1)
            parser.col = 1
        } ElseBlock: {
            parser.col = Add(parser.col, 1)
        }
        
        ReturnValue(ch)
    }
}

Function.CSV_Parser_AtEnd {
    Input: parser: Address
    Output: Integer
    Body: {
        IfCondition GreaterEqual(parser.pos, parser.len) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// ============================================
// FIELD PARSING
// ============================================

Function.CSV_Parse_Quoted_Field {
    Input: parser: Address
    Output: Address
    Body: {
        CSV_Parser_Advance(parser)
        
        max_size = CSV_Config.max_field_size
        buffer = Allocate(max_size)
        buf_pos = 0
        
        done = 0
        WhileLoop EqualTo(done, 0) {
            ch = CSV_Parser_Peek(parser)
            
            IfCondition EqualTo(ch, -1) ThenBlock: {
                done = 1
            } ElseBlock: {
                quote_char = CSV_Config.quote
                IfCondition EqualTo(ch, quote_char) ThenBlock: {
                    CSV_Parser_Advance(parser)
                    next = CSV_Parser_Peek(parser)
                    
                    IfCondition EqualTo(next, quote_char) ThenBlock: {
                        CSV_Parser_Advance(parser)
                        write_pos = Add(buffer, buf_pos)
                        StoreValue(write_pos, quote_char)
                        buf_pos = Add(buf_pos, 1)
                    } ElseBlock: {
                        done = 1
                    }
                } ElseBlock: {
                    CSV_Parser_Advance(parser)
                    write_pos = Add(buffer, buf_pos)
                    StoreValue(write_pos, ch)
                    buf_pos = Add(buf_pos, 1)
                }
            }
            
            max_minus_one = Subtract(max_size, 1)
            IfCondition GreaterEqual(buf_pos, max_minus_one) ThenBlock: {
                done = 1
            }
        }
        
        term_pos = Add(buffer, buf_pos)
        StoreValue(term_pos, 0)
        
        result_size = Add(buf_pos, 1)
        result = Allocate(result_size)
        MemoryCopy(result, buffer, result_size)
        Deallocate(buffer, max_size)
        
        ReturnValue(result)
    }
}

Function.CSV_Parse_Unquoted_Field {
    Input: parser: Address
    Output: Address
    Body: {
        max_size = CSV_Config.max_field_size
        buffer = Allocate(max_size)
        buf_pos = 0
        
        done = 0
        WhileLoop EqualTo(done, 0) {
            ch = CSV_Parser_Peek(parser)
            delim = CSV_Config.delimiter
            newline = CSV_Config.newline
            carriage = CSV_Config.carriage
            
            IfCondition EqualTo(ch, -1) ThenBlock: {
                done = 1
            } ElseBlock: {
                IfCondition EqualTo(ch, delim) ThenBlock: {
                    done = 1
                } ElseBlock: {
                    IfCondition EqualTo(ch, newline) ThenBlock: {
                        done = 1
                    } ElseBlock: {
                        IfCondition EqualTo(ch, carriage) ThenBlock: {
                            done = 1
                        } ElseBlock: {
                            CSV_Parser_Advance(parser)
                            write_pos = Add(buffer, buf_pos)
                            StoreValue(write_pos, ch)
                            buf_pos = Add(buf_pos, 1)
                        }
                    }
                }
            }
            
            max_minus_one = Subtract(max_size, 1)
            IfCondition GreaterEqual(buf_pos, max_minus_one) ThenBlock: {
                done = 1
            }
        }
        
        term_pos = Add(buffer, buf_pos)
        StoreValue(term_pos, 0)
        
        result_size = Add(buf_pos, 1)
        result = Allocate(result_size)
        MemoryCopy(result, buffer, result_size)
        Deallocate(buffer, max_size)
        
        ReturnValue(result)
    }
}

Function.CSV_Parse_Field {
    Input: parser: Address
    Output: Address
    Body: {
        ch = CSV_Parser_Peek(parser)
        quote_char = CSV_Config.quote
        
        IfCondition EqualTo(ch, quote_char) ThenBlock: {
            field = CSV_Parse_Quoted_Field(parser)
        } ElseBlock: {
            field = CSV_Parse_Unquoted_Field(parser)
        }
        
        ReturnValue(field)
    }
}

// ============================================
// ROW FUNCTIONS
// Using direct array instead of XArray to avoid pointer truncation
// ============================================

Function.CSV_Row_Create {
    Output: Address
    Body: {
        // Row structure: 24 bytes
        // [0]:  fields_ptr (8 bytes) - pointer to array of field pointers
        // [8]:  field_count (8 bytes)
        // [16]: capacity (8 bytes)
        max_fields = CSV_Config.max_fields
        
        row = Allocate(24)
        fields_array = Allocate(Multiply(max_fields, 8))  // Array of field pointers
        
        StoreValue(row, fields_array)          // fields_ptr
        StoreValue(Add(row, 8), 0)             // field_count = 0
        StoreValue(Add(row, 16), max_fields)   // capacity
        
        ReturnValue(row)
    }
}

Function.CSV_Row_AddField {
    Input: row: Address
    Input: field: Address
    Body: {
        fields_array = Dereference(row)
        field_count = Dereference(Add(row, 8))
        
        // Store field pointer at fields_array[field_count * 8]
        offset = Multiply(field_count, 8)
        store_addr = Add(fields_array, offset)
        StoreValue(store_addr, field)
        
        // Increment field count
        new_count = Add(field_count, 1)
        StoreValue(Add(row, 8), new_count)
        
        ReturnValue(0)
    }
}

Function.CSV_Row_GetField {
    Input: row: Address
    Input: index: Integer
    Output: Address
    Body: {
        field_count = Dereference(Add(row, 8))
        IfCondition GreaterEqual(index, field_count) ThenBlock: {
            ReturnValue(0)
        }
        
        fields_array = Dereference(row)
        offset = Multiply(index, 8)
        read_addr = Add(fields_array, offset)
        field = Dereference(read_addr)
        
        ReturnValue(field)
    }
}

Function.CSV_Row_GetFieldCount {
    Input: row: Address
    Output: Integer
    Body: {
        count = Dereference(Add(row, 8))
        ReturnValue(count)
    }
}

Function.CSV_Row_Free {
    Input: row: Address
    Body: {
        IfCondition EqualTo(row, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        fields_array = Dereference(row)
        field_count = Dereference(Add(row, 8))
        capacity = Dereference(Add(row, 16))
        
        i = 0
        WhileLoop LessThan(i, field_count) {
            offset = Multiply(i, 8)
            read_addr = Add(fields_array, offset)
            field = Dereference(read_addr)
            IfCondition NotEqual(field, 0) ThenBlock: {
                field_len = StringLength(field)
                dealloc_size = Add(field_len, 1)
                Deallocate(field, dealloc_size)
            }
            i = Add(i, 1)
        }
        
        Deallocate(fields_array, Multiply(capacity, 8))
        Deallocate(row, 24)
        ReturnValue(0)
    }
}

Function.CSV_Parse_Row {
    Input: parser: Address
    Output: Address
    Body: {
        row = CSV_Row_Create()
        newline = CSV_Config.newline
        carriage = CSV_Config.carriage
        delim = CSV_Config.delimiter
        
        ch = CSV_Parser_Peek(parser)
        IfCondition EqualTo(ch, newline) ThenBlock: {
            CSV_Parser_Advance(parser)
            ReturnValue(row)
        }
        IfCondition EqualTo(ch, carriage) ThenBlock: {
            CSV_Parser_Advance(parser)
            next_ch = CSV_Parser_Peek(parser)
            IfCondition EqualTo(next_ch, newline) ThenBlock: {
                CSV_Parser_Advance(parser)
            }
            ReturnValue(row)
        }
        
        done = 0
        WhileLoop EqualTo(done, 0) {
            field = CSV_Parse_Field(parser)
            CSV_Row_AddField(row, field)
            
            ch = CSV_Parser_Peek(parser)
            
            IfCondition EqualTo(ch, delim) ThenBlock: {
                CSV_Parser_Advance(parser)
            } ElseBlock: {
                IfCondition EqualTo(ch, carriage) ThenBlock: {
                    CSV_Parser_Advance(parser)
                    next_ch = CSV_Parser_Peek(parser)
                    IfCondition EqualTo(next_ch, newline) ThenBlock: {
                        CSV_Parser_Advance(parser)
                    }
                    done = 1
                } ElseBlock: {
                    IfCondition EqualTo(ch, newline) ThenBlock: {
                        CSV_Parser_Advance(parser)
                        done = 1
                    } ElseBlock: {
                        IfCondition EqualTo(ch, -1) ThenBlock: {
                            done = 1
                        }
                    }
                }
            }
        }
        
        ReturnValue(row)
    }
}

// ============================================
// DOCUMENT FUNCTIONS
// Using direct array instead of XArray to avoid pointer truncation issues
// ============================================

Function.CSV_Document_Create {
    Output: Address
    Body: {
        // Allocate document structure manually: 32 bytes
        // [0]:  rows_ptr (8 bytes) - pointer to array of row pointers
        // [8]:  row_count (8 bytes)
        // [16]: has_header (8 bytes)
        // [24]: headers (8 bytes) - pointer to header row
        doc = Allocate(32)
        
        // Create array to hold row pointers (max 4096 rows)
        rows_array = Allocate(32768)  // 4096 * 8 bytes
        StoreValue(doc, rows_array)
        StoreValue(Add(doc, 8), 0)    // row_count = 0
        StoreValue(Add(doc, 16), 0)   // has_header = 0
        StoreValue(Add(doc, 24), 0)   // headers = 0
        
        ReturnValue(doc)
    }
}

Function.CSV_Document_AddRow {
    Input: doc: Address
    Input: row: Address
    Body: {
        rows_array = Dereference(doc)
        row_count = Dereference(Add(doc, 8))
        
        // Store row pointer at rows_array[row_count * 8]
        offset = Multiply(row_count, 8)
        store_addr = Add(rows_array, offset)
        StoreValue(store_addr, row)
        
        // Increment row count
        new_count = Add(row_count, 1)
        StoreValue(Add(doc, 8), new_count)
        
        ReturnValue(0)
    }
}

Function.CSV_Document_GetRow {
    Input: doc: Address
    Input: index: Integer
    Output: Address
    Body: {
        row_count = Dereference(Add(doc, 8))
        IfCondition GreaterEqual(index, row_count) ThenBlock: {
            ReturnValue(0)
        }
        
        rows_array = Dereference(doc)
        offset = Multiply(index, 8)
        read_addr = Add(rows_array, offset)
        row = Dereference(read_addr)
        
        ReturnValue(row)
    }
}

Function.CSV_Document_GetHeaders {
    Input: doc: Address
    Output: Address
    Body: {
        headers = Dereference(Add(doc, 24))
        ReturnValue(headers)
    }
}

Function.CSV_Document_SetHeaders {
    Input: doc: Address
    Input: headers: Address
    Body: {
        StoreValue(Add(doc, 24), headers)
        StoreValue(Add(doc, 16), 1)  // has_header = 1
        ReturnValue(0)
    }
}

Function.CSV_Document_HasHeaders {
    Input: doc: Address
    Output: Integer
    Body: {
        has_hdr = Dereference(Add(doc, 16))
        ReturnValue(has_hdr)
    }
}

Function.CSV_Document_GetRowCount {
    Input: doc: Address
    Output: Integer
    Body: {
        count = Dereference(Add(doc, 8))
        ReturnValue(count)
    }
}

Function.CSV_Document_Free {
    Input: doc: Address
    Body: {
        IfCondition EqualTo(doc, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        rows_array = Dereference(doc)
        row_count = Dereference(Add(doc, 8))
        
        i = 0
        WhileLoop LessThan(i, row_count) {
            offset = Multiply(i, 8)
            read_addr = Add(rows_array, offset)
            row = Dereference(read_addr)
            CSV_Row_Free(row)
            i = Add(i, 1)
        }
        
        headers = Dereference(Add(doc, 24))
        IfCondition NotEqual(headers, 0) ThenBlock: {
            CSV_Row_Free(headers)
        }
        
        Deallocate(rows_array, 32768)
        Deallocate(doc, 32)
        ReturnValue(0)
    }
}

// ============================================
// PUBLIC API - PARSING
// ============================================

Function.CSV_Parse {
    Input: data: Address
    Input: len: Integer
    Output: Address
    Body: {
        parser = CSV_Parser_Create(data, len)
        doc = CSV_Document_Create()
        
        at_end = CSV_Parser_AtEnd(parser)
        WhileLoop EqualTo(at_end, 0) {
            row = CSV_Parse_Row(parser)
            CSV_Document_AddRow(doc, row)
            at_end = CSV_Parser_AtEnd(parser)
        }
        
        FreeLinkage(parser)
        ReturnValue(doc)
    }
}

Function.CSV_ParseWithHeaders {
    Input: data: Address
    Input: len: Integer
    Output: Address
    Body: {
        parser = CSV_Parser_Create(data, len)
        doc = CSV_Document_Create()
        
        at_end = CSV_Parser_AtEnd(parser)
        IfCondition EqualTo(at_end, 0) ThenBlock: {
            header_row = CSV_Parse_Row(parser)
            // Set headers directly using memory operations
            StoreValue(Add(doc, 24), header_row)  // headers
            StoreValue(Add(doc, 16), 1)           // has_header = 1
        }
        
        at_end = CSV_Parser_AtEnd(parser)
        WhileLoop EqualTo(at_end, 0) {
            row = CSV_Parse_Row(parser)
            CSV_Document_AddRow(doc, row)
            at_end = CSV_Parser_AtEnd(parser)
        }
        
        FreeLinkage(parser)
        ReturnValue(doc)
    }
}

Function.CSV_GetFieldByName {
    Input: doc: Address
    Input: row_index: Integer
    Input: column_name: Address
    Output: Address
    Body: {
        has_hdr = Dereference(Add(doc, 16))
        IfCondition EqualTo(has_hdr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        col_index = -1
        headers = Dereference(Add(doc, 24))
        header_count = CSV_Row_GetFieldCount(headers)
        i = 0
        WhileLoop LessThan(i, header_count) {
            header = CSV_Row_GetField(headers, i)
            cmp_result = StringCompare(header, column_name)
            IfCondition EqualTo(cmp_result, 0) ThenBlock: {
                col_index = i
            }
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(col_index, -1) ThenBlock: {
            ReturnValue(0)
        }
        
        row = CSV_Document_GetRow(doc, row_index)
        IfCondition EqualTo(row, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        field = CSV_Row_GetField(row, col_index)
        ReturnValue(field)
    }
}

// ============================================
// PUBLIC API - WRITING
// ============================================

Function.CSV_FieldNeedsQuoting {
    Input: field: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(field, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        delim = CSV_Config.delimiter
        quote_char = CSV_Config.quote
        newline = CSV_Config.newline
        carriage = CSV_Config.carriage
        
        len = StringLength(field)
        i = 0
        WhileLoop LessThan(i, len) {
            pos = Add(field, i)
            ch = Dereference(pos, "byte")
            
            IfCondition EqualTo(ch, delim) ThenBlock: {
                ReturnValue(1)
            }
            IfCondition EqualTo(ch, quote_char) ThenBlock: {
                ReturnValue(1)
            }
            IfCondition EqualTo(ch, newline) ThenBlock: {
                ReturnValue(1)
            }
            IfCondition EqualTo(ch, carriage) ThenBlock: {
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

Function.CSV_WriteField {
    Input: field: Address
    Input: buffer: Address
    Input: buf_pos: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(field, 0) ThenBlock: {
            ReturnValue(buf_pos)
        }
        
        quote_char = CSV_Config.quote
        needs_quote = CSV_FieldNeedsQuoting(field)
        
        IfCondition needs_quote ThenBlock: {
            write_pos = Add(buffer, buf_pos)
            StoreValue(write_pos, quote_char)
            buf_pos = Add(buf_pos, 1)
            
            len = StringLength(field)
            i = 0
            WhileLoop LessThan(i, len) {
                read_pos = Add(field, i)
                ch = Dereference(read_pos, "byte")
                
                IfCondition EqualTo(ch, quote_char) ThenBlock: {
                    write_pos = Add(buffer, buf_pos)
                    StoreValue(write_pos, quote_char)
                    buf_pos = Add(buf_pos, 1)
                }
                
                write_pos = Add(buffer, buf_pos)
                StoreValue(write_pos, ch)
                buf_pos = Add(buf_pos, 1)
                i = Add(i, 1)
            }
            
            write_pos = Add(buffer, buf_pos)
            StoreValue(write_pos, quote_char)
            buf_pos = Add(buf_pos, 1)
        } ElseBlock: {
            len = StringLength(field)
            dest = Add(buffer, buf_pos)
            MemoryCopy(dest, field, len)
            buf_pos = Add(buf_pos, len)
        }
        
        ReturnValue(buf_pos)
    }
}

Function.CSV_WriteRow {
    Input: row: Address
    Input: buffer: Address
    Input: buf_pos: Integer
    Output: Integer
    Body: {
        delim = CSV_Config.delimiter
        newline = CSV_Config.newline
        field_count = CSV_Row_GetFieldCount(row)
        i = 0
        WhileLoop LessThan(i, field_count) {
            IfCondition GreaterThan(i, 0) ThenBlock: {
                write_pos = Add(buffer, buf_pos)
                StoreValue(write_pos, delim)
                buf_pos = Add(buf_pos, 1)
            }
            
            field = CSV_Row_GetField(row, i)
            buf_pos = CSV_WriteField(field, buffer, buf_pos)
            
            i = Add(i, 1)
        }
        
        write_pos = Add(buffer, buf_pos)
        StoreValue(write_pos, newline)
        buf_pos = Add(buf_pos, 1)
        
        ReturnValue(buf_pos)
    }
}

Function.CSV_Write {
    Input: doc: Address
    Output: Address
    Body: {
        row_count = CSV_Document_GetRowCount(doc)
        est_size = Multiply(row_count, 2000)
        IfCondition LessThan(est_size, 4096) ThenBlock: {
            est_size = 4096
        }
        
        buffer = Allocate(est_size)
        buf_pos = 0
        
        has_hdr = Dereference(Add(doc, 16))
        IfCondition has_hdr ThenBlock: {
            headers = Dereference(Add(doc, 24))
            buf_pos = CSV_WriteRow(headers, buffer, buf_pos)
        }
        
        i = 0
        WhileLoop LessThan(i, row_count) {
            row = CSV_Document_GetRow(doc, i)
            buf_pos = CSV_WriteRow(row, buffer, buf_pos)
            i = Add(i, 1)
        }
        
        term_pos = Add(buffer, buf_pos)
        StoreValue(term_pos, 0)
        
        result_size = Add(buf_pos, 1)
        result = Allocate(result_size)
        MemoryCopy(result, buffer, result_size)
        Deallocate(buffer, est_size)
        
        ReturnValue(result)
    }
}

// ============================================
// FILE I/O (using SystemCall)
// Syscall numbers: 0=read, 1=write, 2=open, 3=close, 8=lseek
// ============================================

Function.CSV_ParseFile {
    Input: filename: Address
    Output: Address
    Body: {
        // open(filename, O_RDONLY, 0) - syscall 2
        fd = SystemCall(2, filename, CSV_FileFlags.O_RDONLY, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get file size: lseek(fd, 0, SEEK_END) - syscall 8
        size = SystemCall(8, fd, 0, CSV_Seek.SEEK_END)
        // Seek back to start: lseek(fd, 0, SEEK_SET)
        SystemCall(8, fd, 0, CSV_Seek.SEEK_SET)
        
        alloc_size = Add(size, 1)
        buffer = Allocate(alloc_size)
        
        // read(fd, buffer, size) - syscall 0
        bytes_read = SystemCall(0, fd, buffer, size)
        term_pos = Add(buffer, bytes_read)
        StoreValue(term_pos, 0)
        
        // close(fd) - syscall 3
        SystemCall(3, fd)
        
        doc = CSV_Parse(buffer, bytes_read)
        
        Deallocate(buffer, alloc_size)
        
        ReturnValue(doc)
    }
}

Function.CSV_ParseFileWithHeaders {
    Input: filename: Address
    Output: Address
    Body: {
        // open(filename, O_RDONLY, 0) - syscall 2
        fd = SystemCall(2, filename, CSV_FileFlags.O_RDONLY, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get file size
        size = SystemCall(8, fd, 0, CSV_Seek.SEEK_END)
        SystemCall(8, fd, 0, CSV_Seek.SEEK_SET)
        
        alloc_size = Add(size, 1)
        buffer = Allocate(alloc_size)
        
        // read(fd, buffer, size)
        bytes_read = SystemCall(0, fd, buffer, size)
        term_pos = Add(buffer, bytes_read)
        StoreValue(term_pos, 0)
        
        // close(fd)
        SystemCall(3, fd)
        
        doc = CSV_ParseWithHeaders(buffer, bytes_read)
        
        Deallocate(buffer, alloc_size)
        
        ReturnValue(doc)
    }
}

Function.CSV_WriteFile {
    Input: doc: Address
    Input: filename: Address
    Output: Integer
    Body: {
        csv_string = CSV_Write(doc)
        
        IfCondition EqualTo(csv_string, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        // open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0644) - syscall 2
        fd = SystemCall(2, filename, CSV_FileFlags.O_CREAT_TRUNC_WRONLY, 420)
        IfCondition LessThan(fd, 0) ThenBlock: {
            str_len = StringLength(csv_string)
            dealloc_size = Add(str_len, 1)
            Deallocate(csv_string, dealloc_size)
            ReturnValue(-1)
        }
        
        len = StringLength(csv_string)
        
        // write(fd, csv_string, len) - syscall 1
        bytes_written = SystemCall(1, fd, csv_string, len)
        
        // close(fd) - syscall 3
        SystemCall(3, fd)
        
        dealloc_size = Add(len, 1)
        Deallocate(csv_string, dealloc_size)
        
        IfCondition EqualTo(bytes_written, len) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(-1)
    }
}

// ============================================
// CONVENIENCE FUNCTIONS
// ============================================

Function.CSV_RowCount {
    Input: doc: Address
    Output: Integer
    Body: {
        count = Dereference(Add(doc, 8))
        ReturnValue(count)
    }
}

Function.CSV_ColumnCount {
    Input: doc: Address
    Output: Integer
    Body: {
        has_hdr = Dereference(Add(doc, 16))
        IfCondition has_hdr ThenBlock: {
            headers = Dereference(Add(doc, 24))
            count = CSV_Row_GetFieldCount(headers)
            ReturnValue(count)
        }
        
        row_count = Dereference(Add(doc, 8))
        IfCondition GreaterThan(row_count, 0) ThenBlock: {
            row = CSV_Document_GetRow(doc, 0)
            count = CSV_Row_GetFieldCount(row)
            ReturnValue(count)
        }
        
        ReturnValue(0)
    }
}

Function.CSV_GetCell {
    Input: doc: Address
    Input: row: Integer
    Input: col: Integer
    Output: Address
    Body: {
        r = CSV_Document_GetRow(doc, row)
        IfCondition EqualTo(r, 0) ThenBlock: {
            ReturnValue(0)
        }
        field = CSV_Row_GetField(r, col)
        ReturnValue(field)
    }
}