// Library.FixedPointTrig.ailang
// Fixed-point trigonometry library for AILANG
// Uses integer arithmetic with scale factor of 10000 (4 decimal places)
// Angles in degrees for simplicity


LibraryImport.XArrays


PrintMessage("Loading Fixed-Point Trigonometry Library v1.0")
PrintMessage("==============================================")

// Fixed-point configuration
// Scale: 10000 = 1.0000 in fixed-point
// pi = 3.1416, half_pi = 1.5708, two_pi = 6.2832
// e = 2.7183, deg_to_rad = 0.0175, rad_to_deg = 57.2958
FixedPool.FixedPointTrig {
    "scale": Initialize=10000
    "pi": Initialize=31416
    "half_pi": Initialize=15708
    "two_pi": Initialize=62832
    "e": Initialize=27183
    "deg_to_rad": Initialize=175
    "rad_to_deg": Initialize=572958
}

// Sin lookup table (0-90 degrees)
// sin(0)=0, sin(1)=0.0175, sin(2)=0.0349, etc.
FixedPool.SinTable {
    "sin_0": Initialize=0
    "sin_1": Initialize=175
    "sin_2": Initialize=349
    "sin_3": Initialize=523
    "sin_4": Initialize=698
    "sin_5": Initialize=872
    "sin_6": Initialize=1045
    "sin_7": Initialize=1219
    "sin_8": Initialize=1392
    "sin_9": Initialize=1564
    "sin_10": Initialize=1736
    "sin_15": Initialize=2588
    "sin_20": Initialize=3420
    "sin_25": Initialize=4226
    "sin_30": Initialize=5000
    "sin_35": Initialize=5736
    "sin_40": Initialize=6428
    "sin_45": Initialize=7071
    "sin_50": Initialize=7660
    "sin_55": Initialize=8192
    "sin_60": Initialize=8660
    "sin_65": Initialize=9063
    "sin_70": Initialize=9397
    "sin_75": Initialize=9659
    "sin_80": Initialize=9848
    "sin_85": Initialize=9962
    "sin_90": Initialize=10000
}

// === ANGLE NORMALIZATION (moved to top to ensure it's declared first) ===

Function.Trig.NormalizeDegrees {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Normalize angle to 0-359 range
        angle = degrees
        
        // Handle negative angles
        WhileLoop LessThan(angle, 0) {
            angle = Add(angle, 360)
        }
        
        // Handle angles >= 360
        WhileLoop GreaterEqual(angle, 360) {
            angle = Subtract(angle, 360)
        }
        
        ReturnValue(angle)
    }
}

// === CONVERSION FUNCTIONS ===

Function.FixedPoint.FromInt {
    Input: value: Integer
    Output: Integer
    Body: {
        // Convert integer to fixed-point
        ReturnValue(Multiply(value, FixedPointTrig.scale))
    }
}

Function.FixedPoint.ToInt {
    Input: fixed: Integer
    Output: Integer
    Body: {
        // Convert fixed-point to integer (with rounding)
        half_scale = Divide(FixedPointTrig.scale, 2)
        rounded = Add(fixed, half_scale)
        ReturnValue(Divide(rounded, FixedPointTrig.scale))
    }
}

Function.FixedPoint.Multiply {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        // Multiply two fixed-point numbers
        product = Multiply(a, b)
        ReturnValue(Divide(product, FixedPointTrig.scale))
    }
}

Function.FixedPoint.Divide {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        // Divide two fixed-point numbers
        // Gracefully handle division by zero in all builds.
        is_zero = EqualTo(b, 0)
        IfCondition is_zero ThenBlock: {
            PrintMessage("ERROR: Fixed-point divide by zero")
            ReturnValue(0) // Return 0 on error
        }

        // Scale numerator before division
        scaled_a = Multiply(a, FixedPointTrig.scale)
        ReturnValue(Divide(scaled_a, b))
    }
}

// === TRIGONOMETRIC FUNCTIONS ===

// Helper function for sin lookup - MUST BE DEFINED FIRST
Function.Trig.SinLookup {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Simple lookup for key angles (extend as needed)
        IfCondition EqualTo(degrees, 0) ThenBlock: { ReturnValue(SinTable.sin_0) }
        IfCondition EqualTo(degrees, 1) ThenBlock: { ReturnValue(SinTable.sin_1) }
        IfCondition EqualTo(degrees, 2) ThenBlock: { ReturnValue(SinTable.sin_2) }
        IfCondition EqualTo(degrees, 3) ThenBlock: { ReturnValue(SinTable.sin_3) }
        IfCondition EqualTo(degrees, 4) ThenBlock: { ReturnValue(SinTable.sin_4) }
        IfCondition EqualTo(degrees, 5) ThenBlock: { ReturnValue(SinTable.sin_5) }
        IfCondition EqualTo(degrees, 10) ThenBlock: { ReturnValue(SinTable.sin_10) }
        IfCondition EqualTo(degrees, 15) ThenBlock: { ReturnValue(SinTable.sin_15) }
        IfCondition EqualTo(degrees, 20) ThenBlock: { ReturnValue(SinTable.sin_20) }
        IfCondition EqualTo(degrees, 25) ThenBlock: { ReturnValue(SinTable.sin_25) }
        IfCondition EqualTo(degrees, 30) ThenBlock: { ReturnValue(SinTable.sin_30) }
        IfCondition EqualTo(degrees, 35) ThenBlock: { ReturnValue(SinTable.sin_35) }
        IfCondition EqualTo(degrees, 40) ThenBlock: { ReturnValue(SinTable.sin_40) }
        IfCondition EqualTo(degrees, 45) ThenBlock: { ReturnValue(SinTable.sin_45) }
        IfCondition EqualTo(degrees, 50) ThenBlock: { ReturnValue(SinTable.sin_50) }
        IfCondition EqualTo(degrees, 55) ThenBlock: { ReturnValue(SinTable.sin_55) }
        IfCondition EqualTo(degrees, 60) ThenBlock: { ReturnValue(SinTable.sin_60) }
        IfCondition EqualTo(degrees, 65) ThenBlock: { ReturnValue(SinTable.sin_65) }
        IfCondition EqualTo(degrees, 70) ThenBlock: { ReturnValue(SinTable.sin_70) }
        IfCondition EqualTo(degrees, 75) ThenBlock: { ReturnValue(SinTable.sin_75) }
        IfCondition EqualTo(degrees, 80) ThenBlock: { ReturnValue(SinTable.sin_80) }
        IfCondition EqualTo(degrees, 85) ThenBlock: { ReturnValue(SinTable.sin_85) }
        IfCondition EqualTo(degrees, 90) ThenBlock: { ReturnValue(SinTable.sin_90) }
        
        // For angles not in table, use linear interpolation
        // This is simplified - just return nearest
        IfCondition LessThan(degrees, 8) ThenBlock: {
            ReturnValue(Multiply(degrees, 175))  // Approximate
        }
        
        // Default fallback
        ReturnValue(0)
    }
}

// Main sin function - can now call SinLookup
Function.Trig.Sin {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // Returns sin(degrees) in fixed-point format
        angle = Trig.NormalizeDegrees(degrees)

        Debug("Trig.Sin", level=2) {
            PrintMessage("  Input degrees: ")
            PrintNumber(degrees)
            PrintMessage("  Normalized angle: ")
            PrintNumber(angle)
        }

        // Determine quadrant and adjust
        quadrant = 1
        
        IfCondition GreaterThan(angle, 270) ThenBlock: {
            quadrant = 4
            angle = Subtract(360, angle)
            Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 4 detected") }
            // sin(360-x) = -sin(x)
        } ElseBlock: {
            IfCondition GreaterThan(angle, 180) ThenBlock: {
                quadrant = 3
                angle = Subtract(angle, 180)
                Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 3 detected") }
                // sin(180+x) = -sin(x)
            } ElseBlock: {
                IfCondition GreaterThan(angle, 90) ThenBlock: {
                    quadrant = 2
                    angle = Subtract(180, angle)
                    Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 2 detected") }
                    // sin(180-x) = sin(x)
                } ElseBlock: {
                    Debug("Trig.Sin.Quadrant", level=3) { PrintMessage("    Quadrant 1 detected") }
                }
            }
        }
        
        // Look up value for 0-90 range
        result = Trig.SinLookup(angle)
        
        // Apply sign based on quadrant
        IfCondition EqualTo(quadrant, 3) ThenBlock: {
            result = Subtract(0, result)
        }
        IfCondition EqualTo(quadrant, 4) ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Trig.Cos {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // cos(x) = sin(x + 90)
        shifted = Add(degrees, 90)
        ReturnValue(Trig.Sin(shifted))
    }
}

Function.Trig.Tan {
    Input: degrees: Integer
    Output: Integer
    Body: {
        // tan(x) = sin(x) / cos(x)
        sin_val = Trig.Sin(degrees)
        cos_val = Trig.Cos(degrees)
        
        // Check for divide by zero (cos = 0 at 90, 270)
        is_zero = EqualTo(cos_val, 0)
        IfCondition is_zero ThenBlock: {
            // Return large value for "infinity"
            is_positive = GreaterThan(sin_val, 0)
            IfCondition is_positive ThenBlock: {
                ReturnValue(999999)
            }
            ReturnValue(-999999)
        }
        
        ReturnValue(FixedPoint.Divide(sin_val, cos_val))
    }
}

// === INVERSE TRIG FUNCTIONS (using approximations) ===

Function.Trig.Atan {
    Input: fixed_value: Integer
    Output: Integer
    Body: {
        // Simple atan approximation using table lookup
        // For now, just handle common angles
        
        abs_val = fixed_value
        is_negative = LessThan(fixed_value, 0)
        IfCondition is_negative ThenBlock: {
            abs_val = Subtract(0, fixed_value)
        }
        
        // Check common values (in fixed-point)
        IfCondition LessEqual(abs_val, 175) ThenBlock: {
            result = 1
        } ElseBlock: {
            IfCondition LessEqual(abs_val, 364) ThenBlock: {
                result = 2
            } ElseBlock: {
                IfCondition LessEqual(abs_val, 5773) ThenBlock: {
                    result = 30
                } ElseBlock: {
                    IfCondition LessEqual(abs_val, 10000) ThenBlock: {
                        result = 45
                    } ElseBlock: {
                        IfCondition LessEqual(abs_val, 17321) ThenBlock: {
                            result = 60
                        } ElseBlock: {
                            result = 89
                        }
                    }
                }
            }
        }
        
        IfCondition is_negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Trig.Atan2 {
    Input: (y: Integer, x: Integer)
    Output: Integer
    Body: {
        // atan2(y, x) - handles all quadrants
        
        // Handle special cases
        is_x_zero = EqualTo(x, 0)
        is_y_zero = EqualTo(y, 0)
        
        IfCondition is_x_zero ThenBlock: {
            IfCondition is_y_zero ThenBlock: {
                ReturnValue(0)
            }
            IfCondition GreaterThan(y, 0) ThenBlock: {
                ReturnValue(90)
            }
            ReturnValue(270)
        }
        
        IfCondition is_y_zero ThenBlock: {
            IfCondition GreaterThan(x, 0) ThenBlock: {
                ReturnValue(0)
            }
            ReturnValue(180)
        }
        
        // Calculate atan(y/x) and adjust for quadrant
        ratio = FixedPoint.Divide(y, x)
        angle = Trig.Atan(ratio)
        
        IfCondition LessThan(x, 0) ThenBlock: {
            IfCondition GreaterEqual(y, 0) ThenBlock: {
                angle = Add(angle, 180)
            } ElseBlock: {
                angle = Subtract(angle, 180)
            }
        }
        
        ReturnValue(Trig.NormalizeDegrees(angle))
    }
}

// === EXPONENTIAL AND LOGARITHM (using series approximations) ===

Function.Math.Exp {
    Input: x: Integer
    Output: Integer
    Body: {
        // exp(x) using Taylor series: 1 + x + x²/2! + x³/3! + ...
        // Limited to small x for accuracy
        
        // Start with 1.0 in fixed-point
        result = FixedPointTrig.scale
        term = FixedPointTrig.scale
        
        // Calculate first 8 terms
        i = 1
        WhileLoop LessEqual(i, 8) {
            term = FixedPoint.Multiply(term, x)
            term = Divide(term, i)
            result = Add(result, term)
            
            // Early exit if term becomes too small
            IfCondition LessThan(term, 10) ThenBlock: {
                BreakLoop
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

Function.Math.Log {
    Input: x: Integer
    Output: Integer
    Body: {
        // Natural log using series approximation
        // ln(x) = ln(1+y) where y = (x-1)
        // Series: y - y²/2 + y³/3 - y⁴/4 + ...
        
        DebugAssert(GreaterThan(x, 0), "Log of non-positive number")

        // For x close to 1, use series
        y = Subtract(x, FixedPointTrig.scale)
        
        // If x is far from 1, scale it first
        scale_count = 0
        temp_x = x
        WhileLoop GreaterThan(temp_x, Multiply(2, FixedPointTrig.scale)) {
            temp_x = Divide(temp_x, 2)
            scale_count = Add(scale_count, 1)
        }
        
        // Now compute log of scaled value
        y = Subtract(temp_x, FixedPointTrig.scale)
        result = 0
        term = y
        sign = 1
        
        i = 1
        WhileLoop LessEqual(i, 10) {
            divisor = Multiply(i, FixedPointTrig.scale)
            term_contribution = FixedPoint.Divide(term, divisor)
            
            IfCondition EqualTo(sign, 1) ThenBlock: {
                result = Add(result, term_contribution)
            } ElseBlock: {
                result = Subtract(result, term_contribution)
            }
            
            term = FixedPoint.Multiply(term, y)
            sign = Subtract(0, sign)
            i = Add(i, 1)
        }
        
        // Add back the scaling: log(2) = 0.693147 * scale_count
        log2 = 6931
        result = Add(result, Multiply(scale_count, log2))
        
        ReturnValue(result)
    }
}

// === HYPERBOLIC FUNCTIONS ===

Function.Trig.Sinh {
    Input: x: Integer
    Output: Integer
    Body: {
        // sinh(x) = (e^x - e^-x) / 2
        exp_x = Math.Exp(x)
        neg_x = Subtract(0, x)
        exp_neg_x = Math.Exp(neg_x)
        
        diff = Subtract(exp_x, exp_neg_x)
        ReturnValue(Divide(diff, 2))
    }
}

Function.Trig.Cosh {
    Input: x: Integer
    Output: Integer
    Body: {
        // cosh(x) = (e^x + e^-x) / 2
        exp_x = Math.Exp(x)
        neg_x = Subtract(0, x)
        exp_neg_x = Math.Exp(neg_x)
        
        sum = Add(exp_x, exp_neg_x)
        ReturnValue(Divide(sum, 2))
    }
}

Function.Trig.Tanh {
    Input: x: Integer
    Output: Integer
    Body: {
        // tanh(x) = sinh(x) / cosh(x)
        sinh_val = Trig.Sinh(x)
        cosh_val = Trig.Cosh(x)
        
        ReturnValue(FixedPoint.Divide(sinh_val, cosh_val))
    }
}

// === INTEGER SQUARE ROOT (for distance calculations) ===

Function.Math.ISqrt {
    Input: n: Integer
    Output: Integer
    Body: {
        // Integer square root using Newton's method
        DebugAssert(GreaterEqual(n, 0), "ISqrt of negative number")
        IfCondition EqualTo(n, 0) ThenBlock: {
            ReturnValue(0)
        }

        x = n
        y = Divide(Add(x, 1), 2)
        
        WhileLoop LessThan(y, x) {
            x = y
            y = Divide(Add(y, Divide(n, y)), 2)
        }
        
        ReturnValue(x)
    }
}

// === UTILITY FUNCTIONS ===

Function.Math.Distance2D {
    Input: (x1: Integer, y1: Integer, x2: Integer, y2: Integer)
    Output: Integer
    Body: {
        dx = Subtract(x2, x1)
        dy = Subtract(y2, y1)
        
        // Fixed-point squares
        dx_sq = FixedPoint.Multiply(dx, dx)
        dy_sq = FixedPoint.Multiply(dy, dy)
        
        sum = Add(dx_sq, dy_sq)
        
        // Convert to integer for ISqrt, then back to fixed-point
        sum_int = FixedPoint.ToInt(sum)
        sqrt_int = Math.ISqrt(sum_int)
        
        ReturnValue(FixedPoint.FromInt(sqrt_int))
    }
}


//===============================================================================================
//Cobol intrinsic and other support 
//===============================================================================================


Function.Math.Abs {
    Input: x: Integer
    Output: Integer
    Body: {
        IfCondition LessThan(x, 0) ThenBlock: {
            ReturnValue(Subtract(0, x))
        }
        ReturnValue(x)
    }
}

Function.Math.Max {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        IfCondition GreaterThan(a, b) ThenBlock: {
            ReturnValue(a)
        }
        ReturnValue(b)
    }
}

Function.Math.Min {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        IfCondition LessThan(a, b) ThenBlock: {
            ReturnValue(a)
        }
        ReturnValue(b)
    }
}

Function.Math.Mod {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        quotient = Divide(a, b)
        product = Multiply(quotient, b)
        ReturnValue(Subtract(a, product))
    }
}

Function.Math.Rem {
    Input: (a: Integer, b: Integer)
    Output: Integer
    Body: {
        // Remainder (same as MOD for positive numbers)
        quotient = Divide(a, b)
        product = Multiply(quotient, b)
        ReturnValue(Subtract(a, product))
    }
}

Function.Math.Log10 {
    Input: x: Integer
    Output: Integer
    Body: {
        // log10(x) = log(x) / log(10)
        log_x = Math.Log(x)
        log_10 = 23026  // ln(10) in fixed-point (≈ 2.3026 * 10000)
        ReturnValue(FixedPoint.Divide(log_x, log_10))
    }
}

Function.Math.Factorial {
    Input: n: Integer
    Output: Integer
    Body: {
        IfCondition LessEqual(n, 1) ThenBlock: {
            ReturnValue(1)
        }
        
        result = 1
        i = 2
        WhileLoop LessEqual(i, n) {
            result = Multiply(result, i)
            i = Add(i, 1)
        }
        ReturnValue(result)
    }
}

// === INVERSE TRIGONOMETRIC FUNCTIONS ===

Function.Trig.Asin {
    Input: fixed_value: Integer
    Output: Integer
    Body: {
        // asin(x) approximation using lookup
        // Input is in fixed-point format (scaled by 10000)
        abs_val = Math.Abs(fixed_value)
        is_negative = LessThan(fixed_value, 0)
        
        // Lookup table approach based on sin values
        result = 0
        IfCondition LessEqual(abs_val, 175) ThenBlock: {
            result = 1
        } ElseBlock: {
            IfCondition LessEqual(abs_val, 1736) ThenBlock: {
                result = 10
            } ElseBlock: {
                IfCondition LessEqual(abs_val, 3420) ThenBlock: {
                    result = 20
                } ElseBlock: {
                    IfCondition LessEqual(abs_val, 5000) ThenBlock: {
                        result = 30
                    } ElseBlock: {
                        IfCondition LessEqual(abs_val, 7071) ThenBlock: {
                            result = 45
                        } ElseBlock: {
                            IfCondition LessEqual(abs_val, 8660) ThenBlock: {
                                result = 60
                            } ElseBlock: {
                                IfCondition LessEqual(abs_val, 9397) ThenBlock: {
                                    result = 70
                                } ElseBlock: {
                                    IfCondition LessEqual(abs_val, 9848) ThenBlock: {
                                        result = 80
                                    } ElseBlock: {
                                        result = 90
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        IfCondition is_negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

Function.Trig.Acos {
    Input: fixed_value: Integer
    Output: Integer
    Body: {
        // acos(x) = 90 - asin(x)
        asin_val = Trig.Asin(fixed_value)
        ReturnValue(Subtract(90, asin_val))
    }
}

// === STATISTICAL FUNCTIONS (Using XArrays for actual array operations) ===

Function.Math.Sum {
    Input: arr: Address
    Output: Integer
    Body: {
        // Sum all elements in XArray
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = XArray.XSize(arr)
        sum = 0
        i = 0
        
        WhileLoop LessThan(i, size) {
            value = XArray.XGet(arr, i)
            sum = Add(sum, value)
            i = Add(i, 1)
        }
        
        ReturnValue(sum)
    }
}

Function.Math.Mean {
    Input: arr: Address
    Output: Integer
    Body: {
        // Calculate mean (average) of array elements
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = XArray.XSize(arr)
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        sum = Math.Sum(arr)
        ReturnValue(Divide(sum, size))
    }
}

Function.Math.Median {
    Input: arr: Address
    Output: Integer
    Body: {
        // Calculate median (requires sorting)
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = XArray.XSize(arr)
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Create a copy and sort it
        sorted = XArray.XCreate(size)
        i = 0
        WhileLoop LessThan(i, size) {
            value = XArray.XGet(arr, i)
            XArray.XPush(sorted, value)
            i = Add(i, 1)
        }
        
        // Sort the copy using XUtil.XQuickSort
        XUtil.XQuickSort(sorted, 0, Subtract(size, 1))
        
        // Get median value
        mid = Divide(size, 2)
        is_even = EqualTo(Modulo(size, 2), 0)
        
        median = 0
        IfCondition is_even ThenBlock: {
            val1 = XArray.XGet(sorted, Subtract(mid, 1))
            val2 = XArray.XGet(sorted, mid)
            median = Divide(Add(val1, val2), 2)
        } ElseBlock: {
            median = XArray.XGet(sorted, mid)
        }
        
        // Clean up
        XArray.XDestroy(sorted)
        
        ReturnValue(median)
    }
}

Function.Math.Midrange {
    Input: arr: Address
    Output: Integer
    Body: {
        // Midrange = (max + min) / 2
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        max_val = XUtil.XFindMax(arr)
        min_val = XUtil.XFindMin(arr)
        
        ReturnValue(Divide(Add(max_val, min_val), 2))
    }
}

Function.Math.Range {
    Input: arr: Address
    Output: Integer
    Body: {
        // Range = max - min
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        max_val = XUtil.XFindMax(arr)
        min_val = XUtil.XFindMin(arr)
        
        ReturnValue(Subtract(max_val, min_val))
    }
}

Function.Math.Variance {
    Input: arr: Address
    Output: Integer
    Body: {
        // Calculate variance: Σ(x - mean)² / n
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = XArray.XSize(arr)
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        mean = Math.Mean(arr)
        sum_squares = 0
        i = 0
        
        WhileLoop LessThan(i, size) {
            value = XArray.XGet(arr, i)
            diff = Subtract(value, mean)
            square = Multiply(diff, diff)
            sum_squares = Add(sum_squares, square)
            i = Add(i, 1)
        }
        
        ReturnValue(Divide(sum_squares, size))
    }
}

Function.Math.StdDev {
    Input: arr: Address
    Output: Integer
    Body: {
        // Standard deviation = sqrt(variance)
        variance = Math.Variance(arr)
        ReturnValue(Math.ISqrt(variance))
    }
}

Function.Math.Ord {
    Input: (arr: Address, value: Integer)
    Output: Integer
    Body: {
        // Find ordinal position (1-based) of value in array
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = XArray.XSize(arr)
        i = 0
        
        WhileLoop LessThan(i, size) {
            current = XArray.XGet(arr, i)
            IfCondition EqualTo(current, value) ThenBlock: {
                ReturnValue(Add(i, 1))  // 1-based index
            }
            i = Add(i, 1)
        }
        
        ReturnValue(0)  // Not found
    }
}

Function.Math.OrdMin {
    Input: arr: Address
    Output: Integer
    Body: {
        // Position of minimum value (1-based)
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = XArray.XSize(arr)
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        min_val = XArray.XGet(arr, 0)
        min_pos = 0
        i = 1
        
        WhileLoop LessThan(i, size) {
            current = XArray.XGet(arr, i)
            IfCondition LessThan(current, min_val) ThenBlock: {
                min_val = current
                min_pos = i
            }
            i = Add(i, 1)
        }
        
        ReturnValue(Add(min_pos, 1))  // 1-based index
    }
}

Function.Math.OrdMax {
    Input: arr: Address
    Output: Integer
    Body: {
        // Position of maximum value (1-based)
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = XArray.XSize(arr)
        IfCondition EqualTo(size, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        max_val = XArray.XGet(arr, 0)
        max_pos = 0
        i = 1
        
        WhileLoop LessThan(i, size) {
            current = XArray.XGet(arr, i)
            IfCondition GreaterThan(current, max_val) ThenBlock: {
                max_val = current
                max_pos = i
            }
            i = Add(i, 1)
        }
        
        ReturnValue(Add(max_pos, 1))  // 1-based index
    }
}

Function.Math.Random {
    Input: seed: Integer
    Output: Integer
    Body: {
        // Simple linear congruential generator (LCG)
        // X(n+1) = (a * X(n) + c) mod m
        // Using common LCG parameters
        a = 1103515245
        c = 12345
        m = 2147483648  // 2^31
        
        next_val = Add(Multiply(seed, a), c)
        result = Math.Mod(next_val, m)
        
        ReturnValue(result)
    }
}

// === DATE/TIME FUNCTIONS (Using syscalls!) ===

Function.Time.CurrentDate {
    Output: Integer
    Body: {
        // Use syscall 96: gettimeofday(struct timeval *tv, struct timezone *tz)
        // struct timeval { tv_sec: 8 bytes, tv_usec: 8 bytes } = 16 bytes
        
        timeval_buf = Allocate(16)
        
        // gettimeofday syscall (96): returns seconds since epoch
        result = SystemCall(96, timeval_buf, 0)
        
        // Read tv_sec (seconds since Jan 1, 1970)
        seconds = Dereference(timeval_buf)
        
        // Convert Unix timestamp to YYYYMMDD
        // This is simplified - proper conversion needs date arithmetic
        // For now, calculate approximate date (will be off but won't crash)
        days_since_epoch = Divide(seconds, 86400)  // 86400 = seconds per day
        
        // Approximate: Unix epoch (1970) + days
        // This is a placeholder - real implementation would need full date math
        years_approx = Add(1970, Divide(days_since_epoch, 365))
        
        // Format as YYYYMMDD (simplified)
        date_yyyymmdd = Multiply(years_approx, 10000)
        date_yyyymmdd = Add(date_yyyymmdd, 1021)  // Add MMDD = Oct 21
        
        Deallocate(timeval_buf, 16)
        
        ReturnValue(date_yyyymmdd)
    }
}

Function.Time.CompileTime {
    Output: Integer
    Body: {
        // Return a fixed compile timestamp
        // In a real compiler, this would be set at compile time
        ReturnValue(20251021)  // October 21, 2025
    }
}

Function.Time.GetUnixTimestamp {
    Output: Integer
    Body: {
        // Helper: Get current Unix timestamp using syscall
        timeval_buf = Allocate(16)
        result = SystemCall(96, timeval_buf, 0)  // gettimeofday
        seconds = Dereference(timeval_buf)
        Deallocate(timeval_buf, 16)
        ReturnValue(seconds)
    }
}

Function.Time.DateToInt {
    Input: date: Integer
    Output: Integer
    Body: {
        // Convert YYYYMMDD to days since epoch (Jan 1, 1601)
        // Extract year, month, day
        year = Divide(date, 10000)
        remainder = Modulo(date, 10000)
        month = Divide(remainder, 100)
        day = Modulo(remainder, 100)
        
        // Simplified calculation (proper implementation needs leap years, etc.)
        days = Multiply(Subtract(year, 1601), 365)
        days = Add(days, Multiply(month, 30))  // Rough approximation
        days = Add(days, day)
        
        ReturnValue(days)
    }
}

Function.Time.DayToInt {
    Input: day: Integer
    Output: Integer
    Body: {
        // Convert YYYYDDD (Julian date) to days since epoch
        year = Divide(day, 1000)
        day_of_year = Modulo(day, 1000)
        
        days = Multiply(Subtract(year, 1601), 365)
        days = Add(days, day_of_year)
        
        ReturnValue(days)
    }
}

Function.Time.IntToDate {
    Input: days: Integer
    Output: Integer
    Body: {
        // Convert days since epoch to YYYYMMDD
        // Simplified - add days to base year 1601
        years = Divide(days, 365)
        year = Add(1601, years)
        
        remaining_days = Modulo(days, 365)
        month = Add(Divide(remaining_days, 30), 1)  // Rough approximation
        day = Add(Modulo(remaining_days, 30), 1)
        
        result = Multiply(year, 10000)
        result = Add(result, Multiply(month, 100))
        result = Add(result, day)
        
        ReturnValue(result)
    }
}

Function.Time.IntToDay {
    Input: days: Integer
    Output: Integer
    Body: {
        // Convert days since epoch to YYYYDDD (Julian date)
        years = Divide(days, 365)
        year = Add(1601, years)
        day_of_year = Add(Modulo(days, 365), 1)
        
        result = Multiply(year, 1000)
        result = Add(result, day_of_year)
        
        ReturnValue(result)
    }
}



// Library loaded
PrintMessage("Library loaded successfully!")
PrintMessage("Fixed-point scale: 10000 (4 decimal places)")