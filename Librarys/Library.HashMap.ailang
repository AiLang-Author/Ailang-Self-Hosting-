// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.HashMap.ailang
// Enhanced hash table with modern syntax and cache optimization
// Extends existing HashMap functionality

LibraryImport.XArrays

// --- START: Added Helper Functions ---
// These functions are added to make the library self-contained.

// Helper function to convert string to integer
Function.HashMap.StringToInt {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        i = 0
        len = StringLength(str)
        negative = 0
        
        IfCondition GreaterThan(len, 0) ThenBlock: {
            first = GetByte(str, 0)
            IfCondition EqualTo(first, 45) ThenBlock: {  // '-'
                negative = 1
                i = 1
            }
        }
        
        WhileLoop LessThan(i, len) {
            byte = GetByte(str, i)
            IfCondition And(GreaterEqual(byte, 48), LessEqual(byte, 57)) ThenBlock: {
                digit = Subtract(byte, 48)
                result = Multiply(result, 10)
                result = Add(result, digit)
            }
            i = Add(i, 1)
        }
        
        IfCondition negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

// Helper to convert integer to string
Function.HashMap.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        buffer = Allocate(32)
        pos = 0
        value = num
        
        IfCondition LessThan(value, 0) ThenBlock: {
            SetByte(buffer, pos, 45)  // '-'
            pos = Add(pos, 1)
            value = Subtract(0, value)
        }
        
        IfCondition EqualTo(value, 0) ThenBlock: {
            SetByte(buffer, pos, 48)  // '0'
            pos = Add(pos, 1)
            SetByte(buffer, pos, 0)   // null terminate
            ReturnValue(buffer)
        }
        
        start_pos = pos
        WhileLoop GreaterThan(value, 0) {
            digit = Modulo(value, 10)
            SetByte(buffer, pos, Add(48, digit))
            pos = Add(pos, 1)
            value = Divide(value, 10)
        }
        
        end_pos = Subtract(pos, 1)
        WhileLoop LessThan(start_pos, end_pos) {
            temp = GetByte(buffer, start_pos)
            SetByte(buffer, start_pos, GetByte(buffer, end_pos))
            SetByte(buffer, end_pos, temp)
            start_pos = Add(start_pos, 1)
            end_pos = Subtract(end_pos, 1)
        }
        
        SetByte(buffer, pos, 0)
        ReturnValue(buffer)
    }
}

Function.HashMap.HDestroy {
    Input: map: Address
    Body: {
        IfCondition NotEqual(map, 0) ThenBlock: {
            Deallocate(map, 0)
        }
    }
}

// ============================================================================
// Original Nested Hash Table (for hash-of-hashes)
// ============================================================================

// Create a new HashMap (hash of hashes)
Function.HashMap.Create {
    Output: Address
    Body: {
        // Main hash table that stores other hash tables as values
        hashmap = XSHash.XCreate(256)
        ReturnValue(hashmap)
    }
}

// Set a field in a hash
// Returns: 1 if new field was created, 0 if existing field was updated
Function.HashMap.HSet {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Input: value: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        // Create inner hash if it doesn't exist
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            inner_hash = XSHash.XCreate(16)
            XSHash.XInsert(hashmap, key, inner_hash)
        }
        
        // Check if field exists before inserting
        existing_value = XSHash.XLookup(inner_hash, field)
        
        // If field exists, we need to free the old value first
        IfCondition NotEqual(existing_value, XArrays.XNULL) ThenBlock: {
            Deallocate(existing_value, 0)
        }
        
        // XSHash.XInsert now returns 1 for new, 0 for update
        is_new_field = XSHash.XInsert(inner_hash, field, value)
        
        ReturnValue(is_new_field)
    }
}

// Get a field from a hash
// Returns: Address of value or 0 if not found
Function.HashMap.HGet {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Output: Address
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get the field value from inner hash
        value = XSHash.XLookup(inner_hash, field)
        
        IfCondition EqualTo(value, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        ReturnValue(value)
    }
}

// Get all fields and values from a hash
// Returns: XArray with alternating field/value pairs
Function.HashMap.HGetAll {
    Input: hashmap: Address
    Input: key: Address
    Output: Address
    Body: {
        result = XArray.XCreate(16)
        
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(result)  // Return empty array
        }
        
        // Get all keys from inner hash
        fields = XSHash.XKeys(inner_hash)
        num_fields = XArray.XSize(fields)
        
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            value = XSHash.XLookup(inner_hash, field)
            
            // Add field and value to result
            XArray.XPush(result, field)
            XArray.XPush(result, value)
            
            i = Add(i, 1)
        }
        
        // Note: fields array contains copies from XKeys, caller must clean up
        XArray.XDestroy(fields)
        
        ReturnValue(result)
    }
}

// Delete a field from a hash
// Returns: 1 if field was deleted, 0 if not found
Function.HashMap.HDel {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Delete the field from inner hash
        old_value = XSHash.XDelete(inner_hash, field)
        
        IfCondition EqualTo(old_value, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Free the old value
        Deallocate(old_value, 0)
        
        // Check if inner hash is now empty
        keys = XSHash.XKeys(inner_hash)
        num_keys = XArray.XSize(keys)
        
        // Clean up keys array (contains copies)
        i = 0
        WhileLoop LessThan(i, num_keys) {
            key_copy = XArray.XGet(keys, i)
            Deallocate(key_copy, 0)
            i = Add(i, 1)
        }
        XArray.XDestroy(keys)
        
        // If inner hash is empty, remove it from main hashmap
        IfCondition EqualTo(num_keys, 0) ThenBlock: {
            XSHash.XDelete(hashmap, key)
            XSHash.XDestroy(inner_hash)
        }
        
        ReturnValue(1)
    }
}

// Check if a field exists in a hash
// Returns: 1 if exists, 0 if not
Function.HashMap.HExists {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if field exists in inner hash
        value = XSHash.XLookup(inner_hash, field)
        
        IfCondition EqualTo(value, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        ReturnValue(1)
    }
}

// Get all field names from a hash
// Returns: XArray of field names
Function.HashMap.HKeys {
    Input: hashmap: Address
    Input: key: Address
    Output: Address
    Body: {
        result = XArray.XCreate(16)
        
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(result)  // Return empty array
        }
        
        // Get all keys from inner hash
        fields = XSHash.XKeys(inner_hash)
        
        // Fields already contains copies, just return it
        ReturnValue(fields)
    }
}

// Get all values from a hash
// Returns: XArray of values
Function.HashMap.HVals {
    Input: hashmap: Address
    Input: key: Address
    Output: Address
    Body: {
        result = XArray.XCreate(16)
        
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(result)  // Return empty array
        }
        
        // Get all keys from inner hash
        fields = XSHash.XKeys(inner_hash)
        num_fields = XArray.XSize(fields)
        
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            value = XSHash.XLookup(inner_hash, field)
            
            // Add copy of value to result
            XArray.XPush(result, value)
            
            // Clean up field copy
            Deallocate(field, 0)
            
            i = Add(i, 1)
        }
        
        XArray.XDestroy(fields)
        ReturnValue(result)
    }
}

// Get the number of fields in a hash
// Returns: Number of fields
Function.HashMap.HLen {
    Input: hashmap: Address
    Input: key: Address
    Output: Integer
    Body: {
        // Get the inner hash for this key
        inner_hash = XSHash.XLookup(hashmap, key)
        
        IfCondition EqualTo(inner_hash, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        // Count the fields
        fields = XSHash.XKeys(inner_hash)
        num_fields = XArray.XSize(fields)
        
        // Clean up fields array
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            Deallocate(field, 0)
            i = Add(i, 1)
        }
        XArray.XDestroy(fields)
        
        ReturnValue(num_fields)
    }
}

// Set multiple fields at once
// fields_values is an XArray with alternating field/value pairs
// Returns: Number of new fields created
Function.HashMap.HMSet {
    Input: hashmap: Address
    Input: key: Address
    Input: fields_values: Address
    Output: Integer
    Body: {
        new_fields = 0
        array_size = XArray.XSize(fields_values)
        
        // Process pairs
        i = 0
        WhileLoop LessThan(i, array_size) {
            field = XArray.XGet(fields_values, i)
            value = XArray.XGet(fields_values, Add(i, 1))
            
            is_new = HashMap.HSet(hashmap, key, field, value)
            new_fields = Add(new_fields, is_new)
            
            i = Add(i, 2)
        }
        
        ReturnValue(new_fields)
    }
}

// Get multiple fields at once
// fields is an XArray of field names
// Returns: XArray of values (0 for non-existent fields)
Function.HashMap.HMGet {
    Input: hashmap: Address
    Input: key: Address
    Input: fields: Address
    Output: Address
    Body: {
        num_fields = XArray.XSize(fields)
        result = XArray.XCreate(num_fields)
        
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field = XArray.XGet(fields, i)
            value = HashMap.HGet(hashmap, key, field)
            
            // Add value or 0 for non-existent
            XArray.XPush(result, value)
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Increment a numeric field by a given amount
// Returns: New value after increment
Function.HashMap.HIncrBy {
    Input: hashmap: Address
    Input: key: Address
    Input: field: Address
    Input: increment: Integer
    Output: Integer
    Body: {
        // Get current value
        current_str = HashMap.HGet(hashmap, key, field)
        current_val = 0
        
        IfCondition NotEqual(current_str, 0) ThenBlock: {
            current_val = HashMap.StringToInt(current_str)
        }
        
        // Increment
        new_val = Add(current_val, increment)
        
        // Store new value
        new_str = NumberToString(new_val)
        HashMap.HSet(hashmap, key, field, new_str)
        Deallocate(new_str, 0)
        
        ReturnValue(new_val)
    }
}

// Destroy a HashMap and all its contents
Function.HashMap.Destroy {
    Input: hashmap: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(hashmap, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get all main keys
        main_keys = XSHash.XKeys(hashmap)
        num_keys = XArray.XSize(main_keys)
        
        i = 0
        WhileLoop LessThan(i, num_keys) {
            key = XArray.XGet(main_keys, i)
            inner_hash = XSHash.XLookup(hashmap, key)
            
            IfCondition NotEqual(inner_hash, XArrays.XNULL) ThenBlock: {
                // Get all fields in this inner hash
                fields = XSHash.XKeys(inner_hash)
                num_fields = XArray.XSize(fields)
                
                j = 0
                WhileLoop LessThan(j, num_fields) {
                    field = XArray.XGet(fields, j)
                    value = XSHash.XLookup(inner_hash, field)
                    
                    // Free the value
                    IfCondition NotEqual(value, XArrays.XNULL) ThenBlock: {
                        Deallocate(value, 0)
                    }
                    
                    // Free the field copy
                    Deallocate(field, 0)
                    
                    j = Add(j, 1)
                }
                
                XArray.XDestroy(fields)
                XSHash.XDestroy(inner_hash)
            }
            
            // Free the key copy
            Deallocate(key, 0)
            
            i = Add(i, 1)
        }
        
        XArray.XDestroy(main_keys)
        XSHash.XDestroy(hashmap)
        
        ReturnValue(1)
    }
}

// ============================================================================
// Enhanced Hash Table with Open Addressing
// ============================================================================

// Create hash table with linear probing
Function.HashMap.CreateOpen {
    Input: capacity: Integer
    Output: Address
    Body: {
        // Structure: [capacity, size, keys, values, deleted_flags]
        table = Allocate(40)
        StoreValue(table, capacity)
        StoreValue(Add(table, 8), 0)
        
        // Allocate arrays for keys, values, and deleted flags
        keys = ArrayCreate(capacity)
        values = ArrayCreate(capacity)
        deleted = ArrayCreate(capacity)
        
        // Initialize all slots as empty
        i = 0
        WhileLoop LessThan(i, capacity) {
            ArraySet(keys, i, 0)
            ArraySet(values, i, 0)
            ArraySet(deleted, i, 0)
            i = Add(i, 1)
        }
        
        StoreValue(Add(table, 16), keys)
        StoreValue(Add(table, 24), values)
        StoreValue(Add(table, 32), deleted)
        
        ReturnValue(table)
    }
}

Function.HashMap.ResizeOpen {
    Input: table: Address
    Body: {
        old_capacity = Dereference(table)
        new_capacity = Multiply(old_capacity, 2)
        
        old_keys = Dereference(Add(table, 16))
        old_values = Dereference(Add(table, 24))
        old_deleted = Dereference(Add(table, 32))
        
        // Create new larger arrays
        new_keys = ArrayCreate(new_capacity)
        new_values = ArrayCreate(new_capacity)
        new_deleted = ArrayCreate(new_capacity)
        
        // Initialize new arrays
        i = 0
        WhileLoop LessThan(i, new_capacity) {
            ArraySet(new_keys, i, 0)
            ArraySet(new_values, i, 0)
            ArraySet(new_deleted, i, 0)
            i = Add(i, 1)
        }
        
        // Rehash all existing entries
        i = 0
        WhileLoop LessThan(i, old_capacity) {
            key = ArrayGet(old_keys, i)
            is_deleted = ArrayGet(old_deleted, i)
            
            // Only rehash valid entries
            IfCondition And(NotEqual(key, 0), EqualTo(is_deleted, 0)) ThenBlock: {
                value = ArrayGet(old_values, i)
                
                // Find new position
                hash = HashMap.HashString(key)
                pos = Modulo(hash, new_capacity)
                
                // Linear probe to find empty slot
                WhileLoop True {
                    existing = ArrayGet(new_keys, pos)
                    IfCondition EqualTo(existing, 0) ThenBlock: {
                        ArraySet(new_keys, pos, key)
                        ArraySet(new_values, pos, value)
                        BreakLoop
                    }
                    pos = Modulo(Add(pos, 1), new_capacity)
                }
            } ElseBlock: {
                // Free deleted entries
                IfCondition NotEqual(key, 0) ThenBlock: {
                    Deallocate(key, 0)
                    value = ArrayGet(old_values, i)
                    IfCondition NotEqual(value, 0) ThenBlock: {
                        Deallocate(value, 0)
                    }
                }
            }
            
            i = Add(i, 1)
        }
        
        // Free old arrays
        ArrayDestroy(old_keys)
        ArrayDestroy(old_values)
        ArrayDestroy(old_deleted)
        
        // Update table with new arrays and capacity
        StoreValue(table, new_capacity)
        StoreValue(Add(table, 16), new_keys)
        StoreValue(Add(table, 24), new_values)
        StoreValue(Add(table, 32), new_deleted)
    }
}


// Robin Hood hashing for better cache performance
Function.HashMap.InsertRobinHood {
    Input: table: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        capacity = Dereference(table)
        size = Dereference(Add(table, 8))
        
        // Check load factor
        IfCondition GreaterThan(size, Multiply(capacity, 0.75)) ThenBlock: {
            HashMap.ResizeOpen(table)
            capacity = Dereference(table)
        }
        
        hash = HashMap.HashString(key)
        ideal_pos = Modulo(hash, capacity)
        
        keys_array = Dereference(Add(table, 16))
        values_array = Dereference(Add(table, 24))
        deleted_array = Dereference(Add(table, 32))
        
        current_key = key
        current_value = value
        current_distance = 0
        pos = ideal_pos
        
        WhileLoop True {
            existing_key = ArrayGet(keys_array, pos)
            is_deleted = ArrayGet(deleted_array, pos)
            
            // Empty or deleted slot - insert here
            IfCondition Or(EqualTo(existing_key, 0), EqualTo(is_deleted, 1)) ThenBlock: {
                ArraySet(keys_array, pos, current_key)
                ArraySet(values_array, pos, current_value)
                ArraySet(deleted_array, pos, 0)
                
                new_size = Add(size, 1)
                StoreValue(Add(table, 8), new_size)
                ReturnValue(1)
            }
            
            // Check if same key - update
            IfCondition EqualTo(StringCompare(existing_key, current_key), 0) ThenBlock: {
                Deallocate(ArrayGet(values_array, pos), 0)
                ArraySet(values_array, pos, current_value)
                Deallocate(current_key, 0)
                ReturnValue(0)
            }
            
            // Calculate existing item's distance from ideal position
            existing_hash = HashMap.HashString(existing_key)
            existing_ideal = Modulo(existing_hash, capacity)
           existing_distance = Modulo(Add(Add(pos, capacity), Subtract(0, existing_ideal)), capacity)
            
            // Robin Hood: swap if current has traveled further
            IfCondition GreaterThan(current_distance, existing_distance) ThenBlock: {
                // Swap with existing
                temp_key = existing_key
                temp_value = ArrayGet(values_array, pos)
                
                ArraySet(keys_array, pos, current_key)
                ArraySet(values_array, pos, current_value)
                
                current_key = temp_key
                current_value = temp_value
                current_distance = existing_distance
            }
            
            // Move to next position
            pos = Modulo(Add(pos, 1), capacity)
            current_distance = Add(current_distance, 1)
            
            // Safety check
            IfCondition GreaterThan(current_distance, capacity) ThenBlock: {
                BreakLoop
            }
        }
        
        ReturnValue(0)
    }
}

// Cache-friendly batch operations
Function.HashMap.BatchInsert {
    Input: table: Address
    Input: keys: Address
    Input: values: Address
    Output: Integer
    Body: {
        num_items = XArray.XSize(keys)
        inserted = 0
        
        i = 0
        WhileLoop LessThan(i, num_items) {
            key = XArray.XGet(keys, i)
            value = XArray.XGet(values, i)
            
            result = HashMap.InsertRobinHood(table, key, value)
            inserted = Add(inserted, result)
            
            i = Add(i, 1)
        }
        
        ReturnValue(inserted)
    }
}

// ============================================================================
// Concurrent Hash Table with Striped Locking
// ============================================================================

Function.HashMap.CreateConcurrent {
    Input: num_stripes: Integer
    Output: Address
    Body: {
        // Structure: [num_stripes, tables_array, locks_array]
        concurrent_map = Allocate(24)
        StoreValue(concurrent_map, num_stripes)
        
        // Create array of hash tables
        tables = ArrayCreate(num_stripes)
        locks = ArrayCreate(num_stripes)
        
        i = 0
        WhileLoop LessThan(i, num_stripes) {
            table = HashMap.Create()
            lock = Allocate(8)  // Simple mutex
            
            ArraySet(tables, i, table)
            ArraySet(locks, i, lock)
            
            i = Add(i, 1)
        }
        
        StoreValue(Add(concurrent_map, 8), tables)
        StoreValue(Add(concurrent_map, 16), locks)
        
        ReturnValue(concurrent_map)
    }
}

Function.HashMap.ConcurrentPut {
    Input: concurrent_map: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        num_stripes = Dereference(concurrent_map)
        tables = Dereference(Add(concurrent_map, 8))
        locks = Dereference(Add(concurrent_map, 16))
        
        // Determine stripe based on key hash
        hash = HashMap.HashString(key)
        stripe_idx = Modulo(hash, num_stripes)
        
        // Acquire lock for this stripe
        lock = ArrayGet(locks, stripe_idx)
        HashMap.AcquireLock(lock)
        
        // Insert into the appropriate table
        table = ArrayGet(tables, stripe_idx)
        result = HashMap.HSet(table, key, "field", value)
        
        // Release lock
        HashMap.ReleaseLock(lock)
        
        ReturnValue(result)
    }
}

// ============================================================================
// LRU Cache Integration
// ============================================================================

Function.HashMap.CreateLRU {
    Input: capacity: Integer
    Output: Address
    Body: {
        // Structure: [capacity, size, map, head, tail]
        lru = Allocate(40)
        StoreValue(lru, capacity)
        StoreValue(Add(lru, 8), 0)
        
        // Create backing hash map
        map = HashMap.Create()
        StoreValue(Add(lru, 16), map)
        
        // Create sentinel nodes for doubly-linked list
        head = Allocate(24)  // [key, value, prev, next]
        tail = Allocate(24)
        
        StoreValue(Add(head, 16), tail)  // head.next = tail
        StoreValue(Add(tail, 8), head)   // tail.prev = head
        
        StoreValue(Add(lru, 24), head)
        StoreValue(Add(lru, 32), tail)
        
        ReturnValue(lru)
    }
}

Function.HashMap.DestroyLRU {
    Input: lru: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(lru, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Debug("lru_destroy", level=1) {
            PrintMessage("Destroying LRU cache at ")
            PrintNumber(lru)
            PrintMessage("\n")
        }
        
        // Get components
        map = Dereference(Add(lru, 16))
        head = Dereference(Add(lru, 24))
        tail = Dereference(Add(lru, 32))
        
        // Free all nodes in the linked list
        current = Dereference(Add(head, 24))  // First real node (skip sentinel)
        
        WhileLoop NotEqual(current, tail) {
            next = Dereference(Add(current, 24))
            
            // Free key
            key = Dereference(current)
            IfCondition NotEqual(key, 0) ThenBlock: {
                key_len = StringLength(key)
                Deallocate(key, Add(key_len, 1))
            }
            
            // Free value
            value = Dereference(Add(current, 8))
            IfCondition NotEqual(value, 0) ThenBlock: {
                value_len = StringLength(value)
                Deallocate(value, Add(value_len, 1))
            }
            
            // Free node (32 bytes: key, value, prev, next)
            Deallocate(current, 32)
            
            current = next
        }
        
        // Free sentinel nodes (24 bytes each)
        Deallocate(head, 24)
        Deallocate(tail, 24)
        
        // Destroy backing HashMap
        HashMap.HDestroy(map)
        
        // Free LRU structure (40 bytes)
        Deallocate(lru, 40)
        
        Debug("lru_destroy", level=1) {
            PrintMessage("LRU cache destroyed\n")
        }
        
        ReturnValue(1)
    }
}

Function.HashMap.LRUGet {
    Input: lru: Address
    Input: key: Address
    Output: Address
    Body: {
        map = Dereference(Add(lru, 16))
        node_ptr = HashMap.HGet(map, "nodes", key)
        
        IfCondition EqualTo(node_ptr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Move to front
        HashMap.LRUMoveToFront(lru, node_ptr)
        
        // Return value
        value = Dereference(Add(node_ptr, 8))
        ReturnValue(value)
    }
}

Function.HashMap.LRUPut {
    Input: lru: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        capacity = Dereference(lru)
        size = Dereference(Add(lru, 8))
        map = Dereference(Add(lru, 16))
        
        // Check if key exists
        existing_node = HashMap.HGet(map, "nodes", key)
        
        IfCondition NotEqual(existing_node, 0) ThenBlock: {
            // Update existing node - FREE OLD VALUE PROPERLY
            old_value = Dereference(Add(existing_node, 8))
            
            IfCondition NotEqual(old_value, 0) ThenBlock: {
                old_value_len = StringLength(old_value)
                Deallocate(old_value, Add(old_value_len, 1))
            }
            
            // Store new value
            StoreValue(Add(existing_node, 8), value)
            
            HashMap.LRUMoveToFront(lru, existing_node)
            ReturnValue(0)
        }
        
        // Create new node (32 bytes: key, value, prev, next)
        node = Allocate(32)
        
        StoreValue(node, key)
        StoreValue(Add(node, 8), value)
        
        // Add to front
        head = Dereference(Add(lru, 24))
        old_first = Dereference(Add(head, 24)) // head.next
        
        StoreValue(Add(node, 16), head)      // node.prev = head
        StoreValue(Add(node, 24), old_first) // node.next = old_first
        StoreValue(Add(old_first, 16), node) // old_first.prev = node
        StoreValue(Add(head, 24), node)      // head.next = node
        
        // Store in map
        HashMap.HSet(map, "nodes", key, node)
        
        // Update size
        new_size = Add(size, 1)
        StoreValue(Add(lru, 8), new_size)
        
        // Evict if over capacity
        IfCondition GreaterThan(new_size, capacity) ThenBlock: {
            HashMap.LRUEvictLast(lru)
        }
        
        ReturnValue(1)
    }
}

Function.HashMap.LRUMoveToFront {
    Input: lru: Address
    Input: node: Address
    Body: {
        // Remove from current position
        prev = Dereference(Add(node, 16))
        next = Dereference(Add(node, 24))
        StoreValue(Add(prev, 24), next)
        StoreValue(Add(next, 16), prev)
        
        // Add to front
        head = Dereference(Add(lru, 24))
        old_first = Dereference(Add(head, 24))
        
        StoreValue(Add(node, 16), head)
        StoreValue(Add(node, 24), old_first)
        StoreValue(Add(old_first, 16), node)
        StoreValue(Add(head, 24), node)
    }
}

Function.HashMap.LRUEvictLast {
    Input: lru: Address
    Body: {
        tail = Dereference(Add(lru, 32))
        last = Dereference(Add(tail, 16))
        
        // Skip if it's the head sentinel
        head = Dereference(Add(lru, 24))
        IfCondition EqualTo(last, head) ThenBlock: {
            ReturnValue(0)
        }
        
        // Remove from list
        prev = Dereference(Add(last, 16))
        StoreValue(Add(prev, 24), tail)
        StoreValue(Add(tail, 16), prev)
        
        // Remove from map
        map = Dereference(Add(lru, 16))
        key = Dereference(last)
        HashMap.HDel(map, "nodes", key)
        
        // Free memory
        IfCondition NotEqual(key, 0) ThenBlock: {
            key_len = StringLength(key)
            Deallocate(key, Add(key_len, 1))
        }
        
        value = Dereference(Add(last, 8))
        IfCondition NotEqual(value, 0) ThenBlock: {
            value_len = StringLength(value)
            Deallocate(value, Add(value_len, 1))
        }
        
        // Free node (32 bytes)
        Deallocate(last, 32)
        
        // Update size
        size = Dereference(Add(lru, 8))
        StoreValue(Add(lru, 8), Subtract(size, 1))
        
        ReturnValue(0)
    }
}

Function.HashMap.DestroyConcurrent {
    Input: concurrent_map: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(concurrent_map, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Debug("concurrent_destroy", level=1) {
            PrintMessage("Destroying concurrent HashMap\n")
        }
        
        num_stripes = Dereference(concurrent_map)
        tables = Dereference(Add(concurrent_map, 8))
        locks = Dereference(Add(concurrent_map, 16))
        
        i = 0
        WhileLoop LessThan(i, num_stripes) {
            // Destroy each table
            table = ArrayGet(tables, i)
            HashMap.HDestroy(table)
            
            // Free each lock (8 bytes)
            lock = ArrayGet(locks, i)
            Deallocate(lock, 8)
            
            i = Add(i, 1)
        }
        
        // Destroy arrays
        ArrayDestroy(tables)
        ArrayDestroy(locks)
        
        // Free concurrent_map structure (24 bytes)
        Deallocate(concurrent_map, 24)
        
        Debug("concurrent_destroy", level=1) {
            PrintMessage("Concurrent HashMap destroyed\n")
        }
        
        ReturnValue(1)
    }
}








// ============================================================================
// Helper Functions
// ============================================================================

Function.HashMap.HashString {
    Input: str: Address
    Output: Integer
    Body: {
        hash = 5381
        i = 0
        len = StringLength(str)
        
        WhileLoop LessThan(i, len) {
            byte = GetByte(str, i)
            hash = Add(Multiply(hash, 33), byte)
            i = Add(i, 1)
        }
        
        ReturnValue(hash)
    }
}

Function.HashMap.AcquireLock {
    Input: lock: Address
    Body: {
        // Simple spinlock
        WhileLoop True {
            expected = 0
            IfCondition EqualTo(Dereference(lock), expected) ThenBlock: {
                StoreValue(lock, 1)
                BreakLoop
            }
            // Could add small delay here
        }
    }
}

Function.HashMap.ReleaseLock {
    Input: lock: Address
    Body: {
        StoreValue(lock, 0)
    }
}

// ============================================================================
// HashMap "Simple" API - Add these functions to Library.HashMap.ailang
// ============================================================================
// These provide a direct hash-pointer interface for single hash operations
// Used by redis_server.ailang which manages its own hash instances

// Create a standalone hash table (not managed by multi-hash system)
Function.HashMap.CreateSimple {
    Output: Address
    Body: {
        // Call the low-level HashCreate primitive
        // Default capacity of 16 buckets
        hash_ptr = HashCreate(16)
        ReturnValue(hash_ptr)
    }
}

// Set a field-value pair in a hash (2-arg "Simple" interface)
// Returns 1 if new field, 0 if updated existing
Function.HashMap.HSetSimple {
    Input: hash_ptr: Address
    Input: field: Address
    Input: value: Address
    Output: Integer
    Body: {
        // HashSet returns 1 for new, 0 for update
        result = HashSet(hash_ptr, field, value)
        ReturnValue(result)
    }
}

// Get a field value from a hash (returns string copy or 0 if not found)
Function.HashMap.HGetSimple {
    Input: hash_ptr: Address
    Input: field: Address
    Output: Address
    Body: {
        // HashGet returns the value or 0 if not found
        value = HashGet(hash_ptr, field)
        ReturnValue(value)
    }
}

// Delete a field from a hash (returns 1 if deleted, 0 if not found)
Function.HashMap.HDelSimple {
    Input: hash_ptr: Address
    Input: field: Address
    Output: Integer
    Body: {
        // HashDelete returns 1 if deleted, 0 if not found
        result = HashDelete(hash_ptr, field)
        ReturnValue(result)
    }
}

// Check if a field exists in a hash
Function.HashMap.HExistsSimple {
    Input: hash_ptr: Address
    Input: field: Address
    Output: Integer
    Body: {
        // HashExists returns 1 if exists, 0 otherwise
        result = HashExists(hash_ptr, field)
        ReturnValue(result)
    }
}

// Get the number of fields in a hash
Function.HashMap.HLenSimple {
    Input: hash_ptr: Address
    Output: Integer
    Body: {
        // Hash structure: [capacity:8][size:8][entries...]
        // Size is at offset 8
        size = Dereference(Add(hash_ptr, 8))
        ReturnValue(size)
    }
}

// Increment a numeric field by a value (returns new value)
Function.HashMap.HIncrBySimple {
    Input: hash_ptr: Address
    Input: field: Address
    Input: increment: Integer
    Output: Integer
    Body: {
        // Get current value (as string)
        current_str = HashGet(hash_ptr, field)
        current_val = 0
        
        // If field exists, parse its value
        IfCondition NotEqual(current_str, 0) ThenBlock: {
            current_val = StringToNumber(current_str)
            Deallocate(current_str, 0)
        }
        
        // Calculate new value
        new_val = Add(current_val, increment)
        
        // Convert back to string
        new_str = NumberToString(new_val)
        
        // Store updated value
        HashSet(hash_ptr, field, new_str)
        
        // Clean up the string we created
        Deallocate(new_str, 0)
        
        ReturnValue(new_val)
    }
}

// Get all field names from a hash (returns XArray of string copies)
Function.HashMap.HKeysSimple {
    Input: hash_ptr: Address
    Output: Address
    Body: {
        // Get capacity and size from hash structure
        capacity = Dereference(hash_ptr)
        size = Dereference(Add(hash_ptr, 8))
        
        // Create result array
        result = XArray.XCreate(size)
        
        // Iterate through hash table buckets
        // Entries start at offset 16, each entry is 24 bytes
        // Entry structure: [hash:8][key_addr:8][value:8]
        entry_offset = 16
        result_index = 0
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            // Get entry hash (0 means empty)
            entry_hash = Dereference(Add(hash_ptr, entry_offset))
            
            IfCondition NotEqual(entry_hash, 0) ThenBlock: {
                // Get key address
                key_addr = Dereference(Add(hash_ptr, Add(entry_offset, 8)))
                
                // Make a copy of the key string
                key_copy = key_addr

                // Add to result
                XArray.XPush(result, key_copy)
                result_index = Add(result_index, 1)
            }
            
            entry_offset = Add(entry_offset, 24)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Get all values from a hash (returns XArray of string copies)
Function.HashMap.HValsSimple {
    Input: hash_ptr: Address
    Output: Address
    Body: {
        // Get capacity and size from hash structure
        capacity = Dereference(hash_ptr)
        size = Dereference(Add(hash_ptr, 8))
        
        // Create result array
        result = XArray.XCreate(size)
        
        // Iterate through hash table buckets
        entry_offset = 16
        result_index = 0
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            // Get entry hash (0 means empty)
            entry_hash = Dereference(Add(hash_ptr, entry_offset))
            
            IfCondition NotEqual(entry_hash, 0) ThenBlock: {
                // Get value address (at offset +16 from entry start)
                value_addr = Dereference(Add(hash_ptr, Add(entry_offset, 16)))
                
                // Make a copy of the value string
                value_copy = value_addr

                // Add to result
                XArray.XPush(result, value_copy)
                result_index = Add(result_index, 1)
            }
            
            entry_offset = Add(entry_offset, 24)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Get all field-value pairs from a hash (returns XArray of alternating keys and values)
Function.HashMap.HGetAllSimple {
    Input: hash_ptr: Address
    Output: Address
    Body: {
        // Get capacity and size
        capacity = Dereference(hash_ptr)
        size = Dereference(Add(hash_ptr, 8))
        
        // Create result array (size * 2 for key-value pairs)
        result = XArray.XCreate(Multiply(size, 2))
        
        // Iterate through hash table
        entry_offset = 16
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            entry_hash = Dereference(Add(hash_ptr, entry_offset))
            
            IfCondition NotEqual(entry_hash, 0) ThenBlock: {
                // Get key and value
                key_addr = Dereference(Add(hash_ptr, Add(entry_offset, 8)))
                value_addr = Dereference(Add(hash_ptr, Add(entry_offset, 16)))
                
                // Make copies
                key_copy = key_addr
                value_copy = value_addr

                // Add both to result array
                XArray.XPush(result, key_copy)
                XArray.XPush(result, value_copy)
            }
            
            entry_offset = Add(entry_offset, 24)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Destroy a hash table
Function.HashMap.DestroySimple {
    Input: hash_ptr: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(hash_ptr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Debug("hashmap_destroy", level=1) {
            PrintMessage("Destroying HashMap at ")
            PrintNumber(hash_ptr)
            PrintMessage("\n")
        }
        
        // Get capacity
        capacity = Dereference(hash_ptr)
        
        // Free all keys and values
        entry_offset = 16
        i = 0
        
        WhileLoop LessThan(i, capacity) {
            entry_hash = Dereference(Add(hash_ptr, entry_offset))
            
            IfCondition NotEqual(entry_hash, 0) ThenBlock: {
                // Free key (it's a string)
                key_addr = Dereference(Add(hash_ptr, Add(entry_offset, 8)))
                IfCondition NotEqual(key_addr, 0) ThenBlock: {
                    key_len = StringLength(key_addr)
                    Deallocate(key_addr, Add(key_len, 1))  // +1 for null terminator
                }
                
                // Free value (it's a string)
                value_addr = Dereference(Add(hash_ptr, Add(entry_offset, 16)))
                IfCondition NotEqual(value_addr, 0) ThenBlock: {
                    value_len = StringLength(value_addr)
                    Deallocate(value_addr, Add(value_len, 1))  // +1 for null terminator
                }
            }
            
            entry_offset = Add(entry_offset, 24)
            i = Add(i, 1)
        }
        
        // Calculate total HashMap size: 16 bytes header + (capacity * 24 bytes per entry)
        hash_size = Add(16, Multiply(capacity, 24))
        
        // Free the hash table itself
        Deallocate(hash_ptr, hash_size)
        
        Debug("hashmap_destroy", level=1) {
            PrintMessage("HashMap destroyed, freed ")
            PrintNumber(hash_size)
            PrintMessage(" bytes\n")
        }
        
        ReturnValue(1)
    }
}


// ============================================================================
// USAGE NOTES
// ============================================================================
// Add these functions to your existing Library.HashMap.ailang file
//
// IMPORTANT: Make sure Library.HashMap.ailang has this import at the top:
//   LibraryImport.XArrays
//
// These "Simple" functions provide a direct hash pointer interface (2-3 args)
// The existing HashMap.Create(), HashMap.HSet(), etc. remain unchanged (3-4 args)
//
// Simple API - for managing individual hash instances yourself:
//   hash_ptr = HashMap.CreateSimple()
//   HashMap.HSetSimple(hash_ptr, field, value)
//   value = HashMap.HGetSimple(hash_ptr, field)
//
// Managed API - for managing multiple named hashes:
//   manager = HashMap.Create()
//   HashMap.HSet(manager, "user:1000", field, value)
//   value = HashMap.HGet(manager, "user:1000", field)
// ============================================================================