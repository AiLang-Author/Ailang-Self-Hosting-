// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.JSON.ailang
// Basic JSON parsing and building library for AILANG

LibraryImport.XArrays
LibraryImport.StringUtils


// ============================================================================
// JSON PARSER - Parse JSON string into data structures
// ============================================================================

// Parse JSON from string
// Returns: XSHash for objects, XArray for arrays, Address for strings, Integer for numbers/booleans
Function.ParseJSON {
    Input: json_str: Address
    Output: Address
    Body: {
        buffer = json_str
        size = StringLength(json_str)
        pos = 0
        
        // Parse the value
        result = JSON.ParseValueInternal(buffer, size, pos)
        
        ReturnValue(result)
    }
}

// Internal parse function that tracks position
Function.JSON.ParseValueInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        // Skip leading whitespace
        pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
        
        IfCondition GreaterEqual(pos, size) ThenBlock: {
            ReturnValue(0)
        }
        
        char = Dereference(Add(buffer, pos), "byte")
        
        // Object: { ... }
        IfCondition EqualTo(char, 123) ThenBlock: {
            ReturnValue(JSON.ParseObjectInternal(buffer, size, pos))
        }
        
        // Array: [ ... ]
        IfCondition EqualTo(char, 91) ThenBlock: {
            ReturnValue(JSON.ParseArrayInternal(buffer, size, pos))
        }
        
        // String: "..."
        IfCondition EqualTo(char, 34) ThenBlock: {
            ReturnValue(JSON.ParseStringInternal(buffer, size, pos))
        }
        
        // Number or boolean/null
        ReturnValue(JSON.ParsePrimitiveInternal(buffer, size, pos))
    }
}

// Parse JSON object into XSHash
Function.JSON.ParseObjectInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        obj = XSHash.XCreate(16)
        
        // Skip opening {
        pos = Add(pos, 1)
        pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
        
        // Check for empty object
        char = Dereference(Add(buffer, pos), "byte")
        IfCondition EqualTo(char, 125) ThenBlock: {
            ReturnValue(obj)
        }
        
        // Parse key-value pairs
        continue_parsing = 1
        WhileLoop EqualTo(continue_parsing, 1) {
            pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
            
            // Parse key (must be string)
            result = JSON.ParseStringInternalWithPos(buffer, size, pos)
            key = Dereference(result, "qword")
            new_pos = Dereference(Add(result, 8), "qword")
            Deallocate(result, 16)
            
            IfCondition EqualTo(key, 0) ThenBlock: {
                continue_parsing = 0
                BreakLoop
            }
            
            pos = new_pos
            pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
            
            // Expect colon
            char = Dereference(Add(buffer, pos), "byte")
            IfCondition NotEqual(char, 58) ThenBlock: {
                continue_parsing = 0
                BreakLoop
            }
            pos = Add(pos, 1)
            
            pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
            
            // Parse value
            result = JSON.ParseValueInternalWithPos(buffer, size, pos)
            value = Dereference(result, "qword")
            new_pos = Dereference(Add(result, 8), "qword")
            Deallocate(result, 16)
            
            pos = new_pos
            
            // Add to object using XSHash.XInsert
            XSHash.XInsert(obj, key, value)
            
            pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
            
            // Check for comma or closing brace
            char = Dereference(Add(buffer, pos), "byte")
            IfCondition EqualTo(char, 125) ThenBlock: {
                continue_parsing = 0
            } ElseBlock: {
                IfCondition EqualTo(char, 44) ThenBlock: {
                    pos = Add(pos, 1)
                } ElseBlock: {
                    continue_parsing = 0
                }
            }
        }
        
        ReturnValue(obj)
    }
}

// Parse JSON array into XArray
Function.JSON.ParseArrayInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        arr = XArray.XCreate(16)
        
        // Skip opening 
        pos = Add(pos, 1)
        pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
        
        // Check for empty array
        char = Dereference(Add(buffer, pos), "byte")
        IfCondition EqualTo(char, 93) ThenBlock: {
            ReturnValue(arr)
        }
        
        // Parse values
        continue_parsing = 1
        WhileLoop EqualTo(continue_parsing, 1) {
            pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
            
            // Parse value
            result = JSON.ParseValueInternalWithPos(buffer, size, pos)
            value = Dereference(result, "qword")
            new_pos = Dereference(Add(result, 8), "qword")
            Deallocate(result, 16)
            
            pos = new_pos
            
            XArray.XPush(arr, value)
            
            pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
            
            // Check for comma or closing bracket
            char = Dereference(Add(buffer, pos), "byte")
            IfCondition EqualTo(char, 93) ThenBlock: {
                continue_parsing = 0
            } ElseBlock: {
                IfCondition EqualTo(char, 44) ThenBlock: {
                    pos = Add(pos, 1)
                } ElseBlock: {
                    continue_parsing = 0
                }
            }
        }
        
        ReturnValue(arr)
    }
}

// Helper that returns both value and new position
Function.JSON.ParseValueInternalWithPos {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        // Allocate result: [value_ptr, new_pos]
        result = Allocate(16)
        
        pos = JSON.SkipWhitespaceInternal(buffer, size, pos)
        
        IfCondition GreaterEqual(pos, size) ThenBlock: {
            StoreValue(result, 0)
            StoreValue(Add(result, 8), pos)
            ReturnValue(result)
        }
        
        char = Dereference(Add(buffer, pos), "byte")
        
        // String
        IfCondition EqualTo(char, 34) ThenBlock: {
            parse_result = JSON.ParseStringInternalWithPos(buffer, size, pos)
            ReturnValue(parse_result)
        }
        
        // Object
        IfCondition EqualTo(char, 123) ThenBlock: {
            obj = JSON.ParseObjectInternal(buffer, size, pos)
            // Find new position by skipping the object
            new_pos = JSON.SkipObjectInternal(buffer, size, pos)
            StoreValue(result, obj)
            StoreValue(Add(result, 8), new_pos)
            ReturnValue(result)
        }
        
        // Array
        IfCondition EqualTo(char, 91) ThenBlock: {
            arr = JSON.ParseArrayInternal(buffer, size, pos)
            new_pos = JSON.SkipArrayInternal(buffer, size, pos)
            StoreValue(result, arr)
            StoreValue(Add(result, 8), new_pos)
            ReturnValue(result)
        }
        
        // Primitive
        parse_result = JSON.ParsePrimitiveInternalWithPos(buffer, size, pos)
        ReturnValue(parse_result)
    }
}

// Parse JSON string and return both string and new position
Function.JSON.ParseStringInternalWithPos {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        // Allocate result: [string_ptr, new_pos]
        result = Allocate(16)
        
        // Skip opening quote
        pos = Add(pos, 1)
        start_pos = pos
        
        // Find closing quote
        found = 0
        WhileLoop LessThan(pos, size) {
            char = Dereference(Add(buffer, pos), "byte")
            
            IfCondition EqualTo(char, 34) ThenBlock: {
                found = 1
                BreakLoop
            }
            
            pos = Add(pos, 1)
        }
        
        IfCondition EqualTo(found, 0) ThenBlock: {
            StoreValue(result, 0)
            StoreValue(Add(result, 8), pos)
            ReturnValue(result)
        }
        
        // Calculate length
        length = Subtract(pos, start_pos)
        
        // Allocate and copy string
        str = Allocate(Add(length, 1))
        
        i = 0
        WhileLoop LessThan(i, length) {
            byte = Dereference(Add(buffer, Add(start_pos, i)), "byte")
            StoreValue(Add(str, i), byte)
            i = Add(i, 1)
        }
        StoreValue(Add(str, length), 0)
        
        // Skip closing quote
        pos = Add(pos, 1)
        
        StoreValue(result, str)
        StoreValue(Add(result, 8), pos)
        ReturnValue(result)
    }
}

// Parse string (simplified version for backwards compatibility)
Function.JSON.ParseStringInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        result = JSON.ParseStringInternalWithPos(buffer, size, pos)
        str = Dereference(result, "qword")
        Deallocate(result, 16)
        ReturnValue(str)
    }
}

// Parse primitive and return both value and new position
Function.JSON.ParsePrimitiveInternalWithPos {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        result = Allocate(16)
        start_pos = pos
        
        // Find end of primitive
        WhileLoop LessThan(pos, size) {
            char = Dereference(Add(buffer, pos), "byte")
            
            is_delimiter = 0
            IfCondition EqualTo(char, 32) ThenBlock: { is_delimiter = 1 }
            IfCondition EqualTo(char, 9) ThenBlock: { is_delimiter = 1 }
            IfCondition EqualTo(char, 10) ThenBlock: { is_delimiter = 1 }
            IfCondition EqualTo(char, 13) ThenBlock: { is_delimiter = 1 }
            IfCondition EqualTo(char, 44) ThenBlock: { is_delimiter = 1 }
            IfCondition EqualTo(char, 125) ThenBlock: { is_delimiter = 1 }
            IfCondition EqualTo(char, 93) ThenBlock: { is_delimiter = 1 }
            
            IfCondition EqualTo(is_delimiter, 1) ThenBlock: {
                BreakLoop
            }
            
            pos = Add(pos, 1)
        }
        
        // Extract primitive string
        length = Subtract(pos, start_pos)
        str = Allocate(Add(length, 1))
        
        i = 0
        WhileLoop LessThan(i, length) {
            byte = Dereference(Add(buffer, Add(start_pos, i)), "byte")
            StoreValue(Add(str, i), byte)
            i = Add(i, 1)
        }
        StoreValue(Add(str, length), 0)
        
        StoreValue(result, str)
        StoreValue(Add(result, 8), pos)
        ReturnValue(result)
    }
}

// Parse primitive (simplified)
Function.JSON.ParsePrimitiveInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Address
    Body: {
        result = JSON.ParsePrimitiveInternalWithPos(buffer, size, pos)
        str = Dereference(result, "qword")
        Deallocate(result, 16)
        ReturnValue(str)
    }
}

// Skip whitespace and return new position
Function.JSON.SkipWhitespaceInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Integer
    Body: {
        WhileLoop LessThan(pos, size) {
            char = Dereference(Add(buffer, pos), "byte")
            
            is_whitespace = 0
            IfCondition EqualTo(char, 32) ThenBlock: { is_whitespace = 1 }
            IfCondition EqualTo(char, 9) ThenBlock: { is_whitespace = 1 }
            IfCondition EqualTo(char, 10) ThenBlock: { is_whitespace = 1 }
            IfCondition EqualTo(char, 13) ThenBlock: { is_whitespace = 1 }
            
            IfCondition EqualTo(is_whitespace, 0) ThenBlock: {
                BreakLoop
            }
            
            pos = Add(pos, 1)
        }
        
        ReturnValue(pos)
    }
}

// Skip past an object and return new position
Function.JSON.SkipObjectInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Integer
    Body: {
        depth = 0
        
        WhileLoop LessThan(pos, size) {
            char = Dereference(Add(buffer, pos), "byte")
            
            IfCondition EqualTo(char, 123) ThenBlock: {
                depth = Add(depth, 1)
            }
            IfCondition EqualTo(char, 125) ThenBlock: {
                depth = Subtract(depth, 1)
                IfCondition EqualTo(depth, 0) ThenBlock: {
                    ReturnValue(Add(pos, 1))
                }
            }
            
            pos = Add(pos, 1)
        }
        
        ReturnValue(pos)
    }
}

// Skip past an array and return new position
Function.JSON.SkipArrayInternal {
    Input: buffer: Address
    Input: size: Integer
    Input: pos: Integer
    Output: Integer
    Body: {
        depth = 0
        
        WhileLoop LessThan(pos, size) {
            char = Dereference(Add(buffer, pos), "byte")
            
            IfCondition EqualTo(char, 91) ThenBlock: {
                depth = Add(depth, 1)
            }
            IfCondition EqualTo(char, 93) ThenBlock: {
                depth = Subtract(depth, 1)
                IfCondition EqualTo(depth, 0) ThenBlock: {
                    ReturnValue(Add(pos, 1))
                }
            }
            
            pos = Add(pos, 1)
        }
        
        ReturnValue(pos)
    }
}

// ============================================================================
// JSON BUILDER - Build JSON strings from data structures
// ============================================================================

// Build JSON object from XSHash
Function.JSON.BuildObject {
    Input: obj: Address
    Output: Address
    Body: {
        IfCondition EqualTo(obj, 0) ThenBlock: {
            result = Allocate(3)
            StoreValue(result, 123)
            StoreValue(Add(result, 1), 125)
            StoreValue(Add(result, 2), 0)
            ReturnValue(result)
        }
        
        result = StringConcat("{", "")
        
        keys = XSHash.XKeys(obj)
        count = XArray.XSize(keys)
        
        i = 0
        WhileLoop LessThan(i, count) {
            key = XArray.XGet(keys, i)
            value = XSHash.XLookup(obj, key)
            
            IfCondition GreaterThan(i, 0) ThenBlock: {
                temp = result
                result = StringConcat(result, ",")
                Deallocate(temp, 0)
            }
            
            temp = result
            result = StringConcat(result, "\"")
            Deallocate(temp, 0)
            
            temp = result
            result = StringConcat(result, key)
            Deallocate(temp, 0)
            
            temp = result
            result = StringConcat(result, "\":")
            Deallocate(temp, 0)
            
            temp = result
            result = StringConcat(result, "\"")
            Deallocate(temp, 0)
            
            temp = result
            result = StringConcat(result, value)
            Deallocate(temp, 0)
            
            temp = result
            result = StringConcat(result, "\"")
            Deallocate(temp, 0)
            
            i = Add(i, 1)
        }
        
        temp = result
        result = StringConcat(result, "}")
        Deallocate(temp, 0)
        
        ReturnValue(result)
    }
}

// Build JSON array from XArray
Function.JSON.BuildArray {
    Input: arr: Address
    Output: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            result = Allocate(3)
            StoreValue(result, 91)
            StoreValue(Add(result, 1), 93)
            StoreValue(Add(result, 2), 0)
            ReturnValue(result)
        }
        
        result = StringConcat("[", "")
        
        count = XArray.XSize(arr)
        
        i = 0
        WhileLoop LessThan(i, count) {
            value = XArray.XGet(arr, i)
            
            IfCondition GreaterThan(i, 0) ThenBlock: {
                temp = result
                result = StringConcat(result, ",")
                Deallocate(temp, 0)
            }
            
            temp = result
            result = StringConcat(result, "\"")
            Deallocate(temp, 0)
            
            temp = result
            result = StringConcat(result, value)
            Deallocate(temp, 0)
            
            temp = result
            result = StringConcat(result, "\"")
            Deallocate(temp, 0)
            
            i = Add(i, 1)
        }
        
        temp = result
        result = StringConcat(result, "]")
        Deallocate(temp, 0)
        
        ReturnValue(result)
    }
}

// Helper: Get string value from JSON object
Function.JSON.GetString {
    Input: obj: Address
    Input: key: Address
    Output: Address
    Body: {
        IfCondition EqualTo(obj, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        value = XSHash.XLookup(obj, key)
        IfCondition EqualTo(value, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(value)
    }
}

// Helper: Get number value from JSON object (returns as integer)
Function.JSON.GetNumber {
    Input: obj: Address
    Input: key: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(obj, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        value_str = XSHash.XLookup(obj, key)
        IfCondition EqualTo(value_str, XArrays.XNULL) ThenBlock: {
            ReturnValue(0)
        }
        
        num = StrToNum(value_str)
        ReturnValue(num)
    }
}




// Helper: Extract data field and parse into hashmap
Function.JSON.ParseDataField {
    Input: json_str: Address
    Output: Address  // XSHash of the "data" field contents
    Body: {
        // Parse the outer JSON
        outer_obj = ParseJSON(json_str)
        
        IfCondition EqualTo(outer_obj, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get the "data" field
        data_field = XSHash.XLookup(outer_obj, "data")
        
        IfCondition EqualTo(data_field, XArrays.XNULL) ThenBlock: {
            XSHash.XDestroy(outer_obj)
            ReturnValue(0)
        }
        
        // Parse the data field as JSON
        data_obj = ParseJSON(data_field)
        
        // Clean up
        XSHash.XDestroy(outer_obj)
        
        ReturnValue(data_obj)
    }
}