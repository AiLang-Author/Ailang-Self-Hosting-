// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.LifetimeChecker.ailang
// Lifetime safety checking as a library module for AILANG
// Uses existing AILANG primitives (no SetField/GetField)

Library.LifetimeChecker

// Initialize the lifetime checker
// Returns a hash table that tracks all lifetime data
Function.LifetimeChecker.Init {
    Output: Address
    Body: {
        // Create main checker structure as hash table
        checker = HashCreate(256)
        
        // Initialize scope counter
        HashSet(checker, "scope_counter", 1)
        HashSet(checker, "current_scope", 0)
        HashSet(checker, "current_depth", 0)
        
        // Initialize pointer registry
        pointer_registry = HashCreate(256)
        HashSet(checker, "pointer_registry", pointer_registry)
        
        // Initialize scope stack (using array)
        scope_stack = ArrayCreate(64)
        HashSet(checker, "scope_stack", scope_stack)
        
        ReturnValue(checker)
    }
}

// Enter a new scope
Function.LifetimeChecker.EnterScope {
    Input: checker: Address
    Output: Integer
    Body: {
        // Get current state
        scope_counter = HashGet(checker, "scope_counter")
        current_depth = HashGet(checker, "current_depth")
        scope_stack = HashGet(checker, "scope_stack")
        
        // Create new scope ID
        new_scope = scope_counter
        HashSet(checker, "scope_counter", Add(scope_counter, 1))
        
        // Push to stack
        ArraySet(scope_stack, current_depth, new_scope)
        HashSet(checker, "current_depth", Add(current_depth, 1))
        
        ReturnValue(new_scope)
    }
}

// Exit current scope
Function.LifetimeChecker.ExitScope {
    Input: checker: Address
    Output: Boolean
    Body: {
        current_depth = HashGet(checker, "current_depth")
        
        // Check if we're at global scope
        IfCondition EqualTo(current_depth, 0) ThenBlock: {
            PrintMessage("[LIFETIME ERROR] Trying to exit global scope\n")
            ReturnValue(0) // Error
        }
        
        // Get the scope we're exiting
        scope_stack = HashGet(checker, "scope_stack")
        exiting_scope = ArrayGet(scope_stack, Subtract(current_depth, 1))
        
        // Pop scope
        HashSet(checker, "current_depth", Subtract(current_depth, 1))
        
        ReturnValue(1) // Success
    }
}

// Track a new pointer
Function.LifetimeChecker.TrackPointer {
    Input: checker: Address
    Input: ptr: Address
    Input: target: Address
    Input: is_mutable: Boolean
    Output: Boolean
    Body: {
        // Get current scope
        current_depth = HashGet(checker, "current_depth")
        scope_stack = HashGet(checker, "scope_stack")
        
        scope_id = 0  // Global by default
        IfCondition GreaterThan(current_depth, 0) ThenBlock: {
            scope_id = ArrayGet(scope_stack, Subtract(current_depth, 1))
        }
        
        // Create tracking info (packed into single value)
        // Format: (scope_id << 32) | (is_mutable << 16) | borrow_count
        tracking_info = scope_id
        tracking_info = Multiply(tracking_info, 65536)  // Shift left 16
        
        IfCondition is_mutable ThenBlock: {
            tracking_info = Add(tracking_info, 65536)  // Set mutable bit
        }
        
        // Store in registry
        pointer_registry = HashGet(checker, "pointer_registry")
        HashSet(pointer_registry, ptr, tracking_info)
        
        ReturnValue(1)
    }
}

// Borrow a pointer
Function.LifetimeChecker.Borrow {
    Input: checker: Address
    Input: ptr: Address
    Input: is_mutable: Boolean
    Output: Address
    Body: {
        pointer_registry = HashGet(checker, "pointer_registry")
        tracking_info = HashGet(pointer_registry, ptr)
        
        IfCondition EqualTo(tracking_info, 0) ThenBlock: {
            PrintMessage("[LIFETIME ERROR] Borrowing untracked pointer\n")
            ReturnValue(0)
        }
        
        // Extract borrow count (lower 16 bits)
        borrow_count = Modulo(tracking_info, 65536)
        
        // Extract is_already_mutable flag
        temp = Divide(tracking_info, 65536)
        is_already_mutable = Modulo(temp, 2)
        
        // Check borrowing rules
        IfCondition is_mutable ThenBlock: {
            // Mutable borrow - must be exclusive
            IfCondition GreaterThan(borrow_count, 0) ThenBlock: {
                PrintMessage("[LIFETIME ERROR] Cannot mutably borrow - already borrowed\n")
                ReturnValue(0)
            }
            // Update tracking with mutable borrow
            new_info = Add(tracking_info, 1)  // Increment borrow count
            HashSet(pointer_registry, ptr, new_info)
        } ElseBlock: {
            // Immutable borrow - check not mutably borrowed
            IfCondition And(is_already_mutable, GreaterThan(borrow_count, 0)) ThenBlock: {
                PrintMessage("[LIFETIME ERROR] Cannot immutably borrow - mutably borrowed\n")
                ReturnValue(0)
            }
            // Update tracking with immutable borrow
            new_info = Add(tracking_info, 1)  // Increment borrow count
            HashSet(pointer_registry, ptr, new_info)
        }
        
        ReturnValue(ptr)
    }
}

// Release a borrow
Function.LifetimeChecker.ReleaseBorrow {
    Input: checker: Address
    Input: ptr: Address
    Body: {
        pointer_registry = HashGet(checker, "pointer_registry")
        tracking_info = HashGet(pointer_registry, ptr)
        
        IfCondition EqualTo(tracking_info, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Extract borrow count
        borrow_count = Modulo(tracking_info, 65536)
        
        IfCondition GreaterThan(borrow_count, 0) ThenBlock: {
            // Decrement borrow count
            new_info = Subtract(tracking_info, 1)
            HashSet(pointer_registry, ptr, new_info)
        }
    }
}

// Validate a return value
Function.LifetimeChecker.ValidateReturn {
    Input: checker: Address
    Input: return_ptr: Address
    Output: Boolean
    Body: {
        pointer_registry = HashGet(checker, "pointer_registry")
        tracking_info = HashGet(pointer_registry, return_ptr)
        
        IfCondition EqualTo(tracking_info, 0) ThenBlock: {
            // Not a tracked pointer, allow
            ReturnValue(1)
        }
        
        // Extract scope_id (upper bits)
        temp = Divide(tracking_info, 65536)
        lifetime_scope = Divide(temp, 65536)
        
        current_depth = HashGet(checker, "current_depth")
        
        // Check if returning pointer to local scope
        IfCondition And(GreaterThan(lifetime_scope, 0), GreaterThan(lifetime_scope, current_depth)) ThenBlock: {
            PrintMessage("[LIFETIME ERROR] Returning pointer to local variable!\n")
            ReturnValue(0)
        }
        
        ReturnValue(1)
    }
}