// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.MessageQueue.ailang
// Fixed version with proper variable scoping for AILANG

// ============================================================================
// MODULE-LEVEL VARIABLE DECLARATIONS
// All variables that will be used in functions must be declared at module level
// ============================================================================

// Variables for CreateNode
node = 0
data_param = 0
next_param = 0

// Variables for Create
queue = 0

// Variables for Destroy  
head = 0
next_node = 0

// Variables for Enqueue
new_node = 0
tail = 0
count = 0

// Variables for Dequeue
data = 0

// Variables for Clear
empty_check = 0

// Variables for Size/IsEmpty/Peek
// (reuse head, count, data from above)

// ============================================================================
// FUNCTION DEFINITIONS
// ============================================================================

// Queue node structure (using memory allocation)
Function.MessageQueue.CreateNode {
    Input: data_param: Integer
    Input: next_param: Integer
    Output: Integer
    Body: {
        node = Allocate(16)  // 8 bytes data + 8 bytes next pointer
        StoreValue(node, data_param)
        StoreValue(Add(node, 8), next_param)
        ReturnValue(node)
    }
}

// Queue structure: head, tail, count
Function.MessageQueue.Create {
    Output: Integer
    Body: {
        queue = Allocate(24)  // head + tail + count
        StoreValue(queue, 0)  // head = null
        StoreValue(Add(queue, 8), 0)  // tail = null
        StoreValue(Add(queue, 16), 0)  // count = 0
        ReturnValue(queue)
    }
}

Function.MessageQueue.Destroy {
    Input: queue: Integer
    Output: Integer
    Body: {
        // Dequeue all remaining items to free nodes
        head = Dereference(queue)
        WhileLoop NotEqual(head, 0) {
            next_node = Dereference(Add(head, 8))
            Deallocate(head, 16)
            head = next_node
        }
        
        // Free the queue structure itself
        Deallocate(queue, 24)
        ReturnValue(1)
    }
}

Function.MessageQueue.Enqueue {
    Input: queue: Integer
    Input: data: Integer
    Output: Integer
    Body: {
        // Create new node
        new_node = MessageQueue.CreateNode(data, 0)
        
        // Get current tail
        tail = Dereference(Add(queue, 8))
        
        IfCondition EqualTo(tail, 0) ThenBlock: {
            // Empty queue
            StoreValue(queue, new_node)  // head = new_node
            StoreValue(Add(queue, 8), new_node)  // tail = new_node
        } ElseBlock: {
            // Add to tail
            StoreValue(Add(tail, 8), new_node)  // tail.next = new_node
            StoreValue(Add(queue, 8), new_node)  // tail = new_node
        }
        
        // Increment count
        count = Dereference(Add(queue, 16))
        StoreValue(Add(queue, 16), Add(count, 1))
        
        ReturnValue(1)
    }
}

Function.MessageQueue.Dequeue {
    Input: queue: Integer
    Output: Integer
    Body: {
        // Check if empty
        head = Dereference(queue)
        IfCondition EqualTo(head, 0) ThenBlock: {
            ReturnValue(-1)  // Error: empty queue
        }
        
        // Get data from head
        data = Dereference(head)
        
        // Move head to next
        next_node = Dereference(Add(head, 8))
        StoreValue(queue, next_node)
        
        // If queue is now empty, update tail
        IfCondition EqualTo(next_node, 0) ThenBlock: {
            StoreValue(Add(queue, 8), 0)  // tail = null
        }
        
        // Decrement count
        count = Dereference(Add(queue, 16))
        StoreValue(Add(queue, 16), Subtract(count, 1))
        
        // Free old head
        Deallocate(head, 16)
        
        ReturnValue(data)
    }
}

Function.MessageQueue.Peek {
    Input: queue: Integer
    Output: Integer
    Body: {
        // Check if empty
        head = Dereference(queue)
        IfCondition EqualTo(head, 0) ThenBlock: {
            ReturnValue(-1)  // Error: empty queue
        }
        
        // Get data from head without removing
        data = Dereference(head)
        ReturnValue(data)
    }
}

Function.MessageQueue.IsEmpty {
    Input: queue: Integer
    Output: Integer
    Body: {
        // Check both count AND head for safety
        count = Dereference(Add(queue, 16))
        head = Dereference(queue)
        
        // Queue is empty if count is 0 OR head is null
        IfCondition Or(EqualTo(count, 0), EqualTo(head, 0)) ThenBlock: {
            ReturnValue(1)  // Empty
        }
        ReturnValue(0)  // Not empty
    }
}

Function.MessageQueue.Size {
    Input: queue: Integer
    Output: Integer
    Body: {
        count = Dereference(Add(queue, 16))
        ReturnValue(count)
    }
}

Function.MessageQueue.Clear {
    Input: queue: Integer
    Output: Integer
    Body: {
        // Dequeue all items directly using head pointer
        head = Dereference(queue)
        WhileLoop NotEqual(head, 0) {
            next_node = Dereference(Add(head, 8))
            Deallocate(head, 16)
            head = next_node
        }
        
        // Reset the queue state
        StoreValue(queue, 0)  // head = null
        StoreValue(Add(queue, 8), 0)  // tail = null
        StoreValue(Add(queue, 16), 0)  // count = 0
        
        ReturnValue(1)
    }
}

// ============================================================================
// TEST HARNESS (Optional - for testing the queue)
// ============================================================================

// Variables for test harness
q = 0
empty = 0
size = 0
head_value = 0
value = 0
underflow = 0
i = 0

SubRoutine.MessageQueue.TestQueue {
    PrintMessage("Testing Message Queue Library\n")
    PrintMessage("=============================\n")
    
    // Create a queue
    q = MessageQueue.Create()
    PrintMessage("Queue created\n")
    
    // Test empty queue
    empty = MessageQueue.IsEmpty(q)
    PrintMessage("Is empty: ")
    PrintNumber(empty)
    PrintMessage("\n")
    
    // Enqueue some items
    MessageQueue.Enqueue(q, 10)
    MessageQueue.Enqueue(q, 20)
    MessageQueue.Enqueue(q, 30)
    PrintMessage("Enqueued: 10, 20, 30\n")
    
    // Check size
    size = MessageQueue.Size(q)
    PrintMessage("Queue size: ")
    PrintNumber(size)
    PrintMessage("\n")
    
    // Peek at head
    head_value = MessageQueue.Peek(q)
    PrintMessage("Peek (should be 10): ")
    PrintNumber(head_value)
    PrintMessage("\n")
    
    // Dequeue all items
    PrintMessage("Dequeuing all items:\n")
    empty = MessageQueue.IsEmpty(q)
    WhileLoop EqualTo(empty, 0) {
        value = MessageQueue.Dequeue(q)
        PrintMessage("  Dequeued: ")
        PrintNumber(value)
        PrintMessage("\n")
        empty = MessageQueue.IsEmpty(q)
    }
    
    // Test underflow
    underflow = MessageQueue.Dequeue(q)
    PrintMessage("Dequeue from empty (should be -1): ")
    PrintNumber(underflow)
    PrintMessage("\n")
    
    // Clean up
    MessageQueue.Destroy(q)
    PrintMessage("Queue destroyed\n")
    
    PrintMessage("\nMessage Queue Test Complete!\n")
}