// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.PIC.ailang
// Program Interface Console - Bare-bones reflection system
// Provides runtime introspection and dynamic invocation

// ============================================================
// CONFIGURATION
// ============================================================

FixedPool.PICConfig {
    "MAX_FUNCTIONS": Initialize=256
    "MAX_TYPES": Initialize=128
    "MAX_MODULES": Initialize=64
    "METADATA_SIZE": Initialize=10000
}

FixedPool.MetadataOffsets {
    "FUNCTION_COUNT": Initialize=0
    "TYPE_COUNT": Initialize=1
    "MODULE_COUNT": Initialize=2
    "FUNCTION_TABLE_BASE": Initialize=10
    "TYPE_TABLE_BASE": Initialize=2570
    "MODULE_TABLE_BASE": Initialize=3850
}

// Internal state for the PIC library
FixedPool.PIC_InternalState {
    "pic_metadata": Initialize=0
}

// ============================================================
// SIMPLE STRING HASHING
// ============================================================

// Simple hash function for string identifiers
// In real implementation, compiler would handle this
Function.HashString {
    Input: str_id: Integer
    Output: Integer
    Body: {
        // For demo purposes, just return the ID
        // Real version would hash actual strings
        ReturnValue(str_id)
    }
}

// ============================================================
// INITIALIZATION
// ============================================================

Function.Init {
    Body: {
        PIC_InternalState.pic_metadata = ArrayCreate(PICConfig.METADATA_SIZE)
        
        DebugAssert(NotEqual(PIC_InternalState.pic_metadata, 0), "PIC.Init: pic_metadata array allocation failed")
        
        // Initialize counters
        ArraySet(PIC_InternalState.pic_metadata, MetadataOffsets.FUNCTION_COUNT, 0)
        ArraySet(PIC_InternalState.pic_metadata, MetadataOffsets.TYPE_COUNT, 0)
        ArraySet(PIC_InternalState.pic_metadata, MetadataOffsets.MODULE_COUNT, 0)
        
        // Initialize tables to zero
        i = 0
        WhileLoop LessThan(i, PICConfig.METADATA_SIZE) {
            ArraySet(PIC_InternalState.pic_metadata, i, 0)
            i = Add(i, 1)
        }
        
        PrintMessage("[PIC] Program Interface Console initialized\n")
    }
}

// ============================================================
// FUNCTION REGISTRATION
// ============================================================

Function.RegisterFunction {
    Input: module_name: Integer
    Input: function_name: Integer
    Input: function_id: Integer
    Input: param_count: Integer
    Output: Integer
    Body: {
        metadata_ptr = PIC_InternalState.pic_metadata
        func_count = ArrayGet(metadata_ptr, MetadataOffsets.FUNCTION_COUNT)
        
        IfCondition GreaterEqual(func_count, PICConfig.MAX_FUNCTIONS) ThenBlock: {
            PrintMessage("[PIC] ERROR: Function table full\n")
            ReturnValue(-1)
        }
        
        // Each function entry: [module_hash, func_hash, func_id, param_count]
        base_addr = 0
        base_addr = Add(MetadataOffsets.FUNCTION_TABLE_BASE, 
                   Multiply(func_count, 4))
        
        ArraySet(metadata_ptr, base_addr, module_name)
        ArraySet(metadata_ptr, Add(base_addr, 1), function_name)
        ArraySet(metadata_ptr, Add(base_addr, 2), function_id)
        ArraySet(metadata_ptr, Add(base_addr, 3), param_count)
        
        // Increment count
        ArraySet(metadata_ptr, MetadataOffsets.FUNCTION_COUNT, 
                 Add(func_count, 1))
        
        PrintMessage("[PIC] Registered function: Module=")
        PrintNumber(module_name)
        PrintMessage(" Function=")
        PrintNumber(function_name)
        PrintMessage(" ID=")
        PrintNumber(function_id)
        PrintMessage(" Params=")
        PrintNumber(param_count)
        PrintMessage("\n")
        
        ReturnValue(func_count)
    }
}

// ============================================================
// FUNCTION LOOKUP
// ============================================================

Function.FindFunction {
    Input: module_name: Integer
    Input: function_name: Integer
    Output: Integer
    Body: {
        metadata_ptr = PIC_InternalState.pic_metadata
        func_count = ArrayGet(metadata_ptr, MetadataOffsets.FUNCTION_COUNT)
        
        i = 0
        WhileLoop LessThan(i, func_count) {
            base_addr = 0
            stored_module = 0
            stored_func = 0
            is_module_match = 0
            is_func_match = 0
            
            base_addr = Add(MetadataOffsets.FUNCTION_TABLE_BASE, Multiply(i, 4))
            
            stored_module = ArrayGet(metadata_ptr, base_addr)
            stored_func = ArrayGet(metadata_ptr, Add(base_addr, 1))
            
            is_module_match = EqualTo(stored_module, module_name)
            is_func_match = EqualTo(stored_func, function_name)
            
            IfCondition And(is_module_match, is_func_match) ThenBlock: {
                func_addr = ArrayGet(metadata_ptr, Add(base_addr, 2))
                PrintMessage("[PIC] Found function ID: ")
                PrintNumber(func_addr)
                PrintMessage("\n")
                ReturnValue(func_addr)
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[PIC] Function not found: Module=")
        PrintNumber(module_name)
        PrintMessage(" Function=")
        PrintNumber(function_name)
        PrintMessage("\n")
        ReturnValue(-1)
    }
}

// ============================================================
// FUNCTION INVOCATION (SIMPLIFIED)
// ============================================================

Function.Invoke {
    Input: module_name: Integer
    Input: function_name: Integer
    Input: param1: Integer
    Output: Integer
    Body: {
        func_addr = FindFunction(module_name, function_name)
        
        IfCondition EqualTo(func_addr, -1) ThenBlock: {
            PrintMessage("[PIC] Cannot invoke: function not found\n")
            ReturnValue(-1)
        }
        
        // Get parameter count for this function
        metadata_ptr = PIC_InternalState.pic_metadata
        func_count = ArrayGet(metadata_ptr, MetadataOffsets.FUNCTION_COUNT)
        i = 0
        
        WhileLoop LessThan(i, func_count) {
            base_addr = 0
            temp_func_addr = 0
            
            base_addr = Add(MetadataOffsets.FUNCTION_TABLE_BASE,
                      Multiply(i, 4))
            temp_func_addr = ArrayGet(metadata_ptr, Add(base_addr, 2))
            
            IfCondition EqualTo(temp_func_addr, func_addr) ThenBlock: {
                param_count = 0
                param_count = ArrayGet(metadata_ptr, Add(base_addr, 3))
                
                PrintMessage("[PIC] Invoking function ID ")
                PrintNumber(func_addr)
                PrintMessage(" with ")
                PrintNumber(param_count)
                PrintMessage(" parameter(s)\n")
                
                // In real implementation, would use dynamic dispatch
                // For now, just demonstrate the lookup worked
                PrintMessage("[PIC] (Mock invocation - param1=")
                PrintNumber(param1)
                PrintMessage(")\n")
                
                ReturnValue(0)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(-1)
    }
}

// ============================================================
// INTROSPECTION
// ============================================================

Function.ListFunctions {
    Body: {
        metadata_ptr = PIC_InternalState.pic_metadata
        PrintMessage("\n=== PIC FUNCTION REGISTRY ===\n")
        
        func_count = ArrayGet(metadata_ptr, MetadataOffsets.FUNCTION_COUNT)
        PrintMessage("Total functions: ")
        PrintNumber(func_count)
        PrintMessage("\n\n")
        
        i = 0
        WhileLoop LessThan(i, func_count) {
            base_addr = 0
            stored_module = 0
            stored_func = 0
            func_addr = 0
            param_count = 0
            
            base_addr = Add(MetadataOffsets.FUNCTION_TABLE_BASE,
                      Multiply(i, 4))
            
            stored_module = ArrayGet(metadata_ptr, base_addr)
            stored_func = ArrayGet(metadata_ptr, Add(base_addr, 1))
            func_addr = ArrayGet(metadata_ptr, Add(base_addr, 2))
            param_count = ArrayGet(metadata_ptr, Add(base_addr, 3))
            
            PrintMessage("  [")
            PrintNumber(i)
            PrintMessage("] Module:")
            PrintNumber(stored_module)
            PrintMessage(" Func:")
            PrintNumber(stored_func)
            PrintMessage(" ID:")
            PrintNumber(func_addr)
            PrintMessage(" Params:")
            PrintNumber(param_count)
            PrintMessage("\n")
            
            i = Add(i, 1)
        }
        
        PrintMessage("============================\n")
    }
}

Function.GetFunctionCount {
    Output: Integer
    Body: {
        func_count = ArrayGet(PIC_InternalState.pic_metadata, MetadataOffsets.FUNCTION_COUNT)
        ReturnValue(func_count)
    }
}

Function.HasFunction {
    Input: module_name: Integer
    Input: function_name: Integer
    Output: Integer
    Body: {
        func_addr = FindFunction(module_name, function_name)
        IfCondition NotEqual(func_addr, -1) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// ============================================================
// TYPE REGISTRATION
// ============================================================

Function.RegisterType {
    Input: type_name: Integer
    Input: type_size: Integer
    Input: field_count: Integer
    Output: Integer
    Body: {
        metadata_ptr = PIC_InternalState.pic_metadata
        type_count = ArrayGet(metadata_ptr, MetadataOffsets.TYPE_COUNT)
        
        IfCondition GreaterEqual(type_count, PICConfig.MAX_TYPES) ThenBlock: {
            PrintMessage("[PIC] ERROR: Type table full\n")
            ReturnValue(-1)
        }
        
        // Each type entry: [name_hash, size, field_count]
        base_addr = 0
        base_addr = Add(MetadataOffsets.TYPE_TABLE_BASE,
                  Multiply(type_count, 3))
        
        ArraySet(metadata_ptr, base_addr, type_name)
        ArraySet(metadata_ptr, Add(base_addr, 1), type_size)
        ArraySet(metadata_ptr, Add(base_addr, 2), field_count)
        
        ArraySet(metadata_ptr, MetadataOffsets.TYPE_COUNT,
                Add(type_count, 1))
        
        PrintMessage("[PIC] Registered type: Name=")
        PrintNumber(type_name)
        PrintMessage(" Size=")
        PrintNumber(type_size)
        PrintMessage(" Fields=")
        PrintNumber(field_count)
        PrintMessage("\n")
        
        ReturnValue(type_count)
    }
}

Function.GetTypeSize {
    Input: type_name: Integer
    Output: Integer
    Body: {
        metadata_ptr = PIC_InternalState.pic_metadata
        type_count = ArrayGet(metadata_ptr, MetadataOffsets.TYPE_COUNT)
        
        i = 0
        WhileLoop LessThan(i, type_count) {
            base_addr = 0
            stored_type = 0
            
            base_addr = Add(MetadataOffsets.TYPE_TABLE_BASE,
                      Multiply(i, 3))
            
            stored_type = ArrayGet(metadata_ptr, base_addr)
            
            IfCondition EqualTo(stored_type, type_name) ThenBlock: {
                type_size = ArrayGet(metadata_ptr, Add(base_addr, 1))
                PrintMessage("[PIC] Type size: ")
                PrintNumber(type_size)
                PrintMessage("\n")
                ReturnValue(type_size)
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("[PIC] Type not found: ")
        PrintNumber(type_name)
        PrintMessage("\n")
        ReturnValue(-1)
    }
}

Function.ListTypes {
    Body: {
        metadata_ptr = PIC_InternalState.pic_metadata
        PrintMessage("\n=== PIC TYPE REGISTRY ===\n")
        
        type_count = ArrayGet(metadata_ptr, MetadataOffsets.TYPE_COUNT)
        PrintMessage("Total types: ")
        PrintNumber(type_count)
        PrintMessage("\n\n")
        
        i = 0
        WhileLoop LessThan(i, type_count) {
            base_addr = 0
            stored_type = 0
            type_size = 0
            field_count = 0
            
            base_addr = Add(MetadataOffsets.TYPE_TABLE_BASE,
                      Multiply(i, 3))
            
            stored_type = ArrayGet(metadata_ptr, base_addr)
            type_size = ArrayGet(metadata_ptr, Add(base_addr, 1))
            field_count = ArrayGet(metadata_ptr, Add(base_addr, 2))
            
            PrintMessage("  [")
            PrintNumber(i)
            PrintMessage("] Type:")
            PrintNumber(stored_type)
            PrintMessage(" Size:")
            PrintNumber(type_size)
            PrintMessage(" Fields:")
            PrintNumber(field_count)
            PrintMessage("\n")
            i = Add(i, 1)
        }
        
        PrintMessage("========================\n")
    }
}

// ============================================================
// CLEANUP
// ============================================================

Function.Cleanup {
    Body: {
        DebugAssert(NotEqual(PIC_InternalState.pic_metadata, 0), "PIC.Cleanup: pic_metadata is null")
        ArrayDestroy(PIC_InternalState.pic_metadata)
        PIC_InternalState.pic_metadata = 0
        PrintMessage("[PIC] Cleanup complete\n")
    }
}
