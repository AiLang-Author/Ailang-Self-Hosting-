// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.RESP.ailang
// Redis Serialization Protocol (RESP) Library
// Provides parsing and building functions for RESP protocol

LibraryImport.XArrays

// ============================================================================
// RESP Parser Functions
// ============================================================================

// Variables for RESP.Array function
count = 0
count_str = 0
count_len = 0
total_size = 0
elem = 0
elem_len = 0
elem_len_str = 0
len_digits = 0
elem_size = 0
response = 0
pos = 0
elem_len_digits = 0
j = 0

// Variables for RESP.IntToString
absolute_value = 0
num_param = 0
is_negative = 0
value = 0
temp = 0
digit_count = 0
buffer_size = 0
buffer = 0
digit = 0
result = 0
final_pos = 0
end_pos = 0
current_pos = 0

// Variables for other RESP functions
i = 0
len = 0
str_param = 0
msg_param = 0
prefix = 0
full_msg = 0
num_str = 0
len_str = 0
len_str_len = 0
total = 0

// Variables for parsing functions
comparison = 0
offset = 0
type_byte = 0
length = 0
str = 0
start = 0
negative = 0
byte = 0
num = 0
element = 0

// Variables needed for debug blocks
elements_param = 0
buffer_param = 0
size_param = 0
message_param = 0
str_debug = 0
num_debug = 0

// Variables for checking RESP format
first_byte = 0
is_resp_formatted = 0
is_resp_integer = 0
is_resp_simple = 0
is_resp_error = 0
is_resp_bulk = 0
is_resp_array = 0
empty_resp = 0
last_pos = 0
second_last = 0
last_byte = 0
second_last_byte = 0
has_crlf = 0

// Build an array response: *<count>\r\n<elements>
// Fixed RESP.Array function that correctly handles pre-formatted RESP responses
// This replaces the existing Function.RESP.Array in Library.RESP.ailang

Function.RESP.Array {
    Input: elements: Array
    Output: Address
    Body: {
        // First, validate the input
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.Array: Entry point, elements ptr: ")
            PrintNumber(elements)
            PrintMessage("\n")
        }
        
        // Handle null array early
        IfCondition EqualTo(elements, 0) ThenBlock: {
            Debug("resp.build", level=2) {
                PrintMessage("[DEBUG] RESP.Array: NULL array passed, returning empty\n")
            }
            // Return empty array response: *0\r\n
            empty_resp = Allocate(6)
            SetByte(empty_resp, 0, 42)  // '*'
            SetByte(empty_resp, 1, 48)  // '0'
            SetByte(empty_resp, 2, 13)  // '\r'
            SetByte(empty_resp, 3, 10)  // '\n'
            SetByte(empty_resp, 4, 0)   // null terminator
            ReturnValue(empty_resp)
        }
        
        // Get array length safely
        count = ArrayLength(elements)
        
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.Array: Building array with ")
            PrintNumber(count)
            PrintMessage(" elements\n")
        }
        
        // Handle empty array
        IfCondition EqualTo(count, 0) ThenBlock: {
            Debug("resp.build", level=2) {
                PrintMessage("[DEBUG] RESP.Array: Empty array (count=0)\n")
            }
            // Return empty array response: *0\r\n
            empty_resp = Allocate(6)
            SetByte(empty_resp, 0, 42)  // '*'
            SetByte(empty_resp, 1, 48)  // '0'
            SetByte(empty_resp, 2, 13)  // '\r'
            SetByte(empty_resp, 3, 10)  // '\n'
            SetByte(empty_resp, 4, 0)   // null terminator
            ReturnValue(empty_resp)
        }
        
        // Convert count to string
        count_str = RESP.IntToString(count)
        count_len = StringLength(count_str)
        
        Debug("resp.build", level=3) {
            PrintMessage("[DEBUG] RESP.Array: Count string: ")
            PrintMessage(count_str)
            PrintMessage(" (length: ")
            PrintNumber(count_len)
            PrintMessage(")\n")
        }
        
        // First pass: Calculate total size needed
        total_size = 1  // '*'
        total_size = Add(total_size, count_len)  // count digits
        total_size = Add(total_size, 2)  // '\r\n' after count
        
        i = 0
        WhileLoop LessThan(i, count) {
            Debug("resp.build", level=3) {
                PrintMessage("[DEBUG] RESP.Array: Processing element ")
                PrintNumber(i)
                PrintMessage("\n")
            }
            
            elem = ArrayGet(elements, i)
            
            Debug("resp.build", level=3) {
                PrintMessage("[DEBUG] RESP.Array: Element ptr: ")
                PrintNumber(elem)
                PrintMessage("\n")
            }
            
            IfCondition NotEqual(elem, 0) ThenBlock: {
                elem_len = StringLength(elem)
                
                Debug("resp.build", level=3) {
                    PrintMessage("[DEBUG] RESP.Array: Element length: ")
                    PrintNumber(elem_len)
                    PrintMessage("\n")
                }
                
                // Check if this is already a RESP-formatted response
                first_byte = GetByte(elem, 0)
                
                Debug("resp.build", level=3) {
                    PrintMessage("[DEBUG] RESP.Array: First byte: ")
                    PrintNumber(first_byte)
                    PrintMessage("\n")
                }
                
                // Check for RESP type markers: : + - $ *
                is_resp_formatted = 0
                
                // Integer response starts with ':'
                IfCondition EqualTo(first_byte, 58) ThenBlock: {
                    is_resp_formatted = 1
                    Debug("resp.build", level=3) {
                        PrintMessage("[DEBUG] RESP.Array: Element is RESP integer\n")
                    }
                }
                // Simple string starts with '+'
                IfCondition EqualTo(first_byte, 43) ThenBlock: {
                    is_resp_formatted = 1
                    Debug("resp.build", level=3) {
                        PrintMessage("[DEBUG] RESP.Array: Element is RESP simple string\n")
                    }
                }
                // Error starts with '-'
                IfCondition EqualTo(first_byte, 45) ThenBlock: {
                    is_resp_formatted = 1
                }
                // Bulk string starts with '$'
                IfCondition EqualTo(first_byte, 36) ThenBlock: {
                    is_resp_formatted = 1
                }
                // Array starts with '*'
                IfCondition EqualTo(first_byte, 42) ThenBlock: {
                    is_resp_formatted = 1
                }
                
                IfCondition EqualTo(is_resp_formatted, 1) ThenBlock: {
                    // Already RESP formatted - just add its length
                    total_size = Add(total_size, elem_len)
                    
                    // Check if it already has \r\n at end
                    has_crlf = 0
                    IfCondition GreaterEqual(elem_len, 2) ThenBlock: {
                        last_pos = Subtract(elem_len, 1)
                        second_last = Subtract(elem_len, 2)
                        last_byte = GetByte(elem, last_pos)
                        second_last_byte = GetByte(elem, second_last)
                        IfCondition And(EqualTo(second_last_byte, 13), EqualTo(last_byte, 10)) ThenBlock: {
                            has_crlf = 1
                        }
                    }
                    
                    // If no CRLF at end, add space for it
                    IfCondition EqualTo(has_crlf, 0) ThenBlock: {
                        total_size = Add(total_size, 2)
                    }
                } ElseBlock: {
                    // Not RESP formatted - treat as bulk string
                    elem_len_str = RESP.IntToString(elem_len)
                    elem_len_digits = StringLength(elem_len_str)
                    Deallocate(elem_len_str, 0)
                    
                    total_size = Add(total_size, 1)  // '$'
                    total_size = Add(total_size, elem_len_digits)  // length digits
                    total_size = Add(total_size, 2)  // '\r\n' after length
                    total_size = Add(total_size, elem_len)  // content
                    total_size = Add(total_size, 2)  // '\r\n' after content
                }
            } ElseBlock: {
                Debug("resp.build", level=3) {
                    PrintMessage("[DEBUG] RESP.Array: Element is NULL\n")
                }
                // NULL element - represent as $-1\r\n
                total_size = Add(total_size, 5)  // "$-1\r\n"
            }
            
            i = Add(i, 1)
        }
        
        total_size = Add(total_size, 1)  // null terminator
        
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.Array: Total size calculated: ")
            PrintNumber(total_size)
            PrintMessage("\n")
        }
        
        // Allocate response buffer
        response = Allocate(total_size)
        
        Debug("resp.build", level=3) {
            PrintMessage("[DEBUG] RESP.Array: Response buffer allocated at: ")
            PrintNumber(response)
            PrintMessage("\n")
        }
        
        // Write array header
        pos = 0
        SetByte(response, pos, 42)  // '*'
        pos = Add(pos, 1)
        
        // Write count
        i = 0
        WhileLoop LessThan(i, count_len) {
            SetByte(response, pos, GetByte(count_str, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Write \r\n after count
        SetByte(response, pos, 13)  // '\r'
        pos = Add(pos, 1)
        SetByte(response, pos, 10)  // '\n'
        pos = Add(pos, 1)
        
        Debug("resp.build", level=3) {
            PrintMessage("[DEBUG] RESP.Array: Header written, pos: ")
            PrintNumber(pos)
            PrintMessage("\n")
        }
        
        // Second pass: Write each element
        i = 0
        WhileLoop LessThan(i, count) {
            elem = ArrayGet(elements, i)
            
            IfCondition NotEqual(elem, 0) ThenBlock: {
                // Check if already RESP formatted
                first_byte = GetByte(elem, 0)
                
                is_resp_formatted = 0
                IfCondition EqualTo(first_byte, 58) ThenBlock: { is_resp_formatted = 1 }  // ':'
                IfCondition EqualTo(first_byte, 43) ThenBlock: { is_resp_formatted = 1 }  // '+'
                IfCondition EqualTo(first_byte, 45) ThenBlock: { is_resp_formatted = 1 }  // '-'
                IfCondition EqualTo(first_byte, 36) ThenBlock: { is_resp_formatted = 1 }  // '$'
                IfCondition EqualTo(first_byte, 42) ThenBlock: { is_resp_formatted = 1 }  // '*'
                
                IfCondition EqualTo(is_resp_formatted, 1) ThenBlock: {
                    // Copy the already-formatted RESP response directly
                    elem_len = StringLength(elem)
                    
                    // Check if it has CRLF at end
                    has_crlf = 0
                    IfCondition GreaterEqual(elem_len, 2) ThenBlock: {
                        last_pos = Subtract(elem_len, 1)
                        second_last = Subtract(elem_len, 2)
                        last_byte = GetByte(elem, last_pos)
                        second_last_byte = GetByte(elem, second_last)
                        IfCondition And(EqualTo(second_last_byte, 13), EqualTo(last_byte, 10)) ThenBlock: {
                            has_crlf = 1
                        }
                    }
                    
                    // Copy the response
                    j = 0
                    WhileLoop LessThan(j, elem_len) {
                        SetByte(response, pos, GetByte(elem, j))
                        pos = Add(pos, 1)
                        j = Add(j, 1)
                    }
                    
                    // Add CRLF if not present
                    IfCondition EqualTo(has_crlf, 0) ThenBlock: {
                        SetByte(response, pos, 13)  // '\r'
                        pos = Add(pos, 1)
                        SetByte(response, pos, 10)  // '\n'
                        pos = Add(pos, 1)
                    }
                } ElseBlock: {
                    // Format as bulk string
                    elem_len = StringLength(elem)
                    elem_len_str = RESP.IntToString(elem_len)
                    elem_len_digits = StringLength(elem_len_str)
                    
                    // Write $<length>\r\n
                    SetByte(response, pos, 36)  // '$'
                    pos = Add(pos, 1)
                    
                    j = 0
                    WhileLoop LessThan(j, elem_len_digits) {
                        SetByte(response, pos, GetByte(elem_len_str, j))
                        pos = Add(pos, 1)
                        j = Add(j, 1)
                    }
                    
                    SetByte(response, pos, 13)  // '\r'
                    pos = Add(pos, 1)
                    SetByte(response, pos, 10)  // '\n'
                    pos = Add(pos, 1)
                    
                    // Write string content
                    j = 0
                    WhileLoop LessThan(j, elem_len) {
                        SetByte(response, pos, GetByte(elem, j))
                        pos = Add(pos, 1)
                        j = Add(j, 1)
                    }
                    
                    // Write trailing \r\n
                    SetByte(response, pos, 13)  // '\r'
                    pos = Add(pos, 1)
                    SetByte(response, pos, 10)  // '\n'
                    pos = Add(pos, 1)
                    
                    Deallocate(elem_len_str, 0)
                }
            } ElseBlock: {
                // NULL element - write $-1\r\n
                SetByte(response, pos, 36)  // '$'
                pos = Add(pos, 1)
                SetByte(response, pos, 45)  // '-'
                pos = Add(pos, 1)
                SetByte(response, pos, 49)  // '1'
                pos = Add(pos, 1)
                SetByte(response, pos, 13)  // '\r'
                pos = Add(pos, 1)
                SetByte(response, pos, 10)  // '\n'
                pos = Add(pos, 1)
            }
            
            i = Add(i, 1)
        }
        
        // Null terminate
        SetByte(response, pos, 0)
        
        Deallocate(count_str, 0)
        
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.Array: Complete, returning response\n")
        }
        ReturnValue(response)
    }
}



Function.RESP.ParseArray {
    Input: buffer: Address
    Input: size: Integer
    Output: Array
    Body: {
        // Check for array marker '*'
        IfCondition NotEqual(GetByte(buffer, 0), 42) ThenBlock: {
            ReturnValue(0)  // Not an array
        }
        
        // Parse array count
        count = RESP.ParseInteger(buffer, 1)
        
        // Create array to hold results
        result = ArrayCreate(count)
        
        // Find start of first element
        offset = 1
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
            offset = Add(offset, 1)
        }
        offset = Add(offset, 1)  // Skip LF
        
        // Parse each element
        i = 0
        WhileLoop LessThan(i, count) {
            element = RESP.ParseElement(buffer, offset, size)
            ArraySet(result, i, element)
            
            // Move offset past this element
            offset = RESP.SkipElement(buffer, offset, size)
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// Parse a single RESP element starting at offset
Function.RESP.ParseElement {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        type_byte = GetByte(buffer, offset)
        
        // Bulk string ($)
        IfCondition EqualTo(type_byte, 36) ThenBlock: {
            ReturnValue(RESP.ParseBulkString(buffer, offset, size))
        }
        
        // Simple string (+)
        IfCondition EqualTo(type_byte, 43) ThenBlock: {
            ReturnValue(RESP.ParseSimpleString(buffer, offset, size))
        }
        
        // Integer (:)
        IfCondition EqualTo(type_byte, 58) ThenBlock: {
            num = RESP.ParseInteger(buffer, Add(offset, 1))
            ReturnValue(NumberToString(num))
        }
        
        // Error (-)
        IfCondition EqualTo(type_byte, 45) ThenBlock: {
            ReturnValue(RESP.ParseSimpleString(buffer, offset, size))
        }
        
        ReturnValue(0)  // Unknown type
    }
}

// Parse a bulk string from buffer
Function.RESP.ParseBulkString {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        // Skip '$'
        offset = Add(offset, 1)
        
        // Parse length
        length = RESP.ParseInteger(buffer, offset)
        
        // Check for null bulk string
        IfCondition LessThan(length, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Find start of actual string (after \r\n)
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
            offset = Add(offset, 1)
        }
        offset = Add(offset, 1)
        
        // Allocate and copy string
        str = Allocate(Add(length, 1))
        i = 0
        WhileLoop LessThan(i, length) {
            SetByte(str, i, GetByte(buffer, Add(offset, i)))
            i = Add(i, 1)
        }
        SetByte(str, length, 0)  // Null terminate
        
        ReturnValue(str)
    }
}

// Parse a simple string (ends with \r\n)
Function.RESP.ParseSimpleString {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        // Skip type marker
        offset = Add(offset, 1)
        
        // Find end of string
        start = offset
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 13)) {
            offset = Add(offset, 1)
        }
        
        // Allocate and copy
        length = Subtract(offset, start)
        str = Allocate(Add(length, 1))
        i = 0
        WhileLoop LessThan(i, length) {
            SetByte(str, i, GetByte(buffer, Add(start, i)))
            i = Add(i, 1)
        }
        SetByte(str, length, 0)
        
        ReturnValue(str)
    }
}

// Parse an integer from buffer (until \r)
Function.RESP.ParseInteger {
    Input: buffer: Address
    Input: offset: Integer
    Output: Integer
    Body: {
        result = 0
        negative = 0
        
        // Check for negative
        IfCondition EqualTo(GetByte(buffer, offset), 45) ThenBlock: {  // '-'
            negative = 1
            offset = Add(offset, 1)
        }
        
        // Parse digits
        WhileLoop 1 {
            byte = GetByte(buffer, offset)
            
            // Check for CR or non-digit
            IfCondition Or(EqualTo(byte, 13), Or(LessThan(byte, 48), GreaterThan(byte, 57))) ThenBlock: {
                BreakLoop
            }
            
            // Add digit
            result = Multiply(result, 10)
            result = Add(result, Subtract(byte, 48))
            
            offset = Add(offset, 1)
        }
        
        IfCondition negative ThenBlock: {
            result = Subtract(0, result)
        }
        
        ReturnValue(result)
    }
}

// Skip past a RESP element, return new offset
Function.RESP.SkipElement {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Integer
    Body: {
        type_byte = GetByte(buffer, offset)
        
        // Simple types - skip to \r\n
        IfCondition Or(EqualTo(type_byte, 43), Or(EqualTo(type_byte, 45), EqualTo(type_byte, 58))) ThenBlock: {
            WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
                offset = Add(offset, 1)
            }
            ReturnValue(Add(offset, 1))  // Past \n
        }
        
        // Bulk string - parse length then skip
        IfCondition EqualTo(type_byte, 36) ThenBlock: {
            offset = Add(offset, 1)  // Skip '$'
            length = RESP.ParseInteger(buffer, offset)
            
            // Skip to start of string
            WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
                offset = Add(offset, 1)
            }
            offset = Add(offset, 1)  // Past \n
            
            // Skip string + \r\n
            offset = Add(offset, Add(length, 2))
            ReturnValue(offset)
        }
        
        // Array - recursive skip
        IfCondition EqualTo(type_byte, 42) ThenBlock: {
            offset = Add(offset, 1)  // Skip '*'
            count = RESP.ParseInteger(buffer, offset)
            
            // Skip to first element
            WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
                offset = Add(offset, 1)
            }
            offset = Add(offset, 1)
            
            // Skip each element
            i = 0
            WhileLoop LessThan(i, count) {
                offset = RESP.SkipElement(buffer, offset, size)
                i = Add(i, 1)
            }
            
            ReturnValue(offset)
        }
        
        ReturnValue(offset)
    }
}

// ============================================================================
// RESP Builder Functions
// ============================================================================

// Build a simple string response: +OK\r\n
Function.RESP.SimpleString {
    Input: str: Address
    Output: Address
    Body: {
        str_debug = str
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.SimpleString: Building simple string '")
            PrintMessage(str_debug)
            PrintMessage("'")
        }
        len = StringLength(str)
        response = Allocate(Add(len, 4))  // + str \r\n \0
        
        SetByte(response, 0, 43)  // '+'
        
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, Add(i, 1), GetByte(str, i))
            i = Add(i, 1)
        }
        
        SetByte(response, Add(len, 1), 13)  // '\r'
        SetByte(response, Add(len, 2), 10)  // '\n'
        SetByte(response, Add(len, 3), 0)   // '\0'
        
        ReturnValue(response)
    }
}

// Build a bulk string response: $<len>\r\n<data>\r\n
Function.RESP.BulkString {
    Input: str: Address
    Output: Address
    Body: {
        str_debug = str
        Debug("resp.build", level=2) {
            IfCondition EqualTo(str_debug, 0) ThenBlock: {
                PrintMessage("[DEBUG] RESP.BulkString: Building NULL bulk string.")
            } ElseBlock: {
                PrintMessage("[DEBUG] RESP.BulkString: Building bulk string.")
            }
        }

        // Handle null
        IfCondition EqualTo(str, 0) ThenBlock: {
            null_resp = Allocate(6)
            SetByte(null_resp, 0, 36)  // '$'
            SetByte(null_resp, 1, 45)  // '-'
            SetByte(null_resp, 2, 49)  // '1'
            SetByte(null_resp, 3, 13)  // '\r'
            SetByte(null_resp, 4, 10)  // '\n'
            SetByte(null_resp, 5, 0)   // '\0'
            Debug("resp.build", level=3) {
                PrintMessage("[DEBUG] RESP.BulkString: Final response string:\n")
                PrintMessage(null_resp)
            }
            ReturnValue(null_resp)
        }
        
        len = StringLength(str)
        len_str = RESP.IntToString(len)
        len_str_len = StringLength(len_str)
        
        // Calculate total size: $ + len_str + \r\n + str + \r\n + \0
        total = Add(Add(Add(len_str_len, len), 6), 1)
        response = Allocate(total)
        
        pos = 0
        
        // Add '$'
        SetByte(response, pos, 36)
        pos = Add(pos, 1)
        
        // Add length
        i = 0
        WhileLoop LessThan(i, len_str_len) {
            SetByte(response, pos, GetByte(len_str, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Add \r\n
        SetByte(response, pos, 13)
        pos = Add(pos, 1)
        SetByte(response, pos, 10)
        pos = Add(pos, 1)
        
        // Add string
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, pos, GetByte(str, i))
            pos = Add(pos, 1)
            i = Add(i, 1)
        }
        
        // Add final \r\n
        SetByte(response, pos, 13)
        pos = Add(pos, 1)
        SetByte(response, pos, 10)
        pos = Add(pos, 1)
        SetByte(response, pos, 0)
        
        // Deallocate the temporary string used for the length
        Deallocate(len_str, 0)
        
        Debug("resp.build", level=3) {
            PrintMessage("[DEBUG] RESP.BulkString: Final response string:\n")
            PrintMessage(response)
        }

        ReturnValue(response)
    }
}

// Build an error response: -ERR <message>\r\n
Function.RESP.Error {
    Input: message: Address
    Output: Address
    Body: {
        message_param = message
        Debug("resp.build", level=1) {
            PrintMessage("[DEBUG] RESP.Error: Building error response '")
            PrintMessage(message_param)
            PrintMessage("'")
        }
        prefix = "ERR "
        full_msg = StringConcat(prefix, message)
        len = StringLength(full_msg)
        
        response = Allocate(Add(len, 4))
        
        SetByte(response, 0, 45)  // '-'
        
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, Add(i, 1), GetByte(full_msg, i))
            i = Add(i, 1)
        }
        
        SetByte(response, Add(len, 1), 13)
        SetByte(response, Add(len, 2), 10)
        SetByte(response, Add(len, 3), 0)
        
        Deallocate(full_msg, 0)
        
        ReturnValue(response)
    }
}

// Convert integer to string for RESP responses
Function.RESP.IntToString {
    Input: num: Integer
    Output: Address
    Body: {
        num_debug = num
        Debug("resp.internal", level=4) {
            PrintMessage("[DEBUG] RESP.IntToString: Converting number ")
            PrintNumber(num_debug)
        }

        // Handle zero
        IfCondition EqualTo(num, 0) ThenBlock: {
            result = Allocate(2)
            SetByte(result, 0, 48)  // '0'
            SetByte(result, 1, 0)   // null terminator
            ReturnValue(result)
        }
        
        // Check if negative but use a separate variable for absolute value
        is_negative = LessThan(num, 0)
        absolute_value = num
        IfCondition is_negative ThenBlock: {
            absolute_value = Subtract(0, num)  // Make positive
        }

        // Count digits using absolute value
        temp = absolute_value
        digit_count = 0
        WhileLoop GreaterThan(temp, 0) {
            digit_count = Add(digit_count, 1)
            temp = Divide(temp, 10)
        }
        
        // Allocate buffer (digits + sign + null)
        buffer_size = digit_count
        IfCondition is_negative ThenBlock: {
            buffer_size = Add(buffer_size, 1)
        }
        buffer_size = Add(buffer_size, 1)  // null terminator
        
        buffer = Allocate(buffer_size)
        
        // Fill digits from right to left using absolute value
        pos = Subtract(digit_count, 1)
        IfCondition is_negative ThenBlock: {
            pos = Add(pos, 1)
        }
        
        temp = absolute_value  // Use absolute value, not modified num
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            SetByte(buffer, pos, Add(48, digit))  // '0' + digit
            pos = Subtract(pos, 1)
            temp = Divide(temp, 10)
        }
        
        // Add negative sign if needed
        IfCondition is_negative ThenBlock: {
            SetByte(buffer, 0, 45)  // '-'
        }
        
        // Add null terminator
        final_pos = digit_count
        IfCondition is_negative ThenBlock: {
            final_pos = Add(final_pos, 1)
        }
        SetByte(buffer, final_pos, 0)
        
        ReturnValue(buffer)
    }
}

// Build an integer response: :<num>\r\n
Function.RESP.Integer {
    Input: num: Integer
    Output: Address
    Body: {
        num_debug = num
        Debug("resp.build", level=2) {
            PrintMessage("[DEBUG] RESP.Integer: Building integer response for ")
            PrintNumber(num_debug)
        }

        num_str = RESP.IntToString(num)
        len = StringLength(num_str)
        
        response = Allocate(Add(len, 4))
        
        SetByte(response, 0, 58)  // ':'
        
        i = 0
        WhileLoop LessThan(i, len) {
            SetByte(response, Add(i, 1), GetByte(num_str, i))
            i = Add(i, 1)
        }
        
        SetByte(response, Add(len, 1), 13)
        SetByte(response, Add(len, 2), 10)
        SetByte(response, Add(len, 3), 0)
        
        Deallocate(num_str, 0)
        ReturnValue(response)
    }
}

// ============================================================================
// Add this function to Library.RESP.ailang
// ============================================================================

// Parse RESP array without copying strings (returns pointers into original buffer)
// WARNING: Caller must ensure buffer lifetime exceeds parsed array lifetime
// Returns array of string pointers directly into the buffer
Function.RESP.ParseArrayZeroCopy {
    Input: buffer: Address
    Input: size: Integer
    Output: Array
    Body: {
        Debug("resp.parse", level=2) {
            PrintMessage("[DEBUG] RESP.ParseArrayZeroCopy: Parsing buffer at ")
            PrintNumber(buffer)
            PrintMessage(" with size ")
            PrintNumber(size)
            PrintMessage("\n")
        }
        
        // Check for array marker '*'
        IfCondition NotEqual(GetByte(buffer, 0), 42) ThenBlock: {
            Debug("resp.parse", level=1) {
                PrintMessage("[DEBUG] RESP.ParseArrayZeroCopy: Not an array (first byte: ")
                PrintNumber(GetByte(buffer, 0))
                PrintMessage(")\n")
            }
            ReturnValue(0)  // Not an array
        }
        
        // Parse array count
        offset = 1
        count = RESP.ParseInteger(buffer, offset)
        
        Debug("resp.parse", level=2) {
            PrintMessage("[DEBUG] RESP.ParseArrayZeroCopy: Array count: ")
            PrintNumber(count)
            PrintMessage("\n")
        }
        
        // Handle empty or invalid array
        IfCondition LessEqual(count, 0) ThenBlock: {
            ReturnValue(ArrayCreate(0))
        }
        
        // Create array to hold results
        result = ArrayCreate(count)
        
        // Find start of first element (skip past count and \r\n)
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
            offset = Add(offset, 1)
        }
        offset = Add(offset, 1)  // Skip LF
        
        Debug("resp.parse", level=3) {
            PrintMessage("[DEBUG] RESP.ParseArrayZeroCopy: First element starts at offset ")
            PrintNumber(offset)
            PrintMessage("\n")
        }
        
        // Parse each element (zero-copy)
        i = 0
        WhileLoop LessThan(i, count) {
            Debug("resp.parse", level=3) {
                PrintMessage("[DEBUG] RESP.ParseArrayZeroCopy: Parsing element ")
                PrintNumber(i)
                PrintMessage(" at offset ")
                PrintNumber(offset)
                PrintMessage("\n")
            }
            
            element = RESP.ParseElementZeroCopy(buffer, offset, size)
            ArraySet(result, i, element)
            
            Debug("resp.parse", level=3) {
                PrintMessage("[DEBUG] RESP.ParseArrayZeroCopy: Element ")
                PrintNumber(i)
                PrintMessage(" = ")
                IfCondition NotEqual(element, 0) ThenBlock: {
                    PrintMessage(element)
                } ElseBlock: {
                    PrintMessage("(null)")
                }
                PrintMessage("\n")
            }
            
            // Move offset past this element
            offset = RESP.SkipElement(buffer, offset, size)
            
            i = Add(i, 1)
        }
        
        Debug("resp.parse", level=2) {
            PrintMessage("[DEBUG] RESP.ParseArrayZeroCopy: Complete, returning array\n")
        }
        
        ReturnValue(result)
    }
}

// Parse a single RESP element without copying (returns pointer into buffer)
Function.RESP.ParseElementZeroCopy {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        type_byte = GetByte(buffer, offset)
        
        Debug("resp.parse", level=4) {
            PrintMessage("[DEBUG] RESP.ParseElementZeroCopy: Type byte: ")
            PrintNumber(type_byte)
            PrintMessage(" (offset: ")
            PrintNumber(offset)
            PrintMessage(")\n")
        }
        
        // Bulk string ($)
        IfCondition EqualTo(type_byte, 36) ThenBlock: {
            ReturnValue(RESP.ParseBulkStringZeroCopy(buffer, offset, size))
        }
        
        // Simple string (+)
        IfCondition EqualTo(type_byte, 43) ThenBlock: {
            ReturnValue(RESP.ParseSimpleStringZeroCopy(buffer, offset, size))
        }
        
        // Integer (:) - must allocate for this since we convert to string
        IfCondition EqualTo(type_byte, 58) ThenBlock: {
            num = RESP.ParseInteger(buffer, Add(offset, 1))
            ReturnValue(NumberToString(num))  // This allocates - can't be zero-copy
        }
        
        // Error (-)
        IfCondition EqualTo(type_byte, 45) ThenBlock: {
            ReturnValue(RESP.ParseSimpleStringZeroCopy(buffer, offset, size))
        }
        
        ReturnValue(0)  // Unknown type
    }
}

// Parse bulk string zero-copy (returns pointer into buffer, modifies buffer for null terminator)
Function.RESP.ParseBulkStringZeroCopy {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        // Skip '$'
        offset = Add(offset, 1)
        
        // Parse length
        length = RESP.ParseInteger(buffer, offset)
        
        Debug("resp.parse", level=4) {
            PrintMessage("[DEBUG] RESP.ParseBulkStringZeroCopy: Length: ")
            PrintNumber(length)
            PrintMessage("\n")
        }
        
        // Check for null bulk string
        IfCondition LessThan(length, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Handle empty string
        IfCondition EqualTo(length, 0) ThenBlock: {
            // Return pointer to a null terminator somewhere safe
            // We'll just allocate a single byte for empty strings
            empty = Allocate(1)
            SetByte(empty, 0, 0)
            ReturnValue(empty)
        }
        
        // Find start of actual string (after \r\n)
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 10)) {
            offset = Add(offset, 1)
        }
        offset = Add(offset, 1)  // Skip LF
        
        // Return pointer directly into buffer
        // CRITICAL: Replace the \r at end with null terminator for C-string compatibility
        str_start = Add(buffer, offset)
        null_pos = Add(offset, length)  // Position where \r should be
        
        Debug("resp.parse", level=4) {
            PrintMessage("[DEBUG] RESP.ParseBulkStringZeroCopy: String starts at buffer+")
            PrintNumber(offset)
            PrintMessage(", null terminator at buffer+")
            PrintNumber(null_pos)
            PrintMessage("\n")
        }
        
        // Null-terminate by overwriting the \r (this modifies the buffer!)
        SetByte(buffer, null_pos, 0)
        
        ReturnValue(str_start)
    }
}

// Parse simple string zero-copy (returns pointer into buffer, modifies buffer)
Function.RESP.ParseSimpleStringZeroCopy {
    Input: buffer: Address
    Input: offset: Integer
    Input: size: Integer
    Output: Address
    Body: {
        // Skip type marker
        offset = Add(offset, 1)
        
        // Find end of string (\r)
        start = offset
        WhileLoop And(LessThan(offset, size), NotEqual(GetByte(buffer, offset), 13)) {
            offset = Add(offset, 1)
        }
        
        // Null-terminate by overwriting the \r
        SetByte(buffer, offset, 0)
        
        // Return pointer into buffer
        ReturnValue(Add(buffer, start))
    }
}

// ============================================================================
// USAGE NOTES
// ============================================================================
// Add these functions to Library.RESP.ailang after the existing RESP.ParseArray
//
// CRITICAL WARNING: Zero-copy parsing modifies the original buffer by replacing
// \r characters with null terminators. This means:
//   1. The buffer CANNOT be reused or re-parsed
//   2. The buffer must remain allocated while any parsed strings are in use
//   3. This is only safe when you control the buffer lifetime
//
// Use RESP.ParseArrayZeroCopy when:
//   - Performance is critical (avoid allocations)
//   - Buffer can be destroyed after parsing
//   - Parsed strings are short-lived
//
// Use RESP.ParseArray when:
//   - Buffer needs to be reused
//   - Parsed strings need to outlive the buffer
//   - Safety is more important than speed
// ============================================================================