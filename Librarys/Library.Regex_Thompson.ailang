// Library.Regex_Thompson_Fixed.ailang
// Thompson NFA Regex Engine - BUG FIX
// Fixed state structure alignment (40 bytes per state, not 24!)

// ============================================================================
// CONFIGURATION AND CONSTANTS
// ============================================================================

FixedPool.RegexFlags {
    "CASE_INSENSITIVE": Initialize=1
    "MULTILINE": Initialize=2
    "DOTALL": Initialize=4
    "VERBOSE": Initialize=8
    "UNICODE": Initialize=16
}

FixedPool.RegexConstants {
    "MAX_STATES": Initialize=4096
    "MAX_CAPTURES": Initialize=32
    "MAX_THREADS": Initialize=1024
    "CACHE_SIZE": Initialize=256
    "STATE_SIZE": Initialize=40
}

FixedPool.StateType {
    "CHAR": Initialize=0
    "RANGE": Initialize=1
    "DOT": Initialize=2
    "SPLIT": Initialize=3
    "MATCH": Initialize=4
    "SAVE": Initialize=5
    "EMPTY": Initialize=6
    "ASSERT_START": Initialize=7
    "ASSERT_END": Initialize=8
    "WORD_BOUNDARY": Initialize=9
    "NOT_WORD_BOUNDARY": Initialize=10
    "LOOKAHEAD": Initialize=11
    "LOOKBEHIND": Initialize=12
    "BACKREF": Initialize=13
}

// ============================================================================
// CORE DATA STRUCTURES
// ============================================================================

FixedPool.RegexState {
    "states": Initialize=0
    "num_states": Initialize=0
    "start_state": Initialize=0
    "capture_count": Initialize=0
}

FixedPool.CompilerState {
    "pattern": Initialize=0
    "pos": Initialize=0
    "len": Initialize=0
    "group_count": Initialize=0
    "flags": Initialize=0
    "error": Initialize=0
}

FixedPool.MatchState {
    "text": Initialize=0
    "text_len": Initialize=0
    "pos": Initialize=0
    "threads": Initialize=0
    "next_threads": Initialize=0
    "thread_count": Initialize=0
    "next_count": Initialize=0
    "captures": Initialize=0
    "thread_size": Initialize=0
}

// ============================================================================
// INITIALIZATION (Must be called before using library)
// ============================================================================

SubRoutine.InitializeRegexEngine {
    RegexState.states = 0
    RegexState.num_states = 0
    RegexState.start_state = 0
    RegexState.capture_count = 0
    
    CompilerState.pattern = 0
    CompilerState.pos = 0
    CompilerState.len = 0
    CompilerState.group_count = 0
    CompilerState.flags = 0
    CompilerState.error = 0
    
    MatchState.text = 0
    MatchState.text_len = 0
    MatchState.pos = 0
    MatchState.threads = 0
    MatchState.next_threads = 0
    MatchState.thread_count = 0
    MatchState.next_count = 0
    MatchState.captures = 0
    MatchState.thread_size = 0
}

// ============================================================================
// PUBLIC API
// ============================================================================

Function.Regex_Compile {
    Input: pattern: Address
    Input: flags: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(pattern, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        CompilerState.pattern = pattern
        CompilerState.pos = 0
        CompilerState.len = StringLength(pattern)
        CompilerState.group_count = 0
        CompilerState.flags = flags
        CompilerState.error = 0
        
        total_size = Multiply(RegexConstants.MAX_STATES, RegexConstants.STATE_SIZE)
        
        RegexState.states = Allocate(total_size)
        IfCondition EqualTo(RegexState.states, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        RegexState.num_states = 0
        
        // Initialize memory
        i = 0
        WhileLoop LessThan(i, total_size) {
            SetByte(RegexState.states, i, 0)
            i = Add(i, 1)
        }
        
        start_frag = ParsePattern()
        
        IfCondition EqualTo(start_frag, 0) ThenBlock: {
            Deallocate(RegexState.states, total_size)
            ReturnValue(0)
        }
        
        IfCondition NotEqual(CompilerState.error, 0) ThenBlock: {
            Deallocate(RegexState.states, total_size)
            Deallocate(start_frag, 16)
            ReturnValue(0)
        }
        
        match_state = AddState(StateType.MATCH, 0, 0)
        frag_out = Dereference(Add(start_frag, 8))
        PatchList(frag_out, match_state)
        
        handle = Allocate(32)
        IfCondition EqualTo(handle, 0) ThenBlock: {
            Deallocate(RegexState.states, total_size)
            Deallocate(start_frag, 16)
            ReturnValue(0)
        }
        
        StoreValue(handle, RegexState.states)
        StoreValue(Add(handle, 8), RegexState.num_states)
        frag_start = Dereference(start_frag)
        StoreValue(Add(handle, 16), frag_start)
        StoreValue(Add(handle, 24), CompilerState.group_count)
        
        Deallocate(start_frag, 16)
        ReturnValue(handle)
    }
}

Function.Regex_Match {
    Input: regex: Address
    Input: text: Address
    Input: start_pos: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(regex, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        IfCondition EqualTo(text, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        states = Dereference(regex)
        num_states = Dereference(Add(regex, 8))
        start_state = Dereference(Add(regex, 16))
        capture_count = Dereference(Add(regex, 24))
        
        MatchState.text = text
        MatchState.text_len = StringLength(text)
        MatchState.pos = start_pos
        
        // Fixed: thread size is 16 bytes (state_id + pos)
        MatchState.thread_size = 16
        
        IfCondition GreaterThan(start_pos, MatchState.text_len) ThenBlock: {
            ReturnValue(-1)
        }
        
        threads_size = Multiply(RegexConstants.MAX_THREADS, MatchState.thread_size)
        
        MatchState.threads = Allocate(threads_size)
        MatchState.next_threads = Allocate(threads_size)
        
        IfCondition EqualTo(MatchState.threads, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        IfCondition EqualTo(MatchState.next_threads, 0) ThenBlock: {
            Deallocate(MatchState.threads, threads_size)
            ReturnValue(-1)
        }
        
        MatchState.thread_count = 0
        MatchState.next_count = 0
        
        AddThread(start_state, start_pos, 0)
        
        WhileLoop LessEqual(MatchState.pos, MatchState.text_len) {
            ch = 0
            
            IfCondition LessThan(MatchState.pos, MatchState.text_len) ThenBlock: {
                ch = GetByte(text, MatchState.pos)
            }
            
            MatchState.next_count = 0
            i = 0
            WhileLoop LessThan(i, MatchState.thread_count) {
                thread = GetThread(i)
                state_id = Dereference(thread)
                
                result = ProcessState(states, state_id, ch, thread)
                
                IfCondition EqualTo(result, 1) ThenBlock: {
                    match_len = Subtract(MatchState.pos, start_pos)
                    Deallocate(MatchState.threads, threads_size)
                    Deallocate(MatchState.next_threads, threads_size)
                    ReturnValue(match_len)
                }
                
                i = Add(i, 1)
            }
            
            IfCondition LessThan(MatchState.pos, MatchState.text_len) ThenBlock: {
                temp = MatchState.threads
                MatchState.threads = MatchState.next_threads
                MatchState.next_threads = temp
                MatchState.thread_count = MatchState.next_count
                
                IfCondition EqualTo(MatchState.thread_count, 0) ThenBlock: {
                    Deallocate(MatchState.threads, threads_size)
                    Deallocate(MatchState.next_threads, threads_size)
                    ReturnValue(-1)
                }
            } ElseBlock: {
                BreakLoop
            }
            
            MatchState.pos = Add(MatchState.pos, 1)
        }
        
        // Check final states
        i = 0
        WhileLoop LessThan(i, MatchState.thread_count) {
            thread = GetThread(i)
            state_id = Dereference(thread)
            state_type = GetStateType(states, state_id)
            
            IfCondition EqualTo(state_type, StateType.MATCH) ThenBlock: {
                match_len = Subtract(MatchState.pos, start_pos)
                Deallocate(MatchState.threads, threads_size)
                Deallocate(MatchState.next_threads, threads_size)
                ReturnValue(match_len)
            }
            
            i = Add(i, 1)
        }
        
        Deallocate(MatchState.threads, threads_size)
        Deallocate(MatchState.next_threads, threads_size)
        ReturnValue(-1)
    }
}

Function.Regex_Free {
    Input: regex: Address
    Body: {
        IfCondition EqualTo(regex, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        states = Dereference(regex)
        total_size = Multiply(RegexConstants.MAX_STATES, RegexConstants.STATE_SIZE)
        
        IfCondition NotEqual(states, 0) ThenBlock: {
            Deallocate(states, total_size)
        }
        
        Deallocate(regex, 32)
        ReturnValue(1)
    }
}

// ============================================================================
// PARSER FUNCTIONS
// ============================================================================

Function.ParsePattern {
    Output: Address
    Body: {
        frag = ParseAlt()
        ReturnValue(frag)
    }
}

Function.ParseAlt {
    Output: Address
    Body: {
        left = ParseSeq()
        
        IfCondition EqualTo(left, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        WhileLoop 1 {
            IfCondition GreaterEqual(CompilerState.pos, CompilerState.len) ThenBlock: {
                BreakLoop
            }
            
            ch = GetByte(CompilerState.pattern, CompilerState.pos)
            IfCondition NotEqual(ch, 124) ThenBlock: {
                BreakLoop
            }
            
            CompilerState.pos = Add(CompilerState.pos, 1)
            right = ParseSeq()
            
            IfCondition EqualTo(right, 0) ThenBlock: {
                Deallocate(left, 16)
                ReturnValue(0)
            }
            
            split = AddState(StateType.SPLIT, 0, 0)
            left_start = Dereference(left)
            right_start = Dereference(right)
            SetStateOut1(split, left_start)
            SetStateOut2(split, right_start)
            
            left_out = Dereference(Add(left, 8))
            right_out = Dereference(Add(right, 8))
            new_out = MergeLists(left_out, right_out)
            
            Deallocate(left, 16)
            Deallocate(right, 16)
            
            left = Allocate(16)
            IfCondition EqualTo(left, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            StoreValue(left, split)
            StoreValue(Add(left, 8), new_out)
        }
        
        ReturnValue(left)
    }
}

Function.ParseSeq {
    Output: Address
    Body: {
        result = 0
        
        WhileLoop 1 {
            IfCondition GreaterEqual(CompilerState.pos, CompilerState.len) ThenBlock: {
                BreakLoop
            }
            
            ch = GetByte(CompilerState.pattern, CompilerState.pos)
            
            IfCondition EqualTo(ch, 124) ThenBlock: { BreakLoop }
            IfCondition EqualTo(ch, 41) ThenBlock: { BreakLoop }
            
            atom = ParseAtom()
            
            IfCondition EqualTo(atom, 0) ThenBlock: {
                IfCondition NotEqual(result, 0) ThenBlock: {
                    Deallocate(result, 16)
                }
                ReturnValue(0)
            }
            
            IfCondition EqualTo(result, 0) ThenBlock: {
                result = atom
            } ElseBlock: {
                result_out = Dereference(Add(result, 8))
                atom_start = Dereference(atom)
                PatchList(result_out, atom_start)
                
                result_start = Dereference(result)
                atom_out = Dereference(Add(atom, 8))
                
                Deallocate(result, 16)
                Deallocate(atom, 16)
                
                result = Allocate(16)
                IfCondition EqualTo(result, 0) ThenBlock: {
                    ReturnValue(0)
                }
                
                StoreValue(result, result_start)
                StoreValue(Add(result, 8), atom_out)
            }
        }
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            empty = AddState(StateType.EMPTY, 0, 0)
            result = Allocate(16)
            IfCondition NotEqual(result, 0) ThenBlock: {
                StoreValue(result, empty)
                list = CreateList(empty)
                StoreValue(Add(result, 8), list)
            }
        }
        
        ReturnValue(result)
    }
}

Function.ParseAtom {
    Output: Address
    Body: {
        IfCondition GreaterEqual(CompilerState.pos, CompilerState.len) ThenBlock: {
            ReturnValue(0)
        }
        
        ch = GetByte(CompilerState.pattern, CompilerState.pos)
        
        IfCondition EqualTo(ch, 46) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            state = AddState(StateType.DOT, 0, 0)
            frag = Allocate(16)
            IfCondition NotEqual(frag, 0) ThenBlock: {
                StoreValue(frag, state)
                list = CreateList(state)
                StoreValue(Add(frag, 8), list)
            }
            ReturnValue(ParsePost(frag))
        }
        
        IfCondition EqualTo(ch, 94) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            state = AddState(StateType.ASSERT_START, 0, 0)
            frag = Allocate(16)
            IfCondition NotEqual(frag, 0) ThenBlock: {
                StoreValue(frag, state)
                list = CreateList(state)
                StoreValue(Add(frag, 8), list)
            }
            ReturnValue(frag)
        }
        
        IfCondition EqualTo(ch, 36) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            state = AddState(StateType.ASSERT_END, 0, 0)
            frag = Allocate(16)
            IfCondition NotEqual(frag, 0) ThenBlock: {
                StoreValue(frag, state)
                list = CreateList(state)
                StoreValue(Add(frag, 8), list)
            }
            ReturnValue(frag)
        }
        
        IfCondition EqualTo(ch, 40) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            sub = ParseAlt()
            IfCondition GreaterEqual(CompilerState.pos, CompilerState.len) ThenBlock: {
                CompilerState.error = 1
                ReturnValue(0)
            }
            ch = GetByte(CompilerState.pattern, CompilerState.pos)
            IfCondition NotEqual(ch, 41) ThenBlock: {
                CompilerState.error = 1
                ReturnValue(0)
            }
            CompilerState.pos = Add(CompilerState.pos, 1)
            ReturnValue(ParsePost(sub))
        }
        
        IfCondition EqualTo(ch, 91) ThenBlock: {
            ReturnValue(ParseClass())
        }
        
        IfCondition EqualTo(ch, 92) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            IfCondition GreaterEqual(CompilerState.pos, CompilerState.len) ThenBlock: {
                CompilerState.error = 1
                ReturnValue(0)
            }
            ch = GetByte(CompilerState.pattern, CompilerState.pos)
            CompilerState.pos = Add(CompilerState.pos, 1)
            
            IfCondition EqualTo(ch, 110) ThenBlock: { ch = 10 }
            IfCondition EqualTo(ch, 114) ThenBlock: { ch = 13 }
            IfCondition EqualTo(ch, 116) ThenBlock: { ch = 9 }
            
            state = AddState(StateType.CHAR, ch, 0)
            frag = Allocate(16)
            IfCondition NotEqual(frag, 0) ThenBlock: {
                StoreValue(frag, state)
                list = CreateList(state)
                StoreValue(Add(frag, 8), list)
            }
            ReturnValue(ParsePost(frag))
        }
        
        // Literal character
        CompilerState.pos = Add(CompilerState.pos, 1)
        state = AddState(StateType.CHAR, ch, 0)
        frag = Allocate(16)
        IfCondition NotEqual(frag, 0) ThenBlock: {
            StoreValue(frag, state)
            list = CreateList(state)
            StoreValue(Add(frag, 8), list)
        }
        ReturnValue(ParsePost(frag))
    }
}

Function.ParsePost {
    Input: atom: Address
    Output: Address
    Body: {
        IfCondition EqualTo(atom, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition GreaterEqual(CompilerState.pos, CompilerState.len) ThenBlock: {
            ReturnValue(atom)
        }
        
        ch = GetByte(CompilerState.pattern, CompilerState.pos)
        
        IfCondition EqualTo(ch, 42) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            split = AddState(StateType.SPLIT, 0, 0)
            atom_start = Dereference(atom)
            SetStateOut1(split, atom_start)
            atom_out = Dereference(Add(atom, 8))
            PatchList(atom_out, split)
            
            out = CreateList(split)
            SetListNext(out, 1)
            
            result = Allocate(16)
            IfCondition NotEqual(result, 0) ThenBlock: {
                StoreValue(result, split)
                StoreValue(Add(result, 8), out)
            }
            
            Deallocate(atom, 16)
            ReturnValue(result)
        }
        
        IfCondition EqualTo(ch, 43) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            split = AddState(StateType.SPLIT, 0, 0)
            atom_start = Dereference(atom)
            SetStateOut1(split, atom_start)
            atom_out = Dereference(Add(atom, 8))
            PatchList(atom_out, split)
            
            out = CreateList(split)
            SetListNext(out, 1)
            
            result = Allocate(16)
            IfCondition NotEqual(result, 0) ThenBlock: {
                StoreValue(result, atom_start)
                StoreValue(Add(result, 8), out)
            }
            
            Deallocate(atom, 16)
            ReturnValue(result)
        }
        
        IfCondition EqualTo(ch, 63) ThenBlock: {
            CompilerState.pos = Add(CompilerState.pos, 1)
            split = AddState(StateType.SPLIT, 0, 0)
            atom_start = Dereference(atom)
            SetStateOut1(split, atom_start)
            
            atom_out = Dereference(Add(atom, 8))
            split_out = CreateList(split)
            SetListNext(split_out, 1)
            
            out_list = MergeLists(atom_out, split_out)
            
            result = Allocate(16)
            IfCondition NotEqual(result, 0) ThenBlock: {
                StoreValue(result, split)
                StoreValue(Add(result, 8), out_list)
            }
            
            Deallocate(atom, 16)
            ReturnValue(result)
        }
        
        ReturnValue(atom)
    }
}

Function.ParseClass {
    Output: Address
    Body: {
        CompilerState.pos = Add(CompilerState.pos, 1)
        
        negated = 0
        ch = GetByte(CompilerState.pattern, CompilerState.pos)
        IfCondition EqualTo(ch, 94) ThenBlock: {
            negated = 1
            CompilerState.pos = Add(CompilerState.pos, 1)
        }
        
        bitmap = Allocate(32)
        IfCondition EqualTo(bitmap, 0) ThenBlock: {
            CompilerState.error = 1
            ReturnValue(0)
        }
        
        // Initialize bitmap
        i = 0
        WhileLoop LessThan(i, 32) {
            SetByte(bitmap, i, 0)
            i = Add(i, 1)
        }
        
        WhileLoop 1 {
            IfCondition GreaterEqual(CompilerState.pos, CompilerState.len) ThenBlock: {
                CompilerState.error = 1
                Deallocate(bitmap, 32)
                ReturnValue(0)
            }
            
            ch = GetByte(CompilerState.pattern, CompilerState.pos)
            
            IfCondition EqualTo(ch, 93) ThenBlock: {
                CompilerState.pos = Add(CompilerState.pos, 1)
                BreakLoop
            }
            
            CompilerState.pos = Add(CompilerState.pos, 1)
            SetBit(bitmap, ch)
        }
        
        state = AddState(StateType.RANGE, bitmap, negated)
        frag = Allocate(16)
        IfCondition NotEqual(frag, 0) ThenBlock: {
            StoreValue(frag, state)
            list = CreateList(state)
            StoreValue(Add(frag, 8), list)
        }
        ReturnValue(ParsePost(frag))
    }
}

// ============================================================================
// STATE MANAGEMENT - FIXED FOR 40-BYTE ALIGNMENT
// ============================================================================

Function.AddState {
    Input: type: Integer
    Input: data1: Integer
    Input: data2: Integer
    Output: Integer
    Body: {
        state_id = RegexState.num_states
        
        IfCondition GreaterEqual(state_id, RegexConstants.MAX_STATES) ThenBlock: {
            CompilerState.error = 1
            ReturnValue(-1)
        }
        
        IfCondition EqualTo(RegexState.states, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        offset = Multiply(state_id, RegexConstants.STATE_SIZE)
        base = Add(RegexState.states, offset)
        
        // Proper 8-byte aligned offsets
        StoreValue(base, type)              // offset 0
        StoreValue(Add(base, 8), data1)     // offset 8
        StoreValue(Add(base, 16), data2)    // offset 16
        StoreValue(Add(base, 24), -1)       // offset 24 (out1)
        StoreValue(Add(base, 32), -1)       // offset 32 (out2)
        
        RegexState.num_states = Add(state_id, 1)
        ReturnValue(state_id)
    }
}

Function.GetStateType {
    Input: states: Address
    Input: state_id: Integer
    Output: Integer
    Body: {
        IfCondition LessThan(state_id, 0) ThenBlock: {
            ReturnValue(-1)
        }
        offset = Multiply(state_id, RegexConstants.STATE_SIZE)
        ReturnValue(Dereference(Add(states, offset)))
    }
}

Function.SetStateOut1 {
    Input: state_id: Integer
    Input: target: Integer
    Body: {
        offset = Multiply(state_id, RegexConstants.STATE_SIZE)
        base = Add(RegexState.states, offset)
        StoreValue(Add(base, 24), target)
    }
}

Function.SetStateOut2 {
    Input: state_id: Integer
    Input: target: Integer
    Body: {
        offset = Multiply(state_id, RegexConstants.STATE_SIZE)
        base = Add(RegexState.states, offset)
        StoreValue(Add(base, 32), target)
    }
}

// ============================================================================
// LIST MANAGEMENT
// ============================================================================

Function.CreateList {
    Input: state_id: Integer
    Output: Address
    Body: {
        list = Allocate(16)
        IfCondition NotEqual(list, 0) ThenBlock: {
            StoreValue(list, state_id)
            StoreValue(Add(list, 8), 0)
            StoreValue(Add(list, 12), 0)
        }
        ReturnValue(list)
    }
}

Function.SetListNext {
    Input: list: Address
    Input: is_out2: Integer
    Body: {
        IfCondition NotEqual(list, 0) ThenBlock: {
            StoreValue(Add(list, 12), is_out2)
        }
    }
}

Function.MergeLists {
    Input: list1: Address
    Input: list2: Address
    Output: Address
    Body: {
        IfCondition EqualTo(list1, 0) ThenBlock: {
            ReturnValue(list2)
        }
        IfCondition EqualTo(list2, 0) ThenBlock: {
            ReturnValue(list1)
        }
        
        current = list1
        WhileLoop 1 {
            next = Dereference(Add(current, 8))
            IfCondition EqualTo(next, 0) ThenBlock: {
                StoreValue(Add(current, 8), list2)
                BreakLoop
            }
            current = next
        }
        
        ReturnValue(list1)
    }
}

Function.PatchList {
    Input: list: Address
    Input: target: Integer
    Body: {
        WhileLoop NotEqual(list, 0) {
            state_id = Dereference(list)
            is_out2 = Dereference(Add(list, 12))
            
            offset = Multiply(state_id, RegexConstants.STATE_SIZE)
            state = Add(RegexState.states, offset)
            
            IfCondition EqualTo(is_out2, 0) ThenBlock: {
                out1 = Dereference(Add(state, 24))
                IfCondition EqualTo(out1, -1) ThenBlock: {
                    StoreValue(Add(state, 24), target)
                }
            } ElseBlock: {
                out2 = Dereference(Add(state, 32))
                IfCondition EqualTo(out2, -1) ThenBlock: {
                    StoreValue(Add(state, 32), target)
                }
            }
            
            list = Dereference(Add(list, 8))
        }
    }
}

// ============================================================================
// THREAD MANAGEMENT
// ============================================================================

Function.AddThread {
    Input: state_id: Integer
    Input: pos: Integer
    Input: captures: Address
    Body: {
        IfCondition GreaterEqual(MatchState.thread_count, RegexConstants.MAX_THREADS) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check for duplicate threads
        i = 0
        WhileLoop LessThan(i, MatchState.thread_count) {
            thread = GetThread(i)
            IfCondition EqualTo(Dereference(thread), state_id) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        
        thread = GetThread(MatchState.thread_count)
        StoreValue(thread, state_id)
        StoreValue(Add(thread, 8), pos)
        
        MatchState.thread_count = Add(MatchState.thread_count, 1)
        ReturnValue(1)
    }
}

Function.GetThread {
    Input: index: Integer
    Output: Address
    Body: {
        offset = Multiply(index, MatchState.thread_size)
        ReturnValue(Add(MatchState.threads, offset))
    }
}

Function.ProcessState {
    Input: states: Address
    Input: state_id: Integer
    Input: ch: Integer
    Input: thread: Address
    Output: Integer
    Body: {
        IfCondition LessThan(state_id, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        offset = Multiply(state_id, RegexConstants.STATE_SIZE)
        state = Add(states, offset)
        
        type = Dereference(state)
        data1 = Dereference(Add(state, 8))
        data2 = Dereference(Add(state, 16))
        out1 = Dereference(Add(state, 24))
        out2 = Dereference(Add(state, 32))
        
        IfCondition EqualTo(type, StateType.CHAR) ThenBlock: {
            IfCondition EqualTo(data1, ch) ThenBlock: {
                AddNextThread(out1, Add(MatchState.pos, 1), thread)
            }
            ReturnValue(0)
        }
        
        IfCondition EqualTo(type, StateType.RANGE) ThenBlock: {
            hit = TestBit(data1, ch)
            IfCondition EqualTo(data2, 1) ThenBlock: {
                hit = Not2(hit)
            }
            IfCondition NotEqual(hit, 0) ThenBlock: {
                AddNextThread(out1, Add(MatchState.pos, 1), thread)
            }
            ReturnValue(0)
        }
        
        IfCondition EqualTo(type, StateType.DOT) ThenBlock: {
            IfCondition NotEqual(ch, 10) ThenBlock: {
                AddNextThread(out1, Add(MatchState.pos, 1), thread)
            }
            ReturnValue(0)
        }
        
        IfCondition EqualTo(type, StateType.SPLIT) ThenBlock: {
            AddThread(out1, MatchState.pos, thread)
            IfCondition NotEqual(out2, -1) ThenBlock: {
                AddThread(out2, MatchState.pos, thread)
            }
            ReturnValue(0)
        }
        
        IfCondition EqualTo(type, StateType.MATCH) ThenBlock: {
            ReturnValue(1)
        }
        
        IfCondition EqualTo(type, StateType.EMPTY) ThenBlock: {
            AddThread(out1, MatchState.pos, thread)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(type, StateType.ASSERT_START) ThenBlock: {
            IfCondition EqualTo(MatchState.pos, 0) ThenBlock: {
                AddThread(out1, MatchState.pos, thread)
            }
            ReturnValue(0)
        }
        
        IfCondition EqualTo(type, StateType.ASSERT_END) ThenBlock: {
            IfCondition EqualTo(MatchState.pos, MatchState.text_len) ThenBlock: {
                AddThread(out1, MatchState.pos, thread)
            }
            ReturnValue(0)
        }
        
        ReturnValue(0)
    }
}

Function.AddNextThread {
    Input: state_id: Integer
    Input: pos: Integer
    Input: captures: Address
    Body: {
        IfCondition GreaterEqual(MatchState.next_count, RegexConstants.MAX_THREADS) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check for duplicate threads
        i = 0
        WhileLoop LessThan(i, MatchState.next_count) {
            thread = GetNextThread(i)
            IfCondition EqualTo(Dereference(thread), state_id) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        
        thread = GetNextThread(MatchState.next_count)
        StoreValue(thread, state_id)
        StoreValue(Add(thread, 8), pos)
        
        MatchState.next_count = Add(MatchState.next_count, 1)
        ReturnValue(1)
    }
}

Function.GetNextThread {
    Input: index: Integer
    Output: Address
    Body: {
        offset = Multiply(index, MatchState.thread_size)
        ReturnValue(Add(MatchState.next_threads, offset))
    }
}

// ============================================================================
// BIT OPERATIONS
// ============================================================================

Function.SetBit {
    Input: bitmap: Address
    Input: bit: Integer
    Body: {
        IfCondition GreaterEqual(bit, 256) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition LessThan(bit, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        byte_offset = Divide(bit, 8)
        bit_offset = Modulo(bit, 8)
        byte_val = GetByte(bitmap, byte_offset)
        mask = LeftShift(1, bit_offset)
        SetByte(bitmap, byte_offset, BitwiseOr(byte_val, mask))
        ReturnValue(1)
    }
}

Function.TestBit {
    Input: bitmap: Address
    Input: bit: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(bit, 256) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition LessThan(bit, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        byte_offset = Divide(bit, 8)
        bit_offset = Modulo(bit, 8)
        byte_val = GetByte(bitmap, byte_offset)
        mask = LeftShift(1, bit_offset)
        ReturnValue(BitwiseAnd(byte_val, mask))
    }
}

Function.Not2 {
    Input: val: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(val, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}