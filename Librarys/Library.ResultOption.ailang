// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.ResultOption.ailang
// Result and Option types for safe error handling and null safety
// Provides Rust-style Result<T,E> and Option<T> as a library



// === Result Type for Error Handling ===

Record.Result {
    is_ok: Boolean
    ok_value: Address
    err_value: Address
    err_code: Integer
}

// Create a successful Result
Function.Result.Ok {
    Input: value: Address
    Output: Address
    Body: {
        result = Allocate(32)
        SetField(result, "is_ok", 1)
        SetField(result, "ok_value", value)
        SetField(result, "err_value", 0)
        SetField(result, "err_code", 0)
        ReturnValue(result)
    }
}

// Create an error Result
Function.Result.Err {
    Input: error: Address
    Input: code: Integer
    Output: Address
    Body: {
        result = Allocate(32)
        SetField(result, "is_ok", 0)
        SetField(result, "ok_value", 0)
        SetField(result, "err_value", error)
        SetField(result, "err_code", code)
        ReturnValue(result)
    }
}

// Check if Result is Ok
Function.Result.IsOk {
    Input: result: Address
    Output: Boolean
    Body: {
        ReturnValue(GetField(result, "is_ok"))
    }
}

// Check if Result is Err
Function.Result.IsErr {
    Input: result: Address
    Output: Boolean
    Body: {
        is_ok = GetField(result, "is_ok")
        ReturnValue(Subtract(1, is_ok))
    }
}

// Unwrap Result (panics on error)
Function.Result.Unwrap {
    Input: result: Address
    Output: Address
    Body: {
        is_ok = GetField(result, "is_ok")
        
        IfCondition EqualTo(is_ok, 0) ThenBlock: {
            PrintMessage("[PANIC] Result.Unwrap called on Err value: ")
            err_msg = GetField(result, "err_value")
            PrintMessage(err_msg)
            PrintMessage("\n")
            SystemCall(60, 1) // exit(1)
        }
        
        ReturnValue(GetField(result, "ok_value"))
    }
}

// Unwrap with default value
Function.Result.UnwrapOr {
    Input: result: Address
    Input: default: Address
    Output: Address
    Body: {
        is_ok = GetField(result, "is_ok")
        
        IfCondition is_ok ThenBlock: {
            ReturnValue(GetField(result, "ok_value"))
        } ElseBlock: {
            ReturnValue(default)
        }
    }
}

// Map over Ok value
Function.Result.Map {
    Input: result: Address
    Input: transform_fn: Address
    Output: Address
    Body: {
        is_ok = GetField(result, "is_ok")
        
        IfCondition is_ok ThenBlock: {
            ok_value = GetField(result, "ok_value")
            new_value = CallIndirect(transform_fn, ok_value)
            ReturnValue(Result.Ok(new_value))
        } ElseBlock: {
            ReturnValue(result) // Pass through error
        }
    }
}

// Chain Results (monadic bind)
Function.Result.AndThen {
    Input: result: Address
    Input: next_fn: Address
    Output: Address
    Body: {
        is_ok = GetField(result, "is_ok")
        
        IfCondition is_ok ThenBlock: {
            ok_value = GetField(result, "ok_value")
            ReturnValue(CallIndirect(next_fn, ok_value))
        } ElseBlock: {
            ReturnValue(result) // Pass through error
        }
    }
}

// === Option Type for Null Safety ===

Record.Option {
    has_value: Boolean
    value: Address
}

// Create Some variant
Function.Option.Some {
    Input: value: Address
    Output: Address
    Body: {
        option = Allocate(16)
        SetField(option, "has_value", 1)
        SetField(option, "value", value)
        ReturnValue(option)
    }
}

// Create None variant
Function.Option.None {
    Output: Address
    Body: {
        option = Allocate(16)
        SetField(option, "has_value", 0)
        SetField(option, "value", 0)
        ReturnValue(option)
    }
}

// Check if Option has value
Function.Option.IsSome {
    Input: option: Address
    Output: Boolean
    Body: {
        ReturnValue(GetField(option, "has_value"))
    }
}

// Check if Option is None
Function.Option.IsNone {
    Input: option: Address
    Output: Boolean
    Body: {
        has_value = GetField(option, "has_value")
        ReturnValue(Subtract(1, has_value))
    }
}

// Unwrap Option (panics on None)
Function.Option.Unwrap {
    Input: option: Address
    Output: Address
    Body: {
        has_value = GetField(option, "has_value")
        
        IfCondition EqualTo(has_value, 0) ThenBlock: {
            PrintMessage("[PANIC] Option.Unwrap called on None value\n")
            SystemCall(60, 1) // exit(1)
        }
        
        ReturnValue(GetField(option, "value"))
    }
}

// Unwrap with default
Function.Option.UnwrapOr {
    Input: option: Address
    Input: default: Address
    Output: Address
    Body: {
        has_value = GetField(option, "has_value")
        
        IfCondition has_value ThenBlock: {
            ReturnValue(GetField(option, "value"))
        } ElseBlock: {
            ReturnValue(default)
        }
    }
}

// Map over Some value
Function.Option.Map {
    Input: option: Address
    Input: transform_fn: Address
    Output: Address
    Body: {
        has_value = GetField(option, "has_value")
        
        IfCondition has_value ThenBlock: {
            value = GetField(option, "value")
            new_value = CallIndirect(transform_fn, value)
            ReturnValue(Option.Some(new_value))
        } ElseBlock: {
            ReturnValue(option) // Return None
        }
    }
}

// Filter Option based on predicate
Function.Option.Filter {
    Input: option: Address
    Input: predicate_fn: Address
    Output: Address
    Body: {
        has_value = GetField(option, "has_value")
        
        IfCondition has_value ThenBlock: {
            value = GetField(option, "value")
            keep = CallIndirect(predicate_fn, value)
            
            IfCondition keep ThenBlock: {
                ReturnValue(option)
            } ElseBlock: {
                ReturnValue(Option.None())
            }
        } ElseBlock: {
            ReturnValue(option) // Already None
        }
    }
}

// Convert Option to Result
Function.Option.OkOr {
    Input: option: Address
    Input: err: Address
    Output: Address
    Body: {
        has_value = GetField(option, "has_value")
        
        IfCondition has_value ThenBlock: {
            value = GetField(option, "value")
            ReturnValue(Result.Ok(value))
        } ElseBlock: {
            ReturnValue(Result.Err(err, 0))
        }
    }
}

// === Utility Functions ===

// Try operator (? in Rust) - early return on error
Function.Result.Try {
    Input: result: Address
    Input: return_addr: Address
    Output: Address
    Body: {
        is_ok = GetField(result, "is_ok")
        
        IfCondition EqualTo(is_ok, 0) ThenBlock: {
            // Early return with error
            Jump(return_addr)
        }
        
        ReturnValue(GetField(result, "ok_value"))
    }
}

// Example usage function
Function.Example.SafeDivide {
    Input: a: Integer
    Input: b: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(b, 0) ThenBlock: {
            ReturnValue(Result.Err("Division by zero", 1))
        }
        
        result = Divide(a, b)
        ReturnValue(Result.Ok(result))
    }
}

// Example with Option
Function.Example.FindElement {
    Input: array: Address
    Input: target: Integer
    Output: Address
    Body: {
        size = ArraySize(array)
        i = 0
        
        WhileLoop LessThan(i, size) {
            element = ArrayGet(array, i)
            
            IfCondition EqualTo(element, target) ThenBlock: {
                ReturnValue(Option.Some(i))
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(Option.None())
    }
}

// Chaining operations example
Function.Example.ProcessData {
    Input: data: Address
    Output: Address
    Body: {
        // Parse data
        parsed = ParseData(data)
        
        // Validate
        validated = Result.AndThen(parsed, ValidateData)
        
        // Transform
        transformed = Result.Map(validated, TransformData)
        
        // Return result or default
        ReturnValue(Result.UnwrapOr(transformed, DefaultData()))
    }
}