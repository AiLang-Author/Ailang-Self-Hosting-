// Library.SQL.ailang - 
// High-level SQL abstraction layer for AILANG
// Composes on PostgreSQL_Complete to provide simple database operations

LibraryImport.PostgreSQL_Complete
LibraryImport.XArrays
LibraryImport.HashMap
LibraryImport.StringUtils

Debug("library.load", level=1) {
    PrintMessage("Loading SQL Library v1.0\n")
    PrintMessage("========================\n")
}

// =============================================================================
// CONNECTION POOL MANAGEMENT
// =============================================================================

// Create a connection pool
// Pool structure: [connections:XArray, available:XArray, total:int, max:int, host, port, db, user, pass]
Function.SQL.CreatePool {
    Input: host: Address
    Input: port: Integer
    Input: database: Address
    Input: user: Address
    Input: password: Address
    Input: pool_size: Integer
    Output: Address
    Body: {
        Debug("sql_pool", level=1) {
            PrintMessage("Creating connection pool (size=")
            PrintNumber(pool_size)
            PrintMessage(")\n")
        }
        
        // Allocate pool structure: 72 bytes
        // [connections_array:8, available_flags:8, total:8, max:8, host:8, port:8, db:8, user:8, pass:8]
        pool = Allocate(72)
        
        // Create arrays
        connections = XArray.XCreate(pool_size)
        available = XArray.XCreate(pool_size)
        
        StoreValue(pool, connections)
        StoreValue(Add(pool, 8), available)
        StoreValue(Add(pool, 16), 0)  // total connections
        StoreValue(Add(pool, 24), pool_size)  // max connections
        
        // Store connection parameters
        host_copy = Helpers.StringCopy(host)
        db_copy = Helpers.StringCopy(database)
        user_copy = Helpers.StringCopy(user)
        pass_copy = Helpers.StringCopy(password)
        
        StoreValue(Add(pool, 32), host_copy)
        StoreValue(Add(pool, 40), port)
        StoreValue(Add(pool, 48), db_copy)
        StoreValue(Add(pool, 56), user_copy)
        StoreValue(Add(pool, 64), pass_copy)
        
        Debug("sql_pool", level=1) {
            PrintMessage("Connection pool created\n")
        }
        
        ReturnValue(pool)
    }
}

// Get a connection from the pool
Function.SQL.GetConnection {
    Input: pool: Address
    Output: Address
    Body: {
        connections = Dereference(pool)
        available = Dereference(Add(pool, 8))
        total = Dereference(Add(pool, 16))
        max_conns = Dereference(Add(pool, 24))
        
        // First, look for an available connection
        i = 0
        WhileLoop LessThan(i, total) {
            is_available = XArray.XGet(available, i)
            
            IfCondition EqualTo(is_available, 1) ThenBlock: {
                // Mark as in-use
                XArray.XSet(available, i, 0)
                conn = XArray.XGet(connections, i)
                
                Debug("sql_pool", level=2) {
                    PrintMessage("Reusing connection ")
                    PrintNumber(i)
                    PrintMessage("\n")
                }
                
                ReturnValue(conn)
            }
            
            i = Add(i, 1)
        }
        
        // No available connection, create new if under limit
        IfCondition LessThan(total, max_conns) ThenBlock: {
            Debug("sql_pool", level=1) {
                PrintMessage("Creating new connection (")
                PrintNumber(total)
                PrintMessage("/")
                PrintNumber(max_conns)
                PrintMessage(")\n")
            }
            
            host = Dereference(Add(pool, 32))
            port = Dereference(Add(pool, 40))
            db = Dereference(Add(pool, 48))
            user = Dereference(Add(pool, 56))
            pass = Dereference(Add(pool, 64))
            
            conn = PG_Connect(host, port, db, user, pass)
            
            IfCondition NotEqual(conn, 0) ThenBlock: {
                XArray.XPush(connections, conn)
                XArray.XPush(available, 0)  // Mark as in-use
                StoreValue(Add(pool, 16), Add(total, 1))
                
                ReturnValue(conn)
            } ElseBlock: {
                PrintMessage("ERROR: Failed to create connection\n")
                ReturnValue(0)
            }
        }
        
        PrintMessage("ERROR: Connection pool exhausted\n")
        ReturnValue(0)
    }
}

// Release a connection back to the pool
Function.SQL.ReleaseConnection {
    Input: pool: Address
    Input: conn: Address
    Body: {
        connections = Dereference(pool)
        available = Dereference(Add(pool, 8))
        total = Dereference(Add(pool, 16))
        
        // Find the connection and mark as available
        i = 0
        WhileLoop LessThan(i, total) {
            pool_conn = XArray.XGet(connections, i)
            
            IfCondition EqualTo(pool_conn, conn) ThenBlock: {
                XArray.XSet(available, i, 1)
                
                Debug("sql_pool", level=2) {
                    PrintMessage("Released connection ")
                    PrintNumber(i)
                    PrintMessage("\n")
                }
                
                ReturnValue(1)
            }
            
            i = Add(i, 1)
        }
        
        PrintMessage("WARNING: Connection not found in pool\n")
    }
}

// Destroy connection pool
Function.SQL.DestroyPool {
    Input: pool: Address
    Body: {
        IfCondition EqualTo(pool, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        connections = Dereference(pool)
        available = Dereference(Add(pool, 8))
        total = Dereference(Add(pool, 16))
        
        // Disconnect all connections
        i = 0
        WhileLoop LessThan(i, total) {
            conn = XArray.XGet(connections, i)
            PG_Disconnect(conn)
            i = Add(i, 1)
        }
        
        // Free arrays
        XArray.XDestroy(connections)
        XArray.XDestroy(available)
        
        // Free connection parameters
        host = Dereference(Add(pool, 32))
        db = Dereference(Add(pool, 48))
        user = Dereference(Add(pool, 56))
        pass = Dereference(Add(pool, 64))
        
        Deallocate(host, 0)
        Deallocate(db, 0)
        Deallocate(user, 0)
        Deallocate(pass, 0)
        
        // Free pool structure
        Deallocate(pool, 72)
        
        Debug("sql_pool", level=1) {
            PrintMessage("Connection pool destroyed\n")
        }
    }
}

// =============================================================================
// SIMPLE QUERY BUILDERS
// =============================================================================

// SELECT query builder
Function.SQL.Select {
    Input: conn: Address
    Input: table: Address
    Input: columns: Address
    Input: where_clause: Address
    Output: Address
    Body: {
        // Build: SELECT columns FROM table [WHERE where_clause]
        query = StringConcat("SELECT ", columns)
        query2 = StringConcat(query, " FROM ")
        query3 = StringConcat(query2, table)
        
        Deallocate(query, 0)
        Deallocate(query2, 0)
        
        final_query = 0
        
        IfCondition NotEqual(where_clause, 0) ThenBlock: {
            where_len = StringLength(where_clause)
            IfCondition GreaterThan(where_len, 0) ThenBlock: {
                query4 = StringConcat(query3, " WHERE ")
                final_query = StringConcat(query4, where_clause)
                Deallocate(query3, 0)
                Deallocate(query4, 0)
            } ElseBlock: {
                final_query = query3
            }
        } ElseBlock: {
            final_query = query3
        }
        
        Debug("sql_query", level=1) {
            PrintMessage("SQL: ")
            PrintString(final_query)
            PrintMessage("\n")
        }
        
        result = PG_Query(conn, final_query)
        Deallocate(final_query, 0)
        
        ReturnValue(result)
    }
}

// INSERT query builder
Function.SQL.Insert {
    Input: conn: Address
    Input: table: Address
    Input: columns: Address
    Input: values: Address
    Output: Integer
    Body: {
        // Build: INSERT INTO table (columns) VALUES (values)
        query = StringConcat("INSERT INTO ", table)
        query2 = StringConcat(query, " (")
        query3 = StringConcat(query2, columns)
        query4 = StringConcat(query3, ") VALUES (")
        query5 = StringConcat(query4, values)
        final_query = StringConcat(query5, ")")
        
        Deallocate(query, 0)
        Deallocate(query2, 0)
        Deallocate(query3, 0)
        Deallocate(query4, 0)
        Deallocate(query5, 0)
        
        Debug("sql_query", level=1) {
            PrintMessage("SQL: ")
            PrintString(final_query)
            PrintMessage("\n")
        }
        
        result = PG_Query(conn, final_query)
        Deallocate(final_query, 0)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            PG_DestroyResult(result)
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// UPDATE query builder
Function.SQL.Update {
    Input: conn: Address
    Input: table: Address
    Input: set_clause: Address
    Input: where_clause: Address
    Output: Integer
    Body: {
        // Build: UPDATE table SET set_clause WHERE where_clause
        query = StringConcat("UPDATE ", table)
        query2 = StringConcat(query, " SET ")
        query3 = StringConcat(query2, set_clause)
        
        Deallocate(query, 0)
        Deallocate(query2, 0)
        
        final_query = 0
        
        IfCondition NotEqual(where_clause, 0) ThenBlock: {
            where_len = StringLength(where_clause)
            IfCondition GreaterThan(where_len, 0) ThenBlock: {
                query4 = StringConcat(query3, " WHERE ")
                final_query = StringConcat(query4, where_clause)
                Deallocate(query3, 0)
                Deallocate(query4, 0)
            } ElseBlock: {
                final_query = query3
            }
        } ElseBlock: {
            final_query = query3
        }
        
        Debug("sql_query", level=1) {
            PrintMessage("SQL: ")
            PrintString(final_query)
            PrintMessage("\n")
        }
        
        result = PG_Query(conn, final_query)
        Deallocate(final_query, 0)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            PG_DestroyResult(result)
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// DELETE query builder
Function.SQL.Delete {
    Input: conn: Address
    Input: table: Address
    Input: where_clause: Address
    Output: Integer
    Body: {
        // Build: DELETE FROM table WHERE where_clause
        query = StringConcat("DELETE FROM ", table)
        
        final_query = 0
        
        IfCondition NotEqual(where_clause, 0) ThenBlock: {
            where_len = StringLength(where_clause)
            IfCondition GreaterThan(where_len, 0) ThenBlock: {
                query2 = StringConcat(query, " WHERE ")
                final_query = StringConcat(query2, where_clause)
                Deallocate(query, 0)
                Deallocate(query2, 0)
            } ElseBlock: {
                final_query = query
            }
        } ElseBlock: {
            final_query = query
        }
        
        Debug("sql_query", level=1) {
            PrintMessage("SQL: ")
            PrintString(final_query)
            PrintMessage("\n")
        }
        
        result = PG_Query(conn, final_query)
        Deallocate(final_query, 0)
        
        IfCondition NotEqual(result, 0) ThenBlock: {
            PG_DestroyResult(result)
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// RESULT SET HELPERS
// =============================================================================

// Get row count from result set
Function.SQL.RowCount {
    Input: result_set: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(result_set, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        count = XArray.XSize(result_set)
        ReturnValue(count)
    }
}

// Get a specific row as HashMap
Function.SQL.GetRow {
    Input: result_set: Address
    Input: row_index: Integer
    Output: Address
    Body: {
        Debug("sql_result", level=2) {
            PrintMessage("SQL.GetRow: result_set=")
            PrintNumber(result_set)
            PrintMessage(", row_index=")
            PrintNumber(row_index)
            PrintMessage("\n")
        }
        
        IfCondition EqualTo(result_set, 0) ThenBlock: {
            PrintMessage("ERROR: NULL result set\n")
            ReturnValue(0)
        }
        
        row_count = XArray.XSize(result_set)
        
        Debug("sql_result", level=2) {
            PrintMessage("SQL.GetRow: row_count=")
            PrintNumber(row_count)
            PrintMessage("\n")
        }
        
        IfCondition Or(LessThan(row_index, 0), GreaterEqual(row_index, row_count)) ThenBlock: {
            PrintMessage("ERROR: Row index ")
            PrintNumber(row_index)
            PrintMessage(" out of bounds (0-")
            PrintNumber(row_count)
            PrintMessage(")\n")
            ReturnValue(0)
        }
        
        row = XArray.XGet(result_set, row_index)
        
        Debug("sql_result", level=2) {
            PrintMessage("SQL.GetRow: row=")
            PrintNumber(row)
            PrintMessage("\n")
        }
        
        ReturnValue(row)
    }
}

// Get a specific value from result set
Function.SQL.GetValue {
    Input: result_set: Address
    Input: row_index: Integer
    Input: column_name: Address
    Output: Address
    Body: {
        Debug("sql_result", level=1) {
            PrintMessage("SQL.GetValue: Getting column '")
            PrintString(column_name)
            PrintMessage("' from row ")
            PrintNumber(row_index)
            PrintMessage("\n")
        }
        
        row = SQL.GetRow(result_set, row_index)
        
        IfCondition EqualTo(row, 0) ThenBlock: {
            PrintMessage("ERROR: Failed to get row\n")
            ReturnValue(0)
        }
        
        Debug("sql_result", level=2) {
            PrintMessage("SQL.GetValue: Looking up column in HashMap\n")
        }
        
        value = HashMap.HGetSimple(row, column_name)
        
        Debug("sql_result", level=2) {
            PrintMessage("SQL.GetValue: value=")
            PrintNumber(value)
            PrintMessage("\n")
        }
        
        ReturnValue(value)
    }
}

// Print entire result set (for debugging)
Function.SQL.PrintResult {
    Input: result_set: Address
    Body: {
        IfCondition EqualTo(result_set, 0) ThenBlock: {
            PrintMessage("(null result)\n")
            ReturnValue(0)
        }
        
        row_count = SQL.RowCount(result_set)
        
        PrintMessage("Result: ")
        PrintNumber(row_count)
        PrintMessage(" row(s)\n")
        
        i = 0
        WhileLoop LessThan(i, row_count) {
            PrintMessage("Row ")
            PrintNumber(i)
            PrintMessage(": ")
            
            row = SQL.GetRow(result_set, i)
            
            // For now, just print indication
            // (Full HashMap printing would require iterating keys)
            PrintMessage("{HashMap}\n")
            
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// TRANSACTION HELPERS
// =============================================================================

Function.SQL.Begin {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PG_Begin(conn)
        ReturnValue(result)
    }
}

Function.SQL.Commit {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PG_Commit(conn)
        ReturnValue(result)
    }
}

Function.SQL.Rollback {
    Input: conn: Address
    Output: Integer
    Body: {
        result = PG_Rollback(conn)
        ReturnValue(result)
    }
}

// =============================================================================
// PREPARED STATEMENT HELPERS
// =============================================================================

Function.SQL.Prepare {
    Input: conn: Address
    Input: name: Address
    Input: sql: Address
    Output: Address
    Body: {
        stmt = PG_Prepare(conn, name, sql)
        ReturnValue(stmt)
    }
}

Function.SQL.Execute {
    Input: stmt: Address
    Input: params: Address
    Output: Address
    Body: {
        result = PG_Execute(stmt, params)
        ReturnValue(result)
    }
}

Function.SQL.DestroyStatement {
    Input: stmt: Address
    Body: {
        PG_DestroyStatement(stmt)
    }
}

Debug("library.load", level=1) {
    PrintMessage("SQL Library loaded successfully!\n")
    PrintMessage("Features: Connection pooling, query builders, result helpers\n")
}