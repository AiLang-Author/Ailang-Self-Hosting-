// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.Socket.ailang
// WORKAROUND: Use compiler primitives instead of broken SystemCall

FixedPool.SocketConstants {
    "AF_INET": Initialize=2
    "AF_INET6": Initialize=10
    "SOCK_STREAM": Initialize=1
    "SOCK_DGRAM": Initialize=2
    "IPPROTO_TCP": Initialize=6
    "SOL_SOCKET": Initialize=1
    "SO_REUSEADDR": Initialize=2
    "SO_KEEPALIVE": Initialize=9
    "MSG_NOSIGNAL": Initialize=16384
}

FixedPool.SocketOptValOne {
    "value": Initialize=1
}

// Create socket address structure for IPv4
Function.Socket.CreateAddr {
    Input: host: Address
    Input: port: Integer
    // Returns: Address (16 bytes - caller must Deallocate(addr, 16))
    Output: Address 
    Body: {
        addr = Allocate(16)
        
        // Family (AF_INET = 2) - bytes 0-1
        SetByte(addr, 0, 2)
        SetByte(addr, 1, 0)
        
        // Port in network byte order (big-endian) - bytes 2-3
        port_high = RightShift(BitwiseAnd(port, 65280), 8)
        port_low = BitwiseAnd(port, 255)
        SetByte(addr, 2, port_high)
        SetByte(addr, 3, port_low)
        
        // IP address - bytes 4-7
        is_localhost = StringCompare(host, "localhost")
        IfCondition EqualTo(is_localhost, 0) ThenBlock: {
            SetByte(addr, 4, 127)
            SetByte(addr, 5, 0)
            SetByte(addr, 6, 0)
            SetByte(addr, 7, 1)
        } ElseBlock: {
            ip_parts = Socket.ParseIPAddress(host)
            SetByte(addr, 4, ArrayGet(ip_parts, 0))
            SetByte(addr, 5, ArrayGet(ip_parts, 1))
            SetByte(addr, 6, ArrayGet(ip_parts, 2))
            SetByte(addr, 7, ArrayGet(ip_parts, 3))
            ArrayDestroy(ip_parts)
        }
        
        // Zero padding - bytes 8-15
        i = 8
        WhileLoop LessThan(i, 16) {
            SetByte(addr, i, 0)
            i = Add(i, 1)
        }
        
        ReturnValue(addr)
    }
}

// Create socket - USE PRIMITIVE
Function.Socket.Create {
    Input: family: Integer
    Input: type: Integer
    Output: Integer
    Body: {
        // Use the SocketCreate primitive (it works!)
        sock = SocketCreate(family, type)
        
        IfCondition LessThan(sock, 0) ThenBlock: {
            PrintMessage("ERROR: Socket creation failed\n")
            ReturnValue(-1)
        }
        
        ReturnValue(sock)
    }
}

// Connect socket - USE PRIMITIVE with correct IP byte order
Function.Socket.Connect {
    Input: sock: Integer
    Input: addr: Address
    Output: Integer
    Body: {
        // Extract IP bytes from sockaddr_in structure (bytes 4-7)
        ip_byte1 = GetByte(addr, 4)  // First octet (e.g., 127 for 127.0.0.1)
        ip_byte2 = GetByte(addr, 5)  // Second octet (0)
        ip_byte3 = GetByte(addr, 6)  // Third octet (0)
        ip_byte4 = GetByte(addr, 7)  // Fourth octet (1)
        
        // Combine into 32-bit IP in NETWORK byte order (big-endian)
        // For 127.0.0.1: we want 0x7F000001 = 2130706433
        // Formula: byte1*16777216 + byte2*65536 + byte3*256 + byte4
        ip = Multiply(ip_byte1, 16777216)  // 127 * 16777216
        ip = Add(ip, Multiply(ip_byte2, 65536))
        ip = Add(ip, Multiply(ip_byte3, 256))
        ip = Add(ip, ip_byte4)
        
        // Extract port (bytes 2-3) and convert from network to host order
        port_high = GetByte(addr, 2)
        port_low = GetByte(addr, 3)
        port = Add(Multiply(port_high, 256), port_low)
        
        // Use SocketConnect primitive
        result = SocketConnect(sock, ip, port)
        
        IfCondition LessThan(result, 0) ThenBlock: {
            PrintMessage("ERROR: Connect failed\n")
        }
        
        ReturnValue(result)
    }
}

// Send data - WORKAROUND: use primitive write operation
Function.Socket.Send {
    Input: sock: Integer
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        // Use SocketWrite primitive if available
        sent = SocketWrite(sock, buffer, length)
        ReturnValue(sent)
    }
}

// Receive data - WORKAROUND: use primitive read operation  
Function.Socket.Recv {
    Input: sock: Integer
    Input: buffer: Address
    Input: max_length: Integer
    Output: Integer
    Body: {
        // Use SocketRead primitive if available
        received = SocketRead(sock, buffer, max_length)
        ReturnValue(received)
    }
}

// Receive exact number of bytes - FIXED: caller allocates buffer
Function.Socket.RecvExact {
    Input: sock: Integer
    Input: buffer: Address
    Input: length: Integer
    Output: Integer
    Body: {
        total_received = 0
        
        Debug("socket_recv_exact_entry", level=2) {
            PrintMessage("RecvExact: Need to read ")
            PrintNumber(length)
            PrintMessage(" bytes\n")
        }
        
        WhileLoop LessThan(total_received, length) {
            remaining = Subtract(length, total_received)
            
            Debug("socket_recv_exact_loop", level=2) {
                PrintMessage("RecvExact: Calling SocketRead for ")
                PrintNumber(remaining)
                PrintMessage(" bytes (total so far: ")
                PrintNumber(total_received)
                PrintMessage(")\n")
            }
            
            chunk = SocketRead(sock, Add(buffer, total_received), remaining)
            
            Debug("socket_recv_exact_chunk", level=2) {
                PrintMessage("RecvExact: SocketRead returned ")
                PrintNumber(chunk)
                PrintMessage(" bytes\n")
            }
            
            IfCondition LessEqual(chunk, 0) ThenBlock: {
                PrintMessage("ERROR: SocketRead failed in RecvExact\n")
                ReturnValue(0)  // Return error - caller owns buffer
            }
            
            total_received = Add(total_received, chunk)
        }
        
        Debug("socket_recv_exact_exit", level=2) {
            PrintMessage("RecvExact: Successfully read ")
            PrintNumber(total_received)
            PrintMessage(" bytes\n")
        }
        
        ReturnValue(total_received)  // Return bytes read
    }
}

Function.Socket.SetRecvTimeout {
    Input: sock: Integer
    Input: timeout_ms: Integer
    Body: {
        // Set SO_RCVTIMEO socket option
        // struct timeval { tv_sec, tv_usec }
        
        tv_sec = Divide(timeout_ms, 1000)
        tv_usec = Multiply(Modulo(timeout_ms, 1000), 1000)
        
        timeval = Allocate(16)  // 8 bytes for sec, 8 for usec on 64-bit
        StoreValue(timeval, tv_sec)
        StoreValue(Add(timeval, 8), tv_usec)
        
        // setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeval, sizeof(timeval))
        result = SystemCall(54, sock, 1, 20, timeval, 16)  // syscall 54 = setsockopt
        
        Deallocate(timeval, 16)
        ReturnValue(result)
    }
}


// Close socket  
Function.Socket.Close {
    Input: sock: Integer
    Body: {
        SocketClose(sock)
    }
}

// Parse IP address string
Function.Socket.ParseIPAddress {
    Input: ip_str: Address
    // Returns: Address (Array handle - caller must ArrayDestroy)
    Output: Address
    Body: {
        parts = ArrayCreate(4)
        part_idx = 0
        current_num = 0
        i = 0
        ip_len = StringLength(ip_str)
        
        WhileLoop LessThan(i, ip_len) {
            ch = GetByte(ip_str, i)
            
            IfCondition EqualTo(ch, 46) ThenBlock: {  // '.'
                ArraySet(parts, part_idx, current_num)
                part_idx = Add(part_idx, 1)
                current_num = 0
            } ElseBlock: {
                digit = Subtract(ch, 48)  // '0'
                current_num = Add(Multiply(current_num, 10), digit)
            }
            
            i = Add(i, 1)
        }
        
        ArraySet(parts, part_idx, current_num)
        ReturnValue(parts)
    }
}