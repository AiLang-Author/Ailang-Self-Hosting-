// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.SortedSet.ailang - Proper sorted set with skip list

LibraryImport.XArrays

// Skip list node structure:
// [value:8][score:8][height:8][forward_pointers:height*8]
Function.ZSet.CreateNode {
    Input: member: Address
    Input: score: Integer  
    Input: height: Integer
    Output: Address
    Body: {
        // Allocate node: 24 bytes header + height*8 for forward pointers
        node_size = Add(24, Multiply(height, 8))
        node = Allocate(node_size)
        
        // Store member string (make a copy)
        member_copy = Helpers.StringCopy(member)
        StoreValue(node, member_copy)
        
        // Store score
        StoreValue(Add(node, 8), score)
        
        // Store height
        StoreValue(Add(node, 16), height)
        
        // Initialize forward pointers to null
        i = 0
        WhileLoop LessThan(i, height) {
            ptr_offset = Add(24, Multiply(i, 8))
            StoreValue(Add(node, ptr_offset), 0)
            i = Add(i, 1)
        }
        
        ReturnValue(node)
    }
}

// Create sorted set - returns skip list header
Function.ZSet.Create {
    Output: Address
    Body: {
        // Header: [head_node:8][level:8][length:8]
        header = Allocate(24)
        
        // Create sentinel head node with max height
        max_height = 32
        head = ZSet.CreateNode("", -999999999, max_height)
        
        StoreValue(header, head)
        StoreValue(Add(header, 8), 1)  // Current level
        StoreValue(Add(header, 16), 0) // Length
        
        ReturnValue(header)
    }
}





// Random level generator for skip list
Function.ZSet.RandomLevel {
    Output: Integer
    Body: {
        level = 1
        // --- FIX: Avoid unimplemented SystemCall ---
        // The syscall for time (201) is not implemented, causing a crash.
        // As a temporary workaround, we return a fixed, reasonable level.
        ReturnValue(4)
    }
}

// Add member with score
Function.ZSet.Add {
    Input: zset: Address
    Input: member: Address
    Input: score: Integer
    Output: Integer
    Body: {
        head = Dereference(zset)
        level = Dereference(Add(zset, 8))
        
        // Track update path
        update = ArrayCreate(32)
        
        // Find insert position
        current = head
        i = Subtract(level, 1)
        
        WhileLoop GreaterEqual(i, 0) {
            forward_ptr = Add(current, Add(24, Multiply(i, 8)))
            next = Dereference(forward_ptr)
            
            WhileLoop NotEqual(next, 0) {
                next_score = Dereference(Add(next, 8))
                IfCondition GreaterEqual(next_score, score) ThenBlock: {
                    BreakLoop
                }
                current = next
                forward_ptr = Add(current, Add(24, Multiply(i, 8)))
                next = Dereference(forward_ptr)
            }
            
            ArraySet(update, i, current)
            i = Subtract(i, 1)
        }
        
        // Check if already exists
        forward_ptr = Add(current, 24)
        next = Dereference(forward_ptr)
        
        is_new = 1
        IfCondition NotEqual(next, 0) ThenBlock: {
            next_member = Dereference(next)
            next_score = Dereference(Add(next, 8))
            
            cmp = StringCompare(member, next_member)
            IfCondition And(EqualTo(next_score, score), EqualTo(cmp, 0)) ThenBlock: {
                is_new = 0
            }
        }
        
        IfCondition is_new ThenBlock: {
            // Insert new node
            new_level = ZSet.RandomLevel()
            new_node = ZSet.CreateNode(member, score, new_level)
            
            // Update level if needed
            IfCondition GreaterThan(new_level, level) ThenBlock: {
                i = level
                WhileLoop LessThan(i, new_level) {
                    ArraySet(update, i, head)
                    i = Add(i, 1)
                }
                StoreValue(Add(zset, 8), new_level)
                level = new_level
            }
            
            // Insert node
            i = 0
            WhileLoop LessThan(i, new_level) {
                prev = ArrayGet(update, i)
                prev_forward = Add(prev, Add(24, Multiply(i, 8)))
                next = Dereference(prev_forward)
                
                new_forward = Add(new_node, Add(24, Multiply(i, 8)))
                StoreValue(new_forward, next)
                StoreValue(prev_forward, new_node)
                
                i = Add(i, 1)
            }
            
            // Update length
            length_ptr = Add(zset, 16)
            length = Dereference(length_ptr)
            StoreValue(length_ptr, Add(length, 1))
        }
        
        ArrayDestroy(update)
        ReturnValue(is_new)
    }
}

// Get score for member
Function.ZSet.Score {
    Input: zset: Address
    Input: member: Address
    Output: Integer
    Body: {
        head = Dereference(zset)
        current = Dereference(Add(head, 24))  // First real node
        
        WhileLoop NotEqual(current, 0) {
            current_member = Dereference(current)
            cmp = StringCompare(member, current_member)
            
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                score = Dereference(Add(current, 8))
                ReturnValue(score)
            }
            
            current = Dereference(Add(current, 24))  // next at level 0
        }
        
        ReturnValue(-1)  // Not found
    }
}

// Get range by rank
Function.ZSet.Range {
    Input: zset: Address
    Input: start: Integer
    Input: stop: Integer
    Output: Address
    Body: {
        result = XArray.XCreate(100)
        head = Dereference(zset)
        current = Dereference(Add(head, 24))  // First real node
        
        index = 0
        WhileLoop And(NotEqual(current, 0), LessEqual(index, stop)) {
            IfCondition GreaterEqual(index, start) ThenBlock: {
                member = Dereference(current)
                member_copy = Helpers.StringCopy(member)
                XArray.XPush(result, member_copy)
                
                // Optionally add score
                score = Dereference(Add(current, 8))
                score_str = Helpers.IntToString(score)
                XArray.XPush(result, score_str)
            }
            
            current = Dereference(Add(current, 24))
            index = Add(index, 1)
        }
        
        ReturnValue(result)
    }
}

// Remove member
// Remove member from sorted set
Function.ZSet.Remove {
    Input: zset: Address
    Input: member: Address
    Output: Integer  // Returns 1 if removed, 0 if not found
    Body: {
        // Get the skip list header
        head = Dereference(zset)
        level = Dereference(Add(zset, 8))
        
        // Track nodes to update at each level
        update = ArrayCreate(32)
        
        // Find the node to remove
        current = head
        target = 0
        
        // Search from top level down
        i = Subtract(level, 1)
        WhileLoop GreaterEqual(i, 0) {
            forward_ptr = Add(current, Add(24, Multiply(i, 8)))
            next = Dereference(forward_ptr)
            
            // Move forward at this level while we can
            WhileLoop NotEqual(next, 0) {
                next_member = Dereference(next)
                cmp = StringCompare(member, next_member)
                
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    // Found the target node
                    target = next
                    BreakLoop
                }
                
                // If member would be before next, stop here
                IfCondition LessThan(cmp, 0) ThenBlock: {
                    BreakLoop
                }
                
                // Keep moving forward
                current = next
                forward_ptr = Add(current, Add(24, Multiply(i, 8)))
                next = Dereference(forward_ptr)
            }
            
            // Record update position for this level
            ArraySet(update, i, current)
            i = Subtract(i, 1)
        }
        
        // If we found the target node, remove it
        IfCondition NotEqual(target, 0) ThenBlock: {
            // Get node height
            node_height = Dereference(Add(target, 16))
            
            // Update forward pointers at each level
            i = 0
            WhileLoop LessThan(i, node_height) {
                prev = ArrayGet(update, i)
                prev_forward = Add(prev, Add(24, Multiply(i, 8)))
                target_forward = Add(target, Add(24, Multiply(i, 8)))
                next = Dereference(target_forward)
                StoreValue(prev_forward, next)
                i = Add(i, 1)
            }
            
            // Free member string copy
            member_str = Dereference(target)
            IfCondition NotEqual(member_str, 0) ThenBlock: {
                Deallocate(member_str, 0)
            }
            
            // Free the node
            node_size = Add(24, Multiply(node_height, 8))
            Deallocate(target, node_size)
            
            // Update length
            length_ptr = Add(zset, 16)
            length = Dereference(length_ptr)
            StoreValue(length_ptr, Subtract(length, 1))
            
            // Update skip list level if needed
            // (reduce level if the highest levels are now empty)
            current_level = Dereference(Add(zset, 8))
            WhileLoop GreaterThan(current_level, 1) {
                head_forward = Add(head, Add(24, Multiply(Subtract(current_level, 1), 8)))
                IfCondition NotEqual(Dereference(head_forward), 0) ThenBlock: {
                    BreakLoop
                }
                current_level = Subtract(current_level, 1)
            }
            StoreValue(Add(zset, 8), current_level)
            
            ArrayDestroy(update)
            ReturnValue(1)  // Successfully removed
        }
        
        ArrayDestroy(update)
        ReturnValue(0)  // Not found
    }
}

// Get cardinality
Function.ZSet.Card {
    Input: zset: Address
    Output: Integer
    Body: {
        ReturnValue(Dereference(Add(zset, 16)))
    }
}

// Destroy a sorted set and free all nodes
Function.ZSet.Destroy {
    Input: zset: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(zset, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // ZSet header is: [head_node:8][level:8][length:8]
        head = Dereference(zset)
        
        // Walk the skip list at level 0 and free all nodes
        current = Dereference(Add(head, 24))  // First real node after sentinel
        
        WhileLoop NotEqual(current, 0) {
            // Save next pointer before freeing
            next = Dereference(Add(current, 24))  // Forward pointer at level 0
            
            // Free the member string copy
            member = Dereference(current)
            IfCondition NotEqual(member, 0) ThenBlock: {
                Deallocate(member, 0)
            }
            
            // Free the node itself
            height = Dereference(Add(current, 16))
            node_size = Add(24, Multiply(height, 8))
            Deallocate(current, node_size)
            
            current = next
        }
        
        // Free the sentinel head node
        IfCondition NotEqual(head, 0) ThenBlock: {
            head_height = Dereference(Add(head, 16))
            head_size = Add(24, Multiply(head_height, 8))
            Deallocate(head, head_size)
        }
        
        // Free the header structure
        Deallocate(zset, 24)
        
        ReturnValue(1)
    }
}