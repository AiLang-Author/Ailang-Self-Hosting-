// Library.StringUtils.ailang
// String utility functions implemented in pure AILANG

// Get length of null-terminated string
Function.StrLen {
    Input: str: Address
    Output: Integer
    Body: {
        len = 0
        ptr = str
        byte = Dereference(ptr, "byte")
        
        WhileLoop GreaterThan(byte, 0) {
            len = Add(len, 1)
            ptr = Add(ptr, 1)
            byte = Dereference(ptr, "byte")
        }
        
        ReturnValue(len)
    }
}

// Convert string to integer
Function.StrToNum {
    Input: str: Address
    Output: Integer
    Body: {
        result = 0
        ptr = str
        byte = Dereference(ptr, "byte")
        
        // Process each digit
        WhileLoop GreaterThan(byte, 0) {
            // Check if it's a digit (48='0' to 57='9')
            is_digit = GreaterThan(byte, 47)
            is_digit2 = LessEqual(byte, 57)
            
            // Only process if valid digit
            IfCondition And(is_digit, is_digit2) ThenBlock: {
                digit = Subtract(byte, 48)
                result = Multiply(result, 10)
                result = Add(result, digit)
            }
            
            ptr = Add(ptr, 1)
            byte = Dereference(ptr, "byte")
        }
        
        ReturnValue(result)
    }
}

// Find character in string, returns position or -1
Function.StrFindChar {
    Input: str: Address
    Input: target_char: Integer
    Output: Integer
    Body: {
        position = 0
        ptr = str
        byte = Dereference(ptr, "byte")
        
        WhileLoop GreaterThan(byte, 0) {
            IfCondition EqualTo(byte, target_char) ThenBlock: {
                ReturnValue(position)
            }
            position = Add(position, 1)
            ptr = Add(ptr, 1)
            byte = Dereference(ptr, "byte")
        }
        
        ReturnValue(-1)
    }
}

// Compare two strings, returns 0 if equal
Function.StrCompare {
    Input: str1: Address
    Input: str2: Address
    Output: Integer
    Body: {
        ptr1 = str1
        ptr2 = str2
        
        byte1 = Dereference(ptr1, "byte")
        byte2 = Dereference(ptr2, "byte")
        
        WhileLoop And(GreaterThan(byte1, 0), GreaterThan(byte2, 0)) {
            IfCondition NotEqual(byte1, byte2) ThenBlock: {
                ReturnValue(1)
            }
            
            ptr1 = Add(ptr1, 1)
            ptr2 = Add(ptr2, 1)
            byte1 = Dereference(ptr1, "byte")
            byte2 = Dereference(ptr2, "byte")
        }
        
        // Check if both ended at same time
        IfCondition NotEqual(byte1, byte2) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// Check if string starts with prefix
Function.StrStartsWith {
    Input: str: Address
    Input: prefix: Address
    Output: Integer
    Body: {
        ptr1 = str
        ptr2 = prefix
        
        byte1 = Dereference(ptr1, "byte")
        byte2 = Dereference(ptr2, "byte")
        
        WhileLoop GreaterThan(byte2, 0) {
            IfCondition NotEqual(byte1, byte2) ThenBlock: {
                ReturnValue(0)
            }
            
            ptr1 = Add(ptr1, 1)
            ptr2 = Add(ptr2, 1)
            byte1 = Dereference(ptr1, "byte")
            byte2 = Dereference(ptr2, "byte")
        }
        
        ReturnValue(1)
    }
}

// Get substring from start position for given length
Function.StrSubstring {
    Input: str: Address
    Input: start: Integer
    Input: length: Integer
    // Returns: Address (caller must Deallocate with StringLength + 1)
    Output: Address
    Body: {
        result = Allocate(Add(length, 1))
        
        src_ptr = Add(str, start)
        dst_ptr = result
        
        i = 0
        WhileLoop LessThan(i, length) {
            byte = Dereference(src_ptr, "byte")
            
            IfCondition EqualTo(byte, 0) ThenBlock: {
                // Reached end of source string
                StoreValue(dst_ptr, 0)
                ReturnValue(result)
            }
            
            StoreValue(dst_ptr, byte)
            src_ptr = Add(src_ptr, 1)
            dst_ptr = Add(dst_ptr, 1)
            i = Add(i, 1)
        }
        
        // Null terminate
        StoreValue(dst_ptr, 0)
        ReturnValue(result)
    }
}

// Split string by delimiter (returns XArray of strings)
Function.StrSplit {
    Input: str: Address
    Input: delimiter: Address
    // Returns: XArray of string parts
    // CRITICAL: Caller must:
    //   1. Free each string: Deallocate(str, Add(StringLength(str), 1))
    //   2. Destroy array: XArray.XDestroy(result)
    Output: Address
    Body: {
        result = XArray.XCreate()
        
        delim_char = Dereference(delimiter, "byte")
        ptr = str
        start = str
        
        byte = Dereference(ptr, "byte")
        
        WhileLoop GreaterThan(byte, 0) {
            IfCondition EqualTo(byte, delim_char) ThenBlock: {
                // Found delimiter - extract substring
                len = Subtract(ptr, start)
                
                IfCondition GreaterThan(len, 0) ThenBlock: {
                    part = Allocate(Add(len, 1))
                    
                    // Copy substring
                    i = 0
                    src = start
                    WhileLoop LessThan(i, len) {
                        b = Dereference(src, "byte")
                        StoreValue(Add(part, i), b)
                        src = Add(src, 1)
                        i = Add(i, 1)
                    }
                    StoreValue(Add(part, len), 0)
                    
                    XArray.XPush(result, part)
                }
                
                // Move past delimiter
                ptr = Add(ptr, 1)
                start = ptr
                byte = Dereference(ptr, "byte")
            } ElseBlock: {
                ptr = Add(ptr, 1)
                byte = Dereference(ptr, "byte")
            }
        }
        
        // Add last part if any
        len = Subtract(ptr, start)
        IfCondition GreaterThan(len, 0) ThenBlock: {
            part = Allocate(Add(len, 1))
            
            i = 0
            src = start
            WhileLoop LessThan(i, len) {
                b = Dereference(src, "byte")
                StoreValue(Add(part, i), b)
                src = Add(src, 1)
                i = Add(i, 1)
            }
            StoreValue(Add(part, len), 0)
            
            XArray.XPush(result, part)
        }
        
        ReturnValue(result)
    }
}

// Convert integer to string
Function.NumToStr {
    Input: num: Integer
    // Returns: Address (caller must Deallocate with StringLength + 1)
    Output: Address
    Body: {
        // Handle zero
        IfCondition EqualTo(num, 0) ThenBlock: {
            result = Allocate(2)
            StoreValue(result, 48)
            StoreValue(Add(result, 1), 0)
            ReturnValue(result)
        }
        
        // Handle negative
        negative = 0
        value = num
        IfCondition LessThan(num, 0) ThenBlock: {
            negative = 1
            value = Subtract(0, num)
        }
        
        // Count digits
        temp = value
        digit_count = 0
        WhileLoop GreaterThan(temp, 0) {
            temp = Divide(temp, 10)
            digit_count = Add(digit_count, 1)
        }
        
        // Allocate string
        total_len = digit_count
        IfCondition EqualTo(negative, 1) ThenBlock: {
            total_len = Add(total_len, 1)
        }
        
        result = Allocate(Add(total_len, 1))
        
        // Fill digits from right to left
        pos = total_len
        temp = value
        
        WhileLoop GreaterThan(temp, 0) {
            digit = Modulo(temp, 10)
            ascii_digit = Add(digit, 48)
            
            pos = Subtract(pos, 1)
            StoreValue(Add(result, pos), ascii_digit)
            
            temp = Divide(temp, 10)
        }
        
        // Add minus sign if negative
        IfCondition EqualTo(negative, 1) ThenBlock: {
            StoreValue(result, 45)
        }
        
        // Null terminate
        StoreValue(Add(result, total_len), 0)
        
        ReturnValue(result)
    }
}