// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.TArrays.ailang
// Typed Arrays - Dynamic arrays with bulletproof type identification
// 
// This is a new implementation that coexists with XArrays.
// Use TArrays for new code that needs type checking.
// Existing XArray code continues to work unchanged.
//
// Header Structure (32 bytes):
//   [magic: 8][capacity: 8][size: 8][data_ptr: 8]
//
// The magic number allows 100% reliable type detection.

// =============================================================================
// CONSTANTS
// =============================================================================
FixedPool.TArrays {
    "MAGIC": Initialize=6022087695        
    "NULL": Initialize=-1                 
    "DEFAULT_CAPACITY": Initialize=16
    "GROWTH_FACTOR": Initialize=2
    "HEADER_SIZE": Initialize=32         
}

// =============================================================================
// TCREATE - Create a new typed array
// =============================================================================
Function.TArray.TCreate {
    Input: initial_capacity: Integer
    Output: Address
    Body: {
        IfCondition LessEqual(initial_capacity, 0) ThenBlock: {
            initial_capacity = TArrays.DEFAULT_CAPACITY
        }
        
        // Allocate header (32 bytes)
        header = Allocate(TArrays.HEADER_SIZE)
        
        // Allocate data array
        data = ArrayCreate(initial_capacity)
        
        // Store magic at offset 0
        StoreValue(header, TArrays.MAGIC)
        
        // Store capacity at offset 8
        StoreValue(Add(header, 8), initial_capacity)
        
        // Store size (0) at offset 16
        StoreValue(Add(header, 16), 0)
        
        // Store data pointer at offset 24
        StoreValue(Add(header, 24), data)
        
        ReturnValue(header)
    }
}

// =============================================================================
// TDESTROY - Free a typed array
// =============================================================================
Function.TArray.TDestroy {
    Input: arr: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Verify magic before destroying
        magic = Dereference(arr)
        IfCondition NotEqual(magic, TArrays.MAGIC) ThenBlock: {
            // Not a valid TArray - don't destroy
            PrintMessage("TDestroy: Invalid array (bad magic)\n")
            ReturnValue(0)
        }
        
        // Get data pointer and capacity
        capacity = Dereference(Add(arr, 8))
        data = Dereference(Add(arr, 24))
        
        // Free data array
        IfCondition NotEqual(data, 0) ThenBlock: {
            ArrayDestroy(data, capacity)
        }
        
        // Free header
        Deallocate(arr, TArrays.HEADER_SIZE)
    }
}

// =============================================================================
// TISARRAY - Bulletproof type check
// Returns 1 if this is a valid TArray, 0 otherwise
// =============================================================================
Function.TArray.TIsArray {
    Input: value: Address
    Output: Integer
    Body: {
        // Null check
        IfCondition EqualTo(value, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Must be a reasonable heap address
        IfCondition LessThan(value, 1000000) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check magic number
        magic = Dereference(value)
        IfCondition EqualTo(magic, TArrays.MAGIC) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// TSIZE - Get number of elements
// =============================================================================
Function.TArray.TSize {
    Input: arr: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        size = Dereference(Add(arr, 16))
        ReturnValue(size)
    }
}

// =============================================================================
// TCAPACITY - Get current capacity
// =============================================================================
Function.TArray.TCapacity {
    Input: arr: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        capacity = Dereference(Add(arr, 8))
        ReturnValue(capacity)
    }
}

// =============================================================================
// TGET - Get element at index
// =============================================================================
Function.TArray.TGet {
    Input: arr: Address
    Input: index: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = Dereference(Add(arr, 16))
        
        // Bounds check
        IfCondition LessThan(index, 0) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition GreaterEqual(index, size) ThenBlock: {
            ReturnValue(0)
        }
        
        data = Dereference(Add(arr, 24))
        value = ArrayGet(data, index)
        ReturnValue(value)
    }
}

// =============================================================================
// TSET - Set element at index
// =============================================================================
Function.TArray.TSet {
    Input: arr: Address
    Input: index: Integer
    Input: value: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = Dereference(Add(arr, 16))
        
        // Bounds check
        IfCondition LessThan(index, 0) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition GreaterEqual(index, size) ThenBlock: {
            ReturnValue(0)
        }
        
        data = Dereference(Add(arr, 24))
        ArraySet(data, index, value)
    }
}

// =============================================================================
// TPUSH - Add element to end (with auto-grow)
// =============================================================================
Function.TArray.TPush {
    Input: arr: Address
    Input: value: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(arr, 8))
        size = Dereference(Add(arr, 16))
        data = Dereference(Add(arr, 24))
        
        // Check if we need to grow
        IfCondition GreaterEqual(size, capacity) ThenBlock: {
            new_capacity = Multiply(capacity, TArrays.GROWTH_FACTOR)
            new_data = ArrayCreate(new_capacity)
            
            // Copy old data
            i = 0
            WhileLoop LessThan(i, size) {
                old_val = ArrayGet(data, i)
                ArraySet(new_data, i, old_val)
                i = Add(i, 1)
            }
            
            // Free old data
            ArrayDestroy(data, capacity)
            
            // Update header
            StoreValue(Add(arr, 8), new_capacity)
            StoreValue(Add(arr, 24), new_data)
            
            data = new_data
        }
        
        // Add element
        ArraySet(data, size, value)
        StoreValue(Add(arr, 16), Add(size, 1))
    }
}

// =============================================================================
// TPOP - Remove and return last element
// =============================================================================
Function.TArray.TPop {
    Input: arr: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = Dereference(Add(arr, 16))
        IfCondition LessEqual(size, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        data = Dereference(Add(arr, 24))
        new_size = Subtract(size, 1)
        value = ArrayGet(data, new_size)
        
        StoreValue(Add(arr, 16), new_size)
        
        ReturnValue(value)
    }
}

// =============================================================================
// TCLEAR - Remove all elements (keep capacity)
// =============================================================================
Function.TArray.TClear {
    Input: arr: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        StoreValue(Add(arr, 16), 0)
    }
}

// =============================================================================
// TINSERT - Insert element at index, shifting others right
// =============================================================================
Function.TArray.TInsert {
    Input: arr: Address
    Input: index: Integer
    Input: value: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(arr, 8))
        size = Dereference(Add(arr, 16))
        data = Dereference(Add(arr, 24))
        
        // Clamp index
        IfCondition LessThan(index, 0) ThenBlock: {
            index = 0
        }
        IfCondition GreaterThan(index, size) ThenBlock: {
            index = size
        }
        
        // Grow if needed
        IfCondition GreaterEqual(size, capacity) ThenBlock: {
            new_capacity = Multiply(capacity, TArrays.GROWTH_FACTOR)
            new_data = ArrayCreate(new_capacity)
            
            i = 0
            WhileLoop LessThan(i, size) {
                old_val = ArrayGet(data, i)
                ArraySet(new_data, i, old_val)
                i = Add(i, 1)
            }
            
            ArrayDestroy(data, capacity)
            StoreValue(Add(arr, 8), new_capacity)
            StoreValue(Add(arr, 24), new_data)
            data = new_data
        }
        
        // Shift elements right
        i = size
        WhileLoop GreaterThan(i, index) {
            prev_val = ArrayGet(data, Subtract(i, 1))
            ArraySet(data, i, prev_val)
            i = Subtract(i, 1)
        }
        
        // Insert value
        ArraySet(data, index, value)
        StoreValue(Add(arr, 16), Add(size, 1))
        
        ReturnValue(1)
    }
}

// =============================================================================
// TDELETE - Remove element at index, shifting others left
// =============================================================================
Function.TArray.TDelete {
    Input: arr: Address
    Input: index: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = Dereference(Add(arr, 16))
        
        IfCondition LessThan(index, 0) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition GreaterEqual(index, size) ThenBlock: {
            ReturnValue(0)
        }
        
        data = Dereference(Add(arr, 24))
        
        // Get value to return
        deleted = ArrayGet(data, index)
        
        // Shift elements left
        i = index
        WhileLoop LessThan(i, Subtract(size, 1)) {
            next_val = ArrayGet(data, Add(i, 1))
            ArraySet(data, i, next_val)
            i = Add(i, 1)
        }
        
        StoreValue(Add(arr, 16), Subtract(size, 1))
        
        ReturnValue(deleted)
    }
}

// =============================================================================
// TINDEXOF - Find first occurrence of value
// Returns index or -1 if not found
// =============================================================================
Function.TArray.TIndexOf {
    Input: arr: Address
    Input: value: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(TArrays.NULL)
        }
        
        size = Dereference(Add(arr, 16))
        data = Dereference(Add(arr, 24))
        
        i = 0
        WhileLoop LessThan(i, size) {
            current = ArrayGet(data, i)
            IfCondition EqualTo(current, value) ThenBlock: {
                ReturnValue(i)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(TArrays.NULL)
    }
}

// =============================================================================
// TCONTAINS - Check if array contains value
// =============================================================================
Function.TArray.TContains {
    Input: arr: Address
    Input: value: Integer
    Output: Integer
    Body: {
        idx = TArray.TIndexOf(arr, value)
        IfCondition NotEqual(idx, TArrays.NULL) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// TCOPY - Create a shallow copy
// =============================================================================
Function.TArray.TCopy {
    Input: arr: Address
    Output: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(TArray.TCreate(TArrays.DEFAULT_CAPACITY))
        }
        
        size = Dereference(Add(arr, 16))
        data = Dereference(Add(arr, 24))
        
        // Create new array with same capacity
        capacity = Dereference(Add(arr, 8))
        new_arr = TArray.TCreate(capacity)
        new_data = Dereference(Add(new_arr, 24))
        
        // Copy elements
        i = 0
        WhileLoop LessThan(i, size) {
            val = ArrayGet(data, i)
            ArraySet(new_data, i, val)
            i = Add(i, 1)
        }
        
        // Set size
        StoreValue(Add(new_arr, 16), size)
        
        ReturnValue(new_arr)
    }
}

// =============================================================================
// TEXTEND - Add all elements from another array
// =============================================================================
Function.TArray.TExtend {
    Input: arr: Address
    Input: other: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition EqualTo(other, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        other_size = Dereference(Add(other, 16))
        other_data = Dereference(Add(other, 24))
        
        i = 0
        WhileLoop LessThan(i, other_size) {
            val = ArrayGet(other_data, i)
            TArray.TPush(arr, val)
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// TREVERSE - Reverse array in place
// =============================================================================
Function.TArray.TReverse {
    Input: arr: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = Dereference(Add(arr, 16))
        data = Dereference(Add(arr, 24))
        
        left = 0
        right = Subtract(size, 1)
        
        WhileLoop LessThan(left, right) {
            // Swap
            left_val = ArrayGet(data, left)
            right_val = ArrayGet(data, right)
            ArraySet(data, left, right_val)
            ArraySet(data, right, left_val)
            
            left = Add(left, 1)
            right = Subtract(right, 1)
        }
    }
}

// =============================================================================
// TSORT - Sort array in place (insertion sort)
// =============================================================================
Function.TArray.TSort {
    Input: arr: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        size = Dereference(Add(arr, 16))
        data = Dereference(Add(arr, 24))
        
        IfCondition LessEqual(size, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Insertion sort
        i = 1
        WhileLoop LessThan(i, size) {
            key = ArrayGet(data, i)
            j = Subtract(i, 1)
            
            // Shift loop - check bounds BEFORE array access
            continue_shift = 1
            WhileLoop EqualTo(continue_shift, 1) {
                IfCondition LessThan(j, 0) ThenBlock: {
                    continue_shift = 0
                } ElseBlock: {
                    curr_val = ArrayGet(data, j)
                    IfCondition GreaterThan(curr_val, key) ThenBlock: {
                        ArraySet(data, Add(j, 1), curr_val)
                        j = Subtract(j, 1)
                    } ElseBlock: {
                        continue_shift = 0
                    }
                }
            }
            
            ArraySet(data, Add(j, 1), key)
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// TSLICE - Return new array with elements from start to end (exclusive)
// =============================================================================
Function.TArray.TSlice {
    Input: arr: Address
    Input: start: Integer
    Input: end_idx: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(arr, 0) ThenBlock: {
            ReturnValue(TArray.TCreate(0))
        }
        
        size = Dereference(Add(arr, 16))
        data = Dereference(Add(arr, 24))
        
        // Handle negative indices
        IfCondition LessThan(start, 0) ThenBlock: {
            start = Add(size, start)
            IfCondition LessThan(start, 0) ThenBlock: {
                start = 0
            }
        }
        
        IfCondition LessThan(end_idx, 0) ThenBlock: {
            end_idx = Add(size, end_idx)
        }
        
        // Clamp to bounds
        IfCondition GreaterThan(start, size) ThenBlock: {
            start = size
        }
        IfCondition GreaterThan(end_idx, size) ThenBlock: {
            end_idx = size
        }
        IfCondition LessThan(end_idx, start) ThenBlock: {
            end_idx = start
        }
        
        // Create result
        new_size = Subtract(end_idx, start)
        result = TArray.TCreate(new_size)
        
        i = start
        WhileLoop LessThan(i, end_idx) {
            val = ArrayGet(data, i)
            TArray.TPush(result, val)
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// LIBRARY INITIALIZATION
// =============================================================================
SubRoutine.InitializeTArraysLibrary {
    PrintMessage("TArrays Library Loaded (Typed Arrays with Magic Numbers)\n")
}

RunTask(InitializeTArraysLibrary)