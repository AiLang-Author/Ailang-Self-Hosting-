// Library.THash.ailang
// Typed Hash Table with Magic Number for Runtime Type Detection
// Designed for Python dict support in AIMacro

LibraryImport.TArrays

// =============================================================================
// MAGIC NUMBER - Unique identifier for THash structures
// =============================================================================
FixedPool.THashMagic {
    "MAGIC": Initialize=8244561397
}

// =============================================================================
// THASH STRUCTURE
// Header: [magic: 8][capacity: 8][size: 8][entries_ptr: 8] = 32 bytes
// Entry:  [hash: 8][key_ptr: 8][value: 8] = 24 bytes per slot
// =============================================================================

// =============================================================================
// CREATE - Allocate new typed hash table
// =============================================================================
Function.THash.Create {
    Input: capacity: Integer
    Output: Address
    Body: {
        // Minimum capacity
        IfCondition LessThan(capacity, 8) ThenBlock: {
            capacity = 8
        }
        
        // Allocate header (32 bytes)
        header = Allocate(32)
        
        // Set magic number
        StoreValue(header, THashMagic.MAGIC)
        
        // Set capacity
        StoreValue(Add(header, 8), capacity)
        
        // Set size (0 initially)
        StoreValue(Add(header, 16), 0)
        
        // Allocate entries array (24 bytes per slot)
        entries_size = Multiply(capacity, 24)
        entries = Allocate(entries_size)
        
        // Initialize all slots as empty (hash = 0)
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(i, 24)
            StoreValue(Add(entries, offset), 0)        // hash = 0 (empty)
            StoreValue(Add(entries, Add(offset, 8)), 0)  // key = null
            StoreValue(Add(entries, Add(offset, 16)), 0) // value = 0
            i = Add(i, 1)
        }
        
        // Store entries pointer
        StoreValue(Add(header, 24), entries)
        
        ReturnValue(header)
    }
}

// =============================================================================
// ISHASH - Check if address is a THash (has magic number)
// =============================================================================
Function.THash.IsHash {
    Input: addr: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(addr, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check for valid heap address
        IfCondition LessThan(addr, 1000000) ThenBlock: {
            ReturnValue(0)
        }
        
        // Read potential magic number
        magic = Dereference(addr)
        
        IfCondition EqualTo(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// HASH FUNCTION - String hashing (djb2)
// =============================================================================
Function.THash.HashString {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        hash = 5381
        i = 0
        len = StringLength(str)
        
        WhileLoop LessThan(i, len) {
            byte = GetByte(str, i)
            // hash = hash * 33 + byte
            hash = Add(Multiply(hash, 33), byte)
            i = Add(i, 1)
        }
        
        // Ensure positive and non-zero (0 means empty slot)
        IfCondition LessEqual(hash, 0) ThenBlock: {
            hash = Add(hash, 2147483647)
        }
        IfCondition EqualTo(hash, 0) ThenBlock: {
            hash = 1
        }
        
        ReturnValue(hash)
    }
}

// =============================================================================
// SET - Insert or update key-value pair
// Returns: 1 if new key, 0 if updated existing
// =============================================================================
Function.THash.Set {
    Input: table: Address
    Input: key: Address
    Input: value: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Verify it's a THash
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(table, 8))
        size = Dereference(Add(table, 16))
        entries = Dereference(Add(table, 24))
        
        // Check load factor - resize if > 70%
        threshold = Divide(Multiply(capacity, 7), 10)
        IfCondition GreaterThan(size, threshold) ThenBlock: {
            THash.Resize(table)
            // Re-read after resize
            capacity = Dereference(Add(table, 8))
            entries = Dereference(Add(table, 24))
        }
        
        // Hash the key
        hash = THash.HashString(key)
        slot = Modulo(hash, capacity)
        
        // Linear probing
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(slot, 24)
            slot_hash = Dereference(Add(entries, offset))
            slot_key = Dereference(Add(entries, Add(offset, 8)))
            
            // Empty slot - insert new
            IfCondition EqualTo(slot_hash, 0) ThenBlock: {
                // Copy key string
                key_len = StringLength(key)
                key_copy = Allocate(Add(key_len, 1))
                j = 0
                WhileLoop LessThan(j, key_len) {
                    c = GetByte(key, j)
                    SetByte(key_copy, j, c)
                    j = Add(j, 1)
                }
                SetByte(key_copy, key_len, 0)
                
                // Store entry
                StoreValue(Add(entries, offset), hash)
                StoreValue(Add(entries, Add(offset, 8)), key_copy)
                StoreValue(Add(entries, Add(offset, 16)), value)
                
                // Increment size
                StoreValue(Add(table, 16), Add(size, 1))
                
                ReturnValue(1)
            }
            
            // Same key - update value
            IfCondition EqualTo(slot_hash, hash) ThenBlock: {
                cmp = StringCompare(slot_key, key)
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    // Update value
                    StoreValue(Add(entries, Add(offset, 16)), value)
                    ReturnValue(0)
                }
            }
            
            // Collision - probe next
            slot = Modulo(Add(slot, 1), capacity)
            i = Add(i, 1)
        }
        
        // Table full (shouldn't happen with resize)
        ReturnValue(0)
    }
}

// =============================================================================
// GET - Retrieve value by key
// Returns: value or 0 if not found
// =============================================================================
Function.THash.Get {
    Input: table: Address
    Input: key: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(table, 8))
        entries = Dereference(Add(table, 24))
        
        hash = THash.HashString(key)
        slot = Modulo(hash, capacity)
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(slot, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            // Empty slot - not found
            IfCondition EqualTo(slot_hash, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            // Check if key matches
            IfCondition EqualTo(slot_hash, hash) ThenBlock: {
                slot_key = Dereference(Add(entries, Add(offset, 8)))
                cmp = StringCompare(slot_key, key)
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    value = Dereference(Add(entries, Add(offset, 16)))
                    ReturnValue(value)
                }
            }
            
            slot = Modulo(Add(slot, 1), capacity)
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// CONTAINS - Check if key exists
// =============================================================================
Function.THash.Contains {
    Input: table: Address
    Input: key: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(table, 8))
        entries = Dereference(Add(table, 24))
        
        hash = THash.HashString(key)
        slot = Modulo(hash, capacity)
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(slot, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            IfCondition EqualTo(slot_hash, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(slot_hash, hash) ThenBlock: {
                slot_key = Dereference(Add(entries, Add(offset, 8)))
                cmp = StringCompare(slot_key, key)
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    ReturnValue(1)
                }
            }
            
            slot = Modulo(Add(slot, 1), capacity)
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// DELETE - Remove key-value pair
// Returns: 1 if deleted, 0 if not found
// =============================================================================
Function.THash.Delete {
    Input: table: Address
    Input: key: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(table, 8))
        size = Dereference(Add(table, 16))
        entries = Dereference(Add(table, 24))
        
        hash = THash.HashString(key)
        slot = Modulo(hash, capacity)
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(slot, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            IfCondition EqualTo(slot_hash, 0) ThenBlock: {
                ReturnValue(0)
            }
            
            IfCondition EqualTo(slot_hash, hash) ThenBlock: {
                slot_key = Dereference(Add(entries, Add(offset, 8)))
                cmp = StringCompare(slot_key, key)
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    // Free key
                    Deallocate(slot_key, 0)
                    
                    // Mark as deleted (tombstone: hash=-1)
                    StoreValue(Add(entries, offset), -1)
                    StoreValue(Add(entries, Add(offset, 8)), 0)
                    StoreValue(Add(entries, Add(offset, 16)), 0)
                    
                    // Decrement size
                    StoreValue(Add(table, 16), Subtract(size, 1))
                    
                    ReturnValue(1)
                }
            }
            
            slot = Modulo(Add(slot, 1), capacity)
            i = Add(i, 1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// SIZE - Get number of entries
// =============================================================================
Function.THash.Size {
    Input: table: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(0)
        }
        
        size = Dereference(Add(table, 16))
        ReturnValue(size)
    }
}

// =============================================================================
// KEYS - Get all keys as TArray
// =============================================================================
Function.THash.Keys {
    Input: table: Address
    Output: Address
    Body: {
        
        
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(TArray.TCreate(0))
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(TArray.TCreate(0))
        }
        
        capacity = Dereference(Add(table, 8))
        size = Dereference(Add(table, 16))
        entries = Dereference(Add(table, 24))
        
        result = TArray.TCreate(size)
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(i, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            // Valid entry (not empty, not tombstone)
            IfCondition GreaterThan(slot_hash, 0) ThenBlock: {
                slot_key = Dereference(Add(entries, Add(offset, 8)))
                TArray.TPush(result, slot_key)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// VALUES - Get all values as TArray
// =============================================================================
Function.THash.Values {
    Input: table: Address
    Output: Address
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(TArray.TCreate(0))
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(TArray.TCreate(0))
        }
        
        capacity = Dereference(Add(table, 8))
        size = Dereference(Add(table, 16))
        entries = Dereference(Add(table, 24))
        
        result = TArray.TCreate(size)
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(i, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            IfCondition GreaterThan(slot_hash, 0) ThenBlock: {
                slot_value = Dereference(Add(entries, Add(offset, 16)))
                TArray.TPush(result, slot_value)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// ITEMS - Get all key-value pairs as TArray of [key, value] pairs
// =============================================================================
Function.THash.Items {
    Input: table: Address
    Output: Address
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(TArray.TCreate(0))
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(TArray.TCreate(0))
        }
        
        capacity = Dereference(Add(table, 8))
        size = Dereference(Add(table, 16))
        entries = Dereference(Add(table, 24))
        
        result = TArray.TCreate(size)
        
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(i, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            IfCondition GreaterThan(slot_hash, 0) ThenBlock: {
                slot_key = Dereference(Add(entries, Add(offset, 8)))
                slot_value = Dereference(Add(entries, Add(offset, 16)))
                
                // Create pair as TArray
                pair = TArray.TCreate(2)
                TArray.TPush(pair, slot_key)
                TArray.TPush(pair, slot_value)
                
                TArray.TPush(result, pair)
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// CLEAR - Remove all entries
// =============================================================================
Function.THash.Clear {
    Input: table: Address
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(table, 8))
        entries = Dereference(Add(table, 24))
        
        // Free all keys and clear slots
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(i, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            IfCondition GreaterThan(slot_hash, 0) ThenBlock: {
                slot_key = Dereference(Add(entries, Add(offset, 8)))
                IfCondition NotEqual(slot_key, 0) ThenBlock: {
                    Deallocate(slot_key, 0)
                }
            }
            
            StoreValue(Add(entries, offset), 0)
            StoreValue(Add(entries, Add(offset, 8)), 0)
            StoreValue(Add(entries, Add(offset, 16)), 0)
            
            i = Add(i, 1)
        }
        
        // Reset size
        StoreValue(Add(table, 16), 0)
    }
}

// =============================================================================
// RESIZE - Double capacity and rehash
// =============================================================================
Function.THash.Resize {
    Input: table: Address
    Body: {
        old_capacity = Dereference(Add(table, 8))
        old_entries = Dereference(Add(table, 24))
        
        new_capacity = Multiply(old_capacity, 2)
        new_entries_size = Multiply(new_capacity, 24)
        new_entries = Allocate(new_entries_size)
        
        // Initialize new entries
        i = 0
        WhileLoop LessThan(i, new_capacity) {
            offset = Multiply(i, 24)
            StoreValue(Add(new_entries, offset), 0)
            StoreValue(Add(new_entries, Add(offset, 8)), 0)
            StoreValue(Add(new_entries, Add(offset, 16)), 0)
            i = Add(i, 1)
        }
        
        // Rehash existing entries
        i = 0
        WhileLoop LessThan(i, old_capacity) {
            offset = Multiply(i, 24)
            slot_hash = Dereference(Add(old_entries, offset))
            
            // Valid entry (not empty, not tombstone)
            IfCondition GreaterThan(slot_hash, 0) ThenBlock: {
                slot_key = Dereference(Add(old_entries, Add(offset, 8)))
                slot_value = Dereference(Add(old_entries, Add(offset, 16)))
                
                // Find new slot
                new_slot = Modulo(slot_hash, new_capacity)
                
                // Linear probe
                found = 0
                WhileLoop EqualTo(found, 0) {
                    new_offset = Multiply(new_slot, 24)
                    new_slot_hash = Dereference(Add(new_entries, new_offset))
                    
                    IfCondition EqualTo(new_slot_hash, 0) ThenBlock: {
                        StoreValue(Add(new_entries, new_offset), slot_hash)
                        StoreValue(Add(new_entries, Add(new_offset, 8)), slot_key)
                        StoreValue(Add(new_entries, Add(new_offset, 16)), slot_value)
                        found = 1
                    } ElseBlock: {
                        new_slot = Modulo(Add(new_slot, 1), new_capacity)
                    }
                }
            }
            
            i = Add(i, 1)
        }
        
        // Free old entries
        old_size = Multiply(old_capacity, 24)
        Deallocate(old_entries, old_size)
        
        // Update table
        StoreValue(Add(table, 8), new_capacity)
        StoreValue(Add(table, 24), new_entries)
    }
}

// =============================================================================
// DESTROY - Free all memory
// =============================================================================
Function.THash.Destroy {
    Input: table: Address
    Body: {
        IfCondition EqualTo(table, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        magic = Dereference(table)
        IfCondition NotEqual(magic, THashMagic.MAGIC) ThenBlock: {
            ReturnValue(0)
        }
        
        capacity = Dereference(Add(table, 8))
        entries = Dereference(Add(table, 24))
        
        // Free all keys
        i = 0
        WhileLoop LessThan(i, capacity) {
            offset = Multiply(i, 24)
            slot_hash = Dereference(Add(entries, offset))
            
            IfCondition GreaterThan(slot_hash, 0) ThenBlock: {
                slot_key = Dereference(Add(entries, Add(offset, 8)))
                IfCondition NotEqual(slot_key, 0) ThenBlock: {
                    Deallocate(slot_key, 0)
                }
            }
            
            i = Add(i, 1)
        }
        
        // Free entries array
        entries_size = Multiply(capacity, 24)
        Deallocate(entries, entries_size)
        
        // Free header
        Deallocate(table, 32)
    }
}

// =============================================================================
// INITIALIZATION
// =============================================================================
SubRoutine.InitializeTHashLibrary {
    PrintMessage("THash Library Loaded (Typed Hash with Magic Numbers)\n")
}

RunTask(InitializeTHashLibrary)