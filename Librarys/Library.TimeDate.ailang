// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// ============================================================================
// AILANG Unified Time & Date Library
// High-Performance Cache-Aware Temporal Operations with Advanced Scheduling
// Merged from Library.Time.ailang and Library.Date_Time.ailang
// ============================================================================

// Cache-Optimized Memory Pools for High-Performance Time Operations
Pool.Time.Core = FixedPool {
    "timestamps": ElementType-Timestamp, MaximumLength-1000000,
    "datetime_objects": ElementType-DateTime, MaximumLength-1000000,
    "durations": ElementType-Duration, MaximumLength-100000,
    "cache_alignment": Initialize-64, CanChange-False  // Cache-line aligned
}

Pool.Time.Timers = FixedPool {
    "timer_handles": ElementType-TimerHandle, MaximumLength-100000,
    "timer_callbacks": ElementType-Function, MaximumLength-100000,
    "timer_queue": ElementType-Address, CanChange-True,
    "cache_policy": Initialize-"L2", CanChange-False
}

Pool.Time.Scheduling = DynamicPool {
    "scheduled_tasks": ElementType-ScheduledTask, MaximumLength-1000000,
    "cron_jobs": ElementType-CronJob, MaximumLength-100000,
    "task_queue": ElementType-Address, CanChange-True,
    "priority_queue": ElementType-Address, CanChange-True
}

Pool.Time.Zones = FixedPool {
    "timezone_data": ElementType-TimezoneInfo, MaximumLength-1000,
    "dst_rules": ElementType-DSTRule, MaximumLength-10000,
    "zone_cache": ElementType-Address, MaximumLength-10000,
    "cache_lifetime": Initialize-"24_hours", CanChange-False
}

Pool.Time.Performance = FixedPool {
    "benchmarks": ElementType-BenchmarkResult, MaximumLength-100000,
    "profiling_data": ElementType-ProfileData, MaximumLength-1000000,
    "timing_samples": ElementType-UInt64, MaximumLength-10000000,
    "cache_stats": ElementType-CacheStats, MaximumLength-1000000
}

Pool.Time.Formatting = TemporalPool {
    "formatted_strings": ElementType-Text, MaximumLength-100000,
    "parse_cache": ElementType-DateTime, MaximumLength-10000,
    "lifetime": Initialize-"1_hour", CanChange-False
}

// ============================================================================
// Core Data Types (Unified and Enhanced)
// ============================================================================

Timestamp = Record {
    seconds: UInt64,           // Seconds since Unix epoch
    nanoseconds: UInt32,       // Nanosecond component (0-999,999,999)
    timezone_offset: Integer,  // Offset from UTC in minutes
    timezone_name: Text,
    cache_line_padding: Array[UInt8, 32]  // Ensure cache alignment
}

DateTime = Record {
    year: UInt32,
    month: UInt8,              // 1-12
    day: UInt8,                // 1-31
    hour: UInt8,               // 0-23
    minute: UInt8,             // 0-59
    second: UInt8,             // 0-59
    nanosecond: UInt32,        // 0-999,999,999
    weekday: UInt8,            // 0=Sunday, 1=Monday, ..., 6=Saturday
    yearday: UInt16,           // 1-366 (day of year)
    timezone_offset: Integer,  // Minutes from UTC
    timezone_name: Text,
    unix_timestamp: UInt64,    // Cached Unix timestamp
    is_dst: Boolean,
    is_leap_year: Boolean
}

Duration = Record {
    seconds: UInt64,
    nanoseconds: UInt32
}

TimerHandle = Record {
    id: UInt64,
    duration_ms: UInt64,
    callback: Function,
    callback_data: Any,
    trigger_time: Timestamp,
    interval: OptionalType[Duration],  // For repeating timers
    active: Boolean,
    one_shot: Boolean,
    repeat: Boolean,
    running: Boolean,
    created_at: UInt64,
    next_trigger: UInt64,
    trigger_count: UInt64,
    priority: UInt8
}

ScheduledTask = Record {
    id: UInt64,
    task: Function,
    task_data: Any,
    schedule_time: DateTime,
    scheduled_time: Timestamp,
    unix_schedule_time: UInt64,
    repeat_interval: OptionalType[Duration],
    max_executions: OptionalType[UInt32],
    execution_count: UInt32,
    priority: UInt8,
    recurring: Boolean,
    enabled: Boolean
}

CronJob = Record {
    id: UInt64,
    expression: Text,          // Enhanced: "sec min hour day month weekday"
    task: Function,
    task_data: Any,
    next_run: DateTime,
    next_run_timestamp: Timestamp,
    last_run: OptionalType[DateTime],
    execution_count: UInt64,
    enabled: Boolean,
    parsed_expression: CronExpression
}

CronExpression = Record {
    second: CronField,
    minute: CronField,
    hour: CronField,
    day: CronField,
    month: CronField,
    weekday: CronField
}

CronField = Record {
    type: Text,               // "exact", "range", "step", "list", "wildcard"
    values: Array[UInt8],
    step: UInt8,
    min_value: UInt8,
    max_value: UInt8
}

TimezoneInfo = Record {
    name: Text,
    abbreviation: Text,
    utc_offset: Integer,      // Minutes from UTC
    dst_rules: Array[DSTRule],
    cache_expiry: UInt64
}

DSTRule = Record {
    start_month: UInt8,
    start_week: UInt8,
    start_day: UInt8,
    start_time: UInt32,       // Minutes since midnight
    end_month: UInt8,
    end_week: UInt8,
    end_day: UInt8,
    end_time: UInt32,
    offset_minutes: Integer
}

BenchmarkResult = Record {
    name: Text,
    iterations: UInt64,
    total_time_ns: UInt64,
    avg_time_ns: UInt64,
    min_time_ns: UInt64,
    max_time_ns: UInt64,
    memory_usage: UInt64,
    cache_misses: UInt64,
    cache_hits: UInt64
}

ProfileData = Record {
    function_name: Text,
    call_count: UInt64,
    total_time_ns: UInt64,
    self_time_ns: UInt64,
    avg_time_ns: UInt64,
    cache_efficiency: FloatingPoint
}

CacheStats = Record {
    l1_hits: UInt64,
    l1_misses: UInt64,
    l2_hits: UInt64,
    l2_misses: UInt64,
    l3_hits: UInt64,
    l3_misses: UInt64
}

// ============================================================================
// Core Time Functions (Enhanced)
// ============================================================================

Function.Time.Now {
    Output: Timestamp
    Body: {
        Pool.Time.Core.Allocate(timestamp)
        
        // High-resolution time with cache optimization
        unix_time = Hardware.Syscall.GetUnixTime()
        nanoseconds = Hardware.Syscall.GetNanoseconds()
        
        timestamp.seconds = unix_time
        timestamp.nanoseconds = nanoseconds
        timestamp.timezone_offset = Time.GetSystemTimezoneOffset()
        timestamp.timezone_name = Time.GetSystemTimezoneName()
        
        ReturnValue(timestamp)
    }
}

Function.Time.NowUTC {
    Output: Timestamp
    Body: {
        timestamp = Time.Now()
        timestamp.timezone_offset = 0
        timestamp.timezone_name = "UTC"
        
        ReturnValue(timestamp)
    }
}

Function.Time.NowDateTime {
    Output: DateTime
    Body: {
        Pool.Time.Core.Allocate(dt)
        
        // Get current Unix timestamp with nanoseconds
        unix_time = Hardware.Syscall.GetUnixTime()
        nanos = Hardware.Syscall.GetNanoseconds()
        
        dt.unix_timestamp = unix_time
        dt.nanosecond = nanos
        
        // Convert to broken-down time
        Time.Internal.UnixToDateTime(unix_time, dt)
        
        // Get timezone information with caching
        tz_info = Time.Timezone.GetLocal()
        dt.timezone_offset = tz_info.utc_offset
        dt.timezone_name = tz_info.name
        dt.is_dst = Time.Timezone.IsDST(dt, tz_info)
        dt.is_leap_year = Time.IsLeapYear(dt.year)
        
        ReturnValue(dt)
    }
}

Function.Time.Unix {
    Output: UInt64
    Body: {
        ReturnValue(Hardware.Syscall.GetUnixTime())
    }
}

Function.Time.UnixMilli {
    Output: UInt64
    Body: {
        unix_time = Hardware.Syscall.GetUnixTime()
        millis = Hardware.Syscall.GetMilliseconds()
        
        ReturnValue(Add(Multiply(unix_time, 1000), millis))
    }
}

Function.Time.UnixNano {
    Output: UInt64
    Body: {
        unix_time = Hardware.Syscall.GetUnixTime()
        nanos = Hardware.Syscall.GetNanoseconds()
        
        ReturnValue(Add(Multiply(unix_time, 1000000000), nanos))
    }
}

// ============================================================================
// Duration Operations (Enhanced)
// ============================================================================

Function.Time.Duration.Create {
    Input: (seconds: UInt64 = 0, nanoseconds: UInt32 = 0)
    Output: Duration
    Body: {
        Pool.Time.Core.Allocate(duration)
        
        // Normalize nanoseconds for cache efficiency
        extra_seconds = Divide(nanoseconds, 1000000000)
        duration.seconds = Add(seconds, extra_seconds)
        duration.nanoseconds = Modulo(nanoseconds, 1000000000)
        
        ReturnValue(duration)
    }
}

Function.Time.ParseDuration {
    Input: (duration_str: Text)  // "5s", "10m", "1h", "2d", "1.5h"
    Output: Duration
    Body: {
        duration = Duration.Create()
        
        // Handle multiple units: "1h30m45s"
        IfCondition StringContains(duration_str, "h") Or StringContains(duration_str, "m") Or StringContains(duration_str, "s") ThenBlock {
            total_seconds = Time.Internal.ParseComplexDuration(duration_str)
            duration.seconds = total_seconds
        } ElseBox {
            // Simple format: extract number and unit
            length = StringLength(duration_str)
            unit = StringSlice(duration_str, Subtract(length, 1), length)
            number_str = StringSlice(duration_str, 0, Subtract(length, 1))
            
            // Handle decimal numbers
            IfCondition StringContains(number_str, ".") ThenBlock {
                number = StringToFloat(number_str)
            } ElseBlock {
                number = StringToInteger(number_str)
            }
            
            ChoosePath unit {
                CaseOption "s": duration.seconds = number
                CaseOption "m": duration.seconds = Multiply(number, 60)
                CaseOption "h": duration.seconds = Multiply(number, 3600)
                CaseOption "d": duration.seconds = Multiply(number, 86400)
                CaseOption "w": duration.seconds = Multiply(number, 604800)
                DefaultOption: {
                    TryBlock: {} CatchError.InvalidDuration {
                        PrintMessage("Invalid duration format: " + duration_str)
                        duration.seconds = 0
                    }
                }
            }
        }
        
        duration.nanoseconds = 0
        ReturnValue(duration)
    }
}

Function.Time.Duration.FromMilliseconds {
    Input: (milliseconds: UInt64)
    Output: Duration
    Body: {
        seconds = Divide(milliseconds, 1000)
        remaining_ms = Modulo(milliseconds, 1000)
        nanoseconds = Multiply(remaining_ms, 1000000)
        
        ReturnValue(Time.Duration.Create(seconds, nanoseconds))
    }
}

Function.Time.Duration.FromSeconds {
    Input: (seconds: UInt64)
    Output: Duration
    Body: {
        ReturnValue(Time.Duration.Create(seconds, 0))
    }
}

Function.Time.Duration.FromMinutes {
    Input: (minutes: UInt64)
    Output: Duration
    Body: {
        seconds = Multiply(minutes, 60)
        ReturnValue(Time.Duration.Create(seconds, 0))
    }
}

Function.Time.Duration.FromHours {
    Input: (hours: UInt64)
    Output: Duration
    Body: {
        seconds = Multiply(hours, 3600)
        ReturnValue(Time.Duration.Create(seconds, 0))
    }
}

Function.Time.Duration.FromDays {
    Input: (days: UInt64)
    Output: Duration
    Body: {
        seconds = Multiply(days, 86400)
        ReturnValue(Time.Duration.Create(seconds, 0))
    }
}

Function.Time.Duration.Add {
    Input: (d1: Duration, d2: Duration)
    Output: Duration
    Body: {
        total_nanoseconds = Add(d1.nanoseconds, d2.nanoseconds)
        extra_seconds = Divide(total_nanoseconds, 1000000000)
        
        result_seconds = Add(Add(d1.seconds, d2.seconds), extra_seconds)
        result_nanoseconds = Modulo(total_nanoseconds, 1000000000)
        
        ReturnValue(Time.Duration.Create(result_seconds, result_nanoseconds))
    }
}

Function.Time.Duration.Subtract {
    Input: (d1: Duration, d2: Duration)
    Output: Duration
    Body: {
        d1_nanos = Add(Multiply(d1.seconds, 1000000000), d1.nanoseconds)
        d2_nanos = Add(Multiply(d2.seconds, 1000000000), d2.nanoseconds)
        
        IfCondition LessThan(d1_nanos, d2_nanos) ThenBlock {
            ReturnValue(Time.Duration.Create(0, 0))
        }
        
        diff_nanos = Subtract(d1_nanos, d2_nanos)
        result_seconds = Divide(diff_nanos, 1000000000)
        result_nanoseconds = Modulo(diff_nanos, 1000000000)
        
        ReturnValue(Time.Duration.Create(result_seconds, result_nanoseconds))
    }
}

Function.Time.Duration.TotalMilliseconds {
    Input: (duration: Duration)
    Output: UInt64
    Body: {
        milliseconds_from_seconds = Multiply(duration.seconds, 1000)
        milliseconds_from_nanos = Divide(duration.nanoseconds, 1000000)
        
        ReturnValue(Add(milliseconds_from_seconds, milliseconds_from_nanos))
    }
}

Function.Time.Duration.TotalSeconds {
    Input: (duration: Duration)
    Output: FloatingPoint
    Body: {
        seconds_from_nanos = Divide(duration.nanoseconds, 1000000000.0)
        ReturnValue(Add(duration.seconds, seconds_from_nanos))
    }
}

// ============================================================================
// DateTime Creation and Parsing (Enhanced)
// ============================================================================

Function.Time.Create {
    Input: (
        year: UInt32,
        month: UInt8,
        day: UInt8,
        hour: UInt8 = 0,
        minute: UInt8 = 0,
        second: UInt8 = 0,
        nanosecond: UInt32 = 0,
        timezone: Text = "UTC"
    )
    Output: DateTime
    Body: {
        Pool.Time.Core.Allocate(dt)
        
        dt.year = year
        dt.month = month
        dt.day = day
        dt.hour = hour
        dt.minute = minute
        dt.second = second
        dt.nanosecond = nanosecond
        
        // Validate date components
        IfCondition Not(Time.Internal.ValidateDate(dt)) ThenBlock {
            TryBlock: {} CatchError.InvalidDate {
                PrintMessage("Invalid date components")
                ReturnValue(Time.NowDateTime())
            }
        }
        
        // Calculate derived fields
        dt.is_leap_year = Time.IsLeapYear(year)
        dt.yearday = Time.Internal.CalculateYearDay(dt)
        dt.weekday = Time.Internal.CalculateWeekday(dt)
        
        // Set timezone with caching
        tz_info = Time.Timezone.Get(timezone)
        dt.timezone_offset = tz_info.utc_offset
        dt.timezone_name = tz_info.name
        dt.is_dst = Time.Timezone.IsDST(dt, tz_info)
        
        // Calculate Unix timestamp
        dt.unix_timestamp = Time.Internal.DateTimeToUnix(dt)
        
        ReturnValue(dt)
    }
}

Function.Time.Parse {
    Input: (date_string: Text, format: Text = "RFC3339")
    Output: DateTime
    Body: {
        // Check formatting cache first
        cached_result = Time.Internal.GetFromParseCache(date_string, format)
        IfCondition NotEqual(cached_result, Null) ThenBlock {
            ReturnValue(cached_result)
        }
        
        Pool.Time.Core.Allocate(dt)
        
        ChoosePath format {
            CaseOption "RFC3339": {
                // "2023-12-25T15:30:45Z" or "2023-12-25T15:30:45+02:00"
                parsed = Time.Internal.ParseRFC3339(date_string)
            }
            CaseOption "ISO8601": {
                // "2023-12-25T15:30:45.123Z"
                parsed = Time.Internal.ParseISO8601(date_string)
            }
            CaseOption "Unix": {
                // "1703516445"
                unix_time = StringToInteger(date_string)
                parsed = Time.FromUnix(unix_time)
            }
            CaseOption "Custom": {
                // User-defined format
                parsed = Time.Internal.ParseCustom(date_string, format)
            }
            DefaultOption: {
                // Auto-detect format
                parsed = Time.Internal.AutoParseDateTime(date_string)
            }
        }
        
        // Cache result for performance
        Time.Internal.AddToParseCache(date_string, format, parsed)
        
        ReturnValue(parsed)
    }
}

Function.Time.FromUnix {
    Input: (unix_timestamp: UInt64, timezone: Text = "UTC")
    Output: DateTime
    Body: {
        Pool.Time.Core.Allocate(dt)
        
        dt.unix_timestamp = unix_timestamp
        dt.nanosecond = 0
        
        // Convert to broken-down time
        Time.Internal.UnixToDateTime(unix_timestamp, dt)
        
        // Set timezone
        tz_info = Time.Timezone.Get(timezone)
        dt.timezone_offset = tz_info.utc_offset
        dt.timezone_name = tz_info.name
        dt.is_dst = Time.Timezone.IsDST(dt, tz_info)
        dt.is_leap_year = Time.IsLeapYear(dt.year)
        
        ReturnValue(dt)
    }
}

// ============================================================================
// Timestamp Operations (Enhanced)
// ============================================================================

Function.Time.Timestamp.Add {
    Input: (timestamp: Timestamp, duration: Duration)
    Output: Timestamp
    Body: {
        Pool.Time.Core.Allocate(result)
        result.timezone_offset = timestamp.timezone_offset
        result.timezone_name = timestamp.timezone_name
        
        total_nanoseconds = Add(timestamp.nanoseconds, duration.nanoseconds)
        extra_seconds = Divide(total_nanoseconds, 1000000000)
        
        result.seconds = Add(Add(timestamp.seconds, duration.seconds), extra_seconds)
        result.nanoseconds = Modulo(total_nanoseconds, 1000000000)
        
        ReturnValue(result)
    }
}

Function.Time.Timestamp.Subtract {
    Input: (timestamp: Timestamp, duration: Duration)
    Output: Timestamp
    Body: {
        Pool.Time.Core.Allocate(result)
        result.timezone_offset = timestamp.timezone_offset
        result.timezone_name = timestamp.timezone_name
        
        timestamp_nanos = Add(Multiply(timestamp.seconds, 1000000000), timestamp.nanoseconds)
        duration_nanos = Add(Multiply(duration.seconds, 1000000000), duration.nanoseconds)
        
        IfCondition LessThan(timestamp_nanos, duration_nanos) ThenBlock {
            result.seconds = 0
            result.nanoseconds = 0
        } ElseBlock {
            diff_nanos = Subtract(timestamp_nanos, duration_nanos)
            result.seconds = Divide(diff_nanos, 1000000000)
            result.nanoseconds = Modulo(diff_nanos, 1000000000)
        }
        
        ReturnValue(result)
    }
}

Function.Time.Timestamp.Difference {
    Input: (t1: Timestamp, t2: Timestamp)
    Output: Duration
    Body: {
        t1_nanos = Add(Multiply(t1.seconds, 1000000000), t1.nanoseconds)
        t2_nanos = Add(Multiply(t2.seconds, 1000000000), t2.nanoseconds)
        
        IfCondition GreaterThan(t1_nanos, t2_nanos) ThenBlock {
            diff_nanos = Subtract(t1_nanos, t2_nanos)
        } ElseBlock {
            diff_nanos = Subtract(t2_nanos, t1_nanos)
        }
        
        seconds = Divide(diff_nanos, 1000000000)
        nanoseconds = Modulo(diff_nanos, 1000000000)
        
        ReturnValue(Time.Duration.Create(seconds, nanoseconds))
    }
}

Function.Time.Timestamp.Compare {
    Input: (t1: Timestamp, t2: Timestamp)
    Output: Integer  // -1 if t1 < t2, 0 if equal, 1 if t1 > t2
    Body: {
        IfCondition LessThan(t1.seconds, t2.seconds) ThenBlock {
            ReturnValue(-1)
        } ElseBlock {
            IfCondition GreaterThan(t1.seconds, t2.seconds) ThenBlock {
                ReturnValue(1)
            } ElseBlock {
                IfCondition LessThan(t1.nanoseconds, t2.nanoseconds) ThenBlock {
                    ReturnValue(-1)
                } ElseBlock {
                    IfCondition GreaterThan(t1.nanoseconds, t2.nanoseconds) ThenBlock {
                        ReturnValue(1)
                    } ElseBlock {
                        ReturnValue(0)
                    }
                }
            }
        }
    }
}

Function.Time.Timestamp.ToDateTime {
    Input: (timestamp: Timestamp)
    Output: DateTime
    Body: {
        Pool.Time.Core.Allocate(datetime)
        
        // Adjust for timezone
        adjusted_seconds = Add(timestamp.seconds, Multiply(timestamp.timezone_offset, 60))
        
        // Convert to DateTime
        Time.Internal.UnixToDateTime(adjusted_seconds, datetime)
        
        datetime.nanosecond = timestamp.nanoseconds
        datetime.timezone_name = timestamp.timezone_name
        datetime.timezone_offset = timestamp.timezone_offset
        datetime.unix_timestamp = timestamp.seconds
        
        ReturnValue(datetime)
    }
}

Function.Time.DateTime.ToTimestamp {
    Input: (datetime: DateTime)
    Output: Timestamp
    Body: {
        Pool.Time.Core.Allocate(timestamp)
        
        timestamp.seconds = datetime.unix_timestamp
        timestamp.nanoseconds = datetime.nanosecond
        timestamp.timezone_name = datetime.timezone_name
        timestamp.timezone_offset = datetime.timezone_offset
        
        ReturnValue(timestamp)
    }
}

// ============================================================================
// Date Arithmetic (Enhanced)
// ============================================================================

Function.Time.Add {
    Input: (dt: DateTime, duration: Duration)
    Output: DateTime
    Body: {
        new_unix = Add(dt.unix_timestamp, duration.seconds)
        new_nanos = Add(dt.nanosecond, duration.nanoseconds)
        
        // Handle nanosecond overflow
        IfCondition GreaterThanOrEqual(new_nanos, 1000000000) ThenBlock {
            new_unix = Add(new_unix, 1)
            new_nanos = Subtract(new_nanos, 1000000000)
        }
        
        result = Time.FromUnix(new_unix, dt.timezone_name)
        result.nanosecond = new_nanos
        
        ReturnValue(result)
    }
}

Function.Time.Subtract {
    Input: (dt: DateTime, duration: Duration)
    Output: DateTime
    Body: {
        new_unix = Subtract(dt.unix_timestamp, duration.seconds)
        new_nanos = Subtract(dt.nanosecond, duration.nanoseconds)
        
        // Handle nanosecond underflow
        IfCondition LessThan(new_nanos, 0) ThenBlock {
            new_unix = Subtract(new_unix, 1)
            new_nanos = Add(new_nanos, 1000000000)
        }
        
        result = Time.FromUnix(new_unix, dt.timezone_name)
        result.nanosecond = new_nanos
        
        ReturnValue(result)
    }
}

Function.Time.Difference {
    Input: (dt1: DateTime, dt2: DateTime)
    Output: Duration
    Body: {
        // Convert both to UTC for accurate comparison
        unix1 = Subtract(dt1.unix_timestamp, Multiply(dt1.timezone_offset, 60))
        unix2 = Subtract(dt2.unix_timestamp, Multiply(dt2.timezone_offset, 60))
        
        IfCondition GreaterThan(unix1, unix2) ThenBlock {
            seconds = Subtract(unix1, unix2)
            nanos = Subtract(dt1.nanosecond, dt2.nanosecond)
        } ElseBlock {
            seconds = Subtract(unix2, unix1)
            nanos = Subtract(dt2.nanosecond, dt1.nanosecond)
        }
        
        // Handle nanosecond underflow
        IfCondition LessThan(nanos, 0) ThenBlock {
            seconds = Subtract(seconds, 1)
            nanos = Add(nanos, 1000000000)
        }
        
        ReturnValue(Time.Duration.Create(seconds, nanos))
    }
}

// ============================================================================
// Enhanced Timer System (Cache-Aware)
// ============================================================================

Function.Time.Timer.Create {
    Input: (
        duration_ms: UInt64,
        callback: Function,
        callback_data: Any = Null,
        repeat: Boolean = False,
        priority: UInt8 = 50
    )
    Output: TimerHandle
    Body: {
        Pool.Time.Timers.Allocate(timer)
        
        timer.id = Time.Internal.GenerateTimerID()
        timer.duration_ms = duration_ms
        timer.callback = callback
        timer.callback_data = callback_data
        timer.repeat = repeat
        timer.priority = priority
        timer.running = False
        timer.active = False
        timer.one_shot = Not(repeat)
        timer.created_at = Time.UnixMilli()
        timer.next_trigger = 0
        timer.trigger_count = 0
        
        // Set up interval duration
        IfCondition repeat ThenBlock {
            timer.interval = Time.Duration.FromMilliseconds(duration_ms)
        } ElseBlock {
            timer.interval = Null
        }
        
        // Set trigger time
        now = Time.Now()
        delay = Time.Duration.FromMilliseconds(duration_ms)
        timer.trigger_time = Time.Timestamp.Add(now, delay)
        
        ReturnValue(timer)
    }
}

Function.Time.Timer.Start {
    Input: (timer: TimerHandle)
    Body: {
        timer.running = True
        timer.active = True
        timer.next_trigger = Add(Time.UnixMilli(), timer.duration_ms)
        
        // Register with cache-aware timer system
        Time.TimerSystem.ScheduleTimer(timer)
    }
}

Function.Time.Timer.Stop {
    Input: (timer: TimerHandle)
    Body: {
        timer.running = False
        timer.active = False
        
        // Unregister from timer system
        Time.TimerSystem.CancelTimer(timer)
    }
}

Function.Time.Timer.Reset {
    Input: (timer: TimerHandle, new_delay: OptionalType[Duration] = Null)
    Body: {
        IfCondition NotEqual(new_delay, Null) ThenBlock {
            timer.duration_ms = Time.Duration.TotalMilliseconds(new_delay)
        }
        
        now = Time.Now()
        delay = Time.Duration.FromMilliseconds(timer.duration_ms)
        timer.trigger_time = Time.Timestamp.Add(now, delay)
        timer.next_trigger = Add(Time.UnixMilli(), timer.duration_ms)
        
        IfCondition timer.active ThenBlock {
            Time.TimerSystem.RescheduleTimer(timer)
        }
    }
}

// Cache-Aware Timer System Singleton
TimerSystem = Record {
    active_timers: DataStructures.PriorityQueue,
    timer_thread: ThreadHandle,
    running: Boolean,
    mutex: MutexHandle,
    next_timer_id: UInt64,
    cache_stats: CacheStats
}

Function.Time.TimerSystem.Initialize {
    Body: {
        TimerSystem.active_timers = DataStructures.PriorityQueue.Create(heap_type-"min_heap")
        TimerSystem.running = True
        TimerSystem.mutex = Concurrency.Mutex.Create()
        TimerSystem.next_timer_id = 1
        
        // Initialize cache statistics
        TimerSystem.cache_stats = CacheStats.Create()
        
        // Start cache-optimized timer processing thread
        TimerSystem.timer_thread = Thread.Create(
            function-Time.TimerSystem.ProcessTimers,
            cache_policy-"L2",
            priority-"high"
        )
    }
}

Function.Time.TimerSystem.ScheduleTimer {
    Input: (timer: TimerHandle)
    Body: {
        Concurrency.Mutex.Lock(TimerSystem.mutex)
        
        priority = Time.Duration.TotalMilliseconds(
            Time.Timestamp.Difference(timer.trigger_time, Time.Now())
        )
        
        DataStructures.PriorityQueue.Push(TimerSystem.active_timers, timer, priority)
        
        Concurrency.Mutex.Unlock(TimerSystem.mutex)
    }
}

Function.Time.TimerSystem.ProcessTimers {
    Body: {
        WhileLoop TimerSystem.running {
            start_time = Time.UnixNano()
            
            Concurrency.Mutex.Lock(TimerSystem.mutex)
            
            now = Time.Now()
            processed_count = 0
            
            // Process all expired timers in cache-friendly batches
            WhileLoop Not(DataStructures.PriorityQueue.IsEmpty(TimerSystem.active_timers)) {
                next_timer = DataStructures.PriorityQueue.Peek(TimerSystem.active_timers)
                
                IfCondition Time.Timestamp.Compare(now, next_timer.trigger_time) >= 0 ThenBlock {
                    timer = DataStructures.PriorityQueue.Pop(TimerSystem.active_timers)
                    
                    IfCondition timer.active ThenBlock {
                        Concurrency.Mutex.Unlock(TimerSystem.mutex)
                        
                        // Execute timer callback with profiling
                        callback_start = Time.UnixNano()
                        TryBlock: {
                            Apply(timer.callback, timer.callback_data)
                            timer.trigger_count = Add(timer.trigger_count, 1)
                        }
                        CatchError.Any {
                            PrintMessage("Timer callback error: " + GetErrorMessage())
                        }
                        callback_end = Time.UnixNano()
                        
                        Concurrency.Mutex.Lock(TimerSystem.mutex)
                        
                        // Reschedule if repeating
                        IfCondition And(timer.active, Not(timer.one_shot)) ThenBlock {
                            timer.trigger_time = Time.Timestamp.Add(timer.trigger_time, timer.interval)
                            timer.next_trigger = Add(timer.next_trigger, timer.duration_ms)
                            Time.TimerSystem.ScheduleTimer(timer)
                        }
                    }
                    
                    processed_count = Add(processed_count, 1)
                } ElseBlock {
                    BreakLoop
                }
            }
            
            Concurrency.Mutex.Unlock(TimerSystem.mutex)
            
            // Update cache statistics
            end_time = Time.UnixNano()
            cycle_time = Subtract(end_time, start_time)
            Time.Internal.UpdateCacheStats(TimerSystem.cache_stats, cycle_time, processed_count)
            
            // Adaptive sleep based on load
            IfCondition EqualTo(processed_count, 0) ThenBlock {
                Time.SleepMilliseconds(10)  // No work, sleep longer
            } ElseBlock {
                Time.SleepMilliseconds(1)   // Had work, check sooner
            }
        }
    }
}

// ============================================================================
// Enhanced Scheduling System
// ============================================================================

Function.Time.Schedule.Once {
    Input: (
        task: Function,
        delay: Duration,
        task_data: Any = Null,
        priority: UInt8 = 50
    )
    Output: ScheduledTask
    Body: {
        Pool.Time.Scheduling.Allocate(scheduled_task)
        
        scheduled_task.id = Time.Internal.GenerateTaskID()
        scheduled_task.task = task
        scheduled_task.task_data = task_data
        scheduled_task.scheduled_time = Time.Add(Time.NowDateTime(), delay)
        scheduled_task.unix_schedule_time = Add(Time.Unix(), delay.seconds)
        scheduled_task.repeat_interval = Null
        scheduled_task.max_executions = 1
        scheduled_task.execution_count = 0
        scheduled_task.priority = priority
        scheduled_task.recurring = False
        scheduled_task.enabled = True
        
        Time.Scheduler.AddTask(scheduled_task)
        
        ReturnValue(scheduled_task)
    }
}

Function.Time.Schedule.Recurring {
    Input: (
        task: Function,
        interval: Duration,
        start_delay: Duration = Time.Duration.Create(0, 0),
        task_data: Any = Null,
        max_executions: OptionalType[UInt32] = Null
    )
    Output: ScheduledTask
    Body: {
        Pool.Time.Scheduling.Allocate(scheduled_task)
        
        scheduled_task.id = Time.Internal.GenerateTaskID()
        scheduled_task.task = task
        scheduled_task.task_data = task_data
        scheduled_task.scheduled_time = Time.Add(Time.NowDateTime(), start_delay)
        scheduled_task.unix_schedule_time = Add(Time.Unix(), start_delay.seconds)
        scheduled_task.repeat_interval = interval
        scheduled_task.max_executions = max_executions
        scheduled_task.execution_count = 0
        scheduled_task.priority = 50
        scheduled_task.recurring = True
        scheduled_task.enabled = True
        
        Time.Scheduler.AddTask(scheduled_task)
        
        ReturnValue(scheduled_task)
    }
}

Function.Time.Schedule.At {
    Input: (
        task: Function,
        timestamp: Timestamp,
        task_data: Any = Null
    )
    Output: ScheduledTask
    Body: {
        Pool.Time.Scheduling.Allocate(scheduled_task)
        
        scheduled_task.id = Time.Internal.GenerateTaskID()
        scheduled_task.task = task
        scheduled_task.task_data = task_data
        scheduled_task.scheduled_time = Time.Timestamp.ToDateTime(timestamp)
        scheduled_task.unix_schedule_time = timestamp.seconds
        scheduled_task.repeat_interval = Null
        scheduled_task.max_executions = 1
        scheduled_task.execution_count = 0
        scheduled_task.priority = 50
        scheduled_task.recurring = False
        scheduled_task.enabled = True
        
        Time.Scheduler.AddTask(scheduled_task)
        
        ReturnValue(scheduled_task)
    }
}

Function.Time.ScheduleInterval {
    Input: (
        task: Function,
        interval: Text,  // "5s", "10m", "1h", "1d"
        task_data: Any = Null,
        immediate: Boolean = False
    )
    Output: ScheduledTask
    Body: {
        duration = Time.ParseDuration(interval)
        
        start_delay = IfCondition immediate ThenBlock {
            Time.Duration.Create(0, 0)
        } ElseBlock {
            duration
        }
        
        scheduled_task = Time.Schedule.Recurring(task, duration, start_delay, task_data)
        
        ReturnValue(scheduled_task)
    }
}

Function.Time.Schedule.Cancel {
    Input: (task: ScheduledTask)
    Body: {
        task.enabled = False
        Time.Scheduler.RemoveTask(task.id)
    }
}

// Cache-Aware Scheduler Singleton
Scheduler = Record {
    task_queue: DataStructures.PriorityQueue,
    scheduler_thread: ThreadHandle,
    running: Boolean,
    mutex: MutexHandle,
    next_task_id: UInt64,
    cache_stats: CacheStats
}

Function.Time.Scheduler.Initialize {
    Body: {
        Scheduler.task_queue = DataStructures.PriorityQueue.Create(heap_type-"min_heap")
        Scheduler.running = True
        Scheduler.mutex = Concurrency.Mutex.Create()
        Scheduler.next_task_id = 1
        Scheduler.cache_stats = CacheStats.Create()
        
        Scheduler.scheduler_thread = Thread.Create(
            function-Time.Scheduler.ProcessTasks,
            cache_policy-"L2",
            priority-"normal"
        )
    }
}

Function.Time.Scheduler.AddTask {
    Input: (task: ScheduledTask)
    Body: {
        Concurrency.Mutex.Lock(Scheduler.mutex)
        
        priority = Time.Duration.TotalMilliseconds(
            Time.Timestamp.Difference(
                Time.DateTime.ToTimestamp(task.scheduled_time),
                Time.Now()
            )
        )
        
        DataStructures.PriorityQueue.Push(Scheduler.task_queue, task, priority)
        
        Concurrency.Mutex.Unlock(Scheduler.mutex)
    }
}

Function.Time.Scheduler.ProcessTasks {
    Body: {
        WhileLoop Scheduler.running {
            start_time = Time.UnixNano()
            
            Concurrency.Mutex.Lock(Scheduler.mutex)
            
            now = Time.Now()
            processed_count = 0
            
            WhileLoop Not(DataStructures.PriorityQueue.IsEmpty(Scheduler.task_queue)) {
                next_task = DataStructures.PriorityQueue.Peek(Scheduler.task_queue)
                
                IfCondition And(
                    next_task.enabled,
                    LessEqual(next_task.unix_schedule_time, Time.Unix())
                ) ThenBlock {
                    task = DataStructures.PriorityQueue.Pop(Scheduler.task_queue)
                    
                    Concurrency.Mutex.Unlock(Scheduler.mutex)
                    
                    // Execute task in background thread
                    background_task = Lambda() {
                        TryBlock: {
                            Apply(task.task, task.task_data)
                            task.execution_count = Add(task.execution_count, 1)
                        }
                        CatchError.Any {
                            PrintMessage("Scheduled task error: " + GetErrorMessage())
                        }
                    }
                    
                    Thread.Create(background_task, cache_policy-"L1")
                    
                    Concurrency.Mutex.Lock(Scheduler.mutex)
                    
                    // Reschedule if recurring and not at max executions
                    IfCondition And(
                        task.recurring,
                        task.enabled,
                        Or(
                            EqualTo(task.max_executions, Null),
                            LessThan(task.execution_count, task.max_executions)
                        )
                    ) ThenBlock {
                        task.scheduled_time = Time.Add(task.scheduled_time, task.repeat_interval)
                        task.unix_schedule_time = Add(task.unix_schedule_time, task.repeat_interval.seconds)
                        Time.Scheduler.AddTask(task)
                    }
                    
                    processed_count = Add(processed_count, 1)
                } ElseBlock {
                    BreakLoop
                }
            }
            
            Concurrency.Mutex.Unlock(Scheduler.mutex)
            
            // Update cache statistics
            end_time = Time.UnixNano()
            cycle_time = Subtract(end_time, start_time)
            Time.Internal.UpdateCacheStats(Scheduler.cache_stats, cycle_time, processed_count)
            
            IfCondition EqualTo(processed_count, 0) ThenBlock {
                Time.SleepMilliseconds(100)
            } ElseBlock {
                Time.SleepMilliseconds(10)
            }
        }
    }
}

// ============================================================================
// Enhanced Cron System with Advanced Expression Parsing
// ============================================================================

Function.Time.Cron.Create {
    Input: (
        expression: Text,  // "0 */5 * * * *" (sec min hour day month weekday)
        task: Function,
        task_data: Any = Null
    )
    Output: CronJob
    Body: {
        Pool.Time.Scheduling.Allocate(cron_job)
        
        cron_job.id = Time.Internal.GenerateCronID()
        cron_job.expression = expression
        cron_job.task = task
        cron_job.task_data = task_data
        cron_job.execution_count = 0
        cron_job.enabled = True
        cron_job.last_run = Null
        
        // Parse cron expression into structured format
        cron_job.parsed_expression = Time.Cron.ParseExpression(expression)
        
        // Calculate next run time
        cron_job.next_run = Time.Cron.CalculateNextRun(cron_job.parsed_expression, Time.NowDateTime())
        cron_job.next_run_timestamp = Time.DateTime.ToTimestamp(cron_job.next_run)
        
        // Add to cron scheduler
        Time.CronSystem.AddJob(cron_job)
        
        ReturnValue(cron_job)
    }
}

Function.Time.Cron.ParseExpression {
    Input: (expression: Text)
    Output: CronExpression
    Body: {
        parsed = CronExpression.Create()
        
        // Split expression: "sec min hour day month weekday"
        parts = StringSplit(expression, " ")
        IfCondition NotEqual(ArrayLength(parts), 6) ThenBlock {
            TryBlock: {} CatchError.InvalidCronExpression {
                PrintMessage("Invalid cron expression format")
            }
        }
        
        parsed.second = Time.Cron.ParseField(parts[0], 0, 59)
        parsed.minute = Time.Cron.ParseField(parts[1], 0, 59)
        parsed.hour = Time.Cron.ParseField(parts[2], 0, 23)
        parsed.day = Time.Cron.ParseField(parts[3], 1, 31)
        parsed.month = Time.Cron.ParseField(parts[4], 1, 12)
        parsed.weekday = Time.Cron.ParseField(parts[5], 0, 6)
        
        ReturnValue(parsed)
    }
}

Function.Time.Cron.ParseField {
    Input: (field_spec: Text, min_val: UInt8, max_val: UInt8)
    Output: CronField
    Body: {
        field = CronField.Create()
        field.min_value = min_val
        field.max_value = max_val
        
        // Handle different field types
        IfCondition StringEquals(field_spec, "*") ThenBlock {
            field.type = "wildcard"
            field.values = []
            field.step = 1
        } ElseBlock {
            IfCondition StringContains(field_spec, "/") ThenBlock {
                // Step values: "*/5" or "10-20/3"
                step_parts = StringSplit(field_spec, "/")
                field.step = StringToInteger(step_parts[1])
                
                IfCondition StringEquals(step_parts[0], "*") ThenBlock {
                    field.type = "step"
                    field.values = []
                } ElseBlock {
                    // Range with step
                    field.type = "range_step"
                    range_field = Time.Cron.ParseField(step_parts[0], min_val, max_val)
                    field.values = range_field.values
                }
            } ElseBlock {
                IfCondition StringContains(field_spec, "-") ThenBlock {
                    // Range: "10-20"
                    field.type = "range"
                    range_parts = StringSplit(field_spec, "-")
                    start_val = StringToInteger(range_parts[0])
                    end_val = StringToInteger(range_parts[1])
                    
                    field.values = []
                    ForEvery i in Range(start_val, end_val + 1) {
                        ArrayPush(field.values, i)
                    }
                } ElseBlock {
                    IfCondition StringContains(field_spec, ",") ThenBlock {
                        // List: "1,3,5"
                        field.type = "list"
                        value_strings = StringSplit(field_spec, ",")
                        field.values = []
                        
                        ForEvery val_str in value_strings {
                            ArrayPush(field.values, StringToInteger(val_str))
                        }
                    } ElseBlock {
                        // Exact value: "15"
                        field.type = "exact"
                        field.values = [StringToInteger(field_spec)]
                    }
                }
            }
        }
        
        ReturnValue(field)
    }
}

Function.Time.Cron.CalculateNextRun {
    Input: (parsed_expression: CronExpression, from_time: DateTime)
    Output: DateTime
    Body: {
        // Start from the next minute
        current_time = Time.Add(from_time, Time.Duration.FromSeconds(60))
        
        // Zero out seconds for cron calculation
        current_time.second = 0
        current_time.nanosecond = 0
        
        // Find next matching time (max 1 year ahead)
        ForEvery attempt in Range(0, 525600) {  // 365 * 24 * 60 minutes
            IfCondition Time.Cron.MatchesExpression(current_time, parsed_expression) ThenBlock {
                ReturnValue(current_time)
            }
            
            // Advance to next minute
            current_time = Time.Add(current_time, Time.Duration.FromMinutes(1))
        }
        
        // If we can't find a match in a year, something is wrong
        TryBlock: {} CatchError.CronNoMatchFound {
            PrintMessage("No cron match found within one year")
        }
    }
}

Function.Time.Cron.MatchesExpression {
    Input: (datetime: DateTime, parsed_expression: CronExpression)
    Output: Boolean
    Body: {
        IfCondition Not(Time.Cron.FieldMatches(datetime.second, parsed_expression.second)) ThenBlock {
            ReturnValue(False)
        }
        
        IfCondition Not(Time.Cron.FieldMatches(datetime.minute, parsed_expression.minute)) ThenBlock {
            ReturnValue(False)
        }
        
        IfCondition Not(Time.Cron.FieldMatches(datetime.hour, parsed_expression.hour)) ThenBlock {
            ReturnValue(False)
        }
        
        IfCondition Not(Time.Cron.FieldMatches(datetime.day, parsed_expression.day)) ThenBlock {
            ReturnValue(False)
        }
        
        IfCondition Not(Time.Cron.FieldMatches(datetime.month, parsed_expression.month)) ThenBlock {
            ReturnValue(False)
        }
        
        IfCondition Not(Time.Cron.FieldMatches(datetime.weekday, parsed_expression.weekday)) ThenBlock {
            ReturnValue(False)
        }
        
        ReturnValue(True)
    }
}

Function.Time.Cron.FieldMatches {
    Input: (value: UInt8, field: CronField)
    Output: Boolean
    Body: {
        ChoosePath field.type {
            CaseOption "wildcard": ReturnValue(True)
            
            CaseOption "exact": {
                ReturnValue(ArrayContains(field.values, value))
            }
            
            CaseOption "range": {
                ReturnValue(ArrayContains(field.values, value))
            }
            
            CaseOption "list": {
                ReturnValue(ArrayContains(field.values, value))
            }
            
            CaseOption "step": {
                ReturnValue(EqualTo(Modulo(value, field.step), 0))
            }
            
            CaseOption "range_step": {
                ForEvery range_val in field.values {
                    IfCondition EqualTo(Modulo(Subtract(value, range_val), field.step), 0) ThenBlock {
                        ReturnValue(True)
                    }
                }
                ReturnValue(False)
            }
            
            DefaultOption: ReturnValue(False)
        }
    }
}

// ============================================================================
// Performance and Benchmarking (Enhanced)
// ============================================================================

Function.Time.Benchmark {
    Input: (
        name: Text,
        function: Function,
        function_data: Any = Null,
        iterations: UInt64 = 1000,
        warmup_iterations: UInt64 = 100
    )
    Output: BenchmarkResult
    Body: {
        Pool.Time.Performance.Allocate(result)
        
        result.name = name
        result.iterations = iterations
        result.min_time_ns = UInt64.Max
        result.max_time_ns = 0
        result.total_time_ns = 0
        result.cache_hits = 0
        result.cache_misses = 0
        
        // Warmup runs to stabilize cache
        ForEvery i in Range(0, warmup_iterations) {
            Apply(function, function_data)
        }
        
        // Clear cache counters
        Hardware.Cache.ResetCounters()
        memory_before = Hardware.Memory.GetUsedMemory()
        
        // Actual benchmark runs
        ForEvery i in Range(0, iterations) {
            start_time = Time.UnixNano()
            
            // Execute function
            Apply(function, function_data)
            
            end_time = Time.UnixNano()
            elapsed = Subtract(end_time, start_time)
            
            result.total_time_ns = Add(result.total_time_ns, elapsed)
            
            IfCondition LessThan(elapsed, result.min_time_ns) ThenBlock {
                result.min_time_ns = elapsed
            }
            
            IfCondition GreaterThan(elapsed, result.max_time_ns) ThenBlock {
                result.max_time_ns = elapsed
            }
        }
        
        // Collect final statistics
        result.avg_time_ns = Divide(result.total_time_ns, iterations)
        result.memory_usage = Subtract(Hardware.Memory.GetUsedMemory(), memory_before)
        
        cache_counters = Hardware.Cache.GetCounters()
        result.cache_hits = cache_counters.total_hits
        result.cache_misses = cache_counters.total_misses
        
        ReturnValue(result)
    }
}

Function.Time.Profile.Start {
    Input: (name: Text)
    Body: {
        profile_data = ProfileData.Create()
        profile_data.function_name = name
        profile_data.call_count = 0
        profile_data.total_time_ns = 0
        profile_data.self_time_ns = 0
        
        Time.Internal.StartProfiling(name, profile_data)
    }
}

Function.Time.Profile.End {
    Input: (name: Text)
    Output: ProfileData
    Body: {
        ReturnValue(Time.Internal.EndProfiling(name))
    }
}

Function.Time.Sleep {
    Input: (duration_ms: UInt64)
    Body: {
        Hardware.SystemCall.Sleep(duration_ms)
    }
}

Function.Time.SleepNano {
    Input: (duration_ns: UInt64)
    Body: {
        Hardware.SystemCall.Nanosleep(duration_ns)
    }
}

Function.Time.SleepMilliseconds {
    Input: (milliseconds: UInt64)
    Body: {
        Hardware.SystemCall.Sleep(milliseconds)
    }
}

Function.Time.SleepSeconds {
    Input: (seconds: UInt64)
    Body: {
        Hardware.SystemCall.Sleep(Multiply(seconds, 1000))
    }
}

// ============================================================================
// Formatting and Parsing (Enhanced with Caching)
// ============================================================================

Function.Time.Format {
    Input: (dt: DateTime, format: Text = "RFC3339")
    Output: Text
    Body: {
        // Check formatting cache first
        cache_key = StringConcat(Time.DateTime.ToTimestamp(dt).seconds, "_", format)
        cached_result = Time.Internal.GetFromFormatCache(cache_key)
        IfCondition NotEqual(cached_result, Null) ThenBlock {
            ReturnValue(cached_result)
        }
        
        formatted = ChoosePath format {
            CaseOption "RFC3339": Time.Internal.FormatRFC3339(dt)
            CaseOption "ISO8601": Time.Internal.FormatISO8601(dt)
            CaseOption "Unix": NumberToString(dt.unix_timestamp)
            CaseOption "Human": Time.Internal.FormatHuman(dt)
            DefaultOption: Time.Internal.FormatCustom(dt, format)
        }
        
        // Cache result for performance
        Time.Internal.AddToFormatCache(cache_key, formatted)
        
        ReturnValue(formatted)
    }
}

Function.Time.FormatDuration {
    Input: (duration: Duration, format: Text = "auto")
    Output: Text
    Body: {
        total_seconds = duration.seconds
        
        ChoosePath format {
            CaseOption "auto": {
                days = Divide(total_seconds, 86400)
                hours = Divide(Modulo(total_seconds, 86400), 3600)
                minutes = Divide(Modulo(total_seconds, 3600), 60)
                seconds = Modulo(total_seconds, 60)
                
                IfCondition GreaterThan(days, 0) ThenBlock {
                    ReturnValue(StringConcat(
                        NumberToString(days), "d ",
                        NumberToString(hours), "h ",
                        NumberToString(minutes), "m ",
                        NumberToString(seconds), "s"
                    ))
                } ElseBox {
                    IfCondition GreaterThan(hours, 0) ThenBlock {
                        ReturnValue(StringConcat(
                            NumberToString(hours), "h ",
                            NumberToString(minutes), "m ",
                            NumberToString(seconds), "s"
                        ))
                    } ElseBlock {
                        IfCondition GreaterThan(minutes, 0) ThenBlock {
                            ReturnValue(StringConcat(
                                NumberToString(minutes), "m ",
                                NumberToString(seconds), "s"
                            ))
                        } ElseBlock {
                            IfCondition GreaterThan(seconds, 0) ThenBlock {
                                ReturnValue(StringConcat(NumberToString(seconds), "s"))
                            } ElseBlock {
                                millis = Divide(duration.nanoseconds, 1000000)
                                ReturnValue(StringConcat(NumberToString(millis), "ms"))
                            }
                        }
                    }
                }
            }
            
            CaseOption "seconds": {
                total_with_nanos = Add(total_seconds, Divide(duration.nanoseconds, 1000000000.0))
                ReturnValue(StringConcat(NumberToString(total_with_nanos), "s"))
            }
            
            CaseOption "milliseconds": {
                total_ms = Add(Multiply(total_seconds, 1000), Divide(duration.nanoseconds, 1000000))
                ReturnValue(StringConcat(NumberToString(total_ms), "ms"))
            }
            
            DefaultOption: Time.FormatDuration(duration, "auto")
        }
    }
}

// ============================================================================
// Timezone Support (Enhanced with Caching)
// ============================================================================

Function.Time.Timezone.Get {
    Input: (timezone_name: Text)
    Output: TimezoneInfo
    Body: {
        // Check cache first for performance
        cached_tz = Time.Internal.GetCachedTimezone(timezone_name)
        IfCondition And(
            NotEqual(cached_tz, Null),
            GreaterThan(cached_tz.cache_expiry, Time.Unix())
        ) ThenBlock {
            ReturnValue(cached_tz)
        }
        
        // Load timezone data
        tz_info = Time.Internal.LoadTimezoneData(timezone_name)
        tz_info.cache_expiry = Add(Time.Unix(), 86400)  // Cache for 24 hours
        
        // Cache for future use
        Time.Internal.CacheTimezone(timezone_name, tz_info)
        
        ReturnValue(tz_info)
    }
}

Function.Time.Timezone.GetLocal {
    Output: TimezoneInfo
    Body: {
        local_tz_name = Hardware.SystemCall.GetLocalTimezone()
        ReturnValue(Time.Timezone.Get(local_tz_name))
    }
}

Function.Time.ConvertTimezone {
    Input: (dt: DateTime, target_timezone: Text)
    Output: DateTime
    Body: {
        // Convert to UTC first
        utc_timestamp = Subtract(dt.unix_timestamp, Multiply(dt.timezone_offset, 60))
        
        // Get target timezone info with caching
        target_tz = Time.Timezone.Get(target_timezone)
        
        // Create new DateTime in target timezone
        result = Time.FromUnix(utc_timestamp, target_timezone)
        result.nanosecond = dt.nanosecond
        
        ReturnValue(result)
    }
}

Function.Time.Timezone.IsDST {
    Input: (dt: DateTime, tz_info: TimezoneInfo)
    Output: Boolean
    Body: {
        // Simple DST check - can be enhanced with more complex rules
        ForEvery dst_rule in tz_info.dst_rules {
            IfCondition Time.Internal.IsInDSTPeriod(dt, dst_rule) ThenBlock {
                ReturnValue(True)
            }
        }
        
        ReturnValue(False)
    }
}

// ============================================================================
// Utility Functions (Enhanced)
// ============================================================================

Function.Time.IsLeapYear {
    Input: (year: UInt32)
    Output: Boolean
    Body: {
        IfCondition EqualTo(Modulo(year, 4), 0) ThenBlock {
            IfCondition EqualTo(Modulo(year, 100), 0) ThenBlock {
                ReturnValue(EqualTo(Modulo(year, 400), 0))
            } ElseBlock {
                ReturnValue(True)
            }
        } ElseBlock {
            ReturnValue(False)
        }
    }
}

Function.Time.DaysInMonth {
    Input: (year: UInt32, month: UInt8)
    Output: UInt8
    Body: {
        ChoosePath month {
            CaseOption 1: ReturnValue(31)  // January
            CaseOption 2: {  // February
                IfCondition Time.IsLeapYear(year) ThenBlock {
                    ReturnValue(29)
                } ElseBlock {
                    ReturnValue(28)
                }
            }
            CaseOption 3: ReturnValue(31)  // March
            CaseOption 4: ReturnValue(30)  // April
            CaseOption 5: ReturnValue(31)  // May
            CaseOption 6: ReturnValue(30)  // June
            CaseOption 7: ReturnValue(31)  // July
            CaseOption 8: ReturnValue(31)  // August
            CaseOption 9: ReturnValue(30)  // September
            CaseOption 10: ReturnValue(31) // October
            CaseOption 11: ReturnValue(30) // November
            CaseOption 12: ReturnValue(31) // December
            DefaultOption: ReturnValue(30)
        }
    }
}

Function.Time.GetSystemTimezoneOffset {
    Output: Integer
    Body: {
        ReturnValue(Hardware.SystemCall.GetLocalTimezoneOffset())
    }
}

Function.Time.GetSystemTimezoneName {
    Output: Text
    Body: {
        ReturnValue(Hardware.SystemCall.GetLocalTimezoneName())
    }
}

// ============================================================================
// Internal Helper Functions (Implementation details)
// ============================================================================

Function.Time.Internal.GenerateTimerID {
    Output: UInt64
    Body: {
        ReturnValue(Hardware.Atomic.Add(TimerSystem.next_timer_id, 1))
    }
}

Function.Time.Internal.GenerateTaskID {
    Output: UInt64
    Body: {
        ReturnValue(Hardware.Atomic.Add(Scheduler.next_task_id, 1))
    }
}

Function.Time.Internal.GenerateCronID {
    Output: UInt64
    Body: {
        ReturnValue(Hardware.Atomic.Add(CronSystem.next_cron_id, 1))
    }
}

Function.Time.Internal.UpdateCacheStats {
    Input: (cache_stats: CacheStats, cycle_time: UInt64, operations: UInt64)
    Body: {
        // Update cache performance metrics
        cache_info = Hardware.Cache.GetPerformanceInfo()
        cache_stats.l1_hits = Add(cache_stats.l1_hits, cache_info.l1_hits)
        cache_stats.l1_misses = Add(cache_stats.l1_misses, cache_info.l1_misses)
        cache_stats.l2_hits = Add(cache_stats.l2_hits, cache_info.l2_hits)
        cache_stats.l2_misses = Add(cache_stats.l2_misses, cache_info.l2_misses)
    }
}

// Initialize all subsystems on module load
Time.TimerSystem.Initialize()
Time.Scheduler.Initialize()
Time.CronSystem.Initialize()

// Cache warm-up for better performance
Time.Internal.WarmupCaches()