// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Library.Trees.ailang
// Tree data structures with modern AILANG syntax
// AVL, Red-Black, B-Tree implementations

LibraryImport.XArrays

// ============================================================================
// AVL Tree Implementation
// ============================================================================

// Tree node structure: [key, value, left, right, height, parent]
Function.AVL.CreateNode {
    Input: key: Address
    Input: value: Address
    Output: Address
    Body: {
        node = Allocate(48)
        
        key_copy = Helpers.StringCopy(key)
        value_copy = Helpers.StringCopy(value)
        
        StoreValue(node, key_copy)
        StoreValue(Add(node, 8), value_copy)
        StoreValue(Add(node, 16), 0)  // left
        StoreValue(Add(node, 24), 0)  // right
        StoreValue(Add(node, 32), 1)  // height
        StoreValue(Add(node, 40), 0)  // parent
        
        ReturnValue(node)
    }
}

// Create AVL tree: [root, size, compare_fn]
Function.AVL.Create {
    Output: Address
    Body: {
        tree = Allocate(24)
        StoreValue(tree, 0)  // root = null
        StoreValue(Add(tree, 8), 0)  // size = 0
        StoreValue(Add(tree, 16), 0)  // compare_fn = default string compare
        
        ReturnValue(tree)
    }
}

Function.AVL.GetHeight {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(Dereference(Add(node, 32)))
    }
}

Function.AVL.UpdateHeight {
    Input: node: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue()
        }
        
        left = Dereference(Add(node, 16))
        right = Dereference(Add(node, 24))
        
        left_height = AVL.GetHeight(left)
        right_height = AVL.GetHeight(right)
        
        max_height = left_height
        IfCondition GreaterThan(right_height, left_height) ThenBlock: {
            max_height = right_height
        }
        
        StoreValue(Add(node, 32), Add(max_height, 1))
    }
}

Function.AVL.GetBalance {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        left = Dereference(Add(node, 16))
        right = Dereference(Add(node, 24))
        
        ReturnValue(Subtract(AVL.GetHeight(left), AVL.GetHeight(right)))
    }
}

Function.AVL.RotateRight {
    Input: tree: Address
    Input: y: Address
    Output: Address
    Body: {
        x = Dereference(Add(y, 16))  // y.left
        T2 = Dereference(Add(x, 24))  // x.right
        
        // Perform rotation
        StoreValue(Add(x, 24), y)     // x.right = y
        StoreValue(Add(y, 16), T2)    // y.left = T2
        
        // Update parents
        parent = Dereference(Add(y, 40))
        StoreValue(Add(x, 40), parent)
        StoreValue(Add(y, 40), x)
        
        IfCondition NotEqual(T2, 0) ThenBlock: {
            StoreValue(Add(T2, 40), y)
        }
        
        // Update parent's child pointer
        IfCondition EqualTo(parent, 0) ThenBlock: {
            StoreValue(tree, x)  // x is new root
        } ElseBlock: {
            parent_left = Dereference(Add(parent, 16))
            IfCondition EqualTo(parent_left, y) ThenBlock: {
                StoreValue(Add(parent, 16), x)
            } ElseBlock: {
                StoreValue(Add(parent, 24), x)
            }
        }
        
        // Update heights
        AVL.UpdateHeight(y)
        AVL.UpdateHeight(x)
        
        ReturnValue(x)
    }
}

Function.AVL.RotateLeft {
    Input: tree: Address
    Input: x: Address
    Output: Address
    Body: {
        y = Dereference(Add(x, 24))   // x.right
        T2 = Dereference(Add(y, 16))  // y.left
        
        // Perform rotation
        StoreValue(Add(y, 16), x)     // y.left = x
        StoreValue(Add(x, 24), T2)    // x.right = T2
        
        // Update parents
        parent = Dereference(Add(x, 40))
        StoreValue(Add(y, 40), parent)
        StoreValue(Add(x, 40), y)
        
        IfCondition NotEqual(T2, 0) ThenBlock: {
            StoreValue(Add(T2, 40), x)
        }
        
        // Update parent's child pointer
        IfCondition EqualTo(parent, 0) ThenBlock: {
            StoreValue(tree, y)  // y is new root
        } ElseBlock: {
            parent_left = Dereference(Add(parent, 16))
            IfCondition EqualTo(parent_left, x) ThenBlock: {
                StoreValue(Add(parent, 16), y)
            } ElseBlock: {
                StoreValue(Add(parent, 24), y)
            }
        }
        
        // Update heights
        AVL.UpdateHeight(x)
        AVL.UpdateHeight(y)
        
        ReturnValue(y)
    }
}

Function.AVL.Insert {
    Input: tree: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        root = Dereference(tree)
        
        // Empty tree
        IfCondition EqualTo(root, 0) ThenBlock: {
            new_node = AVL.CreateNode(key, value)
            StoreValue(tree, new_node)
            
            size = Dereference(Add(tree, 8))
            StoreValue(Add(tree, 8), Add(size, 1))
            
            ReturnValue(1)
        }
        
        // Find insertion point
        current = root
        parent = 0
        path = XArray.XCreate(32)  // Track path for rebalancing
        
        WhileLoop NotEqual(current, 0) {
            XArray.XPush(path, current)
            parent = current
            
            current_key = Dereference(current)
            cmp = StringCompare(key, current_key)
            
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                // Key exists - update value
                old_value = Dereference(Add(current, 8))
                Deallocate(old_value, 0)
                
                new_value = Helpers.StringCopy(value)
                StoreValue(Add(current, 8), new_value)
                
                XArray.XDestroy(path)
                ReturnValue(0)
            }
            
            IfCondition LessThan(cmp, 0) ThenBlock: {
                current = Dereference(Add(current, 16))
            } ElseBlock: {
                current = Dereference(Add(current, 24))
            }
        }
        
        // Create new node
        new_node = AVL.CreateNode(key, value)
        StoreValue(Add(new_node, 40), parent)
        
        // Link to parent
        parent_key = Dereference(parent)
        cmp = StringCompare(key, parent_key)
        
        IfCondition LessThan(cmp, 0) ThenBlock: {
            StoreValue(Add(parent, 16), new_node)
        } ElseBlock: {
            StoreValue(Add(parent, 24), new_node)
        }
        
        // Update size
        size = Dereference(Add(tree, 8))
        StoreValue(Add(tree, 8), Add(size, 1))
        
        // Rebalance tree
        AVL.RebalanceAfterInsert(tree, path)
        
        XArray.XDestroy(path)
        ReturnValue(1)
    }
}

Function.AVL.RebalanceAfterInsert {
    Input: tree: Address
    Input: path: Address
    Body: {
        path_size = XArray.XSize(path)
        
        // Work up from insertion point
        i = Subtract(path_size, 1)
        WhileLoop GreaterEqual(i, 0) {
            node = XArray.XGet(path, i)
            
            AVL.UpdateHeight(node)
            balance = AVL.GetBalance(node)
            
            // Left-Left case
            IfCondition GreaterThan(balance, 1) ThenBlock: {
                left = Dereference(Add(node, 16))
                left_balance = AVL.GetBalance(left)
                
                IfCondition GreaterEqual(left_balance, 0) ThenBlock: {
                    AVL.RotateRight(tree, node)
                } ElseBlock: {
                    // Left-Right case
                    AVL.RotateLeft(tree, left)
                    AVL.RotateRight(tree, node)
                }
                BreakLoop
            }
            
            // Right-Right case
            IfCondition LessThan(balance, -1) ThenBlock: {
                right = Dereference(Add(node, 24))
                right_balance = AVL.GetBalance(right)
                
                IfCondition LessEqual(right_balance, 0) ThenBlock: {
                    AVL.RotateLeft(tree, node)
                } ElseBlock: {
                    // Right-Left case
                    AVL.RotateRight(tree, right)
                    AVL.RotateLeft(tree, node)
                }
                BreakLoop
            }
            
            i = Subtract(i, 1)
        }
    }
}

Function.AVL.Search {
    Input: tree: Address
    Input: key: Address
    Output: Address
    Body: {
        current = Dereference(tree)
        
        WhileLoop NotEqual(current, 0) {
            current_key = Dereference(current)
            cmp = StringCompare(key, current_key)
            
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(Dereference(Add(current, 8)))
            }
            
            IfCondition LessThan(cmp, 0) ThenBlock: {
                current = Dereference(Add(current, 16))
            } ElseBlock: {
                current = Dereference(Add(current, 24))
            }
        }
        
        ReturnValue(0)
    }
}

// ============================================================================
// B-Tree Implementation
// ============================================================================

// B-Tree node: [is_leaf, num_keys, keys_array, values_array, children_array, parent]
Function.BTree.CreateNode {
    Input: order: Integer
    Input: is_leaf: Integer
    Output: Address
    Body: {
        node = Allocate(48)
        
        StoreValue(node, is_leaf)
        StoreValue(Add(node, 8), 0)  // num_keys
        
        // Max keys = 2*order - 1
        max_keys = Subtract(Multiply(order, 2), 1)
        max_children = Multiply(order, 2)
        
        keys = ArrayCreate(max_keys)
        values = ArrayCreate(max_keys)
        children = ArrayCreate(max_children)
        
        StoreValue(Add(node, 16), keys)
        StoreValue(Add(node, 24), values)
        StoreValue(Add(node, 32), children)
        StoreValue(Add(node, 40), 0)  // parent
        
        ReturnValue(node)
    }
}

// B-Tree: [root, order, size]
Function.BTree.Create {
    Input: order: Integer
    Output: Address
    Body: {
        tree = Allocate(24)
        
        root = BTree.CreateNode(order, 1)  // Start with leaf
        
        StoreValue(tree, root)
        StoreValue(Add(tree, 8), order)
        StoreValue(Add(tree, 16), 0)  // size
        
        ReturnValue(tree)
    }
}

Function.BTree.Search {
    Input: node: Address
    Input: key: Address
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        num_keys = Dereference(Add(node, 8))
        keys_array = Dereference(Add(node, 16))
        values_array = Dereference(Add(node, 24))
        
        // Find key position
        i = 0
        WhileLoop LessThan(i, num_keys) {
            node_key = ArrayGet(keys_array, i)
            cmp = StringCompare(key, node_key)
            
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(values_array, i))
            }
            
            IfCondition LessThan(cmp, 0) ThenBlock: {
                BreakLoop
            }
            
            i = Add(i, 1)
        }
        
        // If leaf, key not found
        is_leaf = Dereference(node)
        IfCondition EqualTo(is_leaf, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Search child
        children_array = Dereference(Add(node, 32))
        child = ArrayGet(children_array, i)
        
        ReturnValue(BTree.Search(child, key))
    }
}

Function.BTree.Insert {
    Input: tree: Address
    Input: key: Address
    Input: value: Address
    Output: Integer
    Body: {
        root = Dereference(tree)
        order = Dereference(Add(tree, 8))
        
        // Check if root is full
        num_keys = Dereference(Add(root, 8))
        max_keys = Subtract(Multiply(order, 2), 1)
        
        IfCondition EqualTo(num_keys, max_keys) ThenBlock: {
            // Split root
            new_root = BTree.CreateNode(order, 0)
            StoreValue(tree, new_root)
            
            children_array = Dereference(Add(new_root, 32))
            ArraySet(children_array, 0, root)
            StoreValue(Add(root, 40), new_root)
            
            BTree.SplitChild(new_root, 0, root, order)
            root = new_root
        }
        
        result = BTree.InsertNonFull(root, key, value, order)
        
        // Update size
        IfCondition EqualTo(result, 1) ThenBlock: {
            size = Dereference(Add(tree, 16))
            StoreValue(Add(tree, 16), Add(size, 1))
        }
        
        ReturnValue(result)
    }
}

Function.BTree.InsertNonFull {
    Input: node: Address
    Input: key: Address
    Input: value: Address
    Input: order: Integer
    Output: Integer
    Body: {
        num_keys = Dereference(Add(node, 8))
        keys_array = Dereference(Add(node, 16))
        values_array = Dereference(Add(node, 24))
        
        // Find insertion position
        i = Subtract(num_keys, 1)
        
        is_leaf = Dereference(node)
        IfCondition EqualTo(is_leaf, 1) ThenBlock: {
            // Leaf node - insert here
            WhileLoop GreaterEqual(i, 0) {
                node_key = ArrayGet(keys_array, i)
                cmp = StringCompare(key, node_key)
                
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    // Key exists - update
                    old_value = ArrayGet(values_array, i)
                    Deallocate(old_value, 0)
                    ArraySet(values_array, i, Helpers.StringCopy(value))
                    ReturnValue(0)
                }
                
                IfCondition GreaterThan(cmp, 0) ThenBlock: {
                    BreakLoop
                }
                
                // Shift right
                ArraySet(keys_array, Add(i, 1), node_key)
                ArraySet(values_array, Add(i, 1), ArrayGet(values_array, i))
                
                i = Subtract(i, 1)
            }
            
            // Insert new key-value
            ArraySet(keys_array, Add(i, 1), Helpers.StringCopy(key))
            ArraySet(values_array, Add(i, 1), Helpers.StringCopy(value))
            
            StoreValue(Add(node, 8), Add(num_keys, 1))
            ReturnValue(1)
        }
        
        // Internal node - find child
        WhileLoop GreaterEqual(i, 0) {
            node_key = ArrayGet(keys_array, i)
            cmp = StringCompare(key, node_key)
            
            IfCondition GreaterThan(cmp, 0) ThenBlock: {
                BreakLoop
            }
            
            i = Subtract(i, 1)
        }
        
        i = Add(i, 1)
        children_array = Dereference(Add(node, 32))
        child = ArrayGet(children_array, i)
        
        // Check if child is full
        child_num_keys = Dereference(Add(child, 8))
        max_keys = Subtract(Multiply(order, 2), 1)
        
        IfCondition EqualTo(child_num_keys, max_keys) ThenBlock: {
            BTree.SplitChild(node, i, child, order)
            
            // Recalculate which child to use
            split_key = ArrayGet(keys_array, i)
            cmp = StringCompare(key, split_key)
            
            IfCondition GreaterThan(cmp, 0) ThenBlock: {
                i = Add(i, 1)
                child = ArrayGet(children_array, i)
            }
        }
        
        ReturnValue(BTree.InsertNonFull(child, key, value, order))
    }
}

Function.BTree.SplitChild {
    Input: parent: Address
    Input: index: Integer
    Input: child: Address
    Input: order: Integer
    Body: {
        // Create new node for right half
        new_node = BTree.CreateNode(order, Dereference(child))
        
        // Get arrays
        child_keys = Dereference(Add(child, 16))
        child_values = Dereference(Add(child, 24))
        new_keys = Dereference(Add(new_node, 16))
        new_values = Dereference(Add(new_node, 24))
        
        mid = Subtract(order, 1)
        
        // Copy right half of keys/values to new node
        j = 0
        WhileLoop LessThan(j, Subtract(order, 1)) {
            ArraySet(new_keys, j, ArrayGet(child_keys, Add(j, Add(mid, 1))))
            ArraySet(new_values, j, ArrayGet(child_values, Add(j, Add(mid, 1))))
            j = Add(j, 1)
        }
        
        // If not leaf, copy children
        is_leaf = Dereference(child)
        IfCondition EqualTo(is_leaf, 0) ThenBlock: {
            child_children = Dereference(Add(child, 32))
            new_children = Dereference(Add(new_node, 32))
            
            j = 0
            WhileLoop LessEqual(j, Subtract(order, 1)) {
                moved_child = ArrayGet(child_children, Add(j, Add(mid, 1)))
                ArraySet(new_children, j, moved_child)
                
                // Update parent pointer
                IfCondition NotEqual(moved_child, 0) ThenBlock: {
                    StoreValue(Add(moved_child, 40), new_node)
                }
                
                j = Add(j, 1)
            }
        }
        
        // Update counts
        StoreValue(Add(child, 8), mid)
        StoreValue(Add(new_node, 8), Subtract(order, 1))
        
        // Insert middle key into parent
        parent_keys = Dereference(Add(parent, 16))
        parent_values = Dereference(Add(parent, 24))
        parent_children = Dereference(Add(parent, 32))
        parent_num_keys = Dereference(Add(parent, 8))
        
        // Shift parent's keys/children right
        i = parent_num_keys
        WhileLoop GreaterThan(i, index) {
            ArraySet(parent_keys, i, ArrayGet(parent_keys, Subtract(i, 1)))
            ArraySet(parent_values, i, ArrayGet(parent_values, Subtract(i, 1)))
            ArraySet(parent_children, Add(i, 1), ArrayGet(parent_children, i))
            i = Subtract(i, 1)
        }
        
        // Insert median
        ArraySet(parent_keys, index, ArrayGet(child_keys, mid))
        ArraySet(parent_values, index, ArrayGet(child_values, mid))
        ArraySet(parent_children, Add(index, 1), new_node)
        
        StoreValue(Add(parent, 8), Add(parent_num_keys, 1))
        StoreValue(Add(new_node, 40), parent)
    }
}