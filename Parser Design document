# AILang Self-Hosting Parser - Module Design

## File Structure

```
Librarys/Compiler/Frontend/Parser/
├── Library.CParserTypes.ailang      # AST node types, parser state pools
├── Library.CParserCore.ailang       # Core parser functions (advance, consume, peek, error)
├── Library.CParserExpressions.ailang # Expression parsing (literals, calls, operators)
├── Library.CParserStatements.ailang  # Statement parsing (assignment, if, while, return)
├── Library.CParserDeclarations.ailang # Top-level (Function, SubRoutine, Pool, Library)
├── Library.CParserMain.ailang        # Main parse loop, entry point
└── Library.CParserUtils.ailang       # Utilities (AST creation, node helpers)
```

## Module Responsibilities

### 1. CParserTypes.ailang
```ailang
// AST Node Type Constants
FixedPool.ASTNode {
    "PROGRAM": Initialize=1
    "FUNCTION": Initialize=2
    "SUBROUTINE": Initialize=3
    "POOL": Initialize=4
    "LIBRARY_IMPORT": Initialize=5
    "ASSIGNMENT": Initialize=6
    "IF": Initialize=7
    "WHILE": Initialize=8
    "RETURN": Initialize=9
    "CALL": Initialize=10
    "IDENTIFIER": Initialize=11
    "NUMBER": Initialize=12
    "STRING": Initialize=13
    "BINARY_OP": Initialize=14
    "UNARY_OP": Initialize=15
    "MEMBER_ACCESS": Initialize=16
    "BLOCK": Initialize=17
    "PARAMETER": Initialize=18
    // ... more node types
}

// Parser State
FixedPool.Parser {
    "pos": Initialize=0, CanChange=True          // Current token index
    "token_count": Initialize=0, CanChange=True  // Total tokens
    "current_type": Initialize=0, CanChange=True // Current token type
    "current_value": Initialize=0, CanChange=True // Current token value
    "error": Initialize=0, CanChange=True
    "error_msg": Initialize=0, CanChange=True
    "error_line": Initialize=0, CanChange=True
    "error_col": Initialize=0, CanChange=True
}

// AST Node Field Indices (for ArrayGet/ArraySet)
FixedPool.NodeField {
    "TYPE": Initialize=0
    "LINE": Initialize=1
    "COL": Initialize=2
    "DATA1": Initialize=3  // Varies by node type
    "DATA2": Initialize=4
    "DATA3": Initialize=5
    "DATA4": Initialize=6
    "CHILDREN": Initialize=7  // XArray of child nodes
}
```

### 2. CParserCore.ailang
```ailang
// Initialize parser with token stream from lexer
Function.Parse_Init { Input: token_count: Integer }

// Token navigation
Function.Parse_CurrentType { Output: Integer }
Function.Parse_CurrentValue { Output: Address }
Function.Parse_Advance { }
Function.Parse_Peek { Input: offset: Integer, Output: Integer }
Function.Parse_PeekValue { Input: offset: Integer, Output: Address }

// Matching and consuming
Function.Parse_Match { Input: token_type: Integer, Output: Integer }
Function.Parse_Consume { Input: token_type: Integer, Input: error_msg: Address }
Function.Parse_Check { Input: token_type: Integer, Output: Integer }

// Error handling
Function.Parse_Error { Input: msg: Address }
Function.Parse_ErrorAt { Input: msg: Address, Input: line: Integer, Input: col: Integer }

// Utility
Function.Parse_SkipNewlines { }
```

### 3. CParserExpressions.ailang
```ailang
// Main expression entry point
Function.Parse_Expression { Output: Address }

// Primary expressions
Function.Parse_Primary { Output: Address }        // literals, identifiers, parens
Function.Parse_Identifier { Output: Address }     // simple or dotted
Function.Parse_Number { Output: Address }
Function.Parse_String { Output: Address }

// Compound expressions  
Function.Parse_Call { Input: name: Address, Output: Address }  // func(args)
Function.Parse_MemberAccess { Input: base: Address, Output: Address }

// Argument lists
Function.Parse_Arguments { Output: Address }      // Returns XArray of expressions
```

### 4. CParserStatements.ailang
```ailang
// Main statement dispatcher
Function.Parse_Statement { Output: Address }

// Individual statement types
Function.Parse_Assignment { Input: target: Address, Output: Address }
Function.Parse_IfCondition { Output: Address }
Function.Parse_WhileLoop { Output: Address }
Function.Parse_ReturnValue { Output: Address }
Function.Parse_PrintMessage { Output: Address }
Function.Parse_Block { Output: Address }          // { ... }

// Control flow
Function.Parse_ExitLoop { Output: Address }
Function.Parse_ContinueLoop { Output: Address }
```

### 5. CParserDeclarations.ailang
```ailang
// Main declaration dispatcher
Function.Parse_Declaration { Output: Address }

// Top-level declarations
Function.Parse_Function { Output: Address }       // Function.Name { ... }
Function.Parse_SubRoutine { Output: Address }     // SubRoutine.Name { ... }
Function.Parse_Pool { Output: Address }           // FixedPool.Name { ... }
Function.Parse_LibraryImport { Output: Address }  // LibraryImport.Path

// Function internals
Function.Parse_Parameters { Output: Address }     // Input: x: Type
Function.Parse_Body { Output: Address }           // Body: { ... }
Function.Parse_Output { Output: Address }         // Output: Type
```

### 6. CParserMain.ailang
```ailang
// Main entry point - parses entire program
Function.Parse_Program { Output: Address }

// Program-level loop
Function.Parse_TopLevel { Output: Address }       // Dispatches to declarations
```

### 7. CParserUtils.ailang
```ailang
// AST Node Creation
Function.AST_CreateNode { Input: node_type: Integer, Output: Address }
Function.AST_SetField { Input: node: Address, Input: field: Integer, Input: value: Integer }
Function.AST_GetField { Input: node: Address, Input: field: Integer, Output: Integer }
Function.AST_AddChild { Input: parent: Address, Input: child: Address }
Function.AST_GetChild { Input: node: Address, Input: index: Integer, Output: Address }
Function.AST_GetChildCount { Input: node: Address, Output: Integer }

// Debug/dump
Function.AST_DumpNode { Input: node: Address, Input: indent: Integer }
Function.AST_DumpTree { Input: root: Address }
```

## AST Node Structures

Each node is an array with fixed layout:
```
[TYPE, LINE, COL, DATA1, DATA2, DATA3, DATA4, CHILDREN]
```

### Node-Specific Data Fields:

| Node Type | DATA1 | DATA2 | DATA3 | DATA4 |
|-----------|-------|-------|-------|-------|
| FUNCTION | name (addr) | params (XArray) | body (node) | return_type |
| SUBROUTINE | name (addr) | body (node) | - | - |
| ASSIGNMENT | target (addr) | value (node) | - | - |
| CALL | func_name (addr) | args (XArray) | - | - |
| IF | condition (node) | then_block | else_block | - |
| WHILE | condition (node) | body (node) | - | - |
| RETURN | value (node) | - | - | - |
| IDENTIFIER | name (addr) | - | - | - |
| NUMBER | value (addr) | - | - | - |
| STRING | value (addr) | - | - | - |
| POOL | pool_type | name (addr) | members (XArray) | - |

## Implementation Order

1. **CParserTypes.ailang** - Define all constants first
2. **CParserCore.ailang** - Basic navigation and error handling
3. **CParserUtils.ailang** - AST node creation helpers
4. **CParserExpressions.ailang** - Start with literals, then calls
5. **CParserStatements.ailang** - Assignment first, then control flow
6. **CParserDeclarations.ailang** - Function/SubRoutine parsing
7. **CParserMain.ailang** - Tie it all together

## Integration with Console

```ailang
// In Compile_Source after lexing:
Parse_Init(Lex.token_count)
ast = Parse_Program()

IfCondition EqualTo(Parser.error, 1) ThenBlock: {
    PrintMessage("PARSER ERROR: ")
    PrintMessage(Parser.error_msg)
    // ... error details
}

IfCondition EqualTo(Console.show_ast, 1) ThenBlock: {
    AST_DumpTree(ast)
}
```
