// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


LibraryImport.PIC

// ============================================================
// INTERACTIVE PIC REPL (Read-Eval-Print Loop)
// ============================================================

// Command constants
FixedPool.Commands {
    "CMD_HELP": Initialize=1
    "CMD_REGISTER_FUNC": Initialize=2
    "CMD_REGISTER_TYPE": Initialize=3
    "CMD_LIST_FUNCS": Initialize=4
    "CMD_LIST_TYPES": Initialize=5
    "CMD_FIND_FUNC": Initialize=6
    "CMD_HAS_FUNC": Initialize=7
    "CMD_GET_TYPE_SIZE": Initialize=8
    "CMD_INVOKE": Initialize=9
    "CMD_COUNT": Initialize=10
    "CMD_EXIT": Initialize=99
}

// Input state
FixedPool.InputState {
    "running": Initialize=1
    "last_command": Initialize=0
}

// ============================================================
// HELPER FUNCTIONS
// ============================================================

Function.ParseCommand {
    Output: Integer
    Body: {
        PrintMessage("\n> ")
        
        // Read entire line from stdin
        input = ReadInput()
        
        // Handle null/empty input
        IfCondition EqualTo(input, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Get first character using GetByte
        cmd = GetByte(input, 0)
        
        // Map single character commands
        // h = help (104)
        IfCondition EqualTo(cmd, 104) ThenBlock: {
            ReturnValue(Commands.CMD_HELP)
        }
        
        // r = register function (114)
        IfCondition EqualTo(cmd, 114) ThenBlock: {
            ReturnValue(Commands.CMD_REGISTER_FUNC)
        }
        
        // t = register type (116)
        IfCondition EqualTo(cmd, 116) ThenBlock: {
            ReturnValue(Commands.CMD_REGISTER_TYPE)
        }
        
        // l = list functions (108)
        IfCondition EqualTo(cmd, 108) ThenBlock: {
            ReturnValue(Commands.CMD_LIST_FUNCS)
        }
        
        // y = list types (121)
        IfCondition EqualTo(cmd, 121) ThenBlock: {
            ReturnValue(Commands.CMD_LIST_TYPES)
        }
        
        // f = find function (102)
        IfCondition EqualTo(cmd, 102) ThenBlock: {
            ReturnValue(Commands.CMD_FIND_FUNC)
        }
        
        // ? = has function (63)
        IfCondition EqualTo(cmd, 63) ThenBlock: {
            ReturnValue(Commands.CMD_HAS_FUNC)
        }
        
        // s = get type size (115)
        IfCondition EqualTo(cmd, 115) ThenBlock: {
            ReturnValue(Commands.CMD_GET_TYPE_SIZE)
        }
        
        // i = invoke (105)
        IfCondition EqualTo(cmd, 105) ThenBlock: {
            ReturnValue(Commands.CMD_INVOKE)
        }
        
        // c = count (99)
        IfCondition EqualTo(cmd, 99) ThenBlock: {
            ReturnValue(Commands.CMD_COUNT)
        }
        
        // q = quit (113)
        IfCondition EqualTo(cmd, 113) ThenBlock: {
            ReturnValue(Commands.CMD_EXIT)
        }
        
        ReturnValue(0)
    }
}

SubRoutine.PrintHelp {
    PrintMessage("\n")
    PrintMessage("╔════════════════════════════════════════════╗\n")
    PrintMessage("║   PIC INTERACTIVE REPL - COMMAND MENU      ║\n")
    PrintMessage("╠════════════════════════════════════════════╣\n")
    PrintMessage("║  h - Show this help menu                   ║\n")
    PrintMessage("║  r - Register a function                   ║\n")
    PrintMessage("║  t - Register a type                       ║\n")
    PrintMessage("║  l - List all functions                    ║\n")
    PrintMessage("║  y - List all types                        ║\n")
    PrintMessage("║  f - Find function by module/name          ║\n")
    PrintMessage("║  ? - Check if function exists              ║\n")
    PrintMessage("║  s - Get type size                         ║\n")
    PrintMessage("║  i - Invoke a function                     ║\n")
    PrintMessage("║  c - Count registered functions            ║\n")
    PrintMessage("║  q - Quit                                  ║\n")
    PrintMessage("╚════════════════════════════════════════════╝\n")
}

Function.ReadInteger {
    Output: Integer
    Body: {
        // Read line from stdin
        input = ReadInput()
        
        // Handle null or empty input
        IfCondition EqualTo(input, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if the string is empty (first char is null)
        first_char = GetByte(input, 0)
        IfCondition EqualTo(first_char, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if it's actually a number (starts with digit or minus)
        is_digit = And(GreaterEqual(first_char, 48), LessEqual(first_char, 57))
        is_minus = EqualTo(first_char, 45)
        
        IfCondition Or(is_digit, is_minus) ThenBlock: {
            result = StringToNumber(input)
            ReturnValue(result)
        }
        
        // Not a valid number - return 0
        ReturnValue(0)
    }
}

// ============================================================
// COMMAND HANDLERS
// ============================================================

SubRoutine.HandleRegisterFunc {
    PrintMessage("Register Function\n")
    PrintMessage("  Module ID: ")
    module = ReadInteger()
    
    PrintMessage("  Function ID: ")
    func_id = ReadInteger()
    
    PrintMessage("  Address: ")
    addr = ReadInteger()
    
    PrintMessage("  Param Count: ")
    params = ReadInteger()
    
    result = PIC.RegisterFunction(module, func_id, addr, params)
    
    IfCondition GreaterEqual(result, 0) ThenBlock: {
        PrintMessage("✓ Function registered successfully\n")
    } ElseBlock: {
        PrintMessage("✗ Failed to register function\n")
    }
}

SubRoutine.HandleRegisterType {
    PrintMessage("Register Type\n")
    PrintMessage("  Type ID: ")
    type_id = ReadInteger()
    
    PrintMessage("  Size (bytes): ")
    size = ReadInteger()
    
    PrintMessage("  Field Count: ")
    fields = ReadInteger()
    
    result = PIC.RegisterType(type_id, size, fields)
    
    IfCondition GreaterEqual(result, 0) ThenBlock: {
        PrintMessage("✓ Type registered successfully\n")
    } ElseBlock: {
        PrintMessage("✗ Failed to register type\n")
    }
}

SubRoutine.HandleFindFunc {
    PrintMessage("Find Function\n")
    PrintMessage("  Module ID: ")
    module = ReadInteger()
    
    PrintMessage("  Function ID: ")
    func_id = ReadInteger()
    
    result = PIC.FindFunction(module, func_id)
    
    IfCondition NotEqual(result, -1) ThenBlock: {
        PrintMessage("✓ Function found at address: ")
        PrintNumber(result)
        PrintMessage("\n")
    } ElseBlock: {
        PrintMessage("✗ Function not found\n")
    }
}

SubRoutine.HandleHasFunc {
    PrintMessage("Check Function Exists\n")
    PrintMessage("  Module ID: ")
    module = ReadInteger()
    
    PrintMessage("  Function ID: ")
    func_id = ReadInteger()
    
    result = PIC.HasFunction(module, func_id)
    
    IfCondition EqualTo(result, 1) ThenBlock: {
        PrintMessage("✓ Function exists\n")
    } ElseBlock: {
        PrintMessage("✗ Function does not exist\n")
    }
}

SubRoutine.HandleGetTypeSize {
    PrintMessage("Get Type Size\n")
    PrintMessage("  Type ID: ")
    type_id = ReadInteger()
    
    result = PIC.GetTypeSize(type_id)
    
    IfCondition NotEqual(result, -1) ThenBlock: {
        PrintMessage("✓ Type size: ")
        PrintNumber(result)
        PrintMessage(" bytes\n")
    } ElseBlock: {
        PrintMessage("✗ Type not found\n")
    }
}

SubRoutine.HandleInvoke {
    PrintMessage("Invoke Function\n")
    PrintMessage("  Module ID: ")
    module = ReadInteger()
    
    PrintMessage("  Function ID: ")
    func_id = ReadInteger()
    
    PrintMessage("  Parameter: ")
    param = ReadInteger()
    
    PIC.Invoke(module, func_id, param)
}

SubRoutine.HandleCount {
    count = PIC.GetFunctionCount()
    PrintMessage("Total registered functions: ")
    PrintNumber(count)
    PrintMessage("\n")
}

// ============================================================
// MAIN REPL LOOP
// ============================================================

SubRoutine.RunREPL {
    PrintMessage("\n")
    PrintMessage("╔════════════════════════════════════════════╗\n")
    PrintMessage("║  PIC INTERACTIVE REFLECTION CONSOLE        ║\n")
    PrintMessage("║  Program Interface Console v1.0            ║\n")
    PrintMessage("╚════════════════════════════════════════════╝\n")
    PrintMessage("\n")
    PrintMessage("Initializing PIC library...\n")
    
    PIC.Init()
    
    PrintMessage("✓ Ready! Type 'h' for help\n")
    
    // Main loop
    WhileLoop EqualTo(InputState.running, 1) {
        command = ParseCommand()
        
        Branch command {
            Case Commands.CMD_HELP: {
                RunTask(PrintHelp)
            }
            Case Commands.CMD_REGISTER_FUNC: {
                RunTask(HandleRegisterFunc)
            }
            Case Commands.CMD_REGISTER_TYPE: {
                RunTask(HandleRegisterType)
            }
            Case Commands.CMD_LIST_FUNCS: {
                PIC.ListFunctions()
            }
            Case Commands.CMD_LIST_TYPES: {
                PIC.ListTypes()
            }
            Case Commands.CMD_FIND_FUNC: {
                RunTask(HandleFindFunc)
            }
            Case Commands.CMD_HAS_FUNC: {
                RunTask(HandleHasFunc)
            }
            Case Commands.CMD_GET_TYPE_SIZE: {
                RunTask(HandleGetTypeSize)
            }
            Case Commands.CMD_INVOKE: {
                RunTask(HandleInvoke)
            }
            Case Commands.CMD_COUNT: {
                RunTask(HandleCount)
            }
            Case Commands.CMD_EXIT: {
                InputState.running = 0
            }
            Default: {
                PrintMessage("Unknown command. Type 'h' for help\n")
            }
        }
    }
    
    PrintMessage("\nShutting down...\n")
    PrintMessage("Goodbye!\n\n")
    
    // Proper exit - HaltProgram should call exit syscall
    HaltProgram()
}

// Entry point
SubRoutine.ProgramExit {
    // Exit syscall
    // mov rax, 60 (sys_exit)
    // mov rdi, 0 (exit code 0)
    // syscall
    InlineAssembly("mov rax, 60; mov rdi, 0; syscall")
}

RunTask(RunREPL)
RunTask(ProgramExit)