// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.





LibraryImport.PIC

// ============================================================
// TEST PROGRAM 1: BASIC REGISTRATION
// ============================================================

SubRoutine.TestBasicRegistration {
    PrintMessage("\n")
    PrintMessage("==========================================\n")
    PrintMessage("TEST 1: Basic Function Registration\n")
    PrintMessage("==========================================\n")
    
    // Initialize PIC
    PIC.Init()
    
    // Register some mock functions
    // Module 100 = "Math", Function 1 = "Add"
    PIC.RegisterFunction(100, 1, 1001, 2)
    
    // Module 100 = "Math", Function 2 = "Multiply"
    PIC.RegisterFunction(100, 2, 1002, 2)
    
    // Module 200 = "String", Function 1 = "Length"
    PIC.RegisterFunction(200, 1, 2001, 1)
    
    // List all registered functions
    PIC.ListFunctions()
    
    // Query function count
    func_count = PIC.GetFunctionCount()
    PrintMessage("\nReported function count: ")
    PrintNumber(func_count)
    PrintMessage("\n")
    
    // Cleanup
    PIC.Cleanup()
    
    PrintMessage("\nTEST 1 COMPLETE\n")
}

// ============================================================
// TEST PROGRAM 2: FUNCTION LOOKUP
// ============================================================

SubRoutine.TestFunctionLookup {
    PrintMessage("\n")
    PrintMessage("==========================================\n")
    PrintMessage("TEST 2: Function Lookup and Invocation\n")
    PrintMessage("==========================================\n")
    
    // Initialize PIC
    PIC.Init()
    
    // Register functions
    PIC.RegisterFunction(100, 1, 1001, 2)
    PIC.RegisterFunction(100, 2, 1002, 2)
    PIC.RegisterFunction(200, 1, 2001, 1)
    
    PrintMessage("\n--- Looking up Math.Add (100, 1) ---\n")
    test_result = PIC.FindFunction(100, 1)
    
    PrintMessage("\n--- Looking up String.Length (200, 1) ---\n")
    test_result = PIC.FindFunction(200, 1)
    
    PrintMessage("\n--- Looking up non-existent function (999, 999) ---\n")
    test_result = PIC.FindFunction(999, 999)
    
    PrintMessage("\n--- Testing HasFunction ---\n")
    found = PIC.HasFunction(100, 1)
    PrintMessage("Math.Add exists: ")
    PrintNumber(found)
    PrintMessage("\n")
    
    found = PIC.HasFunction(999, 999)
    PrintMessage("NonExistent.Func exists: ")
    PrintNumber(found)
    PrintMessage("\n")
    
    PrintMessage("\n--- Invoking Math.Add ---\n")
    PIC.Invoke(100, 1, 42)
    
    // Cleanup
    PIC.Cleanup()
    
    PrintMessage("\nTEST 2 COMPLETE\n")
}

// ============================================================
// TEST PROGRAM 3: TYPE INTROSPECTION
// ============================================================

SubRoutine.TestTypeIntrospection {
    PrintMessage("\n")
    PrintMessage("==========================================\n")
    PrintMessage("TEST 3: Type Registration and Introspection\n")
    PrintMessage("==========================================\n")
    
    // Initialize PIC
    PIC.Init()
    
    // Register some types
    // Type 1000 = "Person", size 24 bytes, 3 fields
    PIC.RegisterType(1000, 24, 3)
    
    // Type 2000 = "Point", size 8 bytes, 2 fields
    PIC.RegisterType(2000, 8, 2)
    
    // Type 3000 = "Vector", size 12 bytes, 3 fields
    PIC.RegisterType(3000, 12, 3)
    
    // List all types
    PIC.ListTypes()
    
    // Query specific type sizes
    PrintMessage("\n--- Querying Type Sizes ---\n")
    type_size = PIC.GetTypeSize(1000)
    type_size = PIC.GetTypeSize(2000)
    type_size = PIC.GetTypeSize(9999)
    
    // Cleanup
    PIC.Cleanup()
    
    PrintMessage("\nTEST 3 COMPLETE\n")
}

// ============================================================
// TEST PROGRAM 4: COMBINED TEST
// ============================================================

SubRoutine.TestCombined {
    PrintMessage("\n")
    PrintMessage("==========================================\n")
    PrintMessage("TEST 4: Combined Functions and Types\n")
    PrintMessage("==========================================\n")
    
    // Initialize PIC
    PIC.Init()
    
    // Register a bunch of stuff
    PrintMessage("\n--- Registering Functions ---\n")
    PIC.RegisterFunction(100, 1, 1001, 2)
    PIC.RegisterFunction(100, 2, 1002, 2)
    PIC.RegisterFunction(100, 3, 1003, 1)
    PIC.RegisterFunction(200, 1, 2001, 1)
    PIC.RegisterFunction(200, 2, 2002, 2)
    
    PrintMessage("\n--- Registering Types ---\n")
    PIC.RegisterType(1000, 16, 2)
    PIC.RegisterType(2000, 32, 4)
    PIC.RegisterType(3000, 8, 1)
    
    // Show everything
    PIC.ListFunctions()
    PIC.ListTypes()
    
    // Do some queries
    PrintMessage("\n--- Sample Queries ---\n")
    func_count = PIC.GetFunctionCount()
    PrintMessage("Total functions: ")
    PrintNumber(func_count)
    PrintMessage("\n")
    
    found = PIC.HasFunction(100, 2)
    PrintMessage("Has Math.Multiply: ")
    PrintNumber(found)
    PrintMessage("\n")
    
    type_size = PIC.GetTypeSize(2000)
    
    // Try an invocation
    PrintMessage("\n--- Invoking Function ---\n")
    PIC.Invoke(200, 1, 12345)
    
    // Cleanup
    PIC.Cleanup()
    
    PrintMessage("\nTEST 4 COMPLETE\n")
}

// ============================================================
// TEST RUNNER MAILBOX & DISPATCHER
// ============================================================

// Mailbox to enforce sequential test execution
FixedPool.TestMailbox {
    "command_queue": Initialize=0 
    "head": Initialize=0
    "tail": Initialize=0
}

// Command constants for the dispatcher
FixedPool.TestCommands {
    "CMD_RUN_TEST1": Initialize=1
    "CMD_RUN_TEST2": Initialize=2
    "CMD_RUN_TEST3": Initialize=3
    "CMD_RUN_TEST4": Initialize=4
    "CMD_SHUTDOWN": Initialize=99
}

Function.SendTestCommand {
    Input: command: Integer
    Body: {
        ArraySet(TestMailbox.command_queue, TestMailbox.tail, command)
        TestMailbox.tail = Add(TestMailbox.tail, 1)
    }
}

Function.ReceiveTestCommand {
    Output: Integer
    Body: {
        command = -1
        IfCondition LessThan(TestMailbox.head, TestMailbox.tail) ThenBlock: {
            command = ArrayGet(TestMailbox.command_queue, TestMailbox.head)
            TestMailbox.head = Add(TestMailbox.head, 1)
        }
        ReturnValue(command)
    }
}



// ============================================================
// MAIN TEST SUITE
// MAIN ENTRY POINT
// ============================================================

SubRoutine.RunAllPICTests {

    PrintMessage("\n")
    PrintMessage("##########################################\n")
    PrintMessage("# PIC LIBRARY SEQUENTIAL TEST SUITE      #\n")
    PrintMessage("##########################################\n")

    // The dispatcher is now self-contained. It creates and manages its own queue.
        TestMailbox.command_queue = ArrayCreate(10)
    
        // Queue up all tests to run sequentially
        SendTestCommand(TestCommands.CMD_RUN_TEST1)
        SendTestCommand(TestCommands.CMD_RUN_TEST2)
        SendTestCommand(TestCommands.CMD_RUN_TEST3)
        SendTestCommand(TestCommands.CMD_RUN_TEST4)
        SendTestCommand(TestCommands.CMD_SHUTDOWN)

        shutdown = 0
        WhileLoop EqualTo(shutdown, 0) {
            command = ReceiveTestCommand()
            
            IfCondition NotEqual(command, -1) ThenBlock: {
                Branch command {
                    Case TestCommands.CMD_RUN_TEST1: { RunTask(TestBasicRegistration) }
                    Case TestCommands.CMD_RUN_TEST2: { RunTask(TestFunctionLookup) }
                    Case TestCommands.CMD_RUN_TEST3: { RunTask(TestTypeIntrospection) }
                    Case TestCommands.CMD_RUN_TEST4: { RunTask(TestCombined) }
                    Case TestCommands.CMD_SHUTDOWN: { shutdown = 1 }
                }
            }
        }

        // Cleanup happens here, after all tasks are complete.
        ArrayDestroy(TestMailbox.command_queue)
    
    // Run the self-contained dispatcher and wait for it to complete.
    
    
    PrintMessage("\n")
    PrintMessage("##########################################\n")
    PrintMessage("# ALL TESTS COMPLETE                     #\n")
    PrintMessage("##########################################\n")
    PrintMessage("\n")
}
RunTask(RunAllPICTests)