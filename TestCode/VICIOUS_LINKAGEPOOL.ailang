// ============================================================================
// VICIOUS LINKAGEPOOL + FLOW CONTROL STRESS TEST
// This will push the allocation system AND flow control to their limits
// ============================================================================

// Define pools of varying sizes
LinkagePool.TinyPool {
    "x": Initialize=0
}

LinkagePool.MonsterPool {
    "f1": Initialize=1
    "f2": Initialize=2
    "f3": Initialize=3
    "f4": Initialize=4
    "f5": Initialize=5
    "f6": Initialize=6
    "f7": Initialize=7
    "f8": Initialize=8
    "f9": Initialize=9
    "f10": Initialize=10
    "f11": Initialize=11
    "f12": Initialize=12
    "f13": Initialize=13
    "f14": Initialize=14
    "f15": Initialize=15
    "f16": Initialize=16
    "f17": Initialize=17
    "f18": Initialize=18
    "f19": Initialize=19
    "f20": Initialize=20
    "f21": Initialize=21
    "f22": Initialize=22
    "f23": Initialize=23
    "f24": Initialize=24
    "f25": Initialize=25
    "f26": Initialize=26
    "f27": Initialize=27
    "f28": Initialize=28
    "f29": Initialize=29
    "f30": Initialize=30
}

LinkagePool.ChainNode {
    "id": Initialize=0
    "value": Initialize=0
    "next": Initialize=0
    "prev": Initialize=0
    "metadata": Initialize=0
}

PrintMessage("\nðŸ”¥ VICIOUS LINKAGE + FLOW CONTROL TEST ðŸ”¥\n")
PrintMessage("=========================================\n\n")

total_allocated = 0
allocation_count = 0

// ============================================================================
// TEST 1: Branch-controlled mass allocation
// ============================================================================
PrintMessage("TEST 1: Branch-Controlled Allocation Mayhem\n")

allocation_mode = 3
Branch allocation_mode {
    Case 1: {
        tiny1 = AllocateLinkage(LinkagePool.TinyPool)
        allocation_count = 1
    }
    Case 2: {
        chain1 = AllocateLinkage(LinkagePool.ChainNode)
        chain2 = AllocateLinkage(LinkagePool.ChainNode)
        allocation_count = 2
    }
    Case 3: {
        // Go crazy - allocate a bunch
        monster1 = AllocateLinkage(LinkagePool.MonsterPool)
        monster2 = AllocateLinkage(LinkagePool.MonsterPool)
        monster3 = AllocateLinkage(LinkagePool.MonsterPool)
        chain1 = AllocateLinkage(LinkagePool.ChainNode)
        chain2 = AllocateLinkage(LinkagePool.ChainNode)
        chain3 = AllocateLinkage(LinkagePool.ChainNode)
        chain4 = AllocateLinkage(LinkagePool.ChainNode)
        chain5 = AllocateLinkage(LinkagePool.ChainNode)
        tiny1 = AllocateLinkage(LinkagePool.TinyPool)
        tiny2 = AllocateLinkage(LinkagePool.TinyPool)
        allocation_count = 10
        
        PrintMessage("  Allocated 3 monsters, 5 chains, 2 tinies\n")
        
        // Test they work
        monster1.f1 = 111
        monster1.f30 = 3030
        chain1.id = 1001
        tiny1.x = 42
        
        PrintMessage("  Monster f1: ")
        PrintNumber(monster1.f1)
        PrintMessage(", f30: ")
        PrintNumber(monster1.f30)
        PrintMessage("\n")
    }
    Default: {
        allocation_count = 0
    }
}

// ============================================================================
// TEST 2: Loop with Break creating LinkagePools
// ============================================================================
PrintMessage("\nTEST 2: Loop Allocation with Break\n")

loop_counter = 0
loop_pools = 0

WhileLoop LessThan(loop_counter, 100) {
    // Allocate on odd numbers only
    IfCondition EqualTo(Modulo(loop_counter, 2), 1) ThenBlock: {
        node = AllocateLinkage(LinkagePool.ChainNode)
        node.id = loop_counter
        node.value = Multiply(loop_counter, 10)
        loop_pools = Add(loop_pools, 1)
        
        // Break after 7 allocations
        IfCondition GreaterEqual(loop_pools, 7) ThenBlock: {
            PrintMessage("  Breaking after ")
            PrintNumber(loop_pools)
            PrintMessage(" allocations\n")
            BreakLoop
        }
    }
    
    loop_counter = Add(loop_counter, 1)
}

allocation_count = Add(allocation_count, loop_pools)

// ============================================================================
// TEST 3: Try-Catch with LinkagePool allocation
// ============================================================================
PrintMessage("\nTEST 3: Try-Catch Allocation\n")

try_result = 0
TryBlock: {
    risky = AllocateLinkage(LinkagePool.MonsterPool)
    risky.f15 = 1515
    
    // Nested allocation in try
    Fork True TrueBlock: {
        inner = AllocateLinkage(LinkagePool.ChainNode)
        inner.id = 999
        allocation_count = Add(allocation_count, 2)
    } FalseBlock: {
        // Never runs
    }
    
    try_result = risky.f15
    PrintMessage("  Try block allocated successfully\n")
    
} CatchError: {
    PrintMessage("  ERROR: Allocation failed!\n")
    try_result = 0
} FinallyBlock: {
    PrintMessage("  Finally: try_result = ")
    PrintNumber(try_result)
    PrintMessage("\n")
}

// ============================================================================
// TEST 4: Recursive allocation torture
// ============================================================================
PrintMessage("\nTEST 4: Recursive Allocation Torture\n")

Function.RecursiveAllocator {
    Input: depth: Number
    Input: max_depth: Number
    Body: {
        IfCondition LessEqual(depth, max_depth) ThenBlock: {
            // Allocate based on depth
            Branch depth {
                Case 1: {
                    n1 = AllocateLinkage(LinkagePool.TinyPool)
                    n1.x = depth
                }
                Case 2: {
                    n2 = AllocateLinkage(LinkagePool.ChainNode)
                    n2.id = Multiply(depth, 100)
                }
                Case 3: {
                    n3 = AllocateLinkage(LinkagePool.MonsterPool)
                    n3.f10 = Multiply(depth, 1000)
                }
                Default: {
                    n4 = AllocateLinkage(LinkagePool.ChainNode)
                    n4.value = depth
                }
            }
            
            PrintMessage("    Depth ")
            PrintNumber(depth)
            PrintMessage(" allocated\n")
            
            // Recurse
            next_depth = Add(depth, 1)
            RecursiveAllocator(next_depth, max_depth)
        }
        ReturnValue(depth)
    }
}

PrintMessage("  Starting recursive allocation...\n")
final_depth = RecursiveAllocator(1, 8)
allocation_count = Add(allocation_count, final_depth)

// ============================================================================
// TEST 5: Nested loops with continue and LinkagePool
// ============================================================================
PrintMessage("\nTEST 5: Nested Loops with Continue\n")

outer = 0
nested_allocs = 0

WhileLoop LessThan(outer, 3) {
    inner = 0
    WhileLoop LessThan(inner, 4) {
        // Skip even inner indices
        IfCondition EqualTo(Modulo(inner, 2), 0) ThenBlock: {
            inner = Add(inner, 1)
            ContinueLoop
        }
        
        // Allocate for odd inner indices
        node = AllocateLinkage(LinkagePool.ChainNode)
        node.id = Add(Multiply(outer, 10), inner)
        node.value = Add(outer, inner)
        nested_allocs = Add(nested_allocs, 1)
        
        inner = Add(inner, 1)
    }
    outer = Add(outer, 1)
}

allocation_count = Add(allocation_count, nested_allocs)
PrintMessage("  Nested loops allocated ")
PrintNumber(nested_allocs)
PrintMessage(" nodes\n")

// ============================================================================
// TEST 6: Fork maze with allocations
// ============================================================================
PrintMessage("\nTEST 6: Fork Maze\n")

maze_a = 5
maze_b = 10
maze_count = 0

Fork GreaterThan(maze_a, 3) TrueBlock: {
    Fork LessThan(maze_b, 20) TrueBlock: {
        Fork NotEqual(maze_a, maze_b) TrueBlock: {
            // Triple nested true path
            m1 = AllocateLinkage(LinkagePool.MonsterPool)
            m2 = AllocateLinkage(LinkagePool.MonsterPool)
            m3 = AllocateLinkage(LinkagePool.MonsterPool)
            maze_count = 3
            
            m1.f5 = 555
            m2.f10 = 1010
            m3.f20 = 2020
            
            PrintMessage("  Triple Fork allocated 3 monsters\n")
        } FalseBlock: {
            maze_count = 0
        }
    } FalseBlock: {
        maze_count = 0
    }
} FalseBlock: {
    maze_count = 0
}

allocation_count = Add(allocation_count, maze_count)

// ============================================================================
// CALCULATION & SUMMARY
// ============================================================================
PrintMessage("\n=========================================\n")
PrintMessage("ALLOCATION SUMMARY:\n")
PrintMessage("  Branch test: 10 allocations\n")
PrintMessage("  Loop test: 7 allocations\n")
PrintMessage("  Try-Catch: 2 allocations\n")
PrintMessage("  Recursive: 8 allocations\n")
PrintMessage("  Nested loops: ")
PrintNumber(nested_allocs)
PrintMessage(" allocations\n")
PrintMessage("  Fork maze: 3 allocations\n")

PrintMessage("\nTOTAL ALLOCATIONS: ")
PrintNumber(allocation_count)
PrintMessage("\n")

// Calculate approximate memory usage
// TinyPool: 8 bytes
// ChainNode: 40 bytes  
// MonsterPool: 240 bytes
approx_memory = Add(Multiply(10, 8), Add(Multiply(20, 40), Multiply(6, 240)))
PrintMessage("Approximate memory used: ")
PrintNumber(approx_memory)
PrintMessage(" bytes\n")

PrintMessage("\nIf this runs without overflow:\n")
PrintMessage("âœ… Smart allocation is working!\n")
PrintMessage("âœ… Flow control is rock solid!\n")
PrintMessage("âœ… LinkagePools handle complexity!\n")

PrintMessage("\nðŸ”¥ VICIOUS TEST COMPLETE ðŸ”¥\n")