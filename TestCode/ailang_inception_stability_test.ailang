// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// ailang_inception_stability_demo.ailang
// STABILITY DEMONSTRATION: 30-level recursion with simple, reliable math
// Purpose: Prove AILANG handles extreme nesting patterns at native speed
// Perfect for AI training data and student reference
// NOW WITH: Cycle-accurate performance profiling via RDTSC

PrintMessage("========================================")
PrintMessage("AILANG 30-LEVEL INCEPTION DEMO")
PrintMessage("Bare-Metal x86_64 Stability Test")
PrintMessage("With CPU Cycle Profiling")
PrintMessage("========================================")
PrintMessage("")

// Stats tracking via FixedPool (shared state)
FixedPool.Stats {
    "nest_depth": Initialize=0
    "exec_count": Initialize=0
    "max_depth": Initialize=0
    "total_iterations": Initialize=0
    "operations": Initialize=0
    "case0_hits": Initialize=0
    "case1_hits": Initialize=0
    "case2_hits": Initialize=0
    "case3_hits": Initialize=0
    "case4_hits": Initialize=0
    "result_sum": Initialize=0
}

// ===========================================
// HELPER SUBROUTINES
// ===========================================

SubRoutine.IncrementDepth {
    current = Stats.nest_depth
    current = Add(current, 1)
    Stats.nest_depth = current
    
    max = Stats.max_depth
    IfCondition GreaterThan(current, max) ThenBlock: {
        Stats.max_depth = current
    }
    
    count = Stats.exec_count
    count = Add(count, 1)
    Stats.exec_count = count
}

SubRoutine.DecrementDepth {
    current = Stats.nest_depth
    current = Subtract(current, 1)
    Stats.nest_depth = current
}

// ===========================================
// SIMPLE MATH WORK (No infinite loops!)
// ===========================================

Function.SimpleCalc {
    Input: operation: Integer
    Input: value: Integer
    Output: Integer
    Body: {
        result = 0
        
        // Track operations
        ops = Stats.operations
        ops = Add(ops, 1)
        Stats.operations = ops
        
        // Branch based on operation (0-4)
        Branch operation {
            Case 0: {
                // Multiplication
                hits = Stats.case0_hits
                hits = Add(hits, 1)
                Stats.case0_hits = hits
                result = Multiply(value, 2)
            }
            Case 1: {
                // Addition chain
                hits = Stats.case1_hits
                hits = Add(hits, 1)
                Stats.case1_hits = hits
                result = Add(Add(value, 10), 5)
            }
            Case 2: {
                // Modulo operations
                hits = Stats.case2_hits
                hits = Add(hits, 1)
                Stats.case2_hits = hits
                temp = Modulo(value, 7)
                result = Add(temp, 100)
            }
            Case 3: {
                // Division and multiplication
                hits = Stats.case3_hits
                hits = Add(hits, 1)
                Stats.case3_hits = hits
                temp = Divide(value, 3)
                result = Multiply(temp, 5)
            }
            Case 4: {
                // Subtract and modulo
                hits = Stats.case4_hits
                hits = Add(hits, 1)
                Stats.case4_hits = hits
                Fork GreaterThan(value, 50) TrueBlock: {
                    result = Subtract(value, 50)
                } FalseBlock: {
                    result = Add(value, 50)
                }
            }
            Default: {
                result = value
            }
        }
        
        // Accumulate results (mod to prevent overflow)
        sum = Stats.result_sum
        sum = Add(sum, Modulo(result, 1000))
        sum = Modulo(sum, 1000000)
        Stats.result_sum = sum
        
        ReturnValue(result)
    }
}

// ===========================================
// 30 LEVEL FUNCTIONS
// ===========================================

Function.Level30 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        operation = Modulo(seed, 5)
        result = SimpleCalc(operation, seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level29 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level30(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level28 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level29(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level27 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level28(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level26 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level27(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level25 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level26(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level24 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level25(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level23 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level24(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level22 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level23(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level21 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level22(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level20 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level21(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level19 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level20(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level18 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level19(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level17 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level18(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level16 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level17(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level15 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level16(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level14 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level15(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level13 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level14(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level12 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level13(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level11 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level12(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level10 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level11(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level9 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level10(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level8 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level9(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level7 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level8(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level6 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level7(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level5 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level6(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level4 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level5(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level3 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level4(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level2 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level3(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

Function.Level1 {
    Input: seed: Integer
    Output: Integer
    Body: {
        RunTask(IncrementDepth)
        result = Level2(seed)
        RunTask(DecrementDepth)
        ReturnValue(result)
    }
}

// ===========================================
// STATUS REPORTING
// ===========================================

SubRoutine.PrintStatus {
    PrintMessage("\r[RUNNING] Iter: ")
    PrintNumber(Stats.total_iterations)
    PrintMessage(" | Depth: ")
    PrintNumber(Stats.max_depth)
    PrintMessage(" | Calls: ")
    PrintNumber(Stats.exec_count)
    PrintMessage(" | Ops: ")
    PrintNumber(Stats.operations)
    PrintMessage("      ")
}

// ===========================================
// MAIN EXECUTION
// ===========================================

SubRoutine.RunStabilityTest {
    PrintMessage("Running 100,000 iterations through 30 levels...")
    PrintMessage("Each iteration: 30 function calls + Branch logic")
    PrintMessage("Compile with -P flag to see CPU cycle counts")
    PrintMessage("")
    
    DebugPerf.Start("total_test")
    
    TARGET = 100000
    iteration = 0
    
    DebugPerf.Start("main_loop")
    
    WhileLoop LessThan(iteration, TARGET) {
        // Profile individual iteration (every 10000th)
        Fork EqualTo(Modulo(iteration, 10000), 0) TrueBlock: {
            DebugPerf.Start("single_iteration")
        } FalseBlock: {
            // No profiling
        }
        
        // Vary seed each iteration (1-100)
        seed = Add(Modulo(iteration, 100), 1)
        
        // Execute 30-level chain
        result = Level1(seed)
        
        Fork EqualTo(Modulo(iteration, 10000), 0) TrueBlock: {
            DebugPerf.End("single_iteration")
        } FalseBlock: {
            // No profiling
        }
        
        // Update iteration counter
        current = Stats.total_iterations
        current = Add(current, 1)
        Stats.total_iterations = current
        
        // Status every 1000 iterations
        mod = Modulo(iteration, 1000)
        Fork EqualTo(mod, 0) TrueBlock: {
            RunTask(PrintStatus)
        } FalseBlock: {
            // Silent
        }
        
        iteration = Add(iteration, 1)
    }
    
    DebugPerf.End("main_loop")
    DebugPerf.End("total_test")
    
    PrintMessage("\n\n")
}

RunTask(RunStabilityTest)

// ===========================================
// FINAL REPORT
// ===========================================

PrintMessage("========================================")
PrintMessage("STABILITY TEST COMPLETE")
PrintMessage("========================================")
PrintMessage("")
PrintMessage("Statistics:")
PrintMessage("  Iterations: ")
PrintNumber(Stats.total_iterations)
PrintMessage("\n  Max Depth: ")
PrintNumber(Stats.max_depth)
PrintMessage("\n  Function Calls: ")
PrintNumber(Stats.exec_count)
PrintMessage("\n  Math Operations: ")
PrintNumber(Stats.operations)
PrintMessage("\n  Result Sum (mod 1M): ")
PrintNumber(Stats.result_sum)
PrintMessage("\n")
PrintMessage("Branch Distribution:")
PrintMessage("\n  Case 0 (Multiply): ")
PrintNumber(Stats.case0_hits)
PrintMessage("\n  Case 1 (Add): ")
PrintNumber(Stats.case1_hits)
PrintMessage("\n  Case 2 (Modulo): ")
PrintNumber(Stats.case2_hits)
PrintMessage("\n  Case 3 (Divide): ")
PrintNumber(Stats.case3_hits)
PrintMessage("\n  Case 4 (Fork): ")
PrintNumber(Stats.case4_hits)
PrintMessage("\n")

Fork EqualTo(Stats.max_depth, 30) TrueBlock: {
    PrintMessage("✅ SUCCESS!")
    PrintMessage("\n  • 30-level recursion sustained")
    PrintMessage("\n  • 3 million function calls")
    PrintMessage("\n  • All 5 Branch cases executed")
    PrintMessage("\n  • Zero crashes or corruption")
    PrintMessage("\n  • Bare-metal x86_64 native code")
    PrintMessage("\n  • ~21KB executable")
} FalseBlock: {
    PrintMessage("❌ Test incomplete")
}

PrintMessage("\n")
PrintMessage("This demonstrates AILANG's ability to handle:")
PrintMessage("\n  • Deep function call chains")
PrintMessage("\n  • Complex nested flow control")
PrintMessage("\n  • FixedPool shared state management")
PrintMessage("\n  • Branch/Fork inside Functions/SubRoutines")
PrintMessage("\n  • High-performance native compilation")
PrintMessage("\n  • Cycle-accurate performance profiling")
PrintMessage("\n")
PrintMessage("Perfect for AI training data and student reference!")
PrintMessage("\n")
PrintMessage("Performance Profiling:")
PrintMessage("  Run with -P flag to see RDTSC cycle counts")
PrintMessage("  Example: python3 main.py demo.ailang -P")
PrintMessage("\n========================================\n")