// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// ============================================================================
// MINIMAL LINKAGEPOOL TEST - Testing What Actually Works
// ============================================================================
//
// This test verifies the ACTUAL working pattern for LinkagePool
// Based on VICIOUS_LINKAGEPOOL.ailang and linkagetest.ailang
//
// The transpiler needs to generate THIS pattern for COBOL LINKAGE SECTION
// ============================================================================

PrintMessage("\n=== MINIMAL LINKAGEPOOL TEST ===\n\n")

// ----------------------------------------------------------------------------
// STEP 1: Define the LinkagePool
// ----------------------------------------------------------------------------
LinkagePool.COBOL_TESTPROG_LINKAGE {
    "INPUT_FIELD": Initialize=0
    "OUTPUT_FIELD": Initialize=0
    "STATUS_CODE": Initialize=0
}

PrintMessage("Step 1: LinkagePool defined\n")

// ----------------------------------------------------------------------------
// STEP 2: Top-level allocation and initialization
// ----------------------------------------------------------------------------
PrintMessage("Step 2: Allocating and initializing\n")

// Allocate once at top level
testprog_linkage_data = AllocateLinkage(LinkagePool.COBOL_TESTPROG_LINKAGE)

PrintMessage("  Allocated at address: ")
PrintNumber(testprog_linkage_data)
PrintMessage("\n")

// Initialize input fields
testprog_linkage_data.INPUT_FIELD = 42
testprog_linkage_data.STATUS_CODE = 99

PrintMessage("  Set INPUT_FIELD = 42\n")
PrintMessage("  Set STATUS_CODE = 99\n\n")

// ----------------------------------------------------------------------------
// STEP 3: Call SubRoutine that accesses the global variable
// ----------------------------------------------------------------------------
PrintMessage("Step 3: Calling ProcessData\n")
RunTask(TESTPROG_ProcessData)

// ----------------------------------------------------------------------------
// STEP 4: Read results
// ----------------------------------------------------------------------------
PrintMessage("\nStep 4: Results after processing\n")
PrintMessage("  INPUT_FIELD = ")
PrintNumber(testprog_linkage_data.INPUT_FIELD)
PrintMessage("\n  OUTPUT_FIELD = ")
PrintNumber(testprog_linkage_data.OUTPUT_FIELD)
PrintMessage("\n  STATUS_CODE = ")
PrintNumber(testprog_linkage_data.STATUS_CODE)
PrintMessage("\n")

// ----------------------------------------------------------------------------
// STEP 5: Cleanup
// ----------------------------------------------------------------------------
FreeLinkage(testprog_linkage_data)
PrintMessage("\nStep 5: Freed linkage memory\n")

// ============================================================================
// SubRoutines - Access the top-level variable directly
// ============================================================================
// This is the pattern that works - SubRoutines access top-level variables
// just like they do in VICIOUS_LINKAGEPOOL.ailang
// ============================================================================

SubRoutine.TESTPROG_ProcessData {
    PrintMessage("  Inside ProcessData\n")
    
    // Read from the top-level variable
    input_value = testprog_linkage_data.INPUT_FIELD
    PrintMessage("    Read INPUT_FIELD: ")
    PrintNumber(input_value)
    PrintMessage("\n")
    
    // Perform calculation
    testprog_linkage_data.OUTPUT_FIELD = Multiply(input_value, 2)
    PrintMessage("    Calculated OUTPUT_FIELD = INPUT * 2: ")
    PrintNumber(testprog_linkage_data.OUTPUT_FIELD)
    PrintMessage("\n")
    
    // Update status
    testprog_linkage_data.STATUS_CODE = 0
    PrintMessage("    Set STATUS_CODE = 0 (success)\n")
    
    // Call another subroutine
    RunTask(TESTPROG_ValidateResult)
}

SubRoutine.TESTPROG_ValidateResult {
    PrintMessage("    Inside ValidateResult\n")
    
    // Validation logic - also accesses top-level variable
    IfCondition GreaterThan(testprog_linkage_data.OUTPUT_FIELD, 0) ThenBlock: {
        PrintMessage("      Validation: OUTPUT_FIELD is positive ✓\n")
    }
    
    IfCondition EqualTo(testprog_linkage_data.STATUS_CODE, 0) ThenBlock: {
        PrintMessage("      Validation: STATUS_CODE is 0 (success) ✓\n")
    }
}

PrintMessage("\n=== TEST COMPLETE ===\n")

// ============================================================================
// TRANSPILER PATTERN FOR COBOL->AILANG
// ============================================================================
//
// For a COBOL program with LINKAGE SECTION, generate:
//
// 1. LinkagePool definition at top level
//    LinkagePool.COBOL_<PROGRAMNAME>_LINKAGE { ... }
//
// 2. Top-level variable + allocation (NOT inside any SubRoutine)
//    <programname>_linkage_data = AllocateLinkage(LinkagePool.COBOL_<PROGRAMNAME>_LINKAGE)
//
// 3. Top-level code to initialize from input
//    <programname>_linkage_data.FIELD = LoadFromInput(...)
//
// 4. Top-level code to call main logic
//    RunTask(PROGRAMNAME_MAIN_PARAGRAPH)
//
// 5. SubRoutines that access the top-level variable directly
//    SubRoutine.PROGRAMNAME_PARAGRAPH {
//        <programname>_linkage_data.FIELD = value
//        RunTask(PROGRAMNAME_OTHER_PARAGRAPH)
//    }
//
// 6. NO Input: parameters needed - all SubRoutines see top-level variables
//
// 7. NO allocations inside SubRoutines - only ONE allocation at top level
//
// This matches how COBOL works: LINKAGE SECTION is visible to ALL paragraphs
// ============================================================================