// complex_computation_system.ailang
// Advanced Computational Pipeline with Ring Buffer Message Passing

PrintMessage("==============================================================")
PrintMessage("  COMPLEX COMPUTATIONAL PIPELINE SYSTEM")
PrintMessage("==============================================================")
PrintMessage("")

// =============================================================================
// GLOBAL COMMUNICATION VARIABLES (ADDED FIX)
// =============================================================================
// These variables are used for communication between SubRoutines

send_value = 0
recv_value = 0
task_data = 0
final_result = 0

// Variables for computational subroutines
fib_n = 0
fib_result = 0
fact_n = 0
fact_result = 0
prime_n = 0
is_prime = 0
power_n = 0
power_result = 0
sum_n = 0
sum_result = 0

// =============================================================================
// MAILBOXES
// =============================================================================

FixedPool.ComputeMailbox {
    "head": Initialize=0
    "tail": Initialize=0
    "count": Initialize=0
    "slot0": Initialize=0
    "slot1": Initialize=0
    "slot2": Initialize=0
    "slot3": Initialize=0
    "slot4": Initialize=0
    "slot5": Initialize=0
    "slot6": Initialize=0
    "slot7": Initialize=0
}

FixedPool.ResultsMailbox {
    "head": Initialize=0
    "tail": Initialize=0
    "count": Initialize=0
    "slot0": Initialize=0
    "slot1": Initialize=0
    "slot2": Initialize=0
    "slot3": Initialize=0
    "slot4": Initialize=0
    "slot5": Initialize=0
    "slot6": Initialize=0
    "slot7": Initialize=0
}

// =============================================================================
// SYSTEM STATE
// =============================================================================

FixedPool.ComputeStats {
    "tasks_submitted": Initialize=0
    "tasks_computed": Initialize=0
    "primes_found": Initialize=0
    "composites_found": Initialize=0
    "fibonacci_computed": Initialize=0
    "factorial_computed": Initialize=0
}

// =============================================================================
// MAILBOX OPERATIONS
// =============================================================================

SubRoutine.SendToCompute {
    IfCondition LessThan(ComputeMailbox.count, 8) ThenBlock: {
        pos = ComputeMailbox.tail
        
        Branch pos {
            Case 0: { ComputeMailbox.slot0 = send_value }
            Case 1: { ComputeMailbox.slot1 = send_value }
            Case 2: { ComputeMailbox.slot2 = send_value }
            Case 3: { ComputeMailbox.slot3 = send_value }
            Case 4: { ComputeMailbox.slot4 = send_value }
            Case 5: { ComputeMailbox.slot5 = send_value }
            Case 6: { ComputeMailbox.slot6 = send_value }
            Case 7: { ComputeMailbox.slot7 = send_value }
        }
        
        ComputeMailbox.tail = Modulo(Add(pos, 1), 8)
        ComputeMailbox.count = Add(ComputeMailbox.count, 1)
    }
}

SubRoutine.ReceiveFromCompute {
    recv_value = 0
    
    IfCondition GreaterThan(ComputeMailbox.count, 0) ThenBlock: {
        pos = ComputeMailbox.head
        
        Branch pos {
            Case 0: { recv_value = ComputeMailbox.slot0 }
            Case 1: { recv_value = ComputeMailbox.slot1 }
            Case 2: { recv_value = ComputeMailbox.slot2 }
            Case 3: { recv_value = ComputeMailbox.slot3 }
            Case 4: { recv_value = ComputeMailbox.slot4 }
            Case 5: { recv_value = ComputeMailbox.slot5 }
            Case 6: { recv_value = ComputeMailbox.slot6 }
            Case 7: { recv_value = ComputeMailbox.slot7 }
        }
        
        ComputeMailbox.head = Modulo(Add(pos, 1), 8)
        ComputeMailbox.count = Subtract(ComputeMailbox.count, 1)
    }
}

SubRoutine.SendToResults {
    IfCondition LessThan(ResultsMailbox.count, 8) ThenBlock: {
        pos = ResultsMailbox.tail
        
        Branch pos {
            Case 0: { ResultsMailbox.slot0 = send_value }
            Case 1: { ResultsMailbox.slot1 = send_value }
            Case 2: { ResultsMailbox.slot2 = send_value }
            Case 3: { ResultsMailbox.slot3 = send_value }
            Case 4: { ResultsMailbox.slot4 = send_value }
            Case 5: { ResultsMailbox.slot5 = send_value }
            Case 6: { ResultsMailbox.slot6 = send_value }
            Case 7: { ResultsMailbox.slot7 = send_value }
        }
        
        ResultsMailbox.tail = Modulo(Add(pos, 1), 8)
        ResultsMailbox.count = Add(ResultsMailbox.count, 1)
    }
}

SubRoutine.ReceiveFromResults {
    recv_value = 0
    
    IfCondition GreaterThan(ResultsMailbox.count, 0) ThenBlock: {
        pos = ResultsMailbox.head
        
        Branch pos {
            Case 0: { recv_value = ResultsMailbox.slot0 }
            Case 1: { recv_value = ResultsMailbox.slot1 }
            Case 2: { recv_value = ResultsMailbox.slot2 }
            Case 3: { recv_value = ResultsMailbox.slot3 }
            Case 4: { recv_value = ResultsMailbox.slot4 }
            Case 5: { recv_value = ResultsMailbox.slot5 }
            Case 6: { recv_value = ResultsMailbox.slot6 }
            Case 7: { recv_value = ResultsMailbox.slot7 }
        }
        
        ResultsMailbox.head = Modulo(Add(pos, 1), 8)
        ResultsMailbox.count = Subtract(ResultsMailbox.count, 1)
    }
}

// =============================================================================
// COMPUTATIONAL ALGORITHMS
// =============================================================================

SubRoutine.ComputeFibonacci {
    // Input: fib_n
    // Output: fib_result
    // Computes nth Fibonacci number iteratively
    
    PrintMessage("    Computing Fibonacci(")
    PrintNumber(fib_n)
    PrintMessage(")")
    
    IfCondition LessThan(fib_n, 2) ThenBlock: {
        fib_result = fib_n
    } ElseBlock: {
        a = 0
        b = 1
        i = 2
        
        WhileLoop Not(GreaterThan(i, fib_n)) {
            temp = Add(a, b)
            a = b
            b = temp
            i = Add(i, 1)
        }
        
        fib_result = b
    }
    
    PrintMessage("    Fibonacci(")
    PrintNumber(fib_n)
    PrintMessage(") = ")
    PrintNumber(fib_result)
    
    ComputeStats.fibonacci_computed = Add(ComputeStats.fibonacci_computed, 1)
}

SubRoutine.ComputeFactorial {
    // Input: fact_n
    // Output: fact_result
    // Computes factorial iteratively
    
    PrintMessage("    Computing Factorial(")
    PrintNumber(fact_n)
    PrintMessage(")")
    
    IfCondition LessThan(fact_n, 2) ThenBlock: {
        fact_result = 1
    } ElseBlock: {
        result = 1
        i = 2
        
        WhileLoop Not(GreaterThan(i, fact_n)) {
            result = Multiply(result, i)
            i = Add(i, 1)
        }
        
        fact_result = result
    }
    
    PrintMessage("    Factorial(")
    PrintNumber(fact_n)
    PrintMessage(") = ")
    PrintNumber(fact_result)
    
    ComputeStats.factorial_computed = Add(ComputeStats.factorial_computed, 1)
}

SubRoutine.CheckPrime {
    // Input: prime_n
    // Output: is_prime (1=prime, 0=composite)
    
    PrintMessage("    Checking if ")
    PrintNumber(prime_n)
    PrintMessage(" is prime")
    
    is_prime = 1
    
    IfCondition LessThan(prime_n, 2) ThenBlock: {
        is_prime = 0
    } ElseBlock: {
        IfCondition EqualTo(prime_n, 2) ThenBlock: {
            is_prime = 1
        } ElseBlock: {
            // Check divisibility from 2 to sqrt(n)
            divisor = 2
            check_limit = Divide(prime_n, 2)
            
            WhileLoop Not(GreaterThan(divisor, check_limit)) {
                remainder = Modulo(prime_n, divisor)
                
                IfCondition EqualTo(remainder, 0) ThenBlock: {
                    is_prime = 0
                    check_limit = 0
                }
                
                divisor = Add(divisor, 1)
            }
        }
    }
    
    IfCondition EqualTo(is_prime, 1) ThenBlock: {
        PrintMessage("    -> PRIME")
        ComputeStats.primes_found = Add(ComputeStats.primes_found, 1)
    } ElseBlock: {
        PrintMessage("    -> COMPOSITE")
        ComputeStats.composites_found = Add(ComputeStats.composites_found, 1)
    }
}

SubRoutine.ComputePowerOfTwo {
    // Input: power_n
    // Output: power_result
    // Computes 2^n
    
    PrintMessage("    Computing 2^")
    PrintNumber(power_n)
    
    power_result = 1
    i = 0
    
    WhileLoop LessThan(i, power_n) {
        power_result = Multiply(power_result, 2)
        i = Add(i, 1)
    }
    
    PrintMessage("    2^")
    PrintNumber(power_n)
    PrintMessage(" = ")
    PrintNumber(power_result)
}

SubRoutine.ComputeSum {
    // Input: sum_n
    // Output: sum_result
    // Computes sum of 1 to n
    
    PrintMessage("    Computing sum 1 to ")
    PrintNumber(sum_n)
    
    sum_result = Divide(Multiply(sum_n, Add(sum_n, 1)), 2)
    
    PrintMessage("    Sum(1 to ")
    PrintNumber(sum_n)
    PrintMessage(") = ")
    PrintNumber(sum_result)
}

// =============================================================================
// COMPUTATION WORKER - Multi-stage pipeline
// =============================================================================

SubRoutine.ComputationWorker {
    // Input: task_data
    // Encoded as: (operation_type * 1000) + input_value
    // operation_type: 1=Fibonacci, 2=Factorial, 3=Prime, 4=Power, 5=Sum
    
    operation = Divide(task_data, 1000)
    input_val = Modulo(task_data, 1000)
    
    PrintMessage("[COMPUTE] Task received - Operation ")
    PrintNumber(operation)
    PrintMessage(", Input ")
    PrintNumber(input_val)
    
    // Branch to appropriate computation
    Branch operation {
        Case 1: {
            PrintMessage("  [FIBONACCI PIPELINE]")
            fib_n = input_val
            RunTask(ComputeFibonacci)
            
            // Check if result is prime (nested computation!)
            prime_n = fib_result
            RunTask(CheckPrime)
            
            // Encode result: (fib_result * 10) + is_prime
            temp_scaled = Multiply(fib_result, 10)
            final_result = Add(temp_scaled, is_prime)
        }
        Case 2: {
            PrintMessage("  [FACTORIAL PIPELINE]")
            fact_n = input_val
            RunTask(ComputeFactorial)
            
            // Compute sum up to factorial result (if small enough)
            IfCondition LessThan(fact_result, 100) ThenBlock: {
                sum_n = fact_result
                RunTask(ComputeSum)
                final_result = sum_result
            } ElseBlock: {
                final_result = fact_result
            }
        }
        Case 3: {
            PrintMessage("  [PRIME CHECK PIPELINE]")
            prime_n = input_val
            RunTask(CheckPrime)
            
            // If prime, compute Fibonacci of that prime
            IfCondition EqualTo(is_prime, 1) ThenBlock: {
                fib_n = prime_n
                RunTask(ComputeFibonacci)
                final_result = fib_result
            } ElseBlock: {
                final_result = 0
            }
        }
        Case 4: {
            PrintMessage("  [POWER PIPELINE]")
            power_n = input_val
            RunTask(ComputePowerOfTwo)
            final_result = power_result
        }
        Case 5: {
            PrintMessage("  [SUM PIPELINE]")
            sum_n = input_val
            RunTask(ComputeSum)
            
            // Check if sum is prime
            prime_n = sum_result
            RunTask(CheckPrime)
            
            temp_scaled = Multiply(sum_result, 10)
            final_result = Add(temp_scaled, is_prime)
        }
        Default: {
            PrintMessage("  [UNKNOWN OPERATION]")
            final_result = 0
        }
    }
    
    PrintMessage("[COMPUTE] Final result: ")
    PrintNumber(final_result)
    PrintMessage("")
    
    ComputeStats.tasks_computed = Add(ComputeStats.tasks_computed, 1)
}

// =============================================================================
// TASK DEFINITIONS
// =============================================================================

SubRoutine.SubmitTasks {
    PrintMessage("[SUBMIT] Queuing computational tasks...")
    PrintMessage("")
    
    // Task 1: Fibonacci(8) then check if prime
    send_value = 1008
    RunTask(SendToCompute)
    ComputeStats.tasks_submitted = Add(ComputeStats.tasks_submitted, 1)
    
    // Task 2: Factorial(5) then sum
    send_value = 2005
    RunTask(SendToCompute)
    ComputeStats.tasks_submitted = Add(ComputeStats.tasks_submitted, 1)
    
    // Task 3: Check if 17 is prime, then Fibonacci
    send_value = 3017
    RunTask(SendToCompute)
    ComputeStats.tasks_submitted = Add(ComputeStats.tasks_submitted, 1)
    
    // Task 4: 2^10
    send_value = 4010
    RunTask(SendToCompute)
    ComputeStats.tasks_submitted = Add(ComputeStats.tasks_submitted, 1)
    
    // Task 5: Sum(1 to 20) then check if prime
    send_value = 5020
    RunTask(SendToCompute)
    ComputeStats.tasks_submitted = Add(ComputeStats.tasks_submitted, 1)
    
    PrintMessage("[SUBMIT] ")
    PrintNumber(ComputeStats.tasks_submitted)
    PrintMessage(" tasks submitted")
    PrintMessage("")
}

// =============================================================================
// PROCESSOR
// =============================================================================

SubRoutine.ProcessTasks {
    PrintMessage("[PROCESSOR] Starting computation pipeline...")
    PrintMessage("")
    
    cycles = 0
    
    WhileLoop LessThan(cycles, 10) {
        IfCondition GreaterThan(ComputeMailbox.count, 0) ThenBlock: {
            RunTask(ReceiveFromCompute)
            task_data = recv_value
            
            // Process the task
            RunTask(ComputationWorker)
            
            // Send result
            send_value = final_result
            RunTask(SendToResults)
        }
        
        cycles = Add(cycles, 1)
    }
    
    PrintMessage("[PROCESSOR] Processing complete")
    PrintMessage("")
}

// =============================================================================
// RESULTS ANALYZER
// =============================================================================

SubRoutine.AnalyzeResults {
    PrintMessage("[ANALYZER] Collecting and analyzing results...")
    PrintMessage("")
    
    total = 0
    count = 0
    
    WhileLoop GreaterThan(ResultsMailbox.count, 0) {
        RunTask(ReceiveFromResults)
        result = recv_value
        
        PrintMessage("  Result ")
        PrintNumber(count)
        PrintMessage(": ")
        PrintNumber(result)
        
        total = Add(total, result)
        count = Add(count, 1)
    }
    
    PrintMessage("")
    PrintMessage("[ANALYZER] Total: ")
    PrintNumber(total)
    PrintMessage(" across ")
    PrintNumber(count)
    PrintMessage(" results")
    PrintMessage("")
}

// =============================================================================
// METRICS DASHBOARD
// =============================================================================

SubRoutine.ShowMetrics {
    PrintMessage("==============================================================")
    PrintMessage("COMPUTATIONAL METRICS DASHBOARD")
    PrintMessage("==============================================================")
    PrintMessage("")
    
    PrintMessage("Tasks:")
    PrintMessage("  Submitted:        ")
    PrintNumber(ComputeStats.tasks_submitted)
    PrintMessage("  Computed:         ")
    PrintNumber(ComputeStats.tasks_computed)
    PrintMessage("")
    
    PrintMessage("Operations:")
    PrintMessage("  Fibonacci calls:  ")
    PrintNumber(ComputeStats.fibonacci_computed)
    PrintMessage("  Factorial calls:  ")
    PrintNumber(ComputeStats.factorial_computed)
    PrintMessage("  Primes found:     ")
    PrintNumber(ComputeStats.primes_found)
    PrintMessage("  Composites found: ")
    PrintNumber(ComputeStats.composites_found)
    PrintMessage("")
    
    total_ops = Add(ComputeStats.fibonacci_computed, ComputeStats.factorial_computed)
    total_ops = Add(total_ops, ComputeStats.primes_found)
    total_ops = Add(total_ops, ComputeStats.composites_found)
    
    PrintMessage("Total operations:   ")
    PrintNumber(total_ops)
    PrintMessage("")
    PrintMessage("==============================================================")
}

// =============================================================================
// MAIN ORCHESTRATOR
// =============================================================================

SubRoutine.Orchestrator {
    PrintMessage("Launching complex computational pipeline...")
    PrintMessage("")
    
    // Submit all tasks
    RunTask(SubmitTasks)
    
    // Process all tasks
    RunTask(ProcessTasks)
    
    // Analyze results
    RunTask(AnalyzeResults)
    
    // Show metrics
    RunTask(ShowMetrics)
    
    PrintMessage("")
    PrintMessage("This demonstrated:")
    PrintMessage("  - Multi-stage computation pipelines")
    PrintMessage("  - Fibonacci, Factorial, Prime checking algorithms")
    PrintMessage("  - Nested computations (Fib -> Prime check)")
    PrintMessage("  - Conditional branching based on results")
    PrintMessage("  - Complex data transformations")
    PrintMessage("  - Ring buffer message passing throughout")
    PrintMessage("")
    PrintMessage("AILANG handles complex algorithms beautifully!")
    PrintMessage("==============================================================")
}

// =============================================================================
// EXECUTION
// =============================================================================

RunTask(Orchestrator)