// ring_buffer_mailbox_demo.ailang
// WORKING RING BUFFER MAILBOX IMPLEMENTATION
// Demonstrates true message queueing with FixedPool

PrintMessage("==============================================")
PrintMessage("RING BUFFER MAILBOX DEMONSTRATION")
PrintMessage("==============================================")
PrintMessage("")

// Define mailbox with 8 message slots
FixedPool.Mailbox {
    "head": Initialize=0
    "tail": Initialize=0
    "count": Initialize=0
    "slot0": Initialize=0
    "slot1": Initialize=0
    "slot2": Initialize=0
    "slot3": Initialize=0
    "slot4": Initialize=0
    "slot5": Initialize=0
    "slot6": Initialize=0
    "slot7": Initialize=0
}

total_tests = 0
passed_tests = 0

SubRoutine.TestResult {
    total_tests = Add(total_tests, 1)
    PrintMessage("TEST: ")
    PrintMessage(test_name)
    PrintMessage(" | Exp: ")
    PrintNumber(expected)
    PrintMessage(" | Act: ")
    PrintNumber(actual)
    
    IfCondition EqualTo(expected, actual) ThenBlock: {
        PrintMessage(" | PASS")
        passed_tests = Add(passed_tests, 1)
    } ElseBlock: {
        PrintMessage(" | FAIL")
    }
}

// Send message to mailbox
SubRoutine.MailboxSend {
    // Input: send_value
    // Check if full
    IfCondition LessThan(Mailbox.count, 8) ThenBlock: {
        tail_pos = Mailbox.tail
        
        PrintMessage("  Sending ")
        PrintNumber(send_value)
        PrintMessage(" to slot ")
        PrintNumber(tail_pos)
        
        // Store in appropriate slot
        Branch tail_pos {
            Case 0: { Mailbox.slot0 = send_value }
            Case 1: { Mailbox.slot1 = send_value }
            Case 2: { Mailbox.slot2 = send_value }
            Case 3: { Mailbox.slot3 = send_value }
            Case 4: { Mailbox.slot4 = send_value }
            Case 5: { Mailbox.slot5 = send_value }
            Case 6: { Mailbox.slot6 = send_value }
            Case 7: { Mailbox.slot7 = send_value }
        }
        
        // Advance tail (circular)
        Mailbox.tail = Modulo(Add(tail_pos, 1), 8)
        Mailbox.count = Add(Mailbox.count, 1)
        
        PrintMessage("  Count now: ")
        PrintNumber(Mailbox.count)
    } ElseBlock: {
        PrintMessage("  ERROR: Mailbox full!")
    }
}

// Receive message from mailbox
SubRoutine.MailboxReceive {
    // Output: received
    received = 0
    
    IfCondition GreaterThan(Mailbox.count, 0) ThenBlock: {
        head_pos = Mailbox.head
        
        PrintMessage("  Receiving from slot ")
        PrintNumber(head_pos)
        
        // Read from appropriate slot
        Branch head_pos {
            Case 0: { received = Mailbox.slot0 }
            Case 1: { received = Mailbox.slot1 }
            Case 2: { received = Mailbox.slot2 }
            Case 3: { received = Mailbox.slot3 }
            Case 4: { received = Mailbox.slot4 }
            Case 5: { received = Mailbox.slot5 }
            Case 6: { received = Mailbox.slot6 }
            Case 7: { received = Mailbox.slot7 }
        }
        
        PrintMessage("  Received: ")
        PrintNumber(received)
        
        // Advance head (circular)
        Mailbox.head = Modulo(Add(head_pos, 1), 8)
        Mailbox.count = Subtract(Mailbox.count, 1)
        
        PrintMessage("  Count now: ")
        PrintNumber(Mailbox.count)
    } ElseBlock: {
        PrintMessage("  No messages available")
        received = -1
    }
}

// ==============================================
// TEST 1: Single Send/Receive
// ==============================================
PrintMessage("")
PrintMessage("TEST 1: Single Send/Receive")

send_value = 42
RunTask(MailboxSend)
RunTask(MailboxReceive)

test_name = "Single message"
expected = 42
actual = received
RunTask(TestResult)

// ==============================================
// TEST 2: Multiple Messages (FIFO)
// ==============================================
PrintMessage("")
PrintMessage("TEST 2: Multiple Messages FIFO")

send_value = 10
RunTask(MailboxSend)
send_value = 20
RunTask(MailboxSend)
send_value = 30
RunTask(MailboxSend)

test_name = "Queue count"
expected = 3
actual = Mailbox.count
RunTask(TestResult)

RunTask(MailboxReceive)
test_name = "First out"
expected = 10
actual = received
RunTask(TestResult)

RunTask(MailboxReceive)
test_name = "Second out"
expected = 20
actual = received
RunTask(TestResult)

RunTask(MailboxReceive)
test_name = "Third out"
expected = 30
actual = received
RunTask(TestResult)

test_name = "Queue empty"
expected = 0
actual = Mailbox.count
RunTask(TestResult)

// ==============================================
// TEST 3: Producer-Consumer Pattern
// ==============================================
PrintMessage("")
PrintMessage("TEST 3: Producer-Consumer")

SubRoutine.Producer {
    PrintMessage("  Producer: Sending 5 items")
    i = 0
    WhileLoop LessThan(i, 5) {
        send_value = Add(i, 100)
        RunTask(MailboxSend)
        i = Add(i, 1)
    }
}

SubRoutine.Consumer {
    PrintMessage("  Consumer: Receiving items")
    sum = 0
    j = 0
    WhileLoop LessThan(j, 5) {
        RunTask(MailboxReceive)
        sum = Add(sum, received)
        j = Add(j, 1)
    }
    consumer_sum = sum
}

RunTask(Producer)
RunTask(Consumer)

test_name = "Producer-consumer sum"
expected = 510  // 100+101+102+103+104
actual = consumer_sum
RunTask(TestResult)

// ==============================================
// TEST 4: Circular Buffer Wrap
// ==============================================
PrintMessage("")
PrintMessage("TEST 4: Circular Buffer Wrap")

// Fill buffer completely
PrintMessage("  Filling buffer to capacity")
send_value = 1
RunTask(MailboxSend)
send_value = 2
RunTask(MailboxSend)
send_value = 3
RunTask(MailboxSend)
send_value = 4
RunTask(MailboxSend)
send_value = 5
RunTask(MailboxSend)
send_value = 6
RunTask(MailboxSend)
send_value = 7
RunTask(MailboxSend)
send_value = 8
RunTask(MailboxSend)

test_name = "Buffer full"
expected = 8
actual = Mailbox.count
RunTask(TestResult)

// Try to overfill
send_value = 999
RunTask(MailboxSend)

test_name = "Still at capacity"
expected = 8
actual = Mailbox.count
RunTask(TestResult)

// Drain 4 messages
PrintMessage("  Draining 4 messages")
RunTask(MailboxReceive)
RunTask(MailboxReceive)
RunTask(MailboxReceive)
RunTask(MailboxReceive)

test_name = "After drain"
expected = 4
actual = Mailbox.count
RunTask(TestResult)

// Add 3 more (tests wrap-around)
PrintMessage("  Adding 3 more (tests wrap)")
send_value = 91
RunTask(MailboxSend)
send_value = 92
RunTask(MailboxSend)
send_value = 93
RunTask(MailboxSend)

test_name = "After wrap-add"
expected = 7
actual = Mailbox.count
RunTask(TestResult)

// Receive all remaining
PrintMessage("  Draining all remaining")
sum_remaining = 0
WhileLoop GreaterThan(Mailbox.count, 0) {
    RunTask(MailboxReceive)
    sum_remaining = Add(sum_remaining, received)
}

test_name = "Buffer empty again"
expected = 0
actual = Mailbox.count
RunTask(TestResult)

// ==============================================
// TEST 5: Empty Receive
// ==============================================
PrintMessage("")
PrintMessage("TEST 5: Receive from Empty")

RunTask(MailboxReceive)

test_name = "Empty receive returns -1"
expected = -1
actual = received
RunTask(TestResult)

// ==============================================
// FINAL SUMMARY
// ==============================================
PrintMessage("")
PrintMessage("==============================================")
PrintMessage("RING BUFFER MAILBOX SUMMARY")
PrintMessage("==============================================")

PrintMessage("Total Tests: ")
PrintNumber(total_tests)
PrintMessage("Passed: ")
PrintNumber(passed_tests)

success_rate = 0
IfCondition GreaterThan(total_tests, 0) ThenBlock: {
    success_rate = Divide(Multiply(passed_tests, 100), total_tests)
}

PrintMessage("Success Rate: ")
PrintNumber(success_rate)
PrintMessage("%")
PrintMessage("")

IfCondition EqualTo(passed_tests, total_tests) ThenBlock: {
    PrintMessage("ALL TESTS PASSED!")
    PrintMessage("")
    PrintMessage("Ring Buffer Mailbox Features:")
    PrintMessage("- Multiple messages queued (8 capacity)")
    PrintMessage("- FIFO ordering preserved")
    PrintMessage("- Circular buffer with wrap-around")
    PrintMessage("- Overflow protection")
    PrintMessage("- Producer-consumer patterns work")
    PrintMessage("")
    PrintMessage("This demonstrates how FixedPool can provide")
    PrintMessage("true message queueing for AILANG!")
} ElseBlock: {
    PrintMessage("SOME TESTS FAILED")
}

PrintMessage("")
PrintMessage("Demo complete.")
PrintMessage("==============================================")