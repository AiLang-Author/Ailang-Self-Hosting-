// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// test_memory_complete.ailang
// Comprehensive Memory Operations Test Harness v2.0
// Tests all memory functions including edge cases

PrintMessage("========================================")
PrintMessage("COMPLETE MEMORY TEST HARNESS v2.0")
PrintMessage("========================================")
PrintMessage("")

// Test result tracking
test_count = 0
pass_count = 0
fail_count = 0

// ==========================================
// SECTION 1: STACK VARIABLES
// ==========================================
PrintMessage("SECTION 1: Stack Variables")
PrintMessage("--------------------------")

// Basic allocation
stack1 = 42
stack2 = -100
stack3 = 0
stack4 = 2147483647  // Max int

PrintMessage("Basic stack (42, -100, 0, max):")
PrintNumber(stack1)
PrintNumber(stack2)
PrintNumber(stack3)
PrintNumber(stack4)

// Variable shadowing in loops
outer = 100
i = 0
WhileLoop LessThan(i, 2) {
    inner = Add(outer, i)
    PrintMessage("Loop scope var:")
    PrintNumber(inner)
    i = Add(i, 1)
}

// Operations on stack
result = Add(Multiply(stack1, 2), stack2)
PrintMessage("(42 * 2) + (-100) = -16:")
PrintNumber(result)

// ==========================================
// SECTION 2: FIXEDPOOL EDGE CASES
// ==========================================
PrintMessage("")
PrintMessage("SECTION 2: FixedPool Edge Cases")
PrintMessage("--------------------------------")

FixedPool.EdgeFixed {
    "zero": Initialize=0
    "negative": Initialize=-2147483648  
    "max_positive": Initialize=2147483647
    "one": Initialize=1
    "minus_one": Initialize=-1
}

PrintMessage("Edge values (0, min, max, 1, -1):")
PrintNumber(EdgeFixed.zero)
PrintNumber(EdgeFixed.negative)
PrintNumber(EdgeFixed.max_positive)
PrintNumber(EdgeFixed.one)
PrintNumber(EdgeFixed.minus_one)

// Multiple FixedPools
FixedPool.Fixed1 {
    "val": Initialize=100
}

FixedPool.Fixed2 {
    "val": Initialize=200
}

PrintMessage("Fixed1.val (100) and Fixed2.val (200):")
PrintNumber(Fixed1.val)
PrintNumber(Fixed2.val)

// ==========================================
// SECTION 3: DYNAMICPOOL EDGE CASES
// ==========================================
PrintMessage("")
PrintMessage("SECTION 3: DynamicPool Edge Cases")
PrintMessage("----------------------------------")

DynamicPool.EdgeDynamic {
    "zero": Initialize=0
    "negative": Initialize=-9999
    "large": Initialize=999999
}

PrintMessage("Initial edge values:")
PrintNumber(EdgeDynamic.zero)
PrintNumber(EdgeDynamic.negative)
PrintNumber(EdgeDynamic.large)

// Overwrite tests
EdgeDynamic.zero = 42
EdgeDynamic.negative = Add(EdgeDynamic.negative, 9999)  // Should be 0
EdgeDynamic.large = Divide(EdgeDynamic.large, 1000)     // Should be 999

PrintMessage("After modifications (42, 0, 999):")
PrintNumber(EdgeDynamic.zero)
PrintNumber(EdgeDynamic.negative)
PrintNumber(EdgeDynamic.large)

// Empty DynamicPool
DynamicPool.EmptyPool {
}

PrintMessage("Empty DynamicPool created (no crash)")

// ==========================================
// SECTION 4: HEAP ALLOCATION EDGE CASES
// ==========================================
PrintMessage("")
PrintMessage("SECTION 4: Heap Allocation Edge Cases")
PrintMessage("--------------------------------------")

// Zero allocation
ptr0 = Allocate(0)
PrintMessage("Zero-byte allocation ptr (non-null):")
PrintNumber(ptr0)
Deallocate(ptr0, 0)

// Small allocation
ptr1 = Allocate(1)
StoreValue(ptr1, 255)
val1 = Dereference(ptr1)
PrintMessage("1-byte allocation, stored 255:")
PrintNumber(val1)
Deallocate(ptr1, 1)

// Large allocation
ptr2 = Allocate(65536)  // 64KB
StoreValue(ptr2, 12345)
val2 = Dereference(ptr2)
PrintMessage("64KB allocation, stored 12345:")
PrintNumber(val2)

// Store at various offsets
StoreValue(Add(ptr2, 8), 111)
StoreValue(Add(ptr2, 16), 222)
StoreValue(Add(ptr2, 65528), 333)  // Near end

PrintMessage("Values at offsets 8, 16, 65528:")
PrintNumber(Dereference(Add(ptr2, 8)))
PrintNumber(Dereference(Add(ptr2, 16)))
PrintNumber(Dereference(Add(ptr2, 65528)))

Deallocate(ptr2, 65536)

// Multiple allocations
p1 = Allocate(100)
p2 = Allocate(200)
p3 = Allocate(300)

StoreValue(p1, 1)
StoreValue(p2, 2)
StoreValue(p3, 3)

sum = Add(Dereference(p1), Add(Dereference(p2), Dereference(p3)))
PrintMessage("Multi-alloc sum (1+2+3=6):")
PrintNumber(sum)

Deallocate(p1, 100)
Deallocate(p2, 200)
Deallocate(p3, 300)

// ==========================================
// SECTION 5: ARRAY EDGE CASES
// ==========================================
PrintMessage("")
PrintMessage("SECTION 5: Array Edge Cases")
PrintMessage("----------------------------")

// Zero-size array (should allocate minimal space)
arr0 = ArrayCreate(0)
PrintMessage("Zero-size array created (no crash)")

// Single element
arr1 = ArrayCreate(1)
ArraySet(arr1, 0, 42)
PrintMessage("Single element array [42]:")
PrintNumber(ArrayGet(arr1, 0))

// Large array
arr_large = ArrayCreate(1000)
ArraySet(arr_large, 0, 100)
ArraySet(arr_large, 500, 200)
ArraySet(arr_large, 999, 300)

PrintMessage("Large array [0]=100, [500]=200, [999]=300:")
PrintNumber(ArrayGet(arr_large, 0))
PrintNumber(ArrayGet(arr_large, 500))
PrintNumber(ArrayGet(arr_large, 999))

// Negative values in array
arr_neg = ArrayCreate(3)
ArraySet(arr_neg, 0, -1)
ArraySet(arr_neg, 1, -999)
ArraySet(arr_neg, 2, -2147483648)

PrintMessage("Negative array values:")
PrintNumber(ArrayGet(arr_neg, 0))
PrintNumber(ArrayGet(arr_neg, 1))
PrintNumber(ArrayGet(arr_neg, 2))

// ==========================================
// SECTION 6: ADDRESS OPERATIONS EDGE CASES
// ==========================================
PrintMessage("")
PrintMessage("SECTION 6: Address Operations Edge Cases")
PrintMessage("-----------------------------------------")

// Address of various types
local = 42
addr_local = AddressOf(local)
PrintMessage("Address of local var:")
PrintNumber(addr_local)

// Modify through pointer
StoreValue(addr_local, 100)
PrintMessage("Modified through pointer (100):")
PrintNumber(local)

// Address of array element (indirect)
arr_addr = ArrayCreate(5)
ArraySet(arr_addr, 2, 999)
// Note: Can't directly get address of array element in AILANG
PrintMessage("Array element via base+offset works")

// Chain of pointers
val_a = 10
addr_a = AddressOf(val_a)
StoreValue(addr_a, 20)
val_b = Dereference(addr_a)
PrintMessage("Pointer chain (20):")
PrintNumber(val_b)

// ==========================================
// SECTION 7: MIXED POOL STRESS TEST
// ==========================================
PrintMessage("")
PrintMessage("SECTION 7: Mixed Pool Stress Test")
PrintMessage("----------------------------------")

FixedPool.Constants {
    "increment": Initialize=5
    "multiplier": Initialize=3
}

DynamicPool.State {
    "counter": Initialize=0
    "accumulator": Initialize=1
}

// Complex mixed operations
j = 0
WhileLoop LessThan(j, 3) {
    State.counter = Add(State.counter, Constants.increment)
    State.accumulator = Multiply(State.accumulator, Constants.multiplier)
    j = Add(j, 1)
}

PrintMessage("Counter (0+5+5+5=15):")
PrintNumber(State.counter)
PrintMessage("Accumulator (1*3*3*3=27):")
PrintNumber(State.accumulator)

// ==========================================
// SECTION 8: BOUNDARY CONDITIONS
// ==========================================
PrintMessage("")
PrintMessage("SECTION 8: Boundary Conditions")
PrintMessage("-------------------------------")

// Integer overflow test
big = 2147483640
big = Add(big, 10)  // Might overflow
PrintMessage("Near-overflow addition:")
PrintNumber(big)

// Division edge cases
zero_div = Divide(0, 100)
PrintMessage("0 / 100 = 0:")
PrintNumber(zero_div)

one_div = Divide(100, 1)
PrintMessage("100 / 1 = 100:")
PrintNumber(one_div)

neg_div = Divide(-100, 10)
PrintMessage("-100 / 10 = -10:")
PrintNumber(neg_div)

// Modulo edge cases
mod1 = Modulo(10, 3)
PrintMessage("10 % 3 = 1:")
PrintNumber(mod1)

mod2 = Modulo(0, 5)
PrintMessage("0 % 5 = 0:")
PrintNumber(mod2)

// ==========================================
// SECTION 9: MEMORY PATTERN TEST
// ==========================================
PrintMessage("")
PrintMessage("SECTION 9: Memory Pattern Test")
PrintMessage("-------------------------------")

// Create pattern in memory
pattern_ptr = Allocate(32)
k = 0
WhileLoop LessThan(k, 4) {
    offset = Multiply(k, 8)
    value = Multiply(k, 111)  // 0, 111, 222, 333
    StoreValue(Add(pattern_ptr, offset), value)
    k = Add(k, 1)
}

// Verify pattern
PrintMessage("Memory pattern (0, 111, 222, 333):")
m = 0
WhileLoop LessThan(m, 4) {
    offset = Multiply(m, 8)
    val = Dereference(Add(pattern_ptr, offset))
    PrintNumber(val)
    m = Add(m, 1)
}

Deallocate(pattern_ptr, 32)

// ==========================================
// SECTION 10: POOL WITH ARRAYS
// ==========================================
PrintMessage("")
PrintMessage("SECTION 10: Pool with Arrays")
PrintMessage("-----------------------------")

DynamicPool.ArrayPool {
    "array_ptr": Initialize=0
    "size": Initialize=10
}

// Store array pointer in pool
ArrayPool.array_ptr = ArrayCreate(ArrayPool.size)

// Initialize through pool
n = 0
WhileLoop LessThan(n, ArrayPool.size) {
    ArraySet(ArrayPool.array_ptr, n, Multiply(n, 10))
    n = Add(n, 1)
}

// Read back first 3 elements
PrintMessage("Array in pool (0, 10, 20):")
PrintNumber(ArrayGet(ArrayPool.array_ptr, 0))
PrintNumber(ArrayGet(ArrayPool.array_ptr, 1))
PrintNumber(ArrayGet(ArrayPool.array_ptr, 2))

// ==========================================
// FINAL SUMMARY
// ==========================================
PrintMessage("")
PrintMessage("========================================")
PrintMessage("MEMORY TEST HARNESS COMPLETE")
PrintMessage("========================================")
PrintMessage("")
PrintMessage("Test Coverage:")
PrintMessage("- Stack variables with edge cases")
PrintMessage("- FixedPool with limits and multiple pools")
PrintMessage("- DynamicPool with modifications and empty pools")
PrintMessage("- Heap allocation from 0 to 64KB")
PrintMessage("- Arrays from size 0 to 1000")
PrintMessage("- Address operations and pointer chains")
PrintMessage("- Mixed pool stress testing")
PrintMessage("- Integer boundary conditions")
PrintMessage("- Memory patterns and verification")
PrintMessage("- Pools containing array pointers")
PrintMessage("")
PrintMessage("Check output for any unexpected values or crashes")