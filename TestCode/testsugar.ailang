// Test file for Syntactic Sugar Features
// Tests Acronyms and LinkagePool functionality

// Define acronyms that might conflict with parameters
AcronymDefinitions {
    CUST: "CustomerData"
    IO: "InputOutput"
    DATA: "DataBlock"
}

// Define LinkagePools for testing
LinkagePool.CustomerData {
    "id": Initialize=0, Direction=Input
    "name": Initialize=0, Direction=Output
    "balance": Initialize=100, Direction=Input
}

LinkagePool.DataBlock {
    "field1": Initialize=0, Direction=Input
    "field2": Initialize=0, Direction=Output
    "field3": Initialize=0, Direction=Input
}

LinkagePool.InputOutput {
    "input": Initialize=0, Direction=Input
    "output": Initialize=0, Direction=Output
    "status": Initialize=1, Direction=Input
}

// ========================================
// TEST PHASE 1: Basic Type Tracking
// ========================================
PrintMessage("\n=== PHASE 1: Type Tracking ===\n")

// Test 1.1: AllocateLinkage creates typed pointer
ptr1 = AllocateLinkage(LinkagePool.CustomerData)
PrintMessage("Allocated CustomerData at: ")
PrintNumber(ptr1)
PrintMessage("\n")

// Test 1.2: Multiple allocations with different types
ptr2 = AllocateLinkage(LinkagePool.DataBlock)
PrintMessage("Allocated DataBlock at: ")
PrintNumber(ptr2)
PrintMessage("\n")

// ========================================
// TEST PHASE 2: Type Propagation
// ========================================
PrintMessage("\n=== PHASE 2: Type Propagation ===\n")

// Test 2.1: Assignment propagates type
ptr3 = ptr1  // Should inherit CustomerData type
PrintMessage("ptr3 = ptr1 (type propagated): ")
PrintNumber(ptr3)
PrintMessage("\n")

// Test 2.2: Chain of propagations
ptr4 = ptr3  // Should also be CustomerData
ptr5 = ptr2  // Should be DataBlock
PrintMessage("Type propagation chain complete\n")

// ========================================
// TEST PHASE 3: Acronym Conflict Detection
// ========================================
PrintMessage("\n=== PHASE 3: Conflict Detection ===\n")

// This function should trigger warnings for CUST and DATA parameters
Function.TestConflicts {
    Input: (CUST: LinkagePool.CustomerData, DATA: LinkagePool.DataBlock)
    Body: {
        PrintMessage("In TestConflicts function\n")
        // Parameters shadow acronyms - should get warnings
        CUST.id = 123
        DATA.field1 = 456
        ReturnValue(0)
    }
}

// Call with actual pointers
TestConflicts(ptr1, ptr2)

// ========================================
// TEST PHASE 4: Emergency Suffix (~)
// ========================================
PrintMessage("\n=== PHASE 4: Force Expansion with ~ ===\n")

// Without suffix, IO might be treated as parameter in some contexts
// With suffix, it forces expansion to InputOutput
io_ptr = AllocateLinkage(LinkagePool.InputOutput)

Function.TestSuffix {
    Input: IO: LinkagePool.InputOutput  // Parameter named IO (conflicts with acronym)
    Body: {
        PrintMessage("Testing ~ suffix:\n")
        
        // IO without suffix - refers to parameter
        IO.input = 111
        PrintMessage("Set parameter IO.input = 111\n")
        
        // IO~ with suffix - forces expansion to InputOutput acronym
        // (This would need the acronym to resolve to something else)
        PrintMessage("Force expansion test complete\n")
        
        ReturnValue(IO.input)
    }
}

result = TestSuffix(io_ptr)
PrintMessage("Result from TestSuffix: ")
PrintNumber(result)
PrintMessage("\n")

// ========================================
// TEST PHASE 5 & 8: Function Parameters
// ========================================
PrintMessage("\n=== PHASE 5/8: Parameter Types ===\n")

Function.ProcessCustomer {
    Input: cust: LinkagePool.CustomerData
    Body: {
        PrintMessage("Processing customer:\n")
        
        // Access fields through typed parameter
        cust.id = 999
        cust.balance = 2500
        
        PrintMessage("  ID: ")
        PrintNumber(cust.id)
        PrintMessage("\n  Balance: ")
        PrintNumber(cust.balance)
        PrintMessage("\n")
        
        ReturnValue(cust.balance)
    }
}

balance = ProcessCustomer(ptr1)
PrintMessage("Returned balance: ")
PrintNumber(balance)
PrintMessage("\n")

// ========================================
// TEST PHASE 6: No Spurious Allocation
// ========================================
PrintMessage("\n=== PHASE 6: Field Assignment ===\n")

// These should NOT create new variables
ptr1.id = 777
ptr1.name = 888
ptr1.balance = 3000

PrintMessage("Direct field assignments completed\n")
PrintMessage("Customer ID: ")
PrintNumber(ptr1.id)
PrintMessage("\n")

// ========================================
// TEST PHASE 7: Field Access Resolution
// ========================================
PrintMessage("\n=== PHASE 7: Field Access ===\n")

// Test various access patterns
value1 = ptr1.id
value2 = ptr1.balance
value3 = ptr2.field1

PrintMessage("Read field values:\n")
PrintMessage("  ptr1.id = ")
PrintNumber(value1)
PrintMessage("\n  ptr1.balance = ")
PrintNumber(value2)
PrintMessage("\n  ptr2.field1 = ")
PrintNumber(value3)
PrintMessage("\n")

// ========================================
// TEST ACRONYM RESOLUTION
// ========================================
PrintMessage("\n=== Acronym Resolution ===\n")

// CUST should expand to CustomerData (when not a parameter)
cust_ptr = AllocateLinkage(LinkagePool.CustomerData)

// Access through acronym (if implemented)
// CUST.id = 100  // Would work if CUST expands to CustomerData

PrintMessage("\n=== All Tests Complete ===\n")
PrintMessage("Check debug output for:\n")
PrintMessage("- Type tracking messages\n")
PrintMessage("- Type propagation messages\n")
PrintMessage("- Conflict warnings\n")
PrintMessage("- Force expansion messages\n")
PrintMessage("- Field access resolution\n")