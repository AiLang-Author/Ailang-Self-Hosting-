// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// hdl_compiler_minimal.ailang - Minimal HDL compiler in AILang
// Compiles subset of AILang HDL to JSON netlist

// AST node types for HDL
Constant.HDL.MODULE = 1
Constant.HDL.INPUT = 2
Constant.HDL.OUTPUT = 3
Constant.HDL.REGISTER = 4
Constant.HDL.WIRE = 5
Constant.HDL.SEQUENTIAL = 6
Constant.HDL.COMBINATIONAL = 7
Constant.HDL.ASSIGN = 8
Constant.HDL.OPERATION = 9

// Gate types in netlist
Constant.GATE.AND = "AND2"
Constant.GATE.OR = "OR2"
Constant.GATE.XOR = "XOR2"
Constant.GATE.NOT = "NOT1"
Constant.GATE.ADD = "ADD8"
Constant.GATE.DFF = "DFF"
Constant.GATE.MUX = "MUX2"

// Simple HDL compiler
Function.HDL.CompileToNetlist {
    Input: (source: Text)
    Output: Text  // JSON netlist
    Body: {
        PrintMessage("Starting HDL compilation...")
        
        // Parse source to AST
        ast = HDL.Parse(source)
        
        // Extract module info
        module_name = HDL.GetModuleName(ast)
        inputs = HDL.ExtractPorts(ast, HDL.INPUT)
        outputs = HDL.ExtractPorts(ast, HDL.OUTPUT)
        
        // Find registers and wires
        registers = HDL.FindRegisters(ast)
        wires = HDL.FindWires(ast)
        
        // Generate gates from logic
        gates = HDL.GenerateGates(ast)
        
        // Build netlist JSON
        netlist = HDL.BuildNetlist(module_name, inputs, outputs, registers, wires, gates)
        
        PrintMessage("HDL compilation complete")
        ReturnValue(netlist)
    }
}

Function.HDL.Parse {
    Input: (source: Text)
    Output: AST
    Body: {
        // Simplified parser - finds patterns
        ast = Array.Create()
        
        // Find module declaration
        module_start = StringFind(source, "Module.")
        module_end = StringFind(source, "{", module_start)
        module_name = StringExtract(source, Add(module_start, 7), module_end)
        
        ast = ArrayPush(ast, CreateNode(HDL.MODULE, module_name))
        
        // Find Sequential.Rising blocks
        seq_pos = StringFind(source, "Sequential.Rising")
        IfCondition NotEqual(seq_pos, -1) ThenBlock {
            ast = ArrayPush(ast, CreateNode(HDL.SEQUENTIAL, "clk"))
        }
        
        // Find Combinational blocks
        comb_pos = StringFind(source, "Combinational")
        IfCondition NotEqual(comb_pos, -1) ThenBlock {
            ast = ArrayPush(ast, CreateNode(HDL.COMBINATIONAL, ""))
        }
        
        // Find Register declarations
        reg_pos = 0
        WhileLoop NotEqual(reg_pos, -1) {
            reg_pos = StringFind(source, "Register.", reg_pos)
            IfCondition NotEqual(reg_pos, -1) ThenBlock {
                reg_end = StringFind(source, ":", reg_pos)
                reg_name = StringExtract(source, Add(reg_pos, 9), reg_end)
                ast = ArrayPush(ast, CreateNode(HDL.REGISTER, reg_name))
                reg_pos = Add(reg_pos, 1)
            }
        }
        
        ReturnValue(ast)
    }
}

Function.HDL.FindRegisters {
    Input: (ast: AST)
    Output: Array
    Body: {
        registers = Array.Create()
        
        ForEvery node in ast {
            IfCondition EqualTo(node.type, HDL.REGISTER) ThenBlock {
                // Create register entry
                reg = HashCreate(3)
                HashSet(reg, "name", node.value)
                HashSet(reg, "width", 8)  // Default 8-bit
                HashSet(reg, "reset", 0)
                
                registers = ArrayPush(registers, reg)
            }
        }
        
        ReturnValue(registers)
    }
}

Function.HDL.GenerateGates {
    Input: (ast: AST)
    Output: Array
    Body: {
        gates = Array.Create()
        gate_id = 0
        
        // For each operation in AST, generate appropriate gates
        ForEvery node in ast {
            IfCondition EqualTo(node.type, HDL.OPERATION) ThenBlock {
                gate = HashCreate(4)
                gate_name = StringConcat("g", NumberToString(gate_id))
                
                ChoosePath node.op {
                    CaseOption "Add": {
                        HashSet(gate, "type", GATE.ADD)
                        HashSet(gate, "name", gate_name)
                        HashSet(gate, "inputs", ["a", "b"])
                        HashSet(gate, "output", "sum")
                    }
                    CaseOption "BitwiseAnd": {
                        HashSet(gate, "type", GATE.AND)
                        HashSet(gate, "name", gate_name)
                        HashSet(gate, "inputs", ["a", "b"])
                        HashSet(gate, "output", "y")
                    }
                    CaseOption "BitwiseOr": {
                        HashSet(gate, "type", GATE.OR)
                        HashSet(gate, "name", gate_name)
                        HashSet(gate, "inputs", ["a", "b"])
                        HashSet(gate, "output", "y")
                    }
                    DefaultOption: {
                        HashSet(gate, "type", GATE.AND)  // Default
                    }
                }
                
                gates = ArrayPush(gates, gate)
                gate_id = Add(gate_id, 1)
            }
        }
        
        // Add DFFs for each register
        ForEvery reg in registers {
            gate = HashCreate(4)
            gate_name = StringConcat(reg.name, "_dff")
            HashSet(gate, "type", GATE.DFF)
            HashSet(gate, "name", gate_name)
            HashSet(gate, "clk", "clk")
            HashSet(gate, "d", StringConcat(reg.name, "_next"))
            HashSet(gate, "q", reg.name)
            
            gates = ArrayPush(gates, gate)
        }
        
        ReturnValue(gates)
    }
}

Function.HDL.BuildNetlist {
    Input: (module: Text, inputs: Array, outputs: Array, registers: Array, wires: Array, gates: Array)
    Output: Text
    Body: {
        // Build JSON netlist
        json = "{\n"
        json = StringConcat(json, "  \"module\": \"")
        json = StringConcat(json, module)
        json = StringConcat(json, "\",\n")
        
        // Add ports
        json = StringConcat(json, "  \"ports\": {\n")
        json = StringConcat(json, "    \"inputs\": [")
        ForEvery input in inputs {
            json = StringConcat(json, "\"")
            json = StringConcat(json, input.name)
            json = StringConcat(json, "\", ")
        }
        json = StringConcat(json, "],\n")
        
        json = StringConcat(json, "    \"outputs\": [")
        ForEvery output in outputs {
            json = StringConcat(json, "\"")
            json = StringConcat(json, output.name)
            json = StringConcat(json, "\", ")
        }
        json = StringConcat(json, "]\n  },\n")
        
        // Add cells (gates)
        json = StringConcat(json, "  \"cells\": [\n")
        ForEvery gate in gates {
            json = StringConcat(json, "    {\n")
            json = StringConcat(json, "      \"name\": \"")
            json = StringConcat(json, HashGet(gate, "name"))
            json = StringConcat(json, "\",\n")
            json = StringConcat(json, "      \"type\": \"")
            json = StringConcat(json, HashGet(gate, "type"))
            json = StringConcat(json, "\",\n")
            
            // Add connections
            IfCondition EqualTo(HashGet(gate, "type"), GATE.DFF) ThenBlock {
                json = StringConcat(json, "      \"connections\": {\n")
                json = StringConcat(json, "        \"CLK\": \"clk\",\n")
                json = StringConcat(json, "        \"D\": \"")
                json = StringConcat(json, HashGet(gate, "d"))
                json = StringConcat(json, "\",\n")
                json = StringConcat(json, "        \"Q\": \"")
                json = StringConcat(json, HashGet(gate, "q"))
                json = StringConcat(json, "\"\n")
                json = StringConcat(json, "      }\n")
            } ElseBlock {
                json = StringConcat(json, "      \"connections\": {\n")
                json = StringConcat(json, "        \"A\": \"input_a\",\n")
                json = StringConcat(json, "        \"B\": \"input_b\",\n")
                json = StringConcat(json, "        \"Y\": \"output\"\n")
                json = StringConcat(json, "      }\n")
            }
            
            json = StringConcat(json, "    },\n")
        }
        json = StringConcat(json, "  ]\n}\n")
        
        ReturnValue(json)
    }
}

// Example usage and test
Function.HDL.TestCompiler {
    Body: {
        // Sample HDL code
        hdl_source = "
Module.SimpleALU {
    Input: (a: Signal[8], b: Signal[8], op: Signal[2])
    Output: (result: Signal[8])
    
    Register.result_reg: Signal[8] = 0
    
    Sequential.Rising(clk) {
        result_reg = alu_output
    }
    
    Combinational {
        ChoosePath op {
            CaseOption 0: alu_output = Add(a, b)
            CaseOption 1: alu_output = BitwiseAnd(a, b)
            CaseOption 2: alu_output = BitwiseOr(a, b)
        }
    }
    
    Assign result = result_reg
}"
        
        // Compile to netlist
        netlist = HDL.CompileToNetlist(hdl_source)
        
        PrintMessage("Generated Netlist:")
        PrintMessage(netlist)
        
        // Would output:
        // {
        //   "module": "SimpleALU",
        //   "ports": {
        //     "inputs": ["a[7:0]", "b[7:0]", "op[1:0]", "clk"],
        //     "outputs": ["result[7:0]"]
        //   },
        //   "cells": [
        //     {
        //       "name": "result_reg_dff",
        //       "type": "DFF8",
        //       "connections": {
        //         "CLK": "clk",
        //         "D": "alu_output",
        //         "Q": "result"
        //       }
        //     },
        //     {
        //       "name": "g0_add",
        //       "type": "ADD8",
        //       "connections": {
        //         "A": "a",
        //         "B": "b",
        //         "Y": "add_result"
        //       }
        //     },
        //     {
        //       "name": "g1_and",
        //       "type": "AND8",
        //       "connections": {
        //         "A": "a",
        //         "B": "b",
        //         "Y": "and_result"
        //       }
        //     },
        //     {
        //       "name": "g2_mux",
        //       "type": "MUX8_3to1",
        //       "connections": {
        //         "SEL": "op",
        //         "I0": "add_result",
        //         "I1": "and_result",
        //         "I2": "or_result",
        //         "Y": "alu_output"
        //       }
        //     }
        //   ]
        // }
    }
}

// Helper to create AST nodes
Function.CreateNode {
    Input: (type: Integer, value: Text)
    Output: Node
    Body: {
        node = HashCreate(2)
        HashSet(node, "type", type)
        HashSet(node, "value", value)
        ReturnValue(node)
    }
}