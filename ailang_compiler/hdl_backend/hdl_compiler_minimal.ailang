// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// hdl_compiler_minimal.ailang - Minimal HDL compiler in AILang
// Using ONLY built-in functions, no user-defined function calls

// AST node types for HDL
GlobalVar HDL_MODULE = 1
GlobalVar HDL_INPUT = 2
GlobalVar HDL_OUTPUT = 3
GlobalVar HDL_REGISTER = 4
GlobalVar HDL_WIRE = 5
GlobalVar HDL_SEQUENTIAL = 6
GlobalVar HDL_COMBINATIONAL = 7
GlobalVar HDL_ASSIGN = 8
GlobalVar HDL_OPERATION = 9

// Gate types in netlist
GlobalVar GATE_AND = 1
GlobalVar GATE_OR = 2
GlobalVar GATE_XOR = 3
GlobalVar GATE_NOT = 4
GlobalVar GATE_ADD = 5
GlobalVar GATE_DFF = 6
GlobalVar GATE_MUX = 7

// Test execution - all inline
PrintMessage("=== AILang HDL Compiler v0.1 ===")

// Create test HDL source
test_source = ArrayCreate(200)
pos = 0

// Write "Module Test {"
ArraySet(test_source, pos, 77)  // 'M'
pos = Add(pos, 1)
ArraySet(test_source, pos, 111) // 'o'
pos = Add(pos, 1)
ArraySet(test_source, pos, 100) // 'd'
pos = Add(pos, 1)
ArraySet(test_source, pos, 117) // 'u'
pos = Add(pos, 1)
ArraySet(test_source, pos, 108) // 'l'
pos = Add(pos, 1)
ArraySet(test_source, pos, 101) // 'e'
pos = Add(pos, 1)
ArraySet(test_source, pos, 32)  // ' '
pos = Add(pos, 1)
ArraySet(test_source, pos, 84)  // 'T'
pos = Add(pos, 1)
ArraySet(test_source, pos, 101) // 'e'
pos = Add(pos, 1)
ArraySet(test_source, pos, 115) // 's'
pos = Add(pos, 1)
ArraySet(test_source, pos, 116) // 't'
pos = Add(pos, 1)
ArraySet(test_source, pos, 32)  // ' '
pos = Add(pos, 1)
ArraySet(test_source, pos, 123) // '{'
pos = Add(pos, 1)
ArraySet(test_source, pos, 32)  // ' '
pos = Add(pos, 1)

// Write "Register a"
ArraySet(test_source, pos, 82)  // 'R'
pos = Add(pos, 1)
ArraySet(test_source, pos, 101) // 'e'
pos = Add(pos, 1)
ArraySet(test_source, pos, 103) // 'g'
pos = Add(pos, 1)
ArraySet(test_source, pos, 105) // 'i'
pos = Add(pos, 1)
ArraySet(test_source, pos, 115) // 's'
pos = Add(pos, 1)
ArraySet(test_source, pos, 116) // 't'
pos = Add(pos, 1)
ArraySet(test_source, pos, 101) // 'e'
pos = Add(pos, 1)
ArraySet(test_source, pos, 114) // 'r'
pos = Add(pos, 1)
ArraySet(test_source, pos, 32)  // ' '
pos = Add(pos, 1)
ArraySet(test_source, pos, 97)  // 'a'
pos = Add(pos, 1)
ArraySet(test_source, pos, 0)   // null terminator

PrintMessage("Test source created: Module Test { Register a")

// Find what's in the source (inline to avoid function calls)
has_module = 0
has_register = 0

// Check for Module pattern inline
mod_pos = -1
pos = 0
WhileLoop LessThan(pos, 100) {
    char = ArrayGet(test_source, pos)
    IfCondition EqualTo(char, 0) ThenBlock {
        BreakLoop
    }
    // Check for 'M'
    IfCondition EqualTo(char, 77) ThenBlock {
        // Check if full "Module" matches
        IfCondition EqualTo(ArrayGet(test_source, Add(pos, 1)), 111) ThenBlock {  // 'o'
            IfCondition EqualTo(ArrayGet(test_source, Add(pos, 2)), 100) ThenBlock {  // 'd'
                IfCondition EqualTo(ArrayGet(test_source, Add(pos, 3)), 117) ThenBlock {  // 'u'
                    IfCondition EqualTo(ArrayGet(test_source, Add(pos, 4)), 108) ThenBlock {  // 'l'
                        IfCondition EqualTo(ArrayGet(test_source, Add(pos, 5)), 101) ThenBlock {  // 'e'
                            mod_pos = pos
                            has_module = 1
                            PrintMessage("Found Module keyword")
                            BreakLoop
                        }
                    }
                }
            }
        }
    }
    pos = Add(pos, 1)
}

// Check for Register pattern inline
reg_pos = -1
pos = 0
WhileLoop LessThan(pos, 100) {
    char = ArrayGet(test_source, pos)
    IfCondition EqualTo(char, 0) ThenBlock {
        BreakLoop
    }
    // Check for 'R'
    IfCondition EqualTo(char, 82) ThenBlock {
        // Check if full "Register" matches
        IfCondition EqualTo(ArrayGet(test_source, Add(pos, 1)), 101) ThenBlock {  // 'e'
            IfCondition EqualTo(ArrayGet(test_source, Add(pos, 2)), 103) ThenBlock {  // 'g'
                IfCondition EqualTo(ArrayGet(test_source, Add(pos, 3)), 105) ThenBlock {  // 'i'
                    IfCondition EqualTo(ArrayGet(test_source, Add(pos, 4)), 115) ThenBlock {  // 's'
                        IfCondition EqualTo(ArrayGet(test_source, Add(pos, 5)), 116) ThenBlock {  // 't'
                            IfCondition EqualTo(ArrayGet(test_source, Add(pos, 6)), 101) ThenBlock {  // 'e'
                                IfCondition EqualTo(ArrayGet(test_source, Add(pos, 7)), 114) ThenBlock {  // 'r'
                                    reg_pos = pos
                                    has_register = 1
                                    PrintMessage("Found Register keyword")
                                    BreakLoop
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    pos = Add(pos, 1)
}

// Generate and show netlist directly inline
PrintMessage("")
PrintMessage("Generated netlist output:")
PrintMessage("// Netlist generated by AILang HDL")
IfCondition has_module ThenBlock {
    PrintMessage("module test")
}
IfCondition has_register ThenBlock {
    PrintMessage("  DFF reg_a")
}
IfCondition has_module ThenBlock {
    PrintMessage("endmodule")
}

PrintMessage("")
PrintMessage("=== Compilation Complete ===")
PrintMessage("This demo shows AILang can:")
PrintMessage("1. Parse HDL keywords")
PrintMessage("2. Generate basic netlists")
PrintMessage("3. Map Register -> DFF gates")