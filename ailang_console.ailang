// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.

// ailang_console.ailang
// TUI Console Application for AILang Self-Hosting Compiler
// Compiles AILang source to native x86-64 ELF executables

// =============================================================================
// LIBRARY IMPORTS
// =============================================================================

// Default provided libraries
LibraryImport.XArrays

// Frontend - Lexer
LibraryImport.Compiler.Frontend.Lexer.CLexerMain

// Frontend - Parser
LibraryImport.Compiler.Frontend.Parser.CParserMain

// Frontend - AST
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes
LibraryImport.Compiler.Frontend.AST.CASTDebug
LibraryImport.Compiler.Frontend.AST.CSemanticCore

// Compile Layer - Main dispatcher and modules
LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.Compile.Modules.CCompileArith
LibraryImport.Compiler.Compile.Modules.CCompileIO
LibraryImport.Compiler.Compile.Modules.CCompileSystem
LibraryImport.Compiler.Compile.Modules.CCompileStmt

// CodeEmit Layer - Core and X86 backend
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys

// Output Layer - ELF generation
LibraryImport.Compiler.Output.CELFTypes
LibraryImport.Compiler.Output.CELFBuilder
LibraryImport.Compiler.Output.COutput

// =============================================================================
// CONSOLE STATE
// =============================================================================
FixedPool.Console {
    "running": Initialize=1, CanChange=True
    "debug_mode": Initialize=0, CanChange=True
    "show_tokens": Initialize=0, CanChange=True
    "show_ast": Initialize=0, CanChange=True
    "show_asm": Initialize=0, CanChange=True
    "show_bytes": Initialize=0, CanChange=True
    "input_buf": Initialize=0, CanChange=True
    "input_size": Initialize=8192
    "line_buf": Initialize=0, CanChange=True
    "line_size": Initialize=1024
    "multiline_buf": Initialize=0, CanChange=True
    "multiline_pos": Initialize=0, CanChange=True
    "last_output": Initialize=0, CanChange=True
    "last_output_len": Initialize=0, CanChange=True
    "last_binary": Initialize=0, CanChange=True
    "last_binary_len": Initialize=0, CanChange=True
    "compile_count": Initialize=0, CanChange=True
    "error_count": Initialize=0, CanChange=True
    "output_file": Initialize="a.x", CanChange=True
}

// =============================================================================
// COMPILER STATE (for console tracking)
// =============================================================================
FixedPool.CompilerState {
    "source": Initialize=0, CanChange=True
    "source_len": Initialize=0, CanChange=True
    "tokens": Initialize=0, CanChange=True
    "token_count": Initialize=0, CanChange=True
    "ast": Initialize=0, CanChange=True
    "last_code_size": Initialize=0, CanChange=True
    "last_data_size": Initialize=0, CanChange=True
    "error": Initialize=0, CanChange=True
    "error_line": Initialize=0, CanChange=True
    "error_msg": Initialize=0, CanChange=True
}

// =============================================================================
// FILE I/O USING SYSCALLS
// =============================================================================
Function.IO_Open {
    Input: filename: Address
    Input: flags: Integer
    Output: Integer
    Body: {
        fd = SystemCall(2, filename, flags, 420)
        ReturnValue(fd)
    }
}

Function.IO_Close {
    Input: fd: Integer
    Output: Integer
    Body: {
        result = SystemCall(3, fd)
        ReturnValue(result)
    }
}

Function.IO_Read {
    Input: fd: Integer
    Input: buffer: Address
    Input: count: Integer
    Output: Integer
    Body: {
        bytes_read = SystemCall(0, fd, buffer, count)
        ReturnValue(bytes_read)
    }
}

Function.IO_Write {
    Input: fd: Integer
    Input: buffer: Address
    Input: count: Integer
    Output: Integer
    Body: {
        bytes_written = SystemCall(1, fd, buffer, count)
        ReturnValue(bytes_written)
    }
}

Function.IO_GetFileSize {
    Input: fd: Integer
    Output: Integer
    Body: {
        size = SystemCall(8, fd, 0, 2)
        SystemCall(8, fd, 0, 0)
        ReturnValue(size)
    }
}

// =============================================================================
// CONSOLE I/O
// =============================================================================
Function.Console_GetLine {
    Output: Address
    Body: {
        bytes_read = SystemCall(0, 0, Console.line_buf, Console.line_size)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition GreaterThan(bytes_read, 0) ThenBlock: {
            last_pos = Subtract(bytes_read, 1)
            last_char = GetByte(Console.line_buf, last_pos)
            IfCondition EqualTo(last_char, 10) ThenBlock: {
                SetByte(Console.line_buf, last_pos, 0)
            } ElseBlock: {
                SetByte(Console.line_buf, bytes_read, 0)
            }
        }
        
        ReturnValue(Console.line_buf)
    }
}

Function.Console_PrintChr {
    Input: ch: Integer
    Body: {
        SetByte(Console.line_buf, 0, ch)
        SystemCall(1, 1, Console.line_buf, 1)
    }
}

// =============================================================================
// CONSOLE INITIALIZATION
// =============================================================================
Function.Console_Init {
    Body: {
        Console.input_buf = Allocate(Console.input_size)
        Console.line_buf = Allocate(Console.line_size)
        Console.multiline_buf = Allocate(Console.input_size)
        Console.multiline_pos = 0
        Console.running = 1
        Console.debug_mode = 0
        Console.show_tokens = 0
        Console.show_ast = 0
        Console.show_asm = 0
        Console.show_bytes = 0
        Console.compile_count = 0
        Console.error_count = 0
    }
}

Function.Console_Cleanup {
    Body: {
        IfCondition NotEqual(Console.input_buf, 0) ThenBlock: {
            Deallocate(Console.input_buf, Console.input_size)
        }
        IfCondition NotEqual(Console.line_buf, 0) ThenBlock: {
            Deallocate(Console.line_buf, Console.line_size)
        }
        IfCondition NotEqual(Console.multiline_buf, 0) ThenBlock: {
            Deallocate(Console.multiline_buf, Console.input_size)
        }
        IfCondition NotEqual(Console.last_output, 0) ThenBlock: {
            Deallocate(Console.last_output, Console.last_output_len)
        }
        IfCondition NotEqual(Console.last_binary, 0) ThenBlock: {
            Deallocate(Console.last_binary, Console.last_binary_len)
        }
    }
}

Function.Console_ShowBanner {
    Body: {
        PrintMessage("\n")
        PrintMessage("==============================================================\n")
        PrintMessage("     AILang Self-Hosting Compiler Console v0.2.0\n")
        PrintMessage("        Written in AILang, Compiling AILang\n")
        PrintMessage("        Backend: x86-64 ELF (CONNECTED)\n")
        PrintMessage("==============================================================\n")
        PrintMessage("  Commands: help, load <file>, compile, build <out>, quit\n")
        PrintMessage("  Target: Linux x86-64 ELF executables\n")
        PrintMessage("==============================================================\n")
        PrintMessage("\n")
    }
}

Function.Console_ShowHelp {
    Body: {
        PrintMessage("\n")
        PrintMessage("COMPILATION COMMANDS:\n")
        PrintMessage("  load <file.ailang>  - Load AILang source file\n")
        PrintMessage("  compile             - Compile loaded source (show output)\n")
        PrintMessage("  build <out>         - Compile and write executable\n")
        PrintMessage("  run                 - Compile and execute immediately\n")
        PrintMessage("  output <name>       - Set default output filename\n")
        PrintMessage("\n")
        PrintMessage("DEBUG COMMANDS:\n")
        PrintMessage("  tokens on/off       - Show lexer token output\n")
        PrintMessage("  ast on/off          - Show AST structure\n")
        PrintMessage("  asm on/off          - Show generated code hex\n")
        PrintMessage("  bytes on/off        - Show full hex dump\n")
        PrintMessage("  debug on/off        - Enable all debug output\n")
        PrintMessage("  status              - Show current settings\n")
        PrintMessage("\n")
        PrintMessage("GENERAL COMMANDS:\n")
        PrintMessage("  help                - Show this help\n")
        PrintMessage("  example             - Show example AILang code\n")
        PrintMessage("  clear               - Clear input buffer\n")
        PrintMessage("  stats               - Show compilation statistics\n")
        PrintMessage("  quit / exit         - Exit console\n")
        PrintMessage("\n")
        PrintMessage("PARSER COMMANDS:\n")
        PrintMessage("  parse               - Parse only (detailed output)\n")
        PrintMessage("  parseexpr <expr>    - Parse single expression\n")
        PrintMessage("\n")
    }
}

Function.Console_ShowExample {
    Body: {
        PrintMessage("\n")
        PrintMessage("EXAMPLE AILANG CODE:\n")
        PrintMessage("----------------------------------------\n")
        PrintMessage("// Simple factorial function\n")
        PrintMessage("Function.Math.Factorial {\n")
        PrintMessage("    Input: n: Integer\n")
        PrintMessage("    Output: Integer\n")
        PrintMessage("    Body: {\n")
        PrintMessage("        IfCondition LessEqual(n, 1) ThenBlock: {\n")
        PrintMessage("            ReturnValue(1)\n")
        PrintMessage("        }\n")
        PrintMessage("        result = Multiply(n, Math.Factorial(Subtract(n, 1)))\n")
        PrintMessage("        ReturnValue(result)\n")
        PrintMessage("    }\n")
        PrintMessage("}\n")
        PrintMessage("----------------------------------------\n")
        PrintMessage("\n")
    }
}

Function.Console_ShowStatus {
    Body: {
        PrintMessage("\n")
        PrintMessage("CURRENT SETTINGS:\n")
        PrintMessage("  Debug mode:    ")
        IfCondition EqualTo(Console.debug_mode, 1) ThenBlock: {
            PrintMessage("ON\n")
        } ElseBlock: {
            PrintMessage("OFF\n")
        }
        PrintMessage("  Show tokens:   ")
        IfCondition EqualTo(Console.show_tokens, 1) ThenBlock: {
            PrintMessage("ON\n")
        } ElseBlock: {
            PrintMessage("OFF\n")
        }
        PrintMessage("  Show AST:      ")
        IfCondition EqualTo(Console.show_ast, 1) ThenBlock: {
            PrintMessage("ON\n")
        } ElseBlock: {
            PrintMessage("OFF\n")
        }
        PrintMessage("  Show ASM:      ")
        IfCondition EqualTo(Console.show_asm, 1) ThenBlock: {
            PrintMessage("ON\n")
        } ElseBlock: {
            PrintMessage("OFF\n")
        }
        PrintMessage("  Show bytes:    ")
        IfCondition EqualTo(Console.show_bytes, 1) ThenBlock: {
            PrintMessage("ON\n")
        } ElseBlock: {
            PrintMessage("OFF\n")
        }
        PrintMessage("  Output file:   ")
        PrintMessage(Console.output_file)
        PrintMessage("\n")
        PrintMessage("\n")
        PrintMessage("LOADED SOURCE:\n")
        IfCondition NotEqual(CompilerState.source, 0) ThenBlock: {
            PrintMessage("  Size: ")
            PrintNumber(CompilerState.source_len)
            PrintMessage(" bytes\n")
        } ElseBlock: {
            PrintMessage("  (none)\n")
        }
        PrintMessage("\n")
    }
}

Function.Console_ShowStats {
    Body: {
        PrintMessage("\n")
        PrintMessage("COMPILATION STATISTICS:\n")
        PrintMessage("  Total compiles:  ")
        PrintNumber(Console.compile_count)
        PrintMessage("\n")
        PrintMessage("  Total errors:    ")
        PrintNumber(Console.error_count)
        PrintMessage("\n")
        IfCondition NotEqual(CompilerState.token_count, 0) ThenBlock: {
            PrintMessage("  Last token count: ")
            PrintNumber(CompilerState.token_count)
            PrintMessage("\n")
        }
        IfCondition NotEqual(CompilerState.last_code_size, 0) ThenBlock: {
            PrintMessage("  Last code size:   ")
            PrintNumber(CompilerState.last_code_size)
            PrintMessage(" bytes\n")
        }
        IfCondition NotEqual(CompilerState.last_data_size, 0) ThenBlock: {
            PrintMessage("  Last data size:   ")
            PrintNumber(CompilerState.last_data_size)
            PrintMessage(" bytes\n")
        }
        PrintMessage("\n")
        IfCondition NotEqual(CompilerState.ast, 0) ThenBlock: {
            PrintMessage("  AST nodes created:  ")
            PrintNumber(ASTState.node_count)
            PrintMessage("\n")
            
            decl_count = AST_GetChildCount(CompilerState.ast)
            PrintMessage("  Declarations:       ")
            PrintNumber(decl_count)
            PrintMessage("\n")
        }
    }
}

// =============================================================================
// STRING UTILITIES
// =============================================================================
Function.Str_StartsWith {
    Input: str: Address
    Input: prefix: Address
    Output: Integer
    Body: {
        prefix_len = StringLength(prefix)
        str_len = StringLength(str)
        
        IfCondition LessThan(str_len, prefix_len) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, prefix_len) {
            c1 = GetByte(str, i)
            c2 = GetByte(prefix, i)
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

Function.Str_Trim {
    Input: str: Address
    Output: Address
    Body: {
        len = StringLength(str)
        
        IfCondition EqualTo(len, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        start = 0
        WhileLoop LessThan(start, len) {
            c = GetByte(str, start)
            is_space = Or(EqualTo(c, 32), EqualTo(c, 9))
            is_newline = Or(EqualTo(c, 10), EqualTo(c, 13))
            IfCondition Not(Or(is_space, is_newline)) ThenBlock: {
                BreakLoop
            }
            start = Add(start, 1)
        }
        
        end_pos = Subtract(len, 1)
        WhileLoop GreaterEqual(end_pos, start) {
            c = GetByte(str, end_pos)
            is_space = Or(EqualTo(c, 32), EqualTo(c, 9))
            is_newline = Or(EqualTo(c, 10), EqualTo(c, 13))
            IfCondition Not(Or(is_space, is_newline)) ThenBlock: {
                BreakLoop
            }
            end_pos = Subtract(end_pos, 1)
        }
        
        new_len = Add(Subtract(end_pos, start), 1)
        IfCondition LessEqual(new_len, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        result = Allocate(Add(new_len, 1))
        i = 0
        WhileLoop LessThan(i, new_len) {
            c = GetByte(str, Add(start, i))
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, new_len, 0)
        
        ReturnValue(result)
    }
}

Function.Str_GetArg {
    Input: str: Address
    Input: start_pos: Integer
    Output: Address
    Body: {
        len = StringLength(str)
        arg_len = Subtract(len, start_pos)
        
        IfCondition LessEqual(arg_len, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        result = Allocate(Add(arg_len, 1))
        i = 0
        WhileLoop LessThan(i, arg_len) {
            c = GetByte(str, Add(start_pos, i))
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, arg_len, 0)
        
        trimmed = Str_Trim(result)
        Deallocate(result, Add(arg_len, 1))
        ReturnValue(trimmed)
    }
}

// =============================================================================
// HEX DUMP UTILITY
// =============================================================================
Function.Util_HexDump {
    Input: buffer: Address
    Input: size: Integer
    Input: bytes_per_line: Integer
    Body: {
        hex_chars = "0123456789ABCDEF"
        
        offset = 0
        WhileLoop LessThan(offset, size) {
            PrintNumber(offset)
            PrintMessage(": ")
            
            i = 0
            WhileLoop LessThan(i, bytes_per_line) {
                pos = Add(offset, i)
                IfCondition LessThan(pos, size) ThenBlock: {
                    b = GetByte(buffer, pos)
                    hi = Divide(b, 16)
                    lo = Modulo(b, 16)
                    hi_char = GetByte(hex_chars, hi)
                    lo_char = GetByte(hex_chars, lo)
                    Console_PrintChr(hi_char)
                    Console_PrintChr(lo_char)
                    PrintMessage(" ")
                } ElseBlock: {
                    PrintMessage("   ")
                }
                i = Add(i, 1)
            }
            
            PrintMessage(" |")
            
            i = 0
            WhileLoop LessThan(i, bytes_per_line) {
                pos = Add(offset, i)
                IfCondition LessThan(pos, size) ThenBlock: {
                    b = GetByte(buffer, pos)
                    IfCondition And(GreaterEqual(b, 32), LessThan(b, 127)) ThenBlock: {
                        Console_PrintChr(b)
                    } ElseBlock: {
                        PrintMessage(".")
                    }
                }
                i = Add(i, 1)
            }
            
            PrintMessage("|\n")
            offset = Add(offset, bytes_per_line)
        }
    }
}

// =============================================================================
// FULL COMPILATION PIPELINE
// Source -> Lex -> Parse -> Compile -> Emit -> (optionally write ELF)
// =============================================================================
Function.Compile_Source {
    Input: source: Address
    Input: write_output: Integer
    Input: output_file: Address
    Output: Integer
    Body: {
        len = StringLength(source)
        
        IfCondition LessEqual(len, 0) ThenBlock: {
            PrintMessage("ERROR: Empty source\n")
            Console.error_count = Add(Console.error_count, 1)
            ReturnValue(0)
        }
        
        PrintMessage("\n")
        PrintMessage("========================================\n")
        PrintMessage("       COMPILATION STARTED\n")
        PrintMessage("========================================\n")
        
        CompilerState.source = source
        CompilerState.source_len = len
        
        PrintMessage("Source: ")
        PrintNumber(len)
        PrintMessage(" bytes\n\n")
        
        // =============================================
        // Phase 1: Lexical Analysis
        // =============================================
        PrintMessage("Phase 1: Lexical Analysis\n")
        PrintMessage("----------------------------------------\n")
        
        Lex_Init(source, len)
        Lex_Tokenize()
        
        CompilerState.token_count = Lex.token_count
        
        IfCondition EqualTo(Lex.error, 1) ThenBlock: {
            PrintMessage("\n!!! LEXER ERROR !!!\n")
            PrintMessage("  Line: ")
            PrintNumber(Lex.error_line)
            PrintMessage(", Column: ")
            PrintNumber(Lex.error_col)
            PrintMessage("\n")
            Console.error_count = Add(Console.error_count, 1)
            Lex_Free()
            ReturnValue(0)
        }
        
        PrintMessage("  Tokens generated: ")
        PrintNumber(CompilerState.token_count)
        PrintMessage("\n")
        
        IfCondition EqualTo(Console.show_tokens, 1) ThenBlock: {
            PrintMessage("\n")
            Lex_DumpTokens()
        }
        
        // =============================================
        // Phase 2: Parsing
        // =============================================
        PrintMessage("\nPhase 2: Parsing\n")
        PrintMessage("----------------------------------------\n")
        
        parse_result = Parse_Init(CompilerState.token_count)
        
        IfCondition EqualTo(parse_result, 0) ThenBlock: {
            PrintMessage("  ERROR: Failed to initialize parser\n")
            Console.error_count = Add(Console.error_count, 1)
            Lex_Free()
            ReturnValue(0)
        }
        
        ast = Parse_Program()
        CompilerState.ast = ast
        
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            PrintMessage("\n!!! PARSER ERROR !!!\n")
            PrintMessage("  Line: ")
            PrintNumber(PParser.p_error_line)
            PrintMessage(", Column: ")
            PrintNumber(PParser.p_error_col)
            PrintMessage("\n")
            PrintMessage("  Message: ")
            IfCondition NotEqual(PParser.p_error_msg, 0) ThenBlock: {
                PrintMessage(PParser.p_error_msg)
            }
            PrintMessage("\n")
            Console.error_count = Add(Console.error_count, 1)
            Parse_Cleanup(0)
            Lex_Free()
            ReturnValue(0)
        }
        
        decl_count = AST_GetChildCount(ast)
        PrintMessage("  Declarations parsed: ")
        PrintNumber(decl_count)
        PrintMessage("\n")
        PrintMessage("  Total AST nodes: ")
        PrintNumber(ASTState.node_count)
        PrintMessage("\n")
        
        IfCondition EqualTo(Console.show_ast, 1) ThenBlock: {
            PrintMessage("\n")
            AST_Dump(ast)
        }
        
        // =============================================
        // Phase 3: Semantic Analysis
        // =============================================
        PrintMessage("\nPhase 3: Semantic Analysis\n")
        PrintMessage("----------------------------------------\n")
        Sem_Init()
        result = Sem_Analyze(CompilerState.ast)
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("  Semantic analysis FAILED\n")
            Console.error_count = Add(Console.error_count, 1)
            Parse_Cleanup(1)
            Lex_Free()
            ReturnValue(0)
        }
        PrintMessage("  Semantic analysis passed\n")
        
        // =============================================
        // Phase 4: Code Generation
        // =============================================
        PrintMessage("\nPhase 4: Code Generation\n")
        PrintMessage("----------------------------------------\n")
        
        // Initialize the emit layer
        Emit_Init()
        
        // Initialize the compile layer
        Compile_Init()
        
        // Create _start label and define entry point
        start_label = Emit_CreateLabel()
        Emit_DefineLabel(start_label)
        
        // Compile the program (or expression for single-line input)
        IfCondition EqualTo(decl_count, 0) ThenBlock: {
            // Single expression - compile as expression
            result = Compile_Expression(ast)
        } ElseBlock: {
            // Full program
            result = Compile_Program(ast)
        }
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("  ERROR: Code generation failed\n")
            IfCondition EqualTo(Compile.error, 1) ThenBlock: {
                PrintMessage("  Message: ")
                IfCondition NotEqual(Compile.error_msg, 0) ThenBlock: {
                    PrintMessage(Compile.error_msg)
                }
                PrintMessage("\n")
            }
            Console.error_count = Add(Console.error_count, 1)
            Compile_Free()
            Parse_Cleanup(1)
            Lex_Free()
            ReturnValue(0)
        }
        
        // Generate exit syscall
        X86_MovRaxImm64(60)      // syscall: exit
        X86_XorRdiRdi()          // exit code 0
        X86_SysInstr()
        
        // Resolve fixups
        Emit_ResolveFixups()
        
        // Apply data relocations for string addresses
        Emit_ApplyDataRelocations()
        
        PrintMessage("  Code size: ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("  Data size: ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        
        CompilerState.last_code_size = Emit.code_size
        CompilerState.last_data_size = Emit.data_size
        
        IfCondition EqualTo(Console.show_asm, 1) ThenBlock: {
            PrintMessage("\n[CODE DUMP]\n")
            Emit_DumpCode(64)
        }
        
        IfCondition EqualTo(Console.show_bytes, 1) ThenBlock: {
            PrintMessage("\n[FULL HEX DUMP]\n")
            Util_HexDump(Emit.code, Emit.code_size, 16)
        }
        
        // =============================================
        // Phase 5: ELF Output (if requested)
        // =============================================
        IfCondition EqualTo(write_output, 1) ThenBlock: {
            PrintMessage("\nPhase 5: ELF Output\n")
            PrintMessage("----------------------------------------\n")
            
            result = Output_BuildAndWrite(output_file)
            
            IfCondition EqualTo(result, 0) ThenBlock: {
                PrintMessage("  ERROR: ELF generation failed\n")
                Console.error_count = Add(Console.error_count, 1)
                Compile_Free()
                Parse_Cleanup(1)
                Lex_Free()
                ReturnValue(0)
            }
            
            PrintMessage("  Executable written: ")
            PrintMessage(output_file)
            PrintMessage("\n")
        } ElseBlock: {
            PrintMessage("\nPhase 5: ELF Output (skipped - use 'build' to write)\n")
        }
        
        PrintMessage("\n")
        PrintMessage("========================================\n")
        PrintMessage("       COMPILATION COMPLETE\n")
        PrintMessage("========================================\n")
        PrintMessage("\n")
        
        // Cleanup
        Compile_Free()
        Parse_Cleanup(1)
        Lex_Free()
        Console.compile_count = Add(Console.compile_count, 1)
        ReturnValue(1)
    }
}

// =============================================================================
// FILE OPERATIONS
// =============================================================================
Function.Console_LoadFile {
    Input: filename: Address
    Body: {
        PrintMessage("\nLoading: ")
        PrintString(filename)
        PrintMessage("\n")
        
        fd = IO_Open(filename, 0)
        IfCondition LessThan(fd, 0) ThenBlock: {
            PrintMessage("ERROR: Could not open file (errno: ")
            err_code = Subtract(0, fd)
            PrintNumber(err_code)
            PrintMessage(")\n")
            Console.error_count = Add(Console.error_count, 1)
            ReturnValue(0)
        }
        
        file_size = IO_GetFileSize(fd)
        IfCondition LessEqual(file_size, 0) ThenBlock: {
            PrintMessage("ERROR: Empty file or size error\n")
            IO_Close(fd)
            Console.error_count = Add(Console.error_count, 1)
            ReturnValue(0)
        }
        
        PrintMessage("File size: ")
        PrintNumber(file_size)
        PrintMessage(" bytes\n")
        
        IfCondition NotEqual(CompilerState.source, 0) ThenBlock: {
            Deallocate(CompilerState.source, CompilerState.source_len)
        }
        
        buffer = Allocate(Add(file_size, 1))
        bytes_read = IO_Read(fd, buffer, file_size)
        IO_Close(fd)
        
        IfCondition LessEqual(bytes_read, 0) ThenBlock: {
            PrintMessage("ERROR: Failed to read file\n")
            Deallocate(buffer, Add(file_size, 1))
            Console.error_count = Add(Console.error_count, 1)
            ReturnValue(0)
        }
        
        SetByte(buffer, bytes_read, 0)
        
        CompilerState.source = buffer
        CompilerState.source_len = bytes_read
        
        PrintMessage("Loaded ")
        PrintNumber(bytes_read)
        PrintMessage(" bytes successfully\n")
        PrintMessage("Use 'compile' to compile, or 'build <out>' to create executable\n")
    }
}

Function.Console_BuildFile {
    Input: output_name: Address
    Body: {
        IfCondition EqualTo(CompilerState.source, 0) ThenBlock: {
            PrintMessage("ERROR: No source loaded. Use 'load <file>' first.\n")
            ReturnValue(0)
        }
        
        // Compile with output enabled
        Compile_Source(CompilerState.source, 1, output_name)
    }
}

Function.Console_CompileOnly {
    Body: {
        IfCondition EqualTo(CompilerState.source, 0) ThenBlock: {
            PrintMessage("ERROR: No source loaded. Use 'load <file>' first.\n")
            ReturnValue(0)
        }
        
        // Compile without writing output
        Compile_Source(CompilerState.source, 0, "")
    }
}

// =============================================================================
// COMMAND PROCESSING
// =============================================================================
Function.Console_ProcessCmd {
    Input: cmd: Address
    Output: Integer
    Body: {
        trimmed = Str_Trim(cmd)
        trimmed_len = StringLength(trimmed)
        
        IfCondition EqualTo(trimmed_len, 0) ThenBlock: {
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(0)
        }
        
        cmp = StringCompare(trimmed, "quit")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.running = 0
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "exit")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.running = 0
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "help")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console_ShowHelp()
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "clear")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.multiline_pos = 0
            PrintMessage("Buffer cleared.\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "status")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console_ShowStatus()
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "stats")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console_ShowStats()
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "example")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console_ShowExample()
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "compile")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console_CompileOnly()
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "parse")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            IfCondition EqualTo(CompilerState.source, 0) ThenBlock: {
                PrintMessage("ERROR: No source loaded. Use 'load <file>' first.\n")
            } ElseBlock: {
                Console_ParseOnly(CompilerState.source)
            }
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }

        cmp = StringCompare(trimmed, "debug on")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.debug_mode = 1
            Console.show_tokens = 1
            Console.show_ast = 1
            Console.show_asm = 1
            Console.show_bytes = 1
            PrintMessage("Debug mode ON (all output enabled)\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "debug off")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.debug_mode = 0
            Console.show_tokens = 0
            Console.show_ast = 0
            Console.show_asm = 0
            Console.show_bytes = 0
            PrintMessage("Debug mode OFF\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "tokens on")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_tokens = 1
            PrintMessage("Token display ON\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "tokens off")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_tokens = 0
            PrintMessage("Token display OFF\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "ast on")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_ast = 1
            PrintMessage("AST display ON\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "ast off")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_ast = 0
            PrintMessage("AST display OFF\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "asm on")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_asm = 1
            PrintMessage("ASM display ON\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "asm off")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_asm = 0
            PrintMessage("ASM display OFF\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "bytes on")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_bytes = 1
            PrintMessage("Bytes display ON\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        cmp = StringCompare(trimmed, "bytes off")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console.show_bytes = 0
            PrintMessage("Bytes display OFF\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        prefix_cmp = Str_StartsWith(trimmed, "parseexpr ")
        IfCondition EqualTo(prefix_cmp, 1) ThenBlock: {
            expr_start = Add(trimmed, 10)  
            Console_ParseExpr(expr_start)
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }

        starts_load = Str_StartsWith(trimmed, "load ")
        IfCondition EqualTo(starts_load, 1) ThenBlock: {
            filename = Str_GetArg(trimmed, 5)
            Console_LoadFile(filename)
            Deallocate(filename, 0)
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        

        cmp = StringCompare(trimmed, "build")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Console_BuildFile(Console.output_file)
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        starts_build = Str_StartsWith(trimmed, "build ")
        IfCondition EqualTo(starts_build, 1) ThenBlock: {
            output = Str_GetArg(trimmed, 6)
            Console_BuildFile(output)
            Deallocate(output, 0)
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        starts_output = Str_StartsWith(trimmed, "output ")
        IfCondition EqualTo(starts_output, 1) ThenBlock: {
            new_output = Str_GetArg(trimmed, 7)
            Console.output_file = new_output
            PrintMessage("Output file set to: ")
            PrintMessage(new_output)
            PrintMessage("\n")
            Deallocate(trimmed, Add(trimmed_len, 1))
            ReturnValue(1)
        }
        
        Deallocate(trimmed, Add(trimmed_len, 1))
        ReturnValue(0)
    }
}

// =============================================================================
// MULTILINE INPUT HANDLING
// =============================================================================
Function.Console_AppendToBuffer {
    Input: line: Address
    Body: {
        len = StringLength(line)
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(line, i)
            SetByte(Console.multiline_buf, Console.multiline_pos, c)
            Console.multiline_pos = Add(Console.multiline_pos, 1)
            i = Add(i, 1)
        }
        
        SetByte(Console.multiline_buf, Console.multiline_pos, 10)
        Console.multiline_pos = Add(Console.multiline_pos, 1)
        SetByte(Console.multiline_buf, Console.multiline_pos, 0)
    }
}

Function.Console_CountBraces {
    Input: str: Address
    Output: Integer
    Body: {
        len = StringLength(str)
        count = 0
        in_string = 0
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            
            IfCondition EqualTo(c, 34) ThenBlock: {
                in_string = Subtract(1, in_string)
            }
            
            IfCondition EqualTo(in_string, 0) ThenBlock: {
                IfCondition EqualTo(c, 123) ThenBlock: {
                    count = Add(count, 1)
                }
                IfCondition EqualTo(c, 125) ThenBlock: {
                    count = Subtract(count, 1)
                }
            }
            
            i = Add(i, 1)
        }
        
        ReturnValue(count)
    }
}

// =============================================================================
// PARSE ONLY (for testing parser)
// =============================================================================
Function.Console_ParseOnly {
    Input: source: Address
    Body: {
        len = StringLength(source)
        
        IfCondition LessEqual(len, 0) ThenBlock: {
            PrintMessage("ERROR: Empty source\n")
            ReturnValue(0)
        }
        
        PrintMessage("\n")
        PrintMessage("========================================\n")
        PrintMessage("       PARSE ONLY MODE\n")
        PrintMessage("========================================\n")
        
        PrintMessage("\nLexing...\n")
        Lex_Init(source, len)
        Lex_Tokenize()
        
        IfCondition EqualTo(Lex.error, 1) ThenBlock: {
            PrintMessage("Lexer error - cannot parse\n")
            Lex_Free()
            ReturnValue(0)
        }
        
        PrintMessage("  Tokens: ")
        PrintNumber(Lex.token_count)
        PrintMessage("\n")
        
        PrintMessage("\n--- TOKEN STREAM ---\n")
        Lex_DumpTokens()
        
        PrintMessage("\n--- PARSING ---\n")
        
        Parse_Init(Lex.token_count)
        ast = Parse_Program()
        
        PrintMessage("\n--- PARSE RESULTS ---\n")
        
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            PrintMessage("PARSE FAILED!\n")
            PrintMessage("Error at line ")
            PrintNumber(PParser.p_error_line)
            PrintMessage(", col ")
            PrintNumber(PParser.p_error_col)
            PrintMessage(": ")
            IfCondition NotEqual(PParser.p_error_msg, 0) ThenBlock: {
                PrintMessage(PParser.p_error_msg)
            }
            PrintMessage("\n")
        } ElseBlock: {
            PrintMessage("PARSE SUCCEEDED!\n")
        }
        
        Parse_PrintStats()
        
        IfCondition NotEqual(ast, 0) ThenBlock: {
            PrintMessage("\n--- AST DUMP ---\n")
            AST_Dump(ast)
        }
        
        PrintMessage("\n========================================\n")
        
        Parse_Cleanup(1)
        Lex_Free()
    }
}

// =============================================================================
// PARSE EXPRESSION (REPL testing)
// =============================================================================
Function.Console_ParseExpr {
    Input: expr_source: Address
    Body: {
        len = StringLength(expr_source)
        
        IfCondition LessEqual(len, 0) ThenBlock: {
            PrintMessage("ERROR: Empty expression\n")
            ReturnValue(0)
        }
        
        PrintMessage("\nParsing expression: \"")
        PrintMessage(expr_source)
        PrintMessage("\"\n\n")
        
        Lex_Init(expr_source, len)
        Lex_Tokenize()
        
        IfCondition EqualTo(Lex.error, 1) ThenBlock: {
            PrintMessage("Lexer error\n")
            Lex_Free()
            ReturnValue(0)
        }
        
        PrintMessage("Tokens: ")
        PrintNumber(Lex.token_count)
        PrintMessage("\n")
        Lex_DumpTokens()
        
        PrintMessage("\nParsing as expression...\n")
        
        expr = Parse_SingleExpression(Lex.token_count)
        
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            PrintMessage("Parse error: ")
            IfCondition NotEqual(PParser.p_error_msg, 0) ThenBlock: {
                PrintMessage(PParser.p_error_msg)
            }
            PrintMessage("\n")
        } ElseBlock: {
            PrintMessage("Success!\n")
            IfCondition NotEqual(expr, 0) ThenBlock: {
                PrintMessage("\nExpression AST:\n")
                AST_PrintTree(expr, 0)
            }
        }
        
        Parse_Cleanup(1)
        Lex_Free()
    }
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================
SubRoutine.ConsoleMain {
    Console_Init()
    Console_ShowBanner()
    
    brace_depth = 0
    in_multiline = 0
    
    WhileLoop EqualTo(Console.running, 1) {
        IfCondition EqualTo(in_multiline, 0) ThenBlock: {
            PrintMessage("ailang> ")
        } ElseBlock: {
            PrintMessage("   ...> ")
        }
        
        line = Console_GetLine()
        
        IfCondition EqualTo(line, 0) ThenBlock: {
            Console.running = 0
            ContinueLoop
        }
        
        IfCondition EqualTo(in_multiline, 0) ThenBlock: {
            is_cmd = Console_ProcessCmd(line)
            IfCondition EqualTo(is_cmd, 1) ThenBlock: {
                ContinueLoop
            }
        }
        
        starts_func = Str_StartsWith(line, "Function.")
        starts_sub = Str_StartsWith(line, "SubRoutine.")
        starts_pool = Str_StartsWith(line, "FixedPool.")
        
        is_start = Or(Or(starts_func, starts_sub), starts_pool)
        
        IfCondition EqualTo(is_start, 1) ThenBlock: {
            Console.multiline_pos = 0
            brace_depth = 0
            in_multiline = 1
        }
        
        Console_AppendToBuffer(line)
        
        line_braces = Console_CountBraces(line)
        brace_depth = Add(brace_depth, line_braces)
        
        IfCondition EqualTo(in_multiline, 1) ThenBlock: {
            IfCondition LessEqual(brace_depth, 0) ThenBlock: {
                IfCondition GreaterThan(Console.multiline_pos, 0) ThenBlock: {
                    // Compile with output to default file
                    Compile_Source(Console.multiline_buf, 1, Console.output_file)
                    Console.multiline_pos = 0
                    in_multiline = 0
                    brace_depth = 0
                }
            }
        }
    }
    
    PrintMessage("\n")
    PrintMessage("==============================================================\n")
    PrintMessage("                      Goodbye!\n")
    PrintMessage("        Self-hosting is the future. Build it.\n")
    PrintMessage("==============================================================\n")
    PrintMessage("\n")
    
    Console_Cleanup()
}

RunTask(ConsoleMain)