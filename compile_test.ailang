// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// Copyright (c) 2025 Sean Collins, 2 Paws Machine and Engineering. All rights reserved.
//
// Licensed under the Sean Collins Software License (SCSL). See the LICENSE file in the root directory of this project
// for the full terms and conditions, including restrictions on forking, corporate use, and permissions for private/teaching purposes.


// compile_test.ailang
// Standalone test harness for the AILang Self-Hosting Compiler
// Test Target: PrintNumber(Add(1, 2)) → outputs "3"
// Location: Tests/compile_test.ailang

// =============================================================================
// LIBRARY IMPORTS
// =============================================================================

// Core utilities
LibraryImport.XArrays

// Frontend
LibraryImport.Compiler.Frontend.Lexer.CLexerMain
LibraryImport.Compiler.Frontend.Parser.CParserMain
LibraryImport.Compiler.Frontend.AST.CASTTypes
LibraryImport.Compiler.Frontend.AST.CASTCore
LibraryImport.Compiler.Frontend.AST.CASTNodes
LibraryImport.Compiler.Frontend.AST.CASTDebug

// Compile layer
LibraryImport.Compiler.Compile.CCompileMain
LibraryImport.Compiler.Compile.Modules.CCompileArith
LibraryImport.Compiler.Compile.Modules.CCompileIO
LibraryImport.Compiler.Compile.Modules.CCompileSystem

// CodeEmit layer
LibraryImport.Compiler.CodeEmit.CEmitTypes
LibraryImport.Compiler.CodeEmit.CEmitCore
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Arith
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys



// Output layer
LibraryImport.Compiler.Output.CELFTypes
LibraryImport.Compiler.Output.CELFBuilder
LibraryImport.Compiler.Output.COutput

// =============================================================================
// TEST CONFIGURATION
// =============================================================================
FixedPool.TestConfig {
    "output_file": Initialize="test_output"
    "show_tokens": Initialize=1
    "show_ast": Initialize=1
    "show_code": Initialize=1
    "show_stats": Initialize=1
}

// =============================================================================
// TEST SOURCE CODE
// =============================================================================

// The test source - our target: PrintNumber(Add(1, 2))
Function.Test_GetSource {
    Output: Address
    Body: {
        // Simple test: print the result of 1 + 2
    //    ReturnValue("PrintNumber(Add(1, 2))")
        ReturnValue("PrintMessage(\"Hello AILang!\\n\")")
    }
}

// =============================================================================
// FULL PIPELINE TEST
// Source → Lex → Parse → Compile → Emit → ELF → File
// =============================================================================
Function.Test_FullPipeline {
    Output: Integer
    Body: {
        PrintMessage("\n")
        PrintMessage("╔══════════════════════════════════════════════════════════════╗\n")
        PrintMessage("║     AILang Self-Hosting Compiler - Pipeline Test             ║\n")
        PrintMessage("║     Target: PrintNumber(Add(1, 2)) → outputs '3'             ║\n")
        PrintMessage("╚══════════════════════════════════════════════════════════════╝\n")
        PrintMessage("\n")
        
        // Get test source
        source = Test_GetSource()
        source_len = StringLength(source)
        
        PrintMessage("[TEST] Source: \"")
        PrintMessage(source)
        PrintMessage("\"\n")
        PrintMessage("[TEST] Length: ")
        PrintNumber(source_len)
        PrintMessage(" bytes\n\n")
        
        // ─────────────────────────────────────────────────────────────────
        // PHASE 1: LEXICAL ANALYSIS
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("┌─────────────────────────────────────────────────────────────┐\n")
        PrintMessage("│ PHASE 1: LEXICAL ANALYSIS                                   │\n")
        PrintMessage("└─────────────────────────────────────────────────────────────┘\n")
        
        Lex_Init(source, source_len)
        Lex_Tokenize()
        
        IfCondition EqualTo(Lex.error, 1) ThenBlock: {
            PrintMessage("[TEST] FAILED: Lexer error\n")
            Lex_Free()
            ReturnValue(0)
        }
        
        PrintMessage("[LEX] Token count: ")
        PrintNumber(Lex.token_count)
        PrintMessage("\n")
        
        IfCondition EqualTo(TestConfig.show_tokens, 1) ThenBlock: {
            Lex_DumpTokens()
        }
        PrintMessage("\n")
        
        // ─────────────────────────────────────────────────────────────────
        // PHASE 2: PARSING
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("┌─────────────────────────────────────────────────────────────┐\n")
        PrintMessage("│ PHASE 2: PARSING                                            │\n")
        PrintMessage("└─────────────────────────────────────────────────────────────┘\n")
        
        // For a single expression, use Parse_SingleExpression
        ast = Parse_SingleExpression(Lex.token_count)
        
        IfCondition EqualTo(Parse_HasError(), 1) ThenBlock: {
            PrintMessage("[TEST] FAILED: Parser error\n")
            Parse_Cleanup(1)
            Lex_Free()
            ReturnValue(0)
        }
        
        IfCondition EqualTo(ast, 0) ThenBlock: {
            PrintMessage("[TEST] FAILED: No AST generated\n")
            Parse_Cleanup(1)
            Lex_Free()
            ReturnValue(0)
        }
        
        PrintMessage("[PARSE] AST generated successfully\n")
        
        IfCondition EqualTo(TestConfig.show_ast, 1) ThenBlock: {
            PrintMessage("[PARSE] AST Structure:\n")
            AST_PrintTree(ast, 2)
        }
        PrintMessage("\n")
        
        // ─────────────────────────────────────────────────────────────────
        // PHASE 3: CODE GENERATION
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("┌─────────────────────────────────────────────────────────────┐\n")
        PrintMessage("│ PHASE 3: CODE GENERATION                                    │\n")
        PrintMessage("└─────────────────────────────────────────────────────────────┘\n")
        
        // Initialize compiler
        Compile_Init()
        
        // For a standalone expression, we need to wrap it in a program structure
        // Generate: _start label, compile expression, exit syscall
        
        // Create _start label
        start_label = Emit_CreateLabel()
        Emit_DefineLabel(start_label)
        
        // Compile the expression (result will be in RAX)
        result = Compile_Expression(ast)
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("[TEST] FAILED: Compilation error\n")
            Compile_Free()
            Parse_Cleanup(1)
            Lex_Free()
            ReturnValue(0)
        }
        
        IfCondition EqualTo(Compile.error, 1) ThenBlock: {
            PrintMessage("[TEST] FAILED: ")
            PrintMessage(Compile.error_msg)
            PrintMessage("\n")
            Compile_Free()
            Parse_Cleanup(1)
            Lex_Free()
            ReturnValue(0)
        }
        
        // Exit cleanly with code 0
        X86_MovRaxImm64(60)      // syscall: exit
        X86_XorRdiRdi()          // exit code 0
        X86_SysInstr()
        
        // Resolve any fixups
        Emit_ResolveFixups()
        
        PrintMessage("[COMPILE] Code generation complete\n")
        PrintMessage("[COMPILE] Code size: ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("[COMPILE] Data size: ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        
        IfCondition EqualTo(TestConfig.show_code, 1) ThenBlock: {
            Emit_DumpCode(64)
        }
        PrintMessage("\n")
        
        // ─────────────────────────────────────────────────────────────────
        // PHASE 4: ELF GENERATION
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("┌─────────────────────────────────────────────────────────────┐\n")
        PrintMessage("│ PHASE 4: ELF GENERATION                                     │\n")
        PrintMessage("└─────────────────────────────────────────────────────────────┘\n")
        
        // Build and write executable
        result = Output_BuildAndWrite(TestConfig.output_file)
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("[TEST] FAILED: ELF generation error\n")
            Compile_Free()
            Parse_Cleanup(1)
            Lex_Free()
            ReturnValue(0)
        }
        
        // ─────────────────────────────────────────────────────────────────
        // PHASE 5: STATISTICS
        // ─────────────────────────────────────────────────────────────────
        IfCondition EqualTo(TestConfig.show_stats, 1) ThenBlock: {
            PrintMessage("┌─────────────────────────────────────────────────────────────┐\n")
            PrintMessage("│ COMPILATION STATISTICS                                      │\n")
            PrintMessage("└─────────────────────────────────────────────────────────────┘\n")
            Compile_PrintStats()
            Emit_PrintStats()
        }
        
        // ─────────────────────────────────────────────────────────────────
        // CLEANUP
        // ─────────────────────────────────────────────────────────────────
        Compile_Free()
        Parse_Cleanup(1)
        Lex_Free()
        
        // ─────────────────────────────────────────────────────────────────
        // SUCCESS
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("\n")
        PrintMessage("╔══════════════════════════════════════════════════════════════╗\n")
        PrintMessage("║                    TEST PASSED!                              ║\n")
        PrintMessage("╠══════════════════════════════════════════════════════════════╣\n")
        PrintMessage("║  Output file: ./test_output                                  ║\n")
        PrintMessage("║  Run with: chmod +x test_output && ./test_output             ║\n")
        PrintMessage("║  Expected output: 3                                          ║\n")
        PrintMessage("╚══════════════════════════════════════════════════════════════╝\n")
        PrintMessage("\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// DIRECT EMIT TEST (BYPASS FRONTEND)
// For debugging the emit/ELF layers directly
// =============================================================================
Function.Test_DirectEmit {
    Output: Integer
    Body: {
        PrintMessage("\n")
        PrintMessage("╔══════════════════════════════════════════════════════════════╗\n")
        PrintMessage("║     Direct Emit Test - Bypass Frontend                       ║\n")
        PrintMessage("║     Directly emit code for: print '3', exit                  ║\n")
        PrintMessage("╚══════════════════════════════════════════════════════════════╝\n")
        PrintMessage("\n")
        
        // Initialize emit layer directly
        Emit_Init()
        
        // ─────────────────────────────────────────────────────────────────
        // ADD STRING "3\n" TO DATA SECTION
        // ─────────────────────────────────────────────────────────────────
        str_offset = Emit.data_size
        Emit_DataByte(51)    // '3' = 0x33 = 51
        Emit_DataByte(10)    // '\n' = 0x0A = 10
        Emit_DataByte(0)     // null terminator
        str_len = 2          // "3\n" is 2 bytes to print
        
        PrintMessage("[EMIT] Added string at data offset ")
        PrintNumber(str_offset)
        PrintMessage("\n")
        
        // ─────────────────────────────────────────────────────────────────
        // GENERATE CODE: _start
        // ─────────────────────────────────────────────────────────────────
        
        // sys_write(1, msg, len)
        // RAX = 1 (syscall write)
        // RDI = 1 (stdout)
        // RSI = address of string (will be patched by ELF loader)
        // RDX = length
        
        X86_MovRaxImm64(1)       // syscall number: write
        X86_MovRdiImm64(1)       // fd: stdout
        
        // RSI = data section address (base + offset)
        // The ELF builder will calculate the actual data address
        // For now, we use a placeholder that ELF_BuildFromEmit will fix
        X86_MovRsiImm64(0)       // placeholder - will be patched
        
        X86_MovRdxImm64(str_len) // length
        X86_SysInstr()
        
        // sys_exit(0)
        X86_MovRaxImm64(60)      // syscall number: exit
        X86_XorRdiRdi()          // exit code: 0
        X86_SysInstr()
        
        PrintMessage("[EMIT] Code size: ")
        PrintNumber(Emit.code_size)
        PrintMessage(" bytes\n")
        PrintMessage("[EMIT] Data size: ")
        PrintNumber(Emit.data_size)
        PrintMessage(" bytes\n")
        
        // Dump generated code
        Emit_DumpCode(48)
        
        // ─────────────────────────────────────────────────────────────────
        // BUILD ELF
        // ─────────────────────────────────────────────────────────────────
        PrintMessage("\n[ELF] Building executable...\n")
        
        ELF_Init()
        result = ELF_Build(Emit.code, Emit.code_size, Emit.data, Emit.data_size)
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("[TEST] FAILED: ELF build error\n")
            ELF_Free()
            Emit_Free()
            ReturnValue(0)
        }
        
        // Write to file
        result = Output_WriteExecutable("test_direct")
        
        ELF_Free()
        Emit_Free()
        
        IfCondition EqualTo(result, 0) ThenBlock: {
            PrintMessage("[TEST] FAILED: File write error\n")
            ReturnValue(0)
        }
        
        PrintMessage("\n")
        PrintMessage("╔══════════════════════════════════════════════════════════════╗\n")
        PrintMessage("║               DIRECT EMIT TEST PASSED!                       ║\n")
        PrintMessage("╠══════════════════════════════════════════════════════════════╣\n")
        PrintMessage("║  Output: ./test_direct                                       ║\n")
        PrintMessage("║  Run: chmod +x test_direct && ./test_direct                  ║\n")
        PrintMessage("║  Expected: prints '3' and exits                              ║\n")
        PrintMessage("╚══════════════════════════════════════════════════════════════╝\n")
        
        ReturnValue(1)
    }
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================
SubRoutine.Main {
    PrintMessage("\n")
    PrintMessage("═══════════════════════════════════════════════════════════════════\n")
    PrintMessage("        AILang Self-Hosting Compiler - Test Suite                  \n")
    PrintMessage("═══════════════════════════════════════════════════════════════════\n")
    PrintMessage("\n")
    
    // Run direct emit test first (simpler, tests emit + ELF)
    PrintMessage("[MAIN] Running Direct Emit Test...\n")
    result1 = Test_DirectEmit()
    
    IfCondition EqualTo(result1, 1) ThenBlock: {
        PrintMessage("\n[MAIN] Direct Emit Test: PASSED\n")
    } ElseBlock: {
        PrintMessage("\n[MAIN] Direct Emit Test: FAILED\n")
    }
    
    // Then run full pipeline test
    PrintMessage("\n[MAIN] Running Full Pipeline Test...\n")
    result2 = Test_FullPipeline()
    
    IfCondition EqualTo(result2, 1) ThenBlock: {
        PrintMessage("\n[MAIN] Full Pipeline Test: PASSED\n")
    } ElseBlock: {
        PrintMessage("\n[MAIN] Full Pipeline Test: FAILED\n")
    }
    
    PrintMessage("\n")
    PrintMessage("═══════════════════════════════════════════════════════════════════\n")
    PrintMessage("                         TEST SUMMARY                              \n")
    PrintMessage("═══════════════════════════════════════════════════════════════════\n")
    PrintMessage("  Direct Emit:    ")
    IfCondition EqualTo(result1, 1) ThenBlock: {
        PrintMessage("PASS\n")
    } ElseBlock: {
        PrintMessage("FAIL\n")
    }
    PrintMessage("  Full Pipeline:  ")
    IfCondition EqualTo(result2, 1) ThenBlock: {
        PrintMessage("PASS\n")
    } ElseBlock: {
        PrintMessage("FAIL\n")
    }
    PrintMessage("═══════════════════════════════════════════════════════════════════\n")
    PrintMessage("\n")
}

RunTask(Main)