diff --git a/Librarys/Compiler/Compile/Library.CCompileMain.ailang b/Librarys/Compiler/Compile/Library.CCompileMain.ailang
index d9fa132..c44cca9 100644
--- a/Librarys/Compiler/Compile/Library.CCompileMain.ailang
+++ b/Librarys/Compiler/Compile/Library.CCompileMain.ailang
@@ -29,9 +29,10 @@ LibraryImport.Compiler.CodeEmit.X86.CEmitX86Sys
 
 //Compile - modules each module has a compiler method for each function or primitive
 LibraryImport.Compiler.Compile.Modules.CCompileIO
+LibraryImport.Compiler.Compile.Modules.CCompileTypes
 LibraryImport.Compiler.Compile.Modules.CCompileArith
 LibraryImport.Compiler.Compile.Modules.CCompileFunc
-
+LibraryImport.Compiler.Compile.Modules.CCompileExpr
 
 
 
@@ -555,101 +556,7 @@ Function.Compile_FunctionCall {
     }
 }
 
-// =============================================================================
-// EXPRESSION COMPILER
-// Compiles any expression, leaving result in RAX
-// =============================================================================
-Function.Compile_Expression {
-    Input: node: Address
-    Output: Integer
-    Body: {
-        IfCondition EqualTo(node, 0) ThenBlock: {
-            ReturnValue(0)
-        }
-        
-        node_type = AST_GetType(node)
-        
-        // ─────────────────────────────────────────────────────────────────
-        // Literals
-        // ─────────────────────────────────────────────────────────────────
-        
-        
-        // Number literal -> MOV RAX, value
-        IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
-            value_str = AST_GetData1(node)
-            value = StringToNumber(value_str)  // Not StringToInteger!
-            Emit_MovRaxImm64(value)
-            ReturnValue(1)
-        }
-                
-        // String literal -> load data section address
-        IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
-            str_ptr = AST_GetData1(node)
-            offset = Emit_AddString(str_ptr)
-            Emit_LoadDataAddress(offset)
-            ReturnValue(1)
-        }
-        
-        // Boolean literal
-        IfCondition EqualTo(node_type, AST.BOOLEAN) ThenBlock: {
-            value = AST_GetData1(node)
-            Emit_MovRaxImm64(value)
-            ReturnValue(1)
-        }
-        
-        // Null literal
-        IfCondition EqualTo(node_type, AST.NULL) ThenBlock: {
-            Emit_XorRaxRax()
-            ReturnValue(1)
-        }
-        
-        // ─────────────────────────────────────────────────────────────────
-        // Identifier - load variable value
-        // ─────────────────────────────────────────────────────────────────
-        IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
-            name = AST_GetData1(node)
-            ReturnValue(CompileExpr_LoadVariable(name))
-        }
-        
-        // ─────────────────────────────────────────────────────────────────
-        // Function call - result in RAX
-        // ─────────────────────────────────────────────────────────────────
-        IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
-            ReturnValue(Compile_FunctionCall(node))
-        }
-        
-        // ─────────────────────────────────────────────────────────────────
-        // Operators
-        // ─────────────────────────────────────────────────────────────────
-        IfCondition EqualTo(node_type, AST.BINARY_OP) ThenBlock: {
-            ReturnValue(CompileExpr_BinaryOp(node))
-        }
-        
-        IfCondition EqualTo(node_type, AST.UNARY_OP) ThenBlock: {
-            ReturnValue(CompileExpr_UnaryOp(node))
-        }
-        
-        // ─────────────────────────────────────────────────────────────────
-        // Member access (Pool.field)
-        // ─────────────────────────────────────────────────────────────────
-        IfCondition EqualTo(node_type, AST.MEMBER_ACCESS) ThenBlock: {
-            ReturnValue(CompileExpr_MemberAccess(node))
-        }
-        
-        // ─────────────────────────────────────────────────────────────────
-        // Index access (array[index])
-        // ─────────────────────────────────────────────────────────────────
-        IfCondition EqualTo(node_type, AST.INDEX_ACCESS) ThenBlock: {
-            ReturnValue(CompileExpr_IndexAccess(node))
-        }
-        
-        // Unknown expression type
-        PrintMessage("[COMPILE] WARNING: Unknown expression type ")
-        PrintNumber(node_type)
-        PrintMessage("\n")
-        ReturnValue(0)
-    }
-}
+
 
 // =============================================================================
 // REGISTRATION HELPERS
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileBitwise.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileBitwise.ailang
index aa260a0..50009b6 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileBitwise.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileBitwise.ailang
@@ -14,7 +14,7 @@
 // Bitwise operations compiler module for the AILang self-hosting compiler
 // Handles: BitwiseAnd, BitwiseOr, BitwiseXor, BitwiseNot, LeftShift, RightShift
 
-LibraryImport.Compiler.Compile.CCompileTypes
+LibraryImport.Compiler.Compile.Modules.CCompileTypes
 LibraryImport.Compiler.CodeEmit.CEmitCore
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileCompare.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileCompare.ailang
index 8a67d0a..43618fc 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileCompare.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileCompare.ailang
@@ -15,8 +15,10 @@
 // Handles: EqualTo, NotEqual, LessThan, GreaterThan, LessEqual, GreaterEqual
 // Result: 1 (true) or 0 (false) in RAX
 
-LibraryImport.Compiler.Compile.CCompileTypes
 LibraryImport.Compiler.CodeEmit.CEmitCore
+
+LibraryImport.Compiler.Compile.Modules.CCompileTypes
+LibraryImport.Compiler.CodeEmit.CEmitCoreArch
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
@@ -117,22 +119,22 @@ Function.CompileCompare_BinaryOp {
         
         // SETcc AL based on condition code
         IfCondition EqualTo(cc_type, CC.E) ThenBlock: {
-            Emit_SetEAl()
+            Emit_Sete()
         }
         IfCondition EqualTo(cc_type, CC.NE) ThenBlock: {
-            Emit_SetNEAl()
+            Emit_Setne()
         }
         IfCondition EqualTo(cc_type, CC.L) ThenBlock: {
-            Emit_SetLAl()
+            Emit_Setl()
         }
         IfCondition EqualTo(cc_type, CC.G) ThenBlock: {
-            Emit_SetGAl()
+            Emit_Setg()
         }
         IfCondition EqualTo(cc_type, CC.LE) ThenBlock: {
-            Emit_SetLEAl()
+            Emit_Setle()
         }
         IfCondition EqualTo(cc_type, CC.GE) ThenBlock: {
-            Emit_SetGEAl()
+            Emit_Setge()
         }
         
         // MOVZX RAX, AL (zero-extend to 64-bit)
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileExpr.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileExpr.ailang
index 7fc8087..b7d984f 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileExpr.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileExpr.ailang
@@ -15,11 +15,15 @@
 // Handles: Numbers, Identifiers, Strings, Function Calls
 // Result of expression evaluation is always in RAX
 
-LibraryImport.Compiler.Compile.CCompileTypes
+//compiler modules
+LibraryImport.Compiler.Compile.Modules.CCompileTypes
 LibraryImport.Compiler.Compile.Modules.CCompileArith
 LibraryImport.Compiler.Compile.Modules.CCompileIO
 LibraryImport.Compiler.Compile.Modules.CCompileCompare
 LibraryImport.Compiler.Compile.Modules.CCompileLogic
+LibraryImport.Compiler.Compile.Modules.CCompileFunc
+
+//emit methods
 LibraryImport.Compiler.CodeEmit.CEmitCore
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
@@ -28,50 +32,97 @@ LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
 // MAIN EXPRESSION COMPILER
 // Dispatches based on AST node type, result always in RAX
 // =============================================================================
+// =============================================================================
+// EXPRESSION COMPILER
+// Compiles any expression, leaving result in RAX
+// =============================================================================
 Function.Compile_Expression {
     Input: node: Address
     Output: Integer
     Body: {
-        // NULL check
         IfCondition EqualTo(node, 0) ThenBlock: {
-            Compile_SetError("Null expression node", 0)
             ReturnValue(0)
         }
         
         node_type = AST_GetType(node)
         
-        // Number literal
+        // ─────────────────────────────────────────────────────────────────
+        // Literals
+        // ─────────────────────────────────────────────────────────────────
+        
+        
+        // Number literal -> MOV RAX, value
         IfCondition EqualTo(node_type, AST.NUMBER) ThenBlock: {
-            ReturnValue(CompileExpr_Number(node))
+            value_str = AST_GetData1(node)
+            value = StringToNumber(value_str)  // Not StringToInteger!
+            Emit_MovRaxImm64(value)
+            ReturnValue(1)
         }
-        
-        // String literal
+                
+        // String literal -> load data section address
         IfCondition EqualTo(node_type, AST.STRING) ThenBlock: {
-            ReturnValue(CompileExpr_String(node))
+            str_ptr = AST_GetData1(node)
+            offset = Emit_AddString(str_ptr)
+            Emit_LoadDataAddress(offset)
+            ReturnValue(1)
+        }
+        
+        // Boolean literal
+        IfCondition EqualTo(node_type, AST.BOOLEAN) ThenBlock: {
+            value = AST_GetData1(node)
+            Emit_MovRaxImm64(value)
+            ReturnValue(1)
+        }
+        
+        // Null literal
+        IfCondition EqualTo(node_type, AST.NULL) ThenBlock: {
+            Emit_XorRaxRax()
+            ReturnValue(1)
         }
         
-        // Identifier (variable reference)
+        // ─────────────────────────────────────────────────────────────────
+        // Identifier - load variable value
+        // ─────────────────────────────────────────────────────────────────
         IfCondition EqualTo(node_type, AST.IDENTIFIER) ThenBlock: {
             ReturnValue(CompileExpr_Identifier(node))
         }
         
-        // Function call
+        // ─────────────────────────────────────────────────────────────────
+        // Function call - result in RAX
+        // ─────────────────────────────────────────────────────────────────
         IfCondition EqualTo(node_type, AST.CALL) ThenBlock: {
             ReturnValue(Compile_FunctionCall(node))
         }
         
-        // Boolean literal
-        IfCondition EqualTo(node_type, AST.BOOLEAN) ThenBlock: {
-            ReturnValue(CompileExpr_Boolean(node))
+        // ─────────────────────────────────────────────────────────────────
+        // Operators
+        // ─────────────────────────────────────────────────────────────────
+        IfCondition EqualTo(node_type, AST.BINARY_OP) ThenBlock: {
+            ReturnValue(CompileExpr_BinaryOp(node))
+        }
+        
+        IfCondition EqualTo(node_type, AST.UNARY_OP) ThenBlock: {
+            ReturnValue(CompileExpr_UnaryOp(node))
+        }
+        
+        // ─────────────────────────────────────────────────────────────────
+        // Member access (Pool.field)
+        // ─────────────────────────────────────────────────────────────────
+        IfCondition EqualTo(node_type, AST.MEMBER_ACCESS) ThenBlock: {
+            ReturnValue(CompileExpr_MemberAccess(node))
         }
         
-        // Unary operation
-        IfCondition EqualTo(node_type, AST.UNARY) ThenBlock: {
-            ReturnValue(CompileExpr_Unary(node))
+        // ─────────────────────────────────────────────────────────────────
+        // Index access (array[index])
+        // ─────────────────────────────────────────────────────────────────
+        IfCondition EqualTo(node_type, AST.INDEX_ACCESS) ThenBlock: {
+            ReturnValue(CompileExpr_IndexAccess(node))
         }
         
-        // Unknown node type
-        Compile_SetError("Unknown expression node type", AST_GetLine(node))
+        // Unknown expression type
+        PrintMessage("[COMPILE] WARNING: Unknown expression type ")
+        PrintNumber(node_type)
+        PrintMessage("\n")
         ReturnValue(0)
     }
 }
@@ -186,7 +237,7 @@ Function.CompileExpr_Unary {
         IfCondition EqualTo(op_type, UnaryOp.NOT) ThenBlock: {
             // Logical not: 0 -> 1, non-zero -> 0
             Emit_TestRaxRax()
-            Emit_SetZAl()
+            Emit_Setz()
             Emit_MovzxRaxAl()
             ReturnValue(1)
         }
@@ -316,34 +367,3 @@ Function.Compile_FunctionCall {
     }
 }
 
-// =============================================================================
-// NODE TYPE CONSTANTS
-// =============================================================================
-FixedPool.NodeType {
-    "NUMBER": Initialize=1, CanChange=False
-    "STRING": Initialize=2, CanChange=False
-    "IDENTIFIER": Initialize=3, CanChange=False
-    "CALL": Initialize=4, CanChange=False
-    "BOOLEAN": Initialize=5, CanChange=False
-    "UNARY": Initialize=6, CanChange=False
-    "BINARY": Initialize=7, CanChange=False
-    "ASSIGNMENT": Initialize=8, CanChange=False
-    "IF": Initialize=9, CanChange=False
-    "WHILE": Initialize=10, CanChange=False
-    "FOR": Initialize=11, CanChange=False
-    "FUNCTION": Initialize=12, CanChange=False
-    "SUBROUTINE": Initialize=13, CanChange=False
-    "RETURN": Initialize=14, CanChange=False
-    "BLOCK": Initialize=15, CanChange=False
-    "POOL": Initialize=16, CanChange=False
-    "POOL_ACCESS": Initialize=17, CanChange=False
-}
-
-// =============================================================================
-// UNARY OPERATOR CONSTANTS
-// =============================================================================
-FixedPool.UnaryOp {
-    "NEGATE": Initialize=1, CanChange=False
-    "NOT": Initialize=2, CanChange=False
-    "BITNOT": Initialize=3, CanChange=False
-}
\ No newline at end of file
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileFunc.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileFunc.ailang
index a17fc92..9975df6 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileFunc.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileFunc.ailang
@@ -18,7 +18,7 @@ LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Stack
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Jump
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Logic
-LibraryImport.Compiler.Compile.CCompileMain
+
 
 // =============================================================================
 // FUNCTION DEFINITION COMPILATION
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileIO.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileIO.ailang
index 6a6cf28..e59603a 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileIO.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileIO.ailang
@@ -23,6 +23,7 @@ LibraryImport.XArrays
 LibraryImport.Compiler.Frontend.AST.CASTTypes
 LibraryImport.Compiler.Frontend.AST.CASTCore
 LibraryImport.Compiler.Compile.CCompileMain
+LibraryImport.Compiler.Compile.Modules.CCompileExpr
 LibraryImport.Compiler.CodeEmit.CEmitTypes
 LibraryImport.Compiler.CodeEmit.CEmitCore
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileLogic.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileLogic.ailang
index 5397296..c7c3678 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileLogic.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileLogic.ailang
@@ -15,7 +15,7 @@
 // Handles: And, Or, Not (with short-circuit evaluation for And/Or)
 // Result: 1 (true) or 0 (false) in RAX
 
-LibraryImport.Compiler.Compile.CCompileTypes
+LibraryImport.Compiler.Compile.Modules.CCompileTypes
 LibraryImport.Compiler.CodeEmit.CEmitCore
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Cmp
@@ -182,7 +182,7 @@ Function.CompileLogic_Not {
         Emit_TestRaxRax()
         
         // SETZ AL (set AL to 1 if ZF=1, i.e., RAX was 0)
-        Emit_SetZAl()
+        Emit_Setz()
         
         // MOVZX RAX, AL (zero-extend)
         Emit_MovzxRaxAl()
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileMem.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileMem.ailang
index dbd8260..7063083 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileMem.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileMem.ailang
@@ -14,7 +14,7 @@
 // Memory operations compiler module for the AILang self-hosting compiler
 // Handles: Allocate, Deallocate, StoreValue, Dereference, GetByte, SetByte
 
-LibraryImport.Compiler.Compile.CCompileTypes
+LibraryImport.Compiler.Compile.Modules.CCompileTypes
 LibraryImport.Compiler.CodeEmit.CEmitCore
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Reg
 LibraryImport.Compiler.CodeEmit.X86.CEmitX86Mem
diff --git a/Librarys/Compiler/Compile/Modules/Library.CCompileTypes.ailang b/Librarys/Compiler/Compile/Modules/Library.CCompileTypes.ailang
index 775ec73..5c4491b 100644
--- a/Librarys/Compiler/Compile/Modules/Library.CCompileTypes.ailang
+++ b/Librarys/Compiler/Compile/Modules/Library.CCompileTypes.ailang
@@ -485,4 +485,37 @@ Function.Compile_GetStackSize {
         }
         ReturnValue(size)
     }
-}
\ No newline at end of file
+}
+// =============================================================================
+// POOL TRACKING (stub - pools handled at parse time for now)
+// =============================================================================
+
+Function.Compile_FindPool {
+    Input: pool_name: Address
+    Output: Integer
+    Body: {
+        // TODO: Implement pool lookup
+        // For now return 0 (not found) - pools are resolved at compile time
+        ReturnValue(0)
+    }
+}
+
+Function.Compile_FindPoolField {
+    Input: pool_name: Address
+    Input: field_name: Address
+    Output: Integer
+    Body: {
+        // TODO: Implement pool field lookup
+        // For now return 0 (not found)
+        ReturnValue(0)
+    }
+}
+
+// =============================================================================
+// UNARY OPERATOR CONSTANTS
+// =============================================================================
+FixedPool.UnaryOp {
+    "NEGATE": Initialize=1, CanChange=False
+    "NOT": Initialize=2, CanChange=False
+    "BITNOT": Initialize=3, CanChange=False
+}
