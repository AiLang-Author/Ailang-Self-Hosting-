// test_checker.ailang
// Test harness for AILang Static Checker (Core + Extended)

LibraryImport.XArrays
LibraryImport.AILangChecker
LibraryImport.AILangChecker2

// =============================================================================
// Build test source code with intentional issues
// =============================================================================
Function.BuildTestSource {
    Output: Address
    Body: {
        // Unbounded recursion
        s = "Function.BadRecursion {\n"
        s = StringConcat(s, "    Input: n: Integer\n")
        s = StringConcat(s, "    Output: Integer\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        result = BadRecursion(n)\n")
        s = StringConcat(s, "        ReturnValue(result)\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        // Memory leak
        s = StringConcat(s, "Function.MemoryLeak {\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        buf = Allocate(1024)\n")
        s = StringConcat(s, "        temp = Allocate(256)\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        // Magic numbers
        s = StringConcat(s, "Function.MagicNumbers {\n")
        s = StringConcat(s, "    Input: x: Integer\n")
        s = StringConcat(s, "    Output: Integer\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        result = Add(x, 42)\n")
        s = StringConcat(s, "        result = Multiply(result, 137)\n")
        s = StringConcat(s, "        timeout = 30000\n")
        s = StringConcat(s, "        ReturnValue(result)\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        // Deep expression nesting
        s = StringConcat(s, "Function.DeepExpr {\n")
        s = StringConcat(s, "    Input: x: Integer\n")
        s = StringConcat(s, "    Output: Integer\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        result = Add(Multiply(Subtract(Add(Divide(x, 2), 3), 1), 4), 5)\n")
        s = StringConcat(s, "        ReturnValue(result)\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        // Undefined function call
        s = StringConcat(s, "Function.CallsUndefined {\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        result = DoesNotExist(1, 2)\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        // Too many parameters (for Checker2)
        s = StringConcat(s, "Function.TooManyParams {\n")
        s = StringConcat(s, "    Input: a: Integer\n")
        s = StringConcat(s, "    Input: b: Integer\n")
        s = StringConcat(s, "    Input: c: Integer\n")
        s = StringConcat(s, "    Input: d: Integer\n")
        s = StringConcat(s, "    Input: e: Integer\n")
        s = StringConcat(s, "    Input: f: Integer\n")
        s = StringConcat(s, "    Input: g: Integer\n")
        s = StringConcat(s, "    Input: h: Integer\n")
        s = StringConcat(s, "    Output: Integer\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        ReturnValue(a)\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        // Dead code (never called) - for Checker2
        s = StringConcat(s, "Function.NeverCalled {\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        PrintMessage(\"dead code\")\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        // Duplicate strings - for Checker2
        s = StringConcat(s, "Function.DuplicateStrings {\n")
        s = StringConcat(s, "    Body: {\n")
        s = StringConcat(s, "        PrintMessage(\"This is a repeated string literal\")\n")
        s = StringConcat(s, "        PrintMessage(\"This is a repeated string literal\")\n")
        s = StringConcat(s, "        PrintMessage(\"This is a repeated string literal\")\n")
        s = StringConcat(s, "    }\n")
        s = StringConcat(s, "}\n")
        
        ReturnValue(s)
    }
}

// =============================================================================
// MAIN
// =============================================================================
SubRoutine.RunTests {
    PrintMessage("========================================\n")
    PrintMessage("AILang Static Checker Test\n")
    PrintMessage("========================================\n\n")
    
    PrintMessage("Building test source with intentional issues...\n")
    PrintMessage("Core checks: recursion, memory leaks, magic numbers, nesting, undefined calls\n")
    PrintMessage("Extended checks: param count, dead code, duplicate strings, function length\n\n")
    
    test_source = BuildTestSource()
    
    PrintMessage("Running analysis...\n\n")
    
    // Core analysis
    Checker.Init(test_source)
    Checker.Lex()
    Checker.Analyze()
    
    // Extended analysis
    Checker2.Analyze()
    
    // Reports
    Checker.Report()
    Checker2.Report()
    
    // Summary
    total_errors = Add(Checker.error_count, Checker2.error_count)
    total_warnings = Add(Checker.warning_count, Checker2.warning_count)
    
    PrintMessage("========================================\n")
    summary = StringConcat("TOTAL: ", NumberToString(total_errors))
    summary = StringConcat(summary, " error(s), ")
    summary = StringConcat(summary, NumberToString(total_warnings))
    summary = StringConcat(summary, " warning(s)\n")
    PrintMessage(summary)
    PrintMessage("========================================\n")
    
    // Cleanup
    Checker2.Cleanup()
    Checker.Cleanup()
}

RunTask(RunTests)