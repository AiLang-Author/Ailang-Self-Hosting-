// stress_test.ailang
// Complex test file - no imports, exercises builtins and parser

// ═══════════════════════════════════════════════════════════════════════════
// POOL DECLARATIONS
// ═══════════════════════════════════════════════════════════════════════════

FixedPool.TestConfig {
    "max_iterations": Initialize=1000
    "debug_level": Initialize=2
    "buffer_size": Initialize=4096
    "enabled": Initialize=1, CanChange=True
    "counter": Initialize=0, CanChange=True
}

FixedPool.MathConstants {
    "pi_approx": Initialize=314159
    "e_approx": Initialize=271828
    "phi_approx": Initialize=161803
}

// ═══════════════════════════════════════════════════════════════════════════
// MATH FUNCTIONS - Test all math builtins
// ═══════════════════════════════════════════════════════════════════════════

Function.TestMathOps {
    Input: a: Integer
    Input: b: Integer
    Output: Integer
    Body: {
        sum = Add(a, b)
        diff = Subtract(a, b)
        prod = Multiply(a, b)
        quot = Divide(a, b)
        rem = Modulo(a, b)
        pwr = Power(a, 2)
        
        result = Add(sum, diff)
        result = Add(result, prod)
        result = Add(result, quot)
        result = Add(result, rem)
        result = Add(result, pwr)
        
        ReturnValue(result)
    }
}

Function.TestNestedMath {
    Input: x: Integer
    Output: Integer
    Body: {
        result = Add(Multiply(x, 2), Subtract(x, 1))
        result = Multiply(result, Add(x, 3))
        result = Divide(result, Subtract(x, Multiply(2, 3)))
        ReturnValue(result)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// COMPARISON FUNCTIONS - Test all comparison builtins
// ═══════════════════════════════════════════════════════════════════════════

Function.TestComparisons {
    Input: a: Integer
    Input: b: Integer
    Output: Integer
    Body: {
        r1 = GreaterThan(a, b)
        r2 = LessThan(a, b)
        r3 = EqualTo(a, b)
        r4 = NotEqual(a, b)
        r5 = GreaterEqual(a, b)
        r6 = LessEqual(a, b)
        
        total = Add(r1, r2)
        total = Add(total, r3)
        total = Add(total, r4)
        total = Add(total, r5)
        total = Add(total, r6)
        
        ReturnValue(total)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// LOGICAL FUNCTIONS - Test all logical builtins
// ═══════════════════════════════════════════════════════════════════════════

Function.TestLogical {
    Input: p: Integer
    Input: q: Integer
    Output: Integer
    Body: {
        r1 = And(p, q)
        r2 = Or(p, q)
        r3 = Not(p)
        
        result = Or(And(r1, r2), r3)
        ReturnValue(result)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// BITWISE FUNCTIONS - Test all bitwise builtins
// ═══════════════════════════════════════════════════════════════════════════

Function.TestBitwise {
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        r1 = BitwiseAnd(x, y)
        r2 = BitwiseOr(x, y)
        r3 = BitwiseXor(x, y)
        r5 = LeftShift(x, 2)
        r6 = RightShift(y, 1)
        
        result = BitwiseOr(r1, r2)
        result = BitwiseXor(result, r3)
        result = BitwiseAnd(result, r5)
        result = BitwiseOr(result, r6)
        
        ReturnValue(result)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// CONTROL FLOW - Test if/else, while loops
// ═══════════════════════════════════════════════════════════════════════════

Function.TestIfElse {
    Input: value: Integer
    Output: Integer
    Body: {
        result = 0
        
        IfCondition GreaterThan(value, 100) ThenBlock: {
            result = 1
        } ElseBlock: {
            IfCondition GreaterThan(value, 50) ThenBlock: {
                result = 2
            } ElseBlock: {
                IfCondition GreaterThan(value, 0) ThenBlock: {
                    result = 3
                } ElseBlock: {
                    result = 4
                }
            }
        }
        
        ReturnValue(result)
    }
}

Function.TestWhileLoop {
    Input: n: Integer
    Output: Integer
    Body: {
        sum = 0
        i = 0
        
        WhileLoop LessThan(i, n) {
            sum = Add(sum, i)
            i = Add(i, 1)
        }
        
        ReturnValue(sum)
    }
}

Function.TestNestedLoops {
    Input: rows: Integer
    Input: cols: Integer
    Output: Integer
    Body: {
        total = 0
        i = 0
        
        WhileLoop LessThan(i, rows) {
            j = 0
            WhileLoop LessThan(j, cols) {
                cell = Multiply(i, cols)
                cell = Add(cell, j)
                total = Add(total, cell)
                j = Add(j, 1)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(total)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// COMPLEX EXPRESSIONS - Test operator combinations
// ═══════════════════════════════════════════════════════════════════════════

Function.TestComplexExpr {
    Input: a: Integer
    Input: b: Integer
    Input: c: Integer
    Output: Integer
    Body: {
        t1 = Add(Multiply(a, b), Divide(c, 2))
        t2 = Subtract(Power(a, 2), Multiply(b, c))
        t3 = Modulo(Add(a, b), Subtract(c, 1))
        
        cond1 = And(GreaterThan(t1, t2), LessThan(t2, t3))
        cond2 = Or(EqualTo(a, b), NotEqual(b, c))
        
        IfCondition And(cond1, cond2) ThenBlock: {
            result = Add(t1, t2)
        } ElseBlock: {
            result = Subtract(t1, t3)
        }
        
        ReturnValue(result)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// POOL ACCESS - Test reading/writing pool fields
// ═══════════════════════════════════════════════════════════════════════════

Function.TestPoolAccess {
    Output: Integer
    Body: {
        max = TestConfig.max_iterations
        level = TestConfig.debug_level
        size = TestConfig.buffer_size
        
        TestConfig.counter = Add(TestConfig.counter, 1)
        TestConfig.enabled = 0
        
        result = Add(max, level)
        result = Add(result, size)
        result = Add(result, TestConfig.counter)
        
        ReturnValue(result)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// FUNCTION CALLS - Test calling other functions
// ═══════════════════════════════════════════════════════════════════════════

Function.TestFunctionCalls {
    Input: x: Integer
    Input: y: Integer
    Output: Integer
    Body: {
        m = TestMathOps(x, y)
        c = TestComparisons(x, y)
        l = TestLogical(x, y)
        b = TestBitwise(x, y)
        
        result = Add(m, c)
        result = Add(result, l)
        result = Add(result, b)
        
        ReturnValue(result)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// UNARY OPERATORS - Test negation and bitwise not
// ═══════════════════════════════════════════════════════════════════════════

Function.TestUnary {
    Input: x: Integer
    Output: Integer
    Body: {
        neg = -x
        notneg = -neg
        
        result = Add(neg, notneg)
        
        ReturnValue(result)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// INFIX OPERATORS - Test parenthesized infix syntax
// ═══════════════════════════════════════════════════════════════════════════

Function.TestInfix {
    Input: a: Integer
    Input: b: Integer
    Output: Integer
    Body: {
        r1 = (a + b)
        r2 = (a - b)
        r3 = (a * b)
        r4 = (a / b)
        r5 = (a > b)
        r6 = (a < b)
        r7 = (a == b)
        r8 = (a != b)
        
        total = Add(r1, r2)
        total = Add(total, r3)
        total = Add(total, r4)
        total = Add(total, r5)
        total = Add(total, r6)
        total = Add(total, r7)
        total = Add(total, r8)
        
        ReturnValue(total)
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN - Entry point
// ═══════════════════════════════════════════════════════════════════════════

SubRoutine.Main {
    PrintMessage("=== AILang Stress Test ===\n")
    
    m = TestMathOps(10, 3)
    PrintMessage("Math ops result: ")
    PrintNumber(m)
    PrintMessage("\n")
    
    c = TestComparisons(5, 5)
    PrintMessage("Comparisons result: ")
    PrintNumber(c)
    PrintMessage("\n")
    
    l = TestLogical(1, 0)
    PrintMessage("Logical result: ")
    PrintNumber(l)
    PrintMessage("\n")
    
    b = TestBitwise(255, 170)
    PrintMessage("Bitwise result: ")
    PrintNumber(b)
    PrintMessage("\n")
    
    w = TestWhileLoop(10)
    PrintMessage("While loop sum: ")
    PrintNumber(w)
    PrintMessage("\n")
    
    n = TestNestedLoops(3, 4)
    PrintMessage("Nested loops result: ")
    PrintNumber(n)
    PrintMessage("\n")
    
    p = TestPoolAccess()
    PrintMessage("Pool access result: ")
    PrintNumber(p)
    PrintMessage("\n")
    
    u = TestUnary(42)
    PrintMessage("Unary result: ")
    PrintNumber(u)
    PrintMessage("\n")
    
    PrintMessage("=== Test Complete ===\n")
}

RunTask(Main)