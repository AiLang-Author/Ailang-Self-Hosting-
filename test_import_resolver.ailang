// test_import_resolver.ailang
// Comprehensive test suite for CImportResolver library
// Tests ALL exported functions

LibraryImport.XArrays
LibraryImport.Compiler.Import.CImportResolver

// =============================================================================
// TEST TRACKING
// =============================================================================
FixedPool.TestState {
    "total": Initialize=0, CanChange=True
    "passed": Initialize=0, CanChange=True
    "failed": Initialize=0, CanChange=True
}

Function.Test_Pass {
    Input: name: Address
    Body: {
        TestState.passed = Add(TestState.passed, 1)
        TestState.total = Add(TestState.total, 1)
        PrintMessage("[PASS] ")
        PrintMessage(name)
        PrintMessage("\n")
    }
}

Function.Test_Fail {
    Input: name: Address
    Input: reason: Address
    Body: {
        TestState.failed = Add(TestState.failed, 1)
        TestState.total = Add(TestState.total, 1)
        PrintMessage("[FAIL] ")
        PrintMessage(name)
        PrintMessage(": ")
        PrintMessage(reason)
        PrintMessage("\n")
    }
}

// =============================================================================
// TEST 1: Import_Init
// =============================================================================
Function.Test_Import_Init {
    Output: Address
    Body: {
        PrintMessage("\n=== Test Import_Init ===\n")
        
        state = Import_Init()
        
        IfCondition EqualTo(state, 0) ThenBlock: {
            Test_Fail("Import_Init", "returned null")
            ReturnValue(0)
        }
        
        // Verify all fields are initialized
        loaded_paths = Dereference(state)
        IfCondition EqualTo(loaded_paths, 0) ThenBlock: {
            Test_Fail("Import_Init", "loaded_paths is null")
            ReturnValue(0)
        }
        
        loaded_content = Dereference(Add(state, 8))
        IfCondition EqualTo(loaded_content, 0) ThenBlock: {
            Test_Fail("Import_Init", "loaded_content is null")
            ReturnValue(0)
        }
        
        lib_base = Dereference(Add(state, 56))
        IfCondition EqualTo(lib_base, 0) ThenBlock: {
            Test_Fail("Import_Init", "lib_base is null")
            ReturnValue(0)
        }
        
        // Check lib_base value
        lib_len = StringLength(lib_base)
        IfCondition NotEqual(lib_len, 8) ThenBlock: {
            Test_Fail("Import_Init", "lib_base wrong length")
            ReturnValue(0)
        }
        
        Test_Pass("Import_Init")
        ReturnValue(state)
    }
}

// =============================================================================
// TEST 2: Import_AllocString
// =============================================================================
Function.Test_Import_AllocString {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_AllocString ===\n")
        
        // Test basic string
        str1 = Import_AllocString("Hello")
        len1 = StringLength(str1)
        IfCondition NotEqual(len1, 5) ThenBlock: {
            Test_Fail("AllocString basic", "wrong length")
            ReturnValue(0)
        }
        
        // Verify content
        c0 = GetByte(str1, 0)
        IfCondition NotEqual(c0, 72) ThenBlock: {
            Test_Fail("AllocString basic", "wrong first char")
            ReturnValue(0)
        }
        Test_Pass("AllocString basic")
        
        // Test empty string
        str2 = Import_AllocString("")
        len2 = StringLength(str2)
        IfCondition NotEqual(len2, 0) ThenBlock: {
            Test_Fail("AllocString empty", "not zero length")
            ReturnValue(0)
        }
        Test_Pass("AllocString empty")
        
        // Test null termination
        term = GetByte(str1, 5)
        IfCondition NotEqual(term, 0) ThenBlock: {
            Test_Fail("AllocString null-term", "not null terminated")
            ReturnValue(0)
        }
        Test_Pass("AllocString null-term")
        
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 3: Import_HashString
// =============================================================================
Function.Test_Import_HashString {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_HashString ===\n")
        
        // Test consistency
        hash1 = Import_HashString("TestFunction")
        hash2 = Import_HashString("TestFunction")
        IfCondition NotEqual(hash1, hash2) ThenBlock: {
            Test_Fail("HashString consistency", "same string different hash")
            ReturnValue(0)
        }
        Test_Pass("HashString consistency")
        
        // Test differentiation
        hash3 = Import_HashString("OtherFunction")
        IfCondition EqualTo(hash1, hash3) ThenBlock: {
            Test_Fail("HashString differentiation", "different strings same hash")
            ReturnValue(0)
        }
        Test_Pass("HashString differentiation")
        
        // Test empty string
        hash4 = Import_HashString("")
        IfCondition EqualTo(hash4, 5381) ThenBlock: {
            Test_Pass("HashString empty (DJB2 init)")
        } ElseBlock: {
            Test_Fail("HashString empty", "wrong hash for empty")
        }
        
        // Test positive (31-bit mask)
        IfCondition LessThan(hash1, 0) ThenBlock: {
            Test_Fail("HashString positive", "hash is negative")
            ReturnValue(0)
        }
        Test_Pass("HashString positive")
        
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 4: Import_BuildPath
// =============================================================================
Function.Test_Import_BuildPath {
    Input: state: Address
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_BuildPath ===\n")
        
        // Test simple module (no dots)
        path1 = Import_BuildPath(state, "XArrays")
        PrintMessage("  XArrays -> ")
        PrintMessage(path1)
        PrintMessage("\n")
        
        expected1 = "Librarys/Library.XArrays.ailang"
        cmp1 = StringCompare(path1, expected1)
        IfCondition NotEqual(cmp1, 0) ThenBlock: {
            Test_Fail("BuildPath simple", "wrong path")
            ReturnValue(0)
        }
        Test_Pass("BuildPath simple")
        
        // Test nested module (multiple dots)
        path2 = Import_BuildPath(state, "Compiler.Frontend.Lexer.CLexerMain")
        PrintMessage("  Compiler.Frontend.Lexer.CLexerMain -> ")
        PrintMessage(path2)
        PrintMessage("\n")
        
        expected2 = "Librarys/Compiler/Frontend/Lexer/Library.CLexerMain.ailang"
        cmp2 = StringCompare(path2, expected2)
        IfCondition NotEqual(cmp2, 0) ThenBlock: {
            Test_Fail("BuildPath nested", "wrong path")
            ReturnValue(0)
        }
        Test_Pass("BuildPath nested")
        
        // Test single dot
        path3 = Import_BuildPath(state, "Compiler.CEmitCore")
        PrintMessage("  Compiler.CEmitCore -> ")
        PrintMessage(path3)
        PrintMessage("\n")
        
        expected3 = "Librarys/Compiler/Library.CEmitCore.ailang"
        cmp3 = StringCompare(path3, expected3)
        IfCondition NotEqual(cmp3, 0) ThenBlock: {
            Test_Fail("BuildPath single dot", "wrong path")
            ReturnValue(0)
        }
        Test_Pass("BuildPath single dot")
        
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 5: Import_BuildFilePath
// =============================================================================
Function.Test_Import_BuildFilePath {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_BuildFilePath ===\n")
        
        path = Import_BuildFilePath("helpers")
        PrintMessage("  helpers -> ")
        PrintMessage(path)
        PrintMessage("\n")
        
        expected = "helpers.ailang"
        cmp = StringCompare(path, expected)
        IfCondition NotEqual(cmp, 0) ThenBlock: {
            Test_Fail("BuildFilePath", "wrong path")
            ReturnValue(0)
        }
        Test_Pass("BuildFilePath")
        
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 6: Import_ExtractImports
// =============================================================================
Function.Test_Import_ExtractImports {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_ExtractImports ===\n")
        
        // Test source with mixed imports
        test_source = "// Test file\nLibraryImport.XArrays\nLibraryImport.Compiler.CEmitCore\n\nImport.helpers\nImport.utils\n\nFunction.Main {\n}\n"
        
        imports = Import_ExtractImports(test_source)
        count = XArray.XSize(imports)
        
        PrintMessage("  Found ")
        PrintNumber(count)
        PrintMessage(" imports\n")
        
        IfCondition NotEqual(count, 4) ThenBlock: {
            Test_Fail("ExtractImports count", "expected 4")
            ReturnValue(0)
        }
        Test_Pass("ExtractImports count")
        
        // Check first import (should be "XArrays")
        imp0 = XArray.XGet(imports, 0)
        PrintMessage("  [0]: ")
        PrintMessage(imp0)
        PrintMessage("\n")
        
        cmp0 = StringCompare(imp0, "XArrays")
        IfCondition NotEqual(cmp0, 0) ThenBlock: {
            Test_Fail("ExtractImports first", "wrong value")
        } ElseBlock: {
            Test_Pass("ExtractImports first")
        }
        
        // Check file import (should have FILE: prefix)
        imp2 = XArray.XGet(imports, 2)
        PrintMessage("  [2]: ")
        PrintMessage(imp2)
        PrintMessage("\n")
        
        c0 = GetByte(imp2, 0)
        IfCondition NotEqual(c0, 70) ThenBlock: {
            Test_Fail("ExtractImports file prefix", "missing FILE:")
        } ElseBlock: {
            Test_Pass("ExtractImports file prefix")
        }
        
        XArray.XDestroy(imports)
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 7: Import_ExtractSymbols
// =============================================================================
Function.Test_Import_ExtractSymbols {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_ExtractSymbols ===\n")
        
        test_source = "Function.Calculate {\n    Body: {\n    }\n}\n\nSubRoutine.Initialize {\n}\n\nFunction.Process {\n    Output: Integer\n    Body: {\n    }\n}\n"
        
        symbols = Import_ExtractSymbols(test_source)
        count = XArray.XSize(symbols)
        
        PrintMessage("  Found ")
        PrintNumber(count)
        PrintMessage(" symbols\n")
        
        IfCondition NotEqual(count, 3) ThenBlock: {
            Test_Fail("ExtractSymbols count", "expected 3")
            ReturnValue(0)
        }
        Test_Pass("ExtractSymbols count")
        
        // Symbols should be hashes
        sym0 = XArray.XGet(symbols, 0)
        IfCondition LessEqual(sym0, 0) ThenBlock: {
            Test_Fail("ExtractSymbols hash", "invalid hash")
            ReturnValue(0)
        }
        Test_Pass("ExtractSymbols hash valid")
        
        XArray.XDestroy(symbols)
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 8: Import_IsLoaded / Import_MarkLoaded
// =============================================================================
Function.Test_Import_LoadTracking {
    Input: state: Address
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_IsLoaded / Import_MarkLoaded ===\n")
        
        path = "Librarys/Library.TestModule.ailang"
        
        // Should not be loaded initially
        is_loaded1 = Import_IsLoaded(state, path)
        IfCondition NotEqual(is_loaded1, 0) ThenBlock: {
            Test_Fail("IsLoaded initial", "should be 0")
            ReturnValue(0)
        }
        Test_Pass("IsLoaded initial")
        
        // Mark as loaded
        content = Import_AllocString("// test content")
        name = Import_AllocString("TestModule")
        Import_MarkLoaded(state, path, content, name)
        
        // Should now be loaded
        is_loaded2 = Import_IsLoaded(state, path)
        IfCondition NotEqual(is_loaded2, 1) ThenBlock: {
            Test_Fail("IsLoaded after mark", "should be 1")
            ReturnValue(0)
        }
        Test_Pass("IsLoaded after mark")
        
        // Different path should not be loaded
        other_path = "Librarys/Library.OtherModule.ailang"
        is_loaded3 = Import_IsLoaded(state, other_path)
        IfCondition NotEqual(is_loaded3, 0) ThenBlock: {
            Test_Fail("IsLoaded different", "should be 0")
            ReturnValue(0)
        }
        Test_Pass("IsLoaded different path")
        
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 9: Import_GeneratePrefix
// =============================================================================
Function.Test_Import_GeneratePrefix {
    Input: state: Address
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_GeneratePrefix ===\n")
        
        prefix1 = Import_GeneratePrefix(state)
        prefix2 = Import_GeneratePrefix(state)
        prefix3 = Import_GeneratePrefix(state)
        
        PrintMessage("  Generated: ")
        PrintMessage(prefix1)
        PrintMessage(", ")
        PrintMessage(prefix2)
        PrintMessage(", ")
        PrintMessage(prefix3)
        PrintMessage("\n")
        
        // Check format (should start with "NS")
        c0 = GetByte(prefix1, 0)
        c1 = GetByte(prefix1, 1)
        IfCondition Or(NotEqual(c0, 78), NotEqual(c1, 83)) ThenBlock: {
            Test_Fail("GeneratePrefix format", "should start with NS")
            ReturnValue(0)
        }
        Test_Pass("GeneratePrefix format")
        
        // Check length (should be 8 chars)
        len = StringLength(prefix1)
        IfCondition NotEqual(len, 8) ThenBlock: {
            Test_Fail("GeneratePrefix length", "should be 8")
            ReturnValue(0)
        }
        Test_Pass("GeneratePrefix length")
        
        // Check uniqueness
        cmp1 = StringCompare(prefix1, prefix2)
        cmp2 = StringCompare(prefix2, prefix3)
        IfCondition Or(EqualTo(cmp1, 0), EqualTo(cmp2, 0)) ThenBlock: {
            Test_Fail("GeneratePrefix unique", "collision detected")
            ReturnValue(0)
        }
        Test_Pass("GeneratePrefix unique")
        
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 10: Import_DetectConflicts
// =============================================================================
Function.Test_Import_DetectConflicts {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_DetectConflicts ===\n")
        
        // Create fresh state for this test
        state = Import_Init()
        
        // Manually add symbols with conflicts
        symbol_table = Dereference(Add(state, 24))
        
        // Add same symbol hash from two modules (simulates conflict)
        test_hash = Import_HashString("ConflictFunc")
        XArray.XPush(symbol_table, test_hash)
        XArray.XPush(symbol_table, 0)  // module 0
        XArray.XPush(symbol_table, test_hash)
        XArray.XPush(symbol_table, 1)  // module 1
        
        // Add unique symbol
        unique_hash = Import_HashString("UniqueFunc")
        XArray.XPush(symbol_table, unique_hash)
        XArray.XPush(symbol_table, 0)
        
        // Detect conflicts
        Import_DetectConflicts(state)
        
        // Check conflicts array
        conflicts = Dereference(Add(state, 32))
        conf_count = XArray.XSize(conflicts)
        
        PrintMessage("  Conflicts found: ")
        PrintNumber(conf_count)
        PrintMessage("\n")
        
        IfCondition NotEqual(conf_count, 1) ThenBlock: {
            Test_Fail("DetectConflicts count", "expected 1 conflict")
            ReturnValue(0)
        }
        Test_Pass("DetectConflicts count")
        
        // Verify it's the right conflict
        conf_hash = XArray.XGet(conflicts, 0)
        IfCondition NotEqual(conf_hash, test_hash) ThenBlock: {
            Test_Fail("DetectConflicts hash", "wrong conflict hash")
            ReturnValue(0)
        }
        Test_Pass("DetectConflicts hash")
        
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 11: Import_CollectLibraryImports
// =============================================================================
Function.Test_Import_CollectLibraryImports {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_CollectLibraryImports ===\n")
        
        test_source = "LibraryImport.XArrays\nLibraryImport.Compiler.CEmitCore\nImport.helpers\nLibraryImport.XArrays\n"
        
        imports = XArray.XCreate(16)
        Import_CollectLibraryImports(test_source, imports)
        
        count = XArray.XSize(imports)
        PrintMessage("  Unique library imports: ")
        PrintNumber(count)
        PrintMessage("\n")
        
        // Should have 2 (XArrays deduplicated)
        IfCondition NotEqual(count, 2) ThenBlock: {
            Test_Fail("CollectLibraryImports dedup", "expected 2")
            ReturnValue(0)
        }
        Test_Pass("CollectLibraryImports dedup")
        
        // Should NOT include Import.helpers
        i = 0
        found_file_import = 0
        WhileLoop LessThan(i, count) {
            imp = XArray.XGet(imports, i)
            c0 = GetByte(imp, 0)
            IfCondition EqualTo(c0, 73) ThenBlock: {
                found_file_import = 1
            }
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(found_file_import, 1) ThenBlock: {
            Test_Fail("CollectLibraryImports filter", "included file import")
            ReturnValue(0)
        }
        Test_Pass("CollectLibraryImports filter")
        
        XArray.XDestroy(imports)
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 12: Import_InlineContent
// =============================================================================
Function.Test_Import_InlineContent {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_InlineContent ===\n")
        
        test_source = "LibraryImport.XArrays\nImport.helpers\n\nFunction.Test {\n}\n"
        
        output = XArray.XCreate(16)
        Import_InlineContent(test_source, output)
        
        count = XArray.XSize(output)
        PrintMessage("  Lines after stripping imports: ")
        PrintNumber(count)
        PrintMessage("\n")
        
        // Should have 3 lines (empty, Function.Test, })
        // Import lines should be stripped
        IfCondition LessThan(count, 2) ThenBlock: {
            Test_Fail("InlineContent count", "too few lines")
            ReturnValue(0)
        }
        Test_Pass("InlineContent strips imports")
        
        // Verify no import lines remain
        i = 0
        found_import = 0
        WhileLoop LessThan(i, count) {
            line = XArray.XGet(output, i)
            line_len = StringLength(line)
            IfCondition GreaterEqual(line_len, 7) ThenBlock: {
                c0 = GetByte(line, 0)
                IfCondition Or(EqualTo(c0, 76), EqualTo(c0, 73)) ThenBlock: {
                    found_import = 1
                }
            }
            i = Add(i, 1)
        }
        
        IfCondition EqualTo(found_import, 1) ThenBlock: {
            Test_Fail("InlineContent filter", "import lines remain")
        } ElseBlock: {
            Test_Pass("InlineContent filter")
        }
        
        XArray.XDestroy(output)
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 13: Import_JoinLines
// =============================================================================
Function.Test_Import_JoinLines {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_JoinLines ===\n")
        
        lines = XArray.XCreate(8)
        
        line1 = Import_AllocString("Line one")
        line2 = Import_AllocString("Line two")
        line3 = Import_AllocString("Line three")
        
        XArray.XPush(lines, line1)
        XArray.XPush(lines, line2)
        XArray.XPush(lines, line3)
        
        result = Import_JoinLines(lines)
        result_len = StringLength(result)
        
        PrintMessage("  Result length: ")
        PrintNumber(result_len)
        PrintMessage("\n")
        PrintMessage("  Result:\n---\n")
        PrintMessage(result)
        PrintMessage("---\n")
        
        // Should be "Line one\nLine two\nLine three\n"
        // Length: 8 + 1 + 8 + 1 + 10 + 1 = 29
        IfCondition LessThan(result_len, 25) ThenBlock: {
            Test_Fail("JoinLines length", "too short")
            ReturnValue(0)
        }
        Test_Pass("JoinLines length")
        
        // Check newlines present
        c8 = GetByte(result, 8)
        IfCondition NotEqual(c8, 10) ThenBlock: {
            Test_Fail("JoinLines newlines", "missing newline")
            ReturnValue(0)
        }
        Test_Pass("JoinLines newlines")
        
        XArray.XDestroy(lines)
        ReturnValue(1)
    }
}

// =============================================================================
// TEST 14: Import_ReadFile (requires actual file)
// =============================================================================
Function.Test_Import_ReadFile {
    Output: Integer
    Body: {
        PrintMessage("\n=== Test Import_ReadFile ===\n")
        
        // Try to read this test file itself
        content = Import_ReadFile("test_import_resolver.ailang")
        
        IfCondition EqualTo(content, 0) ThenBlock: {
            Test_Fail("ReadFile exists", "failed to read self")
            ReturnValue(0)
        }
        Test_Pass("ReadFile exists")
        
        // Check content starts with "//"
        c0 = GetByte(content, 0)
        c1 = GetByte(content, 1)
        IfCondition And(EqualTo(c0, 47), EqualTo(c1, 47)) ThenBlock: {
            Test_Pass("ReadFile content valid")
        } ElseBlock: {
            Test_Fail("ReadFile content", "unexpected start")
        }
        
        // Test non-existent file
        bad_content = Import_ReadFile("nonexistent_xyz_123.txt")
        IfCondition NotEqual(bad_content, 0) ThenBlock: {
            Test_Fail("ReadFile nonexistent", "should return 0")
            ReturnValue(0)
        }
        Test_Pass("ReadFile nonexistent")
        
        ReturnValue(1)
    }
}

// =============================================================================
// MAIN TEST RUNNER
// =============================================================================
SubRoutine.Main {
    PrintMessage("==================================================\n")
    PrintMessage("  AILang Import Resolver - Comprehensive Tests\n")
    PrintMessage("==================================================\n")
    
    TestState.total = 0
    TestState.passed = 0
    TestState.failed = 0
    
    // Initialize shared state for tests that need it
    state = Test_Import_Init()
    
    IfCondition NotEqual(state, 0) ThenBlock: {
        // Run all tests
        Test_Import_AllocString()
        Test_Import_HashString()
        Test_Import_BuildPath(state)
        Test_Import_BuildFilePath()
        Test_Import_ExtractImports()
        Test_Import_ExtractSymbols()
        Test_Import_LoadTracking(state)
        Test_Import_GeneratePrefix(state)
        Test_Import_DetectConflicts()
        Test_Import_CollectLibraryImports()
        Test_Import_InlineContent()
        Test_Import_JoinLines()
        Test_Import_ReadFile()
    }
    
    // Summary
    PrintMessage("\n==================================================\n")
    PrintMessage("                   SUMMARY\n")
    PrintMessage("==================================================\n")
    PrintMessage("  Total:  ")
    PrintNumber(TestState.total)
    PrintMessage("\n")
    PrintMessage("  Passed: ")
    PrintNumber(TestState.passed)
    PrintMessage("\n")
    PrintMessage("  Failed: ")
    PrintNumber(TestState.failed)
    PrintMessage("\n")
    PrintMessage("==================================================\n")
    
    IfCondition EqualTo(TestState.failed, 0) ThenBlock: {
        PrintMessage("  ALL TESTS PASSED!\n")
    } ElseBlock: {
        PrintMessage("  SOME TESTS FAILED\n")
    }
    PrintMessage("==================================================\n")
}

RunTask(Main)